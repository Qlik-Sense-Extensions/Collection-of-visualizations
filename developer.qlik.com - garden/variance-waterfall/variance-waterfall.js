/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 4);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* WEBPACK VAR INJECTION */(function(global) {/*
* picasso-plugin-q v0.25.3
* Copyright (c) 2019 QlikTech International AB
* Released under the MIT license.
*/


function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var defineProperty = Object.defineProperty;
var gOPD = Object.getOwnPropertyDescriptor;

var isArray = function isArray(arr) {
	if (typeof Array.isArray === 'function') {
		return Array.isArray(arr);
	}

	return toStr.call(arr) === '[object Array]';
};

var isPlainObject = function isPlainObject(obj) {
	if (!obj || toStr.call(obj) !== '[object Object]') {
		return false;
	}

	var hasOwnConstructor = hasOwn.call(obj, 'constructor');
	var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
	if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
		return false;
	}

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for (key in obj) { /**/ }

	return typeof key === 'undefined' || hasOwn.call(obj, key);
};

// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
var setProperty = function setProperty(target, options) {
	if (defineProperty && options.name === '__proto__') {
		defineProperty(target, options.name, {
			enumerable: true,
			configurable: true,
			value: options.newValue,
			writable: true
		});
	} else {
		target[options.name] = options.newValue;
	}
};

// Return undefined instead of __proto__ if '__proto__' is not an own property
var getProperty = function getProperty(obj, name) {
	if (name === '__proto__') {
		if (!hasOwn.call(obj, name)) {
			return void 0;
		} else if (gOPD) {
			// In early versions of node, obj['__proto__'] is buggy when obj has
			// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
			return gOPD(obj, name).value;
		}
	}

	return obj[name];
};

var extend = function extend() {
	var options, name, src, copy, copyIsArray, clone;
	var target = arguments[0];
	var i = 1;
	var length = arguments.length;
	var deep = false;

	// Handle a deep copy situation
	if (typeof target === 'boolean') {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}
	if (target == null || (typeof target !== 'object' && typeof target !== 'function')) {
		target = {};
	}

	for (; i < length; ++i) {
		options = arguments[i];
		// Only deal with non-null/undefined values
		if (options != null) {
			// Extend the base object
			for (name in options) {
				src = getProperty(target, name);
				copy = getProperty(options, name);

				// Prevent never-ending loop
				if (target !== copy) {
					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone = src && isArray(src) ? src : [];
						} else {
							clone = src && isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						setProperty(target, { name: name, newValue: extend(deep, clone, copy) });

					// Don't bring in undefined values
					} else if (typeof copy !== 'undefined') {
						setProperty(target, { name: name, newValue: copy });
					}
				}
			}
		}
	}

	// Return the modified object
	return target;
};

function getFieldAccessor(field, page, deps) {
  if (!field) {
    return -1;
  }

  var cache = deps.cache;
  var origin = field.origin ? field.origin() : null;

  if (origin) {
    field = origin;
  }

  var fieldIdx = cache.fields.indexOf(field);
  var attrIdx = -1;
  var attrDimIdx = -1;

  if (fieldIdx === -1) {
    for (var i = 0; i < cache.wrappedFields.length; i++) {
      attrDimIdx = cache.wrappedFields[i].attrDims.map(function (v) {
        return v.instance;
      }).indexOf(field);
      attrIdx = cache.wrappedFields[i].attrExps.map(function (v) {
        return v.instance;
      }).indexOf(field);

      if (attrDimIdx !== -1 || attrIdx !== -1) {
        fieldIdx = i;
        break;
      }
    }
  }

  fieldIdx -= page.qArea.qLeft;

  if (fieldIdx < 0 || fieldIdx >= page.qArea.qWidth) {
    // throw new Error('Field out of range');
    return -1;
  }

  if (attrDimIdx >= 0) {
    return function (row) {
      return row[fieldIdx].qAttrDims.qValues[attrDimIdx];
    };
  }

  if (attrIdx >= 0) {
    return function (row) {
      return row[fieldIdx].qAttrExps.qValues[attrIdx];
    };
  }

  return function (row) {
    return row[fieldIdx];
  };
} // TODO - handle 'other' value
// const specialTextValues = {
//   '-3': (meta) => {
//     if ('othersLabel' in meta) {
//       return meta.othersLabel;
//     }
//     return '';
//   }
// };

function datumExtract(propCfg, cell, _ref) {
  var key = _ref.key;
  var datum = {
    value: typeof propCfg.value === 'function' ? propCfg.value(cell) : typeof propCfg.value !== 'undefined' ? propCfg.value : cell // eslint-disable-line no-nested-ternary

  };
  datum.label = typeof propCfg.label === 'function' ? propCfg.label(cell) : typeof propCfg.label !== 'undefined' ? String(propCfg.label) : String(datum.value); // eslint-disable-line no-nested-ternary

  if (propCfg.field) {
    datum.source = {
      key: key,
      field: propCfg.field.key()
    };
  }

  return datum;
}

function cellToValue(_ref2) {
  var cache = _ref2.cache,
      f = _ref2.f,
      mainCell = _ref2.mainCell,
      p = _ref2.p,
      prop = _ref2.prop,
      page = _ref2.page,
      rowIdx = _ref2.rowIdx,
      row = _ref2.row,
      sourceKey = _ref2.sourceKey,
      target = _ref2.target,
      targetProp = _ref2.targetProp;
  var propCell = mainCell;

  if (p.field && p.field !== f) {
    var propCellFn = getFieldAccessor(p.field, page, {
      cache: cache
    });

    if (propCellFn === -1) {
      return;
    }

    propCell = extend({
      qRow: rowIdx
    }, propCellFn(row));
  }

  target[targetProp] = datumExtract(p, propCell, {
    key: sourceKey
  }, prop);
}

function extract(config, dataset, cache, util) {
  var cfgs = Array.isArray(config) ? config : [config];
  var dataItems = [];

  for (var i = 0; i < cfgs.length; i++) {
    if (typeof cfgs[i].field !== 'undefined') {
      var cube = dataset.raw();
      var sourceKey = dataset.key();
      var f = _typeof(cfgs[i].field) === 'object' ? cfgs[i].field : dataset.field(cfgs[i].field);

      var _util$normalizeConfig = util.normalizeConfig(cfgs[i], dataset),
          props = _util$normalizeConfig.props,
          main = _util$normalizeConfig.main;

      var propsArr = Object.keys(props);
      var track = !!cfgs[i].trackBy;

      var trackType = _typeof(cfgs[i].trackBy);

      var tracker = {};
      var trackedItems = [];
      var items = [];

      for (var j = 0; j < cube.qDataPages.length; j++) {
        var fn = getFieldAccessor(f, cube.qDataPages[j], {
          cache: cache
        });

        if (fn === -1) {
          continue;
        }

        for (var k = 0; k < cube.qDataPages[j].qMatrix.length; k++) {
          var rowIdx = cube.qDataPages[j].qArea.qTop + k;
          var mainCell = extend({
            qRow: rowIdx
          }, fn(cube.qDataPages[j].qMatrix[k]));
          var ret = datumExtract(main, mainCell, {
            key: sourceKey
          });
          var exclude = main.filter && !main.filter(mainCell);

          if (exclude) {
            continue;
          }

          for (var l = 0; l < propsArr.length; l++) {
            var p = props[propsArr[l]];
            var arr = p.fields || [p];

            if (p.fields) {
              ret[propsArr[l]] = [];
            } // loop through all props that need to be mapped and
            // assign 'value' and 'source' to each property


            for (var m = 0; m < arr.length; m++) {
              cellToValue({
                cache: cache,
                f: f,
                mainCell: mainCell,
                p: arr[m],
                prop: propsArr[l],
                props: props,
                page: cube.qDataPages[j],
                rowIdx: rowIdx,
                row: cube.qDataPages[j].qMatrix[k],
                sourceKey: sourceKey,
                target: p.fields ? ret[propsArr[l]] : ret,
                targetProp: p.fields ? m : propsArr[l]
              });
            }

            if (p.fields) {
              var fieldValues = ret[propsArr[l]].map(function (v) {
                return v.value;
              });
              var fieldLabels = ret[propsArr[l]].map(function (v) {
                return v.label;
              });
              ret[propsArr[l]] = {
                value: typeof p.value === 'function' ? p.value(fieldValues) : typeof p.value !== 'undefined' ? p.value : fieldValues,
                label: typeof p.label === 'function' ? p.label(fieldLabels) : typeof p.label !== 'undefined' ? String(p.label) : String(ret[propsArr[l]].value)
              };
            }
          } // collect items based on the trackBy value
          // items with the same trackBy value are placed in an array and reduced later


          if (track) {
            util.track({
              cfg: cfgs[i],
              itemData: mainCell,
              obj: ret,
              target: trackedItems,
              tracker: tracker,
              trackType: trackType
            });
          }

          items.push(ret);
        }
      } // reduce if items have been grouped


      if (track) {
        dataItems.push.apply(dataItems, _toConsumableArray(util.collect(trackedItems, {
          main: main,
          propsArr: propsArr,
          props: props
        })));
      } else {
        dataItems.push.apply(dataItems, items);
      }
    }
  }

  return dataItems;
}

function count(node) {
  var sum = 0,
      children = node.children,
      i = children && children.length;
  if (!i) sum = 1;
  else while (--i >= 0) sum += children[i].value;
  node.value = sum;
}

function node_count() {
  return this.eachAfter(count);
}

function node_each(callback) {
  var node = this, current, next = [node], children, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      callback(node), children = node.children;
      if (children) for (i = 0, n = children.length; i < n; ++i) {
        next.push(children[i]);
      }
    }
  } while (next.length);
  return this;
}

function node_eachBefore(callback) {
  var node = this, nodes = [node], children, i;
  while (node = nodes.pop()) {
    callback(node), children = node.children;
    if (children) for (i = children.length - 1; i >= 0; --i) {
      nodes.push(children[i]);
    }
  }
  return this;
}

function node_eachAfter(callback) {
  var node = this, nodes = [node], next = [], children, i, n;
  while (node = nodes.pop()) {
    next.push(node), children = node.children;
    if (children) for (i = 0, n = children.length; i < n; ++i) {
      nodes.push(children[i]);
    }
  }
  while (node = next.pop()) {
    callback(node);
  }
  return this;
}

function node_sum(value) {
  return this.eachAfter(function(node) {
    var sum = +value(node.data) || 0,
        children = node.children,
        i = children && children.length;
    while (--i >= 0) sum += children[i].value;
    node.value = sum;
  });
}

function node_sort(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}

function node_path(end) {
  var start = this,
      ancestor = leastCommonAncestor(start, end),
      nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
}

function leastCommonAncestor(a, b) {
  if (a === b) return a;
  var aNodes = a.ancestors(),
      bNodes = b.ancestors(),
      c = null;
  a = aNodes.pop();
  b = bNodes.pop();
  while (a === b) {
    c = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }
  return c;
}

function node_ancestors() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}

function node_descendants() {
  var nodes = [];
  this.each(function(node) {
    nodes.push(node);
  });
  return nodes;
}

function node_leaves() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}

function node_links() {
  var root = this, links = [];
  root.each(function(node) {
    if (node !== root) { // Don’t include the root’s parent, if any.
      links.push({source: node.parent, target: node});
    }
  });
  return links;
}

function hierarchy(data, children) {
  var root = new Node(data),
      valued = +data.value && (root.value = data.value),
      node,
      nodes = [root],
      child,
      childs,
      i,
      n;

  if (children == null) children = defaultChildren;

  while (node = nodes.pop()) {
    if (valued) node.value = +node.data.value;
    if ((childs = children(node.data)) && (n = childs.length)) {
      node.children = new Array(n);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }

  return root.eachBefore(computeHeight);
}

function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}

function defaultChildren(d) {
  return d.children;
}

function copyData(node) {
  node.data = node.data.data;
}

function computeHeight(node) {
  var height = 0;
  do node.height = height;
  while ((node = node.parent) && (node.height < ++height));
}

function Node(data) {
  this.data = data;
  this.depth =
  this.height = 0;
  this.parent = null;
}

Node.prototype = hierarchy.prototype = {
  constructor: Node,
  count: node_count,
  each: node_each,
  eachAfter: node_eachAfter,
  eachBefore: node_eachBefore,
  sum: node_sum,
  sort: node_sort,
  path: node_path,
  ancestors: node_ancestors,
  descendants: node_descendants,
  leaves: node_leaves,
  links: node_links,
  copy: node_copy
};

function required(f) {
  if (typeof f !== "function") throw new Error;
  return f;
}

var keyPrefix = "$", // Protect against keys like “__proto__”.
    preroot = {depth: -1},
    ambiguous = {};

function defaultId(d) {
  return d.id;
}

function defaultParentId(d) {
  return d.parentId;
}

function stratify() {
  var id = defaultId,
      parentId = defaultParentId;

  function stratify(data) {
    var d,
        i,
        n = data.length,
        root,
        parent,
        node,
        nodes = new Array(n),
        nodeId,
        nodeKey,
        nodeByKey = {};

    for (i = 0; i < n; ++i) {
      d = data[i], node = nodes[i] = new Node(d);
      if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
        nodeKey = keyPrefix + (node.id = nodeId);
        nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;
      }
    }

    for (i = 0; i < n; ++i) {
      node = nodes[i], nodeId = parentId(data[i], i, data);
      if (nodeId == null || !(nodeId += "")) {
        if (root) throw new Error("multiple roots");
        root = node;
      } else {
        parent = nodeByKey[keyPrefix + nodeId];
        if (!parent) throw new Error("missing: " + nodeId);
        if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
        if (parent.children) parent.children.push(node);
        else parent.children = [node];
        node.parent = parent;
      }
    }

    if (!root) throw new Error("no root");
    root.parent = preroot;
    root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);
    root.parent = null;
    if (n > 0) throw new Error("cycle");

    return root;
  }

  stratify.id = function(x) {
    return arguments.length ? (id = required(x), stratify) : id;
  };

  stratify.parentId = function(x) {
    return arguments.length ? (parentId = required(x), stratify) : parentId;
  };

  return stratify;
}

/**
 * Resolves the value at the given JSON path
 * @private
 * @param  {String} path [description]
 * @param  {Object} obj  [description]
 * @return {Object}      [description]
 *
 * @example
 * let path = "/path/to/paradise";
 * let obj = {
 *   path: {
 *     to: { paradise: "heaven"},
 *     from: {...}
 *   }
 * };
 * resolve( path, obj ); // "heaven"
 */
function resolve(path, obj) {
  if (path.charAt(0) === '/') {
    path = path.substring(1);
  }

  var arr = path.split('/');
  var subpath;
  var container = obj;

  for (var i = 0; i < arr.length; i++) {
    if (arr[i] === '*' && Array.isArray(container)) {
      var carr = [];
      subpath = arr.slice(i + 1).join('/');

      for (var c = 0; c < container.length; c++) {
        var v = resolve(subpath, container[c]); // v.forEach(_ => _._parent = container[c]);

        if (Array.isArray(v)) {
          carr.push.apply(carr, _toConsumableArray(v));
        } else {
          carr.push(v);
        }
      }

      return carr; // return container.map(v => resolve(arr.slice(i + 1).join('/'), v));
    }

    if (!arr[i] && Array.isArray(container)) {
      var _carr = new Array(container.length);

      subpath = arr.slice(i + 1).join('/');

      for (var _c = 0; _c < container.length; _c++) {
        _carr[_c] = resolve(subpath, container[_c]);
      }

      return _carr; // return container.map(v => resolve(arr.slice(i + 1).join('/'), v));
    }

    if (arr[i] in container) {
      container = container[arr[i]];
    }
  }

  return container;
}

function flattenTree(children, steps, arrIndexAtTargetDepth) {
  var arr = [];

  if (!children || !children.length) {
    return arr;
  }

  if (steps <= 0) {
    var nodes = arrIndexAtTargetDepth >= 0 ? [children[arrIndexAtTargetDepth]] : children;
    arr.push.apply(arr, _toConsumableArray(nodes));
  } else {
    for (var i = 0; i < children.length; i++) {
      if (children[i].children && children[i].children.length) {
        arr.push.apply(arr, _toConsumableArray(flattenTree(children[i].children, steps - 1, arrIndexAtTargetDepth)));
      }
    }
  }

  return arr;
}

function treeAccessor(sourceDepth, targetDepth, arrIndexAtTargetDepth) {
  if (sourceDepth === targetDepth) {
    return function (d) {
      return d;
    };
  }

  if (sourceDepth > targetDepth) {
    // traverse upwards
    var steps = Math.max(0, Math.min(100, sourceDepth - targetDepth));

    var path = _toConsumableArray(Array(steps)).map(String.prototype.valueOf, 'parent').join('.');

    return Function('node', "return node.".concat(path, ";")); // eslint-disable-line no-new-func
  }

  if (targetDepth > sourceDepth) {
    // flatten descendants
    var _steps = Math.max(0, Math.min(100, targetDepth - sourceDepth));

    return function (node) {
      return flattenTree(node.children, _steps - 1, arrIndexAtTargetDepth);
    };
  }

  return false;
}
function findField(query, _ref) {
  var cache = _ref.cache;

  if (typeof query === 'number') {
    return cache.fields[query];
  }

  var allFields = cache.allFields;

  if (typeof query === 'function') {
    for (var i = 0; i < allFields.length; i++) {
      if (query(allFields[i])) {
        return allFields[i];
      }
    }

    return false;
  }

  if (typeof query === 'string') {
    for (var _i = 0; _i < allFields.length; _i++) {
      if (allFields[_i].key() === query || allFields[_i].title() === query) {
        return allFields[_i];
      }
    }
  } else if (query && allFields.indexOf(query) !== -1) {
    // assume 'query' is a field instance
    return query;
  }

  throw Error("Field not found: ".concat(query));
}

var DIM_RX = /^qDimensionInfo(?:\/(\d+))?/;
var M_RX = /^\/?qMeasureInfo\/(\d+)/;
var ATTR_EXPR_RX = /\/qAttrExprInfo\/(\d+)/;
var ATTR_DIM_RX = /\/qAttrDimInfo\/(\d+)/;

function getColumnOrder(dataset) {
  var qColumnOrder = dataset.raw().qColumnOrder;
  var fields = dataset.fields();
  return qColumnOrder && qColumnOrder.length === fields.length ? qColumnOrder : fields.map(function (f, i) {
    return i;
  });
}

function getDimensionColumnOrder(cube) {
  var order = cube.qColumnOrder && cube.qColumnOrder.length ? cube.qColumnOrder : cube.qDimensionInfo.map(function (d, ii) {
    return ii;
  });
  return order.filter(function (ii) {
    return ii < cube.qDimensionInfo.length;
  });
}

function getFieldDepth(field, _ref) {
  var cube = _ref.cube;

  if (!field) {
    return -1;
  }

  var key = field.origin && field.origin() ? field.origin().key() : field.key();
  var isFieldDimension = false;
  var fieldIdx = -1; // cache.fields.indexOf(field);

  var attrIdx = -1;
  var attrDimIdx = -1;
  var fieldDepth = -1;
  var pseudoMeasureIndex = -1;
  var measureIdx = -1;
  var remainder = key;
  var treeOrder = cube.qEffectiveInterColumnSortOrder;
  var columnOrder = getDimensionColumnOrder(cube);

  if (DIM_RX.test(remainder)) {
    isFieldDimension = true;
    fieldIdx = +DIM_RX.exec(remainder)[1];
    remainder = key.replace(DIM_RX, '');
  }

  if (M_RX.test(remainder)) {
    if (cube.qMode === 'K') {
      pseudoMeasureIndex = +M_RX.exec(remainder)[1];
    } else if (treeOrder && treeOrder.indexOf(-1) !== -1) {
      pseudoMeasureIndex = +M_RX.exec(remainder)[1];
      measureIdx = 0;
    } else {
      measureIdx = +M_RX.exec(remainder)[1];
    }

    remainder = remainder.replace(M_RX, '');
  }

  if (remainder) {
    if (ATTR_DIM_RX.exec(remainder)) {
      attrDimIdx = +ATTR_DIM_RX.exec(remainder)[1];
    } else if (ATTR_EXPR_RX.exec(remainder)) {
      attrIdx = +ATTR_EXPR_RX.exec(remainder)[1];
    }
  }

  if (isFieldDimension) {
    if (cube.qMode === 'S') {
      fieldDepth = columnOrder[fieldIdx];
    } else {
      fieldDepth = treeOrder ? treeOrder.indexOf(fieldIdx) : fieldIdx;
    }
  } else if (treeOrder && treeOrder.indexOf(-1) !== -1) {
    // if pseudo dimension exists in sort order
    fieldDepth = treeOrder.indexOf(-1); // depth of pesudodimension
  } else {
    // assume measure is at the bottom of the tree
    fieldDepth = cube.qDimensionInfo.length - (cube.qMode === 'K' ? 0 : 1);
  }

  return {
    fieldDepth: fieldDepth + 1,
    // +1 due to root node
    pseudoMeasureIndex: pseudoMeasureIndex,
    measureIdx: measureIdx,
    attrDimIdx: attrDimIdx,
    attrIdx: attrIdx
  };
}

function getFieldAccessor$1(sourceDepthObject, targetDepthObject) {
  var nodeFn = treeAccessor(sourceDepthObject.fieldDepth, targetDepthObject.fieldDepth, targetDepthObject.pseudoMeasureIndex);
  var valueFn;

  if (targetDepthObject.measureIdx >= 0) {
    valueFn = function valueFn(node) {
      return node.data.qValues[targetDepthObject.measureIdx];
    };
  } else {
    valueFn = function valueFn(node) {
      return node.data;
    };
  }

  var attrFn;

  if (targetDepthObject.attrDimIdx >= 0) {
    attrFn = function attrFn(data) {
      return data.qAttrDims.qValues[targetDepthObject.attrDimIdx];
    };
  } else if (targetDepthObject.attrIdx >= 0) {
    attrFn = function attrFn(data) {
      return data.qAttrExps.qValues[targetDepthObject.attrIdx];
    };
  }

  return {
    nodeFn: nodeFn,
    attrFn: attrFn,
    valueFn: valueFn
  };
}

function datumExtract$1(propCfg, cell, _ref2) {
  var key = _ref2.key;
  var datum = {
    value: typeof propCfg.value === 'function' ? propCfg.value(cell) : typeof propCfg.value !== 'undefined' ? propCfg.value : cell // eslint-disable-line no-nested-ternary

  };
  datum.label = typeof propCfg.label === 'function' ? propCfg.label(cell) : typeof propCfg.label !== 'undefined' ? String(propCfg.label) : String(datum.value); // eslint-disable-line no-nested-ternary

  if (propCfg.field) {
    datum.source = {
      key: key,
      field: propCfg.field.key()
    };
  }

  return datum;
}

function doIt(_ref3) {
  var propsArr = _ref3.propsArr,
      props = _ref3.props,
      item = _ref3.item,
      itemData = _ref3.itemData,
      ret = _ref3.ret,
      sourceKey = _ref3.sourceKey;

  for (var i = 0; i < propsArr.length; i++) {
    var pCfg = props[propsArr[i]];
    var arr = pCfg.fields || [pCfg];
    var coll = void 0;
    var collStr = void 0;

    if (pCfg.fields) {
      coll = [];
      collStr = [];
    }

    var _loop = function _loop(j) {
      var p = arr[j];
      var fn = void 0;
      var str = void 0;
      var value = void 0;
      var nodes = void 0;
      var cells = void 0;
      var label = void 0;

      if (p.type === 'primitive') {
        value = p.value;
        label = String(p.value);
      } else {
        if (typeof p.value === 'function') {
          fn = function fn(v) {
            return p.value(v, item);
          };
        }

        if (typeof p.label === 'function') {
          str = function str(v) {
            return p.label(v, item);
          };
        }

        if (p.accessor) {
          nodes = p.accessor(item);

          if (Array.isArray(nodes)) {
            // propably descendants
            cells = nodes.map(p.valueAccessor);

            if (p.attrAccessor) {
              cells = cells.map(p.attrAccessor);
            }

            if (fn) {
              value = cells.map(fn);
              fn = null;
            }

            if (str) {
              label = cells.map(str);
              str = null;
            }

            value = p.reduce ? p.reduce(value) : value;
            label = p.reduceLabel ? p.reduceLabel(label, value) : String(value);
          } else {
            value = p.attrAccessor ? p.attrAccessor(p.valueAccessor(nodes)) : p.valueAccessor(nodes);
            label = value;
          }
        } else {
          value = itemData;
          label = itemData;
        }
      }

      if (pCfg.fields) {
        var v = fn ? fn(value) : value;
        coll.push(v);
        collStr.push(str && label != null ? str(label) : label != null ? label : String(v));
      } else {
        var _v = fn ? fn(value) : value;

        ret[propsArr[i]] = {
          value: _v,
          label: str ? str(label) : label != null ? label : String(_v)
        };

        if (p.field) {
          ret[propsArr[i]].source = {
            field: p.field.key(),
            key: sourceKey
          };
        }
      }
    };

    for (var j = 0; j < arr.length; j++) {
      _loop(j);
    }

    if (coll) {
      ret[propsArr[i]] = {
        value: typeof pCfg.value === 'function' ? pCfg.value(coll, item) : coll,
        label: typeof pCfg.label === 'function' ? pCfg.label(collStr, item) : collStr
      };
    }
  }
}

var getHierarchy = function getHierarchy(cube, cache, config) {
  var rootPath = cube.qMode === 'K' ? '/qStackedDataPages/*/qData' : '/qTreeDataPages/*';
  var childNodes = cube.qMode === 'K' ? 'qSubNodes' : 'qNodes';
  var root = resolve(rootPath, cube);

  if (!root || !root[0]) {
    return null;
  }

  cache.tree = hierarchy(root[0], config.children || function (node) {
    return node[childNodes];
  });
  return cache.tree;
};

function getHierarchyForSMode(dataset) {
  var matrix = dataset.raw().qDataPages.length ? dataset.raw().qDataPages[0].qMatrix : [];
  var order = getColumnOrder(dataset);
  var fields = dataset.fields();
  var dimensions = dataset.fields().filter(function (f) {
    return f.type() === 'dimension';
  }).map(function (f) {
    return order.indexOf(fields.indexOf(f));
  });
  var measures = dataset.fields().filter(function (f) {
    return f.type() === 'measure';
  }).map(function (f) {
    return order.indexOf(fields.indexOf(f));
  });
  var root = {
    __id: '__root',
    qValues: []
  };
  var keys = {
    __root: root
  };

  for (var r = 0; r < matrix.length; r++) {
    var row = matrix[r];
    var id = '__root'; // let parent = root;

    var isNew = false;

    for (var c = 0; c < dimensions.length; c++) {
      var cell = row[dimensions[c]];
      var key = "".concat(id, "__").concat(cell.qText);

      if (!keys[key]) {
        keys[key] = Object.assign({
          __id: key,
          __parent: id,
          qValues: []
        }, cell);
        isNew = true;
      }

      id = key;
    }

    if (isNew) {
      for (var _c = 0; _c < measures.length; _c++) {
        var _cell = row[measures[_c]];
        keys[id].qValues.push(_cell);
      }
    }
  }

  var nodes = Object.keys(keys).map(function (key) {
    return keys[key];
  });
  var h = stratify().id(function (d) {
    return d.__id;
  }).parentId(function (d) {
    return d.__parent;
  })(nodes);
  return h;
}

var attachPropsAccessors = function attachPropsAccessors(_ref4) {
  var propsArr = _ref4.propsArr,
      props = _ref4.props,
      cube = _ref4.cube,
      cache = _ref4.cache,
      itemDepthObject = _ref4.itemDepthObject,
      f = _ref4.f;

  for (var i = 0; i < propsArr.length; i++) {
    var pCfg = props[propsArr[i]];
    var arr = pCfg.fields ? pCfg.fields : [pCfg];

    for (var j = 0; j < arr.length; j++) {
      var p = arr[j];

      if (p.field !== f) {
        var depthObject = getFieldDepth(p.field, {
          cube: cube,
          cache: cache
        });
        var accessors = getFieldAccessor$1(itemDepthObject, depthObject);
        p.accessor = accessors.nodeFn; // nodes accessor

        p.valueAccessor = accessors.valueFn; // cell accessor

        p.attrAccessor = accessors.attrFn; // attr cell accessor
      }
    }
  }
};

function augment() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var dataset = arguments.length > 1 ? arguments[1] : undefined;
  var cache = arguments.length > 2 ? arguments[2] : undefined;
  var util = arguments.length > 3 ? arguments[3] : undefined;
  var cube = dataset.raw();
  var sourceKey = dataset.key();
  var h = cube.qMode === 'S' ? getHierarchyForSMode(dataset) : getHierarchy(cube, cache, config);

  if (!h) {
    return null;
  }

  var height = h.height;
  var propDefs = [];

  for (var i = 0; i <= height; i++) {
    var f = null;

    if (i > 0) {
      if (cube.qMode === 'S') {
        var order = getDimensionColumnOrder(cube);
        var idx = order[i - 1];
        f = cache.fields[idx];
      } else {
        var _idx = cube.qEffectiveInterColumnSortOrder[i - 1]; // if (idx === -1) { // pseudo
        //   let childIdx = node.parent.children.indexOf(node);
        //   idx = cube.qDimensionInfo.length + childIdx; // measure field
        // }

        if (i > cube.qEffectiveInterColumnSortOrder.length) {
          _idx = cube.qDimensionInfo.length;
        }

        f = cache.fields[_idx];
      }
    }

    var _util$normalizeConfig = util.normalizeConfig(Object.assign({}, config, {
      field: f ? f.key() : undefined
    }), dataset),
        props = _util$normalizeConfig.props,
        main = _util$normalizeConfig.main;

    var propsArr = Object.keys(props);
    propDefs[i] = {
      propsArr: propsArr,
      props: props,
      main: main
    };
    var itemDepthObject = f ? getFieldDepth(f, {
      cube: cube,
      cache: cache
    }) : {
      fieldDepth: 0
    };
    attachPropsAccessors({
      propsArr: propsArr,
      props: props,
      cube: cube,
      cache: cache,
      itemDepthObject: itemDepthObject,
      f: f
    });
  }

  var replica = h.copy();
  var replicaDescendants = replica.descendants();
  var descendants = h.descendants();

  for (var _i = 0; _i < descendants.length; _i++) {
    var _propsArr = propDefs[descendants[_i].depth].propsArr;
    var props = propDefs[descendants[_i].depth].props;
    var main = propDefs[descendants[_i].depth].main;
    var item = replicaDescendants[_i];
    var itemData = item.data; // main.valueAccessor(currentOriginal);

    var ret = datumExtract$1(main, itemData, {
      key: sourceKey
    });
    doIt({
      propsArr: _propsArr,
      props: props,
      item: item,
      itemData: itemData,
      ret: ret,
      sourceKey: sourceKey,
      isTree: true
    });
    descendants[_i].data = ret;
  }

  return h;
}
function extract$1(config, dataset, cache, util) {
  var cfgs = Array.isArray(config) ? config : [config];
  var dataItems = [];

  for (var g = 0; g < cfgs.length; g++) {
    if (typeof cfgs[g].field !== 'undefined') {
      var cube = dataset.raw();
      var sourceKey = dataset.key();
      var h = getHierarchy(cube, cache, config);

      if (!h) {
        continue;
      }

      var f = _typeof(cfgs[g].field) === 'object' ? cfgs[g].field : dataset.field(cfgs[g].field);

      var _util$normalizeConfig2 = util.normalizeConfig(cfgs[g], dataset),
          props = _util$normalizeConfig2.props,
          main = _util$normalizeConfig2.main;

      var propsArr = Object.keys(props);
      var itemDepthObject = getFieldDepth(f, {
        cube: cube,
        cache: cache
      });

      var _getFieldAccessor = getFieldAccessor$1({
        fieldDepth: 0
      }, itemDepthObject),
          nodeFn = _getFieldAccessor.nodeFn,
          attrFn = _getFieldAccessor.attrFn,
          valueFn = _getFieldAccessor.valueFn;

      attachPropsAccessors({
        propsArr: propsArr,
        props: props,
        cube: cube,
        cache: cache,
        itemDepthObject: itemDepthObject,
        f: f
      });
      var track = !!cfgs[g].trackBy;

      var trackType = _typeof(cfgs[g].trackBy);

      var tracker = {};
      var trackedItems = [];
      var items = nodeFn(cache.tree);
      var mapped = [];

      for (var i = 0; i < items.length; i++) {
        var item = items[i];
        var itemData = attrFn ? attrFn(valueFn(item)) : valueFn(item);
        var exclude = main.filter && !main.filter(itemData);

        if (exclude) {
          continue;
        }

        var ret = datumExtract$1(main, itemData, {
          key: sourceKey
        });
        doIt({
          propsArr: propsArr,
          props: props,
          item: item,
          itemData: itemData,
          ret: ret,
          sourceKey: sourceKey
        }); // collect items based on the trackBy value
        // items with the same trackBy value are placed in an array and reduced later

        if (track) {
          util.track({
            cfg: cfgs[g],
            itemData: itemData,
            obj: ret,
            target: trackedItems,
            tracker: tracker,
            trackType: trackType
          });
        }

        mapped.push(ret);
      } // reduce if items have been grouped


      if (track) {
        dataItems.push.apply(dataItems, _toConsumableArray(util.collect(trackedItems, {
          main: main,
          propsArr: propsArr,
          props: props
        })));
      } else {
        dataItems.push.apply(dataItems, mapped);
      }
    }
  }

  return dataItems;
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var format_min = createCommonjsModule(function (module) {
/*! javascript-number-formatter - v1.1.11 - http://mottie.github.com/javascript-number-formatter/ * © ecava */
!function(a,b){module.exports=b();}(commonjsGlobal,function(){return function(a,b){if(!a||isNaN(+b))return b;var c,d,e,f,g,h,i,j,k,l,m=a.length,n=a.search(/[0-9\-\+#]/),o=n>0?a.substring(0,n):"",p=a.split("").reverse().join(""),q=p.search(/[0-9\-\+#]/),r=m-q,s=a.substring(r,r+1),t=r+("."===s||","===s?1:0),u=q>0?a.substring(t,m):"";if(a=a.substring(n,t),b="-"===a.charAt(0)?-b:+b,c=b<0?b=-b:0,d=a.match(/[^\d\-\+#]/g),e=d&&d[d.length-1]||".",f=d&&d[1]&&d[0]||",",a=a.split(e),b=b.toFixed(a[1]&&a[1].length),b=+b+"",h=a[1]&&a[1].lastIndexOf("0"),j=b.split("."),(!j[1]||j[1]&&j[1].length<=h)&&(b=(+b).toFixed(h+1)),k=a[0].split(f),a[0]=k.join(""),g=a[0]&&a[0].indexOf("0"),g>-1)for(;j[0].length<a[0].length-g;)j[0]="0"+j[0];else 0===+j[0]&&(j[0]="");if(b=b.split("."),b[0]=j[0],i=k[1]&&k[k.length-1].length){for(l=b[0],p="",r=l.length%i,m=l.length,t=0;t<m;t++)p+=l.charAt(t),!((t-r+1)%i)&&t<m-i&&(p+=f);b[0]=p;}return b[1]=a[1]&&b[1]?e+b[1]:"",d=b.join(""),"0"!==d&&""!==d||(c=!1),o+((c?"-":"")+d)+u}});
});

function escapeRegExp(str) {
  return str.replace(/[-[\]/{}()*+?.\\^$|]/g, '\\$&');
}

var SIprefixes = {
  3: 'k',
  6: 'M',
  9: 'G',
  12: 'T',
  15: 'P',
  18: 'E',
  21: 'Z',
  24: 'Y',
  '-3': 'm',
  '-6': 'μ',
  '-9': 'n',
  '-12': 'p',
  '-15': 'f',
  '-18': 'a',
  '-21': 'z',
  '-24': 'y'
},
    percentage = /%$/,
    //    scientific = /e[\+\-][0-9]+/,
radix = /^\(r(0[2-9]|[12]\d|3[0-6])\)/i,
    oct = /^\(oct\)/i,
    dec = /^\(dec\)/i,
    hex = /^\(hex\)/i,
    bin = /^\(bin\)/i,
    rom = /^\(rom\)/i,
    functional = /^(\(rom\)|\(bin\)|\(hex\)|\(dec\)|\(oct\)|\(r(0[2-9]|[12]\d|3[0-6])\))/i,
    prec = /#|0/g;

function formatRadix(value, fradix, pattern, decimal) {
  value = value.toString(fradix);

  if (pattern[1] === pattern[1].toUpperCase()) {
    value = value.toUpperCase();
  }

  if (value.length - value.indexOf('.') > 10) {
    // limit to 10 decimal places
    value = value.slice(0, value.indexOf('.') + 11);
  }

  return value.replace('.', decimal || '.');
} // value must be an integer
// value must not be in scientific notation


function formatRoman(value, pattern) {
  var i,
      s = '',
      v = Number(String(value).slice(-3)),
      nThousands = (value - v) / 1000,
      decimal = [0, 1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900].reverse(),
      numeral = ['0', 'I', 'IV', 'V', 'IX', 'X', 'XL', 'L', 'XC', 'C', 'CD', 'D', 'CM'].reverse();

  while (v > 0) {
    for (i = 0; i < decimal.length; i++) {
      if (decimal[i] <= v) {
        s += numeral[i];
        v -= decimal[i];
        break;
      }
    }
  }

  for (i = 0; i < nThousands; i++) {
    s = "M".concat(s);
  }

  if (pattern[1] !== pattern[1].toUpperCase()) {
    s = s.toLowerCase();
  }

  return s;
}

function formatFunctional(value, pattern, d) {
  var temp;

  if (radix.test(pattern)) {
    value = formatRadix(value, Number(/\d{2}/.exec(pattern)[0]), pattern, d);
  } else if (oct.test(pattern)) {
    value = formatRadix(value, 8, pattern, d);
  } else if (dec.test(pattern)) {
    value = formatRadix(value, 10, pattern, d);
  } else if (hex.test(pattern)) {
    value = formatRadix(value, 16, pattern, d);
  } else if (bin.test(pattern)) {
    value = formatRadix(value, 2, pattern, d);
  } else if (rom.test(pattern)) {
    temp = '';

    if (value < 0) {
      temp = '-';
      value = -value;
    }

    value = Math.floor(value);

    if (value === 0) {
      value = '0';
    } else if (value <= 500000) {
      // limit in engine
      value = formatRoman(value, pattern);
      value = temp + value;
    } else {
      value = pattern + temp + value.toExponential(0); // to return same result as engine
    }
  }

  return value;
}

function escape(value, flags, justStr) {
  var str = escapeRegExp(value);

  if (justStr) {
    return str;
  }

  return new RegExp(str || '', flags);
}

function createRegExp(thousand, decimal) {
  if (decimal) {
    decimal = escapeRegExp(decimal);
  }

  if (thousand) {
    thousand = escapeRegExp(thousand);
  }

  return new RegExp("(?:[#0]+".concat(thousand, ")?[#0]+(?:").concat(decimal, "[#0]+)?"));
}

function getAbbreviations(localeInfo, listSeparator) {
  if (!localeInfo || !localeInfo.qNumericalAbbreviation) {
    return SIprefixes;
  }

  var abbreviations = {};
  var abbrs = localeInfo.qNumericalAbbreviation.split(listSeparator);
  abbrs.forEach(function (abbreviation) {
    var abbreviationTuple = abbreviation.split(':');

    if (abbreviationTuple.length === 2) {
      abbreviations[abbreviationTuple[0]] = abbreviationTuple[1];
    }
  });
  return abbreviations;
}

function preparePattern(o, t, d) {
  var parts,
      lastPart,
      pattern = o.pattern,
      numericPattern,
      prefix,
      postfix,
      groupTemp,
      decTemp,
      temp,
      regex;

  if (pattern.indexOf('A') >= 0) {
    // abbreviate SI
    pattern = pattern.replace('A', '');
    o.abbreviate = true;
  } // extract the numeric part from the pattern


  regex = createRegExp(t, d);
  numericPattern = pattern.match(regex);
  numericPattern = numericPattern ? numericPattern[0] : '';
  prefix = numericPattern ? pattern.substr(0, pattern.indexOf(numericPattern)) : pattern;
  postfix = numericPattern ? pattern.substring(pattern.indexOf(numericPattern) + numericPattern.length) : '';

  if (!numericPattern) {
    numericPattern = pattern ? '#' : '##########';
  }

  if (t && t === d) {
    // ignore grouping if grouping separator is same as decimal separator
    // extract decimal part
    parts = numericPattern.split(d);
    lastPart = parts.pop();
    numericPattern = parts.join('') + d + lastPart;
    t = '';
  } // formatting library does not support multiple characters as separator (nor +-).
  // do a temporary replacement


  groupTemp = t;
  t = /,/.test(d) ? '¤' : ',';

  if (groupTemp) {
    numericPattern = numericPattern.replace(escape(groupTemp, 'g'), t);
  }

  decTemp = d;
  d = '.';

  if (decTemp) {
    numericPattern = numericPattern.replace(escape(decTemp, 'g'), d);
  }

  temp = numericPattern.match(/#/g);
  temp = temp ? temp.length : 0;
  var splitPattern = pattern.split(decTemp);
  var matchPrecisionResult;

  if (splitPattern[1]) {
    matchPrecisionResult = splitPattern[1].match(prec);
  }

  o.prefix = prefix || '';
  o.postfix = postfix || '';
  o.pattern = pattern;
  o.maxPrecision = matchPrecisionResult ? matchPrecisionResult.length : 2;
  o.percentage = percentage.test(pattern);
  o.numericPattern = numericPattern || '';
  o.numericRegex = new RegExp("".concat(escape(t, null, true), "|").concat(escape(d, null, true)), 'g');
  o.groupTemp = groupTemp;
  o.decTemp = decTemp;
  o.t = t;
  o.d = d;
  o.temp = temp;
}

var NumberFormatter =
/*#__PURE__*/
function () {
  /**
   * @name NumberFormatter
   * @constructs
   * @param {Object} localeInfo
   * @param {String} pattern
   * @param {String} [thousand]
   * @param {String} [decimal]
   * @param {String} [type]
   */
  function NumberFormatter(localeInfo, pattern, thousand, decimal, type) {
    _classCallCheck(this, NumberFormatter);

    this.localeInfo = localeInfo;
    this.pattern = pattern;
    this.thousandDelimiter = thousand || ',';
    this.decimalDelimiter = decimal || '.';
    this.type = type || 'numeric'; // FIXME qListSep?
    // this.patternSeparator = this.localeInfo && this.localeInfo.qListSep ? this.localeInfo.qListSep : ';';

    this.patternSeparator = ';';
    this.abbreviations = getAbbreviations(localeInfo, this.patternSeparator);
    this.prepare();
  }

  _createClass(NumberFormatter, [{
    key: "clone",
    value: function clone() {
      var n = new NumberFormatter(this.localeInfo, this.pattern, this.thousandDelimiter, this.decimalDelimiter, this.type);
      n.subtype = this.subtype;
      return n;
    }
    /**
     * Formats a number according to a specific pattern.
     * Use # for optional numbers and 0 for padding.
     * @param {Number} value Number to format.
     * @param {String} [pattern] The pattern to apply.
     * @param {String} [t] Grouping separator.
     * @param {String} [d] Decimal delimiter.
     * @example
     * format(10, "0") // 10;
     * format(10, "#") // 10;
     * format(10, "##.#") // 10;
     * format(10, "##.0") // 10.0;
     * format(10, "000") // 010;
     * format(10.123, "0.0") // 10.1;
     * format(10.123, "0.00##") // 10.123; // at least 2 decimals, never more than 4
     * format(123456789, "#,###") // 123,456,789;
     * format(123456789, "####-####", "-") // 1-2345-6789;
     * format(10000, "#A") // 10k,  A -> SI abbreviation
     * format(1234567, "#.###A") // 1.235M;
     * format(0.0001, "#.#A") // 0.1m;
     *
     * format(0.257, "0.0%") // 25.7%; // will multiply by 100
     * format(9876, "$#,###") // $9,876;
     * format(-9876, "$#,###;$(#,###)") // $(9,876); // use ; for alternative formatting for negative values
     * format(10, "(r16)") // a; // radix 16
     * format(15, "(hex)") // f; // same as (r16)
     * format(15, "(HEX)") // F;
     * format(10, "(bin)") // 1010; // same as (r02)
     * format(10, "(oct)") // 12; // same as (r08)
     */

  }, {
    key: "format",
    value: function format(value, pattern, t, d) {
      this.prepare(pattern, t, d);
      return this.formatValue(value);
    }
  }, {
    key: "prepare",
    value: function prepare(pattern, t, d) {
      var prep;

      if (typeof pattern === 'undefined') {
        pattern = this.pattern;
      }

      if (typeof t === 'undefined') {
        t = this.thousandDelimiter;
      }

      if (typeof d === 'undefined') {
        d = this.decimalDelimiter;
      }

      if (!pattern) {
        this._prepared = {
          pattern: false
        };
        return;
      }

      this._prepared = {
        positive: {
          d: d,
          t: t,
          abbreviate: false,
          isFunctional: false,
          prefix: '',
          postfix: ''
        },
        negative: {
          d: d,
          t: t,
          abbreviate: false,
          isFunctional: false,
          prefix: '',
          postfix: ''
        },
        zero: {
          d: d,
          t: t,
          abbreviate: false,
          isFunctional: false,
          prefix: '',
          postfix: ''
        }
      };
      prep = this._prepared;
      pattern = pattern.split(this.patternSeparator);
      prep.positive.pattern = pattern[0];
      prep.negative.pattern = pattern[1];
      prep.zero.pattern = pattern[2];

      if (functional.test(pattern[0])) {
        prep.positive.isFunctional = true;
      }

      if (!pattern[1]) {
        prep.negative = false;
      } else if (functional.test(pattern[1])) {
        prep.negative.isFunctional = true;
      }

      if (!pattern[2]) {
        prep.zero = false;
      } else if (functional.test(pattern[2])) {
        prep.zero.isFunctional = true;
      }

      if (!prep.positive.isFunctional) {
        preparePattern(prep.positive, t, d);
      }

      if (prep.negative && !prep.negative.isFunctional) {
        preparePattern(prep.negative, t, d);
      }

      if (prep.zero && !prep.zero.isFunctional) {
        preparePattern(prep.zero, t, d);
      }
    }
  }, {
    key: "formatValue",
    value: function formatValue(value) {
      var prep = this._prepared,
          temp,
          exponent,
          abbr = '',
          absValue,
          num,
          sciValue = '',
          d,
          t,
          i,
          numericPattern,
          decimalPartPattern,
          original = value;

      if (isNaN(value)) {
        return "".concat(original);
      }

      value = +value;

      if (prep.pattern === false) {
        return value.toString();
      }

      if (value === 0 && prep.zero) {
        prep = prep.zero;
        return prep.pattern;
      }

      if (value < 0 && prep.negative) {
        prep = prep.negative;
        value = -value;
      } else {
        prep = prep.positive;
      }

      d = prep.d;
      t = prep.t;

      if (prep.isFunctional) {
        value = formatFunctional(value, prep.pattern, d);
      } else {
        if (prep.percentage) {
          value *= 100;
        }

        if (prep.abbreviate) {
          var abbrArray = Object.keys(this.abbreviations).map(function (key) {
            return parseInt(key, 10);
          }).sort(function (a, b) {
            return a - b;
          });
          var lowerAbbreviation;
          var upperAbbreviation = abbrArray[0];
          i = 0;
          exponent = Number(Number(value).toExponential().split('e')[1]);

          while (upperAbbreviation <= exponent && i < abbrArray.length) {
            i++;
            upperAbbreviation = abbrArray[i];
          }

          if (i > 0) {
            lowerAbbreviation = abbrArray[i - 1];
          }

          var suggestedAbbrExponent; // value and lower abbreviation is for values above 10, use the lower (move to the left <==)

          if (lowerAbbreviation && exponent > 0 && lowerAbbreviation > 0) {
            suggestedAbbrExponent = lowerAbbreviation; // value and lower abbreviation is for values below 0.1 (move to the right ==>)
          } else if (exponent < 0 && lowerAbbreviation < 0 || !lowerAbbreviation) {
            // upper abbreviation is also for values below 0.1 and precision allows for using the upper abbreviation(move to the right ==>)
            if (upperAbbreviation < 0 && upperAbbreviation - exponent <= prep.maxPrecision) {
              suggestedAbbrExponent = upperAbbreviation; // lower abbrevaition is smaller than exponent and we can't get away with not abbreviating
            } else if (lowerAbbreviation <= exponent && !(upperAbbreviation > 0 && -exponent <= prep.maxPrecision)) {
              // (move to left <==)
              suggestedAbbrExponent = lowerAbbreviation;
            }
          }

          if (suggestedAbbrExponent) {
            abbr = this.abbreviations[suggestedAbbrExponent];
            value /= Math.pow(10, suggestedAbbrExponent);
          }
        }

        absValue = Math.abs(value);
        temp = prep.temp;
        numericPattern = prep.numericPattern;
        decimalPartPattern = numericPattern.split(d)[1];

        if (this.type === 'I') {
          value = Math.round(value);
        }

        num = value;

        if (!decimalPartPattern && numericPattern.slice(-1)[0] === '#') {
          if (absValue >= Math.pow(10, temp) || absValue < 1 || absValue < 1e-4) {
            if (value === 0) {
              value = '0';
            } else if (absValue < 1e-4 || absValue >= 1e20) {
              // engine always formats values < 1e-4 in scientific form, values >= 1e20 can only be represented in scientific form
              value = num.toExponential(Math.max(1, Math.min(14, temp)) - 1);
              value = value.replace(/\.?0+(?=e)/, '');
              sciValue = '';
            } else {
              value = value.toPrecision(Math.max(1, Math.min(14, temp)));

              if (value.indexOf('.') >= 0) {
                value = value.replace(value.indexOf('e') < 0 ? /0+$/ : /\.?0+(?=e)/, '');
                value = value.replace('.', d);
              }
            }
          } else {
            numericPattern += d;
            temp = Math.max(0, Math.min(20, temp - Math.ceil(Math.log(absValue) / Math.log(10))));

            for (i = 0; i < temp; i++) {
              numericPattern += '#';
            }

            value = format_min(numericPattern, value);
          }
        } else if (absValue >= 1e15 || absValue > 0 && absValue <= 1e-14) {
          value = absValue ? absValue.toExponential(15).replace(/\.?0+(?=e)/, '') : '0';
        } else {
          var wholePart = Number(value.toFixed(Math.min(20, decimalPartPattern ? decimalPartPattern.length : 0)).split('.')[0]);
          var wholePartPattern = numericPattern.split(d)[0];
          wholePartPattern += d;
          value = format_min(wholePartPattern, wholePart) || '0';

          if (decimalPartPattern) {
            var nDecimals = Math.max(0, Math.min(14, decimalPartPattern.length)); // the length of e.g. 0000#####

            var nZeroes = decimalPartPattern.replace(/#+$/, '').length;
            var decimalPart = (this.type === 'I' ? 0 : absValue % 1).toFixed(nDecimals).slice(2).replace(/0+$/, ''); // remove trailing zeroes

            for (i = decimalPart.length; i < nZeroes; i++) {
              decimalPart += '0';
            }

            if (decimalPart) {
              value += d + decimalPart;
            }
          } else if (wholePart === 0) {
            // to avoid "-" being prefixed to value
            num = 0;
          }
        }

        value = value.replace(prep.numericRegex, function (m) {
          if (m === t) {
            return prep.groupTemp;
          }

          if (m === d) {
            return prep.decTemp;
          }

          return '';
        });

        if (num < 0 && !/^-/.test(value)) {
          value = "-".concat(value);
        }
      }

      return prep.prefix + value + sciValue + abbr + prep.postfix;
    }
  }], [{
    key: "getStaticFormatter",
    value: function getStaticFormatter() {
      return {
        prepare: function prepare() {},
        formatValue: function formatValue(v) {
          return "".concat(v);
        }
      };
    }
  }]);

  return NumberFormatter;
}();

function numberFormatFactory() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return _construct(NumberFormatter, args);
}

function memoize(func) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _opts$size = opts.size,
      size = _opts$size === void 0 ? 5000 : _opts$size,
      _opts$multipleArgumen = opts.multipleArguments,
      multipleArguments = _opts$multipleArgumen === void 0 ? false : _opts$multipleArgumen,
      _opts$toKey = opts.toKey,
      toKey = _opts$toKey === void 0 ? function (arg) {
    return arg;
  } : _opts$toKey;
  var cache = Object.create(null);
  var index = Object.create(null);
  var counter = 0;
  var fifo = 0; // First-In-First-Out index

  var _cacher2;

  var k;

  if (multipleArguments) {
    _cacher2 = function cacher() {
      k = toKey.apply(void 0, arguments);

      if (_cacher2.has(k)) {
        return _cacher2.get(k);
      }

      return _cacher2.set(k, func.apply(void 0, arguments));
    };
  } else {
    _cacher2 = function _cacher(arg) {
      k = toKey(arg);

      if (_cacher2.has(k)) {
        return _cacher2.get(k);
      }

      return _cacher2.set(k, func(arg));
    };
  }

  _cacher2.set = function (key, val) {
    if (counter >= size) {
      delete cache[index[fifo]];
      delete index[fifo];
      counter--;
      fifo++;
    }

    cache[key] = val;
    index[counter] = key;
    counter++;
    return val;
  };

  _cacher2.get = function (key) {
    return cache[key];
  };

  _cacher2.has = function (key) {
    return key in cache;
  };

  _cacher2.clear = function () {
    cache = Object.create(null);
    index = Object.create(null);
    counter = 0;
    fifo = 0;
  };

  _cacher2.size = function () {
    return counter;
  };

  return _cacher2;
}

function formatter(pattern, thousand, decimal, qType, localeInfo) {
  var qformat = numberFormatFactory(localeInfo, pattern, thousand, decimal, qType);
  var memoized = memoize(qformat.formatValue.bind(qformat), {
    // Handle NaN and cases where toString yields different result than +operator. Ex. a Date.
    toKey: function toKey(value) {
      return isNaN(value) ? value : +value;
    }
  });
  /**
   * Format a value according to the specified pattern created at construct
   *
   * @param  {Number} value   The number to be formatted
   * @return {String}         [description]
   */

  function format(value) {
    return memoized(value);
  }
  /**
    * Format a value according to a specific pattern
    * that is not the one specified in the constructor
    *
    * @param  {String} p   Pattern
    * @param  {Number} v   Value
    * @param  {String} t   Thousand
    * @param  {String} d   Decimal
    * @return {String}     Formatted value
    */


  format.format = function formatFn(p, v, t, d) {
    memoized.clear();
    return qformat.format(v, p, t, d);
  };
  /**
    * Change the pattern on existing formatter
    *
    * @param  {String} p     Pattern (optional)
    * @return {String}       Returns the pattern
    */


  format.pattern = function patternFn(p) {
    if (p) {
      memoized.clear();
      qformat.pattern = p;
      qformat.prepare();
    }

    return qformat.pattern;
  };
  /**
   * Set the locale for the formatter
   *
   * @param  {Object} args   Locale object for formatting
   * @return {Undefined}      Returns nothing
   */

  /* format.locale = function( ...args ) {
    locale = formatLocale( ...args );
    d3format = locale.format( pattern );
     return this;
  }; */


  return format;
}

/* eslint import/prefer-default-export: 0 */
var TYPES = {
  AUTO: 'U',
  INTEGER: 'I',
  NUMBER: 'R',
  FIXED_TO: 'F',
  MONEY: 'M',
  DATE: 'D',
  TIME: 'T',
  DATE_TIME: 'TS',
  INTERVAL: 'IV'
};

var DAYS = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
var DAYS_ABBR = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
var MONTHS = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
var MONTHS_ABBR = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
var SECONDS_PER_DAY = 86400;

function pad(s, n) {
  for (var i = s.length; i < n; i++) {
    s = "0".concat(s);
  }

  return s;
}

function parseDate(d, twelveFormat) {
  var h = d.getUTCHours();
  var day = d.getUTCDay() - 1;

  if (twelveFormat) {
    h %= 12;

    if (!h) {
      // h == 0 -> 12
      h = 12;
    }
  }

  if (day < 0) {
    day = 6;
  }

  return {
    year: d.getUTCFullYear(),
    month: d.getUTCMonth(),
    day: day,
    date: d.getUTCDate(),
    h: h,
    m: d.getUTCMinutes(),
    s: d.getUTCSeconds(),
    f: d.getUTCMilliseconds(),
    t: d.getUTCHours() >= 12 ? 'pm' : 'am'
  };
}

function getRemainder(value) {
  var s = value.toString().split('.');

  if (s[1]) {
    s = Number("0.".concat(s[1]));
  } else {
    return 0;
  }

  return s;
}

function parseIntervalDays(days) {
  var d = days;
  var h = 24 * getRemainder(d);
  var m = 60 * getRemainder(h);
  var s = 60 * getRemainder(m);
  var ms = 1000 * getRemainder(s);
  return {
    d: Math.floor(d),
    h: Math.floor(h),
    m: Math.floor(m),
    s: Math.floor(s),
    f: Math.round(ms)
  };
}

function parseInterval(days, pattern) {
  var units = parseIntervalDays(days),
      d = units.d,
      h = units.h,
      m = units.m,
      s = units.s,
      f = units.f,
      w = 0,
      date;

  if (/w+|t+/gi.test(pattern)) {
    date = new Date(Date.UTC(1899, 11, 30 + Math.floor(days), 0, 0, Math.round(SECONDS_PER_DAY * (days - Math.floor(days)))));

    if (isNaN(date.getTime())) {
      date = null;
    }
  }

  if (!/D+/gi.test(pattern)) {
    h += d * 24;
  }

  if (!/h+/gi.test(pattern)) {
    m += h * 60;
  }

  if (!/m+/gi.test(pattern)) {
    s += m * 60;
  }

  if (/w+/gi.test(pattern)) {
    w = date ? date.getDay() - 1 : 0;

    if (w < 0) {
      w = 6;
    }
  }

  var someT = '';

  if (date) {
    someT = date.getUTCHours() >= 12 ? 'pm' : 'am';
  }

  return {
    year: 0,
    month: 0,
    day: w,
    date: d,
    h: h,
    m: m,
    s: s,
    f: f,
    t: someT
  };
}

function getMasks(inst, d) {
  return {
    'Y+|y+': {
      Y: "".concat(Number("".concat(d.year).slice(-2))),
      YY: pad("".concat(d.year).slice(-2), 2),
      YYY: pad("".concat(d.year).slice(-3), 3),
      def: function def(m) {
        // default
        return pad("".concat(d.year), m.length);
      }
    },
    'M+': {
      M: d.month + 1,
      MM: pad("".concat(d.month + 1), 2),
      MMM: inst.locale_months_abbr[d.month],
      def: inst.locale_months[d.month]
    },
    'W+|w+': {
      W: d.day,
      WW: pad("".concat(d.day), 2),
      WWW: inst.locale_days_abbr[d.day],
      def: inst.locale_days[d.day]
    },
    'D+|d+': {
      D: d.date,
      def: function def(m) {
        return pad("".concat(d.date), m.length);
      }
    },
    'h+|H+': {
      h: d.h,
      def: function def(m) {
        return pad("".concat(d.h), m.length);
      }
    },
    'm+': {
      m: d.m,
      def: function def(m) {
        return pad("".concat(d.m), m.length);
      }
    },
    's+|S+': {
      s: d.s,
      def: function def(m) {
        return pad("".concat(d.s), m.length);
      }
    },
    'f+|F+': {
      def: function def(m) {
        var f = "".concat(d.f),
            n = m.length - f.length;

        if (n > 0) {
          for (var i = 0; i < n; i++) {
            f += '0';
          }
        } else if (n < 0) {
          f = f.slice(0, m.length);
        }

        return f;
      }
    },
    't{1,2}|T{1,2}': {
      def: function def(m) {
        var t = d.t;

        if (m[0].toUpperCase() === m[0]) {
          t = t.toUpperCase();
        }

        t = t.slice(0, m.length);
        return t;
      }
    }
  };
}

var DateFormatter =
/*#__PURE__*/
function () {
  /**
   * @name DateFormatter
   * @constructs
   * @param {Object} localeInfo
   * @param {String} pattern
   */
  function DateFormatter(localeInfo, pattern, qtype) {
    _classCallCheck(this, DateFormatter);

    var info = localeInfo || {};

    if (!info.qCalendarStrings) {
      info.qCalendarStrings = {
        qLongDayNames: DAYS,
        qDayNames: DAYS_ABBR,
        qLongMonthNames: MONTHS,
        qMonthNames: MONTHS_ABBR
      };
    }

    this.localeInfo = info;
    this.locale_days = info.qCalendarStrings.qLongDayNames.slice();
    this.locale_days_abbr = info.qCalendarStrings.qDayNames.slice();
    this.locale_months = info.qCalendarStrings.qLongMonthNames.slice();
    this.locale_months_abbr = info.qCalendarStrings.qMonthNames.slice();

    if (!pattern) {
      var _patternMap;

      var patternMap = (_patternMap = {}, _defineProperty(_patternMap, TYPES.TIME, info.qTimeFmt || 'hh:mm:ss'), _defineProperty(_patternMap, TYPES.DATE, info.qDateFmt || 'YYYY-MM-DD'), _defineProperty(_patternMap, TYPES.DATE_TIME, info.qTimestampFmt || 'YYYY-MM-DD hh:mm:ss'), _patternMap);
      pattern = patternMap[qtype];
    }

    this.pattern = pattern;
  }

  _createClass(DateFormatter, [{
    key: "clone",
    value: function clone() {
      var n = new DateFormatter(this.localeInfo, this.pattern);
      n.subtype = this.subtype;
      return n;
    }
    /**
     * Formats a date according to given pattern
     * @param {Date} date The date to format.
     * @param {String} pattern The desired format of the date
     * var d = new Date(2013, 8, 15, 13, 55, 40, 987);
     * var n = new DateFormatter();
     * @example
     * m.format( d, 'YYYY-MM-DD hh:mm:ss.ffff') // 2013-08-15 13:55:40.9870
     * m.format( d, 'h:m:s tt') // 1:55:40 pm
     * m.format( d, 'h:m:s TT') // 1:55:40 PM
     * m.format( d, 'M/D/YYYY') // 8/15/2013
     * m.format( d, 'WWWW DD MMM') // Thursday 15 Aug
     * m.format( d, 'WWW DD MMMM @ hh:mm:ss') // Thu 15 August @ 13:55:40
     */

  }, {
    key: "format",
    value: function format(date, pattern) {
      // Fallback pattern is set in constructor
      if (!pattern) {
        pattern = this.pattern ? this.pattern : 'YYYY-MM-DD hh:mm:ss';
      }

      pattern = pattern.replace(/\[.+]|\[|]/g, '');
      var hasTwelveFlag = /t+/ig.test(pattern);
      var parsedDate;

      if (date instanceof Date) {
        parsedDate = parseDate(date, hasTwelveFlag);
      } else {
        if (date < 0) {
          // parseInterval don't support for negative values
          date = -date;
          pattern = "-".concat(pattern);
        }

        parsedDate = parseInterval(date, pattern);
      } // remove [] and everything inside it


      var masks = getMasks(this, parsedDate);
      var masksArr = [];

      for (var mask in masks) {
        if (Object.prototype.hasOwnProperty.call(masks, mask)) {
          masksArr.push(mask);
        }
      }

      var dateTimeRegex = new RegExp(masksArr.join('|'), 'g');
      var result = pattern.replace(dateTimeRegex, function (m) {
        var r;
        var mask;

        for (mask in masks) {
          if (Object.prototype.hasOwnProperty.call(masks, mask)) {
            r = new RegExp(mask);

            if (r.test(m)) {
              break;
            }
          }
        }

        if (!r) {
          return '';
        }

        var value;

        for (var submask in masks[mask]) {
          if (submask === m || submask.toLowerCase() === m) {
            value = masks[mask][submask];

            if (typeof value === 'undefined') {
              value = masks[mask][submask.toLowerCase()];
            }

            break;
          }
        }

        if (typeof value === 'undefined') {
          value = masks[mask].def;
        }

        if (typeof value === 'function') {
          value = value(m);
        }

        return value;
      });
      return result;
    }
  }]);

  return DateFormatter;
}();

function dateFormatFactory() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return _construct(DateFormatter, args);
}

var MS_PER_DAY = 86400000;
function QlikTimeToDate(value) {
  return new Date(Date.UTC(1899, 11, 30 + Math.floor(value), 0, 0, 0, Math.round(MS_PER_DAY * (value - Math.floor(value)))));
}
function formatter$1(pattern) {
  var qtype = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'TS';
  var localeInfo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var qformat = dateFormatFactory(localeInfo, pattern, qtype);
  var memoized = memoize(qformat.format.bind(qformat), {
    toKey: function toKey(date) {
      return _typeof(date) === 'object' && typeof date.getTime === 'function' ? date.getTime() : date;
    }
  });
  /**
   * Prepare a value according to the specified qtype
   *
   * @param  {Number} value The value to be formatted
   * @return {Number}       The converted value (if applied)
   */

  function prepare(value) {
    if (qtype !== TYPES.INTERVAL) {
      return QlikTimeToDate(value);
    }

    return value;
  }
  /**
   * Format a value according to the specified pattern created at construct
   *
   * @param  {Date} value   The number to be formatted
   * @return {String}         [description]
   */


  function format(value) {
    value = prepare(value);
    return memoized(value);
  }
  /**
    * Format a value according to a specific pattern
    * that is not the one specified in the constructor
    *
    * @param  {String} p   Pattern
    * @param  {Date} v   Value
    * @return {String}     Formatted value
    */


  format.format = function formatFn(p, v) {
    memoized.clear();
    v = prepare(v);
    return qformat.format(v, p);
  };
  /**
   * Set the locale for the formatter
   *
   * @param  {Object} args   Locale object for formatting
   * @return {Undefined}      Returns nothing
   */


  format.locale = function locale(li) {
    qformat = dateFormatFactory(li, pattern, qtype);
    memoized = memoize(qformat.format.bind(qformat), {
      toKey: function toKey(date) {
        return _typeof(date) === 'object' ? date.getTime() : date;
      }
    });
    return this;
  };
  /**
   * Get or set the QType
   *
   * @param  {String} nqt New qType (optional)
   * @return {String}     Current qtype
   */


  format.qtype = function qtypeFn(nqt) {
    if (nqt !== undefined) {
      qtype = nqt;
      memoized.clear();
    }

    return qtype;
  };

  return format;
}

function createFromMetaInfo(meta, localeInfo) {
  if (meta && meta.qNumFormat && ['D', 'T', 'TS', 'IV'].indexOf(meta.qNumFormat.qType) !== -1) {
    return formatter$1(meta.qNumFormat.qFmt, meta.qNumFormat.qType, localeInfo);
  }

  var pattern = '#';
  var thousand = localeInfo && typeof localeInfo.qThousandSep !== 'undefined' ? localeInfo.qThousandSep : ',';
  var decimal = localeInfo && typeof localeInfo.qDecimalSep !== 'undefined' ? localeInfo.qDecimalSep : '.';
  var type = 'U';
  var isAuto = meta && !!meta.qIsAutoFormat;

  if (meta && meta.qNumFormat) {
    pattern = meta.qNumFormat.qFmt || pattern;
    thousand = meta.qNumFormat.qThou || thousand;
    decimal = meta.qNumFormat.qDec || decimal;
    type = meta.qNumFormat.qType || type;
    isAuto = isAuto && ['M'].indexOf(meta.qNumFormat.qType) === -1;
  } else {
    isAuto = true;
  }

  if (isAuto || type === 'U') {
    pattern = "#".concat(decimal, "##A");
    type = 'U';
  }

  return formatter(pattern, thousand, decimal, type, localeInfo);
}

function qField() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      meta = _ref.meta,
      _id = _ref.id,
      _key = _ref.key,
      localeInfo = _ref.localeInfo,
      fieldExtractor = _ref.fieldExtractor,
      value = _ref.value,
      _type = _ref.type,
      sourceField = _ref.sourceField;

  var values;
  var valueFn = value || (_type === 'dimension' ? function (d) {
    return d.qElemNo;
  } : function (d) {
    return d.qValue;
  });

  var labelFn = function labelFn(d) {
    return d.qText || '';
  };

  var reduce = _type === 'dimension' ? 'first' : 'avg';

  var _formatter = createFromMetaInfo(meta, localeInfo);

  var reduceLabel = _type === 'dimension' ? 'first' : function (labels, v) {
    return _formatter(v);
  };
  var f = {
    id: function id() {
      return _id;
    },
    key: function key() {
      return _key;
    },
    raw: function raw() {
      return meta;
    },
    title: function title() {
      return meta.qFallbackTitle || meta.label;
    },
    type: function type() {
      return _type;
    },
    origin: function origin() {
      return sourceField;
    },
    items: function items() {
      if (!values) {
        values = fieldExtractor(f);
      }

      return values;
    },
    min: function min() {
      return meta.qMin;
    },
    max: function max() {
      return meta.qMax;
    },
    value: valueFn,
    label: labelFn,
    reduce: reduce,
    reduceLabel: reduceLabel,
    formatter: function formatter() {
      return _formatter;
    },
    tags: function tags() {
      return meta.qTags;
    }
  };
  return f;
}

function createFields(path, obj, prefix, parentKey, opts) {
  return (obj[path] || []).map(function (meta, i) {
    var fieldKey = "".concat(parentKey ? "".concat(parentKey, "/") : '').concat(path, "/").concat(i);
    var f = {
      instance: qField(extend({
        id: "".concat(prefix ? "".concat(prefix, "/") : '').concat(fieldKey),
        key: fieldKey,
        meta: meta
      }, opts))
    };
    f.attrDims = createFields('qAttrDimInfo', meta, prefix, fieldKey, extend({}, opts, {
      value: function value(v) {
        return v.qElemNo;
      },
      type: 'dimension'
    }));
    f.attrExps = createFields('qAttrExprInfo', meta, prefix, fieldKey, extend({}, opts, {
      value: function value(v) {
        return v.qNum;
      },
      type: 'measure'
    }));
    f.measures = createFields('qMeasureInfo', meta, prefix, fieldKey, extend({}, opts, {
      value: function value(v) {
        return v.qValue;
      },
      type: 'measure'
    }));
    return f;
  });
}

function q() {
  var _cache$wrappedFields, _cache$wrappedFields2, _cache$allFields;

  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _key = _ref.key,
      data = _ref.data,
      _ref$config = _ref.config,
      config = _ref$config === void 0 ? {} : _ref$config;

  var cache = {
    fields: [],
    wrappedFields: [],
    allFields: [],
    virtualFields: []
  };
  var cube = data;

  if (!cube) {
    throw new Error('Missing "data" input');
  }

  if (!cube.qDimensionInfo) {
    throw new Error('The "data" input is not recognized as a hypercube');
  }

  var deps = q.util;
  var opts = {
    cache: cache,
    cube: cube,
    localeInfo: config.localeInfo,
    fieldExtractor: null,
    pages: null,
    hierarchy: function hierarchy() {
      return null;
    },
    virtualFields: config.virtualFields
  };
  var dataset = {
    key: function key() {
      return _key;
    },
    raw: function raw() {
      return cube;
    },
    field: function field(query) {
      return findField(query, opts);
    },
    fields: function fields() {
      return cache.fields.slice();
    },
    extract: function extract(extractionConfig) {
      return opts.extractor(extractionConfig, dataset, cache, deps);
    },
    hierarchy: function hierarchy(hierarchyConfig) {
      return opts.hierarchy(hierarchyConfig, dataset, cache, deps);
    },
    _cache: function _cache() {
      return cache;
    }
  };

  if (cube.qMode === 'K' || cube.qMode === 'T' || !cube.qMode && cube.qNodesOnDim) {
    opts.extractor = extract$1;
    opts.hierarchy = augment;
    opts.pages = cube.qMode === 'K' ? cube.qStackedDataPages : cube.qTreeDataPages;
  } else if (cube.qMode === 'S') {
    opts.extractor = extract;
    opts.pages = cube.qDataPages;
    opts.hierarchy = augment;
  } else {
    opts.extractor = function () {
      return [];
    }; // TODO - throw unsupported error?

  }

  opts.fieldExtractor = function (f) {
    return opts.extractor({
      field: f
    }, dataset, cache, deps);
  };

  var dimAcc = cube.qMode === 'S' ? function (d) {
    return d.qElemNumber;
  } : undefined;
  var measAcc = cube.qMode === 'S' ? function (d) {
    return d.qNum;
  } : undefined;

  (_cache$wrappedFields = cache.wrappedFields).push.apply(_cache$wrappedFields, _toConsumableArray(createFields('qDimensionInfo', cube, _key, '', extend({}, opts, {
    value: dimAcc,
    type: 'dimension'
  }))));

  (_cache$wrappedFields2 = cache.wrappedFields).push.apply(_cache$wrappedFields2, _toConsumableArray(createFields('qMeasureInfo', cube, _key, '', extend({}, opts, {
    value: measAcc,
    type: 'measure'
  }))));

  cache.fields = cache.wrappedFields.map(function (f) {
    return f.instance;
  });

  var traverse = function traverse(arr) {
    arr.forEach(function (f) {
      cache.allFields.push(f.instance);
      traverse(f.measures);
      traverse(f.attrDims);
      traverse(f.attrExps);
    });
  };

  traverse(cache.wrappedFields);
  (config.virtualFields || []).forEach(function (v) {
    // key: 'temporal',
    // from: 'qDimensionInfo/0',
    // override: {
    //   value: v => v.qNum,
    // },
    var sourceField = dataset.field(v.from);
    var f = qField(_objectSpread({
      meta: sourceField.raw(),
      id: "".concat(_key, "/").concat(v.key),
      sourceField: sourceField,
      fieldExtractor: function fieldExtractor(ff) {
        return opts.extractor({
          field: ff
        }, dataset, cache, deps);
      },
      key: v.key,
      type: sourceField.type(),
      localeInfo: opts.localeInfo,
      value: sourceField.value
    }, v.override || {}));
    cache.virtualFields.push(f);
  });

  (_cache$allFields = cache.allFields).push.apply(_cache$allFields, _toConsumableArray(cache.virtualFields));

  return dataset;
}

var LAYOUT_TO_PROP = [['qHyperCube', 'qHyperCubeDef'], ['qTreeData', 'qTreeDataDef'], ['qDimensionInfo', 'qDimensions'], ['qMeasureInfo', 'qMeasures'], ['qAttrDimInfo', 'qAttributeDimensions'], ['qAttrExprInfo', 'qAttributeExpressions']];
var DIM_RX$1 = /\/qDimensionInfo(?:\/(\d+))?/;
var M_RX$1 = /\/qMeasureInfo\/(\d+)/;
var ATTR_DIM_RX$1 = /\/qAttrDimInfo\/(\d+)(?:\/(\d+))?/;
var ATTR_EXPR_RX$1 = /\/qAttrExprInfo\/(\d+)/;
var HC_RX = /\/?qHyperCube/;
var TD_RX = /\/?qTreeData/;

var SHORTEN_HC = function SHORTEN_HC(path) {
  return "".concat(path.substr(0, path.indexOf('/qHyperCubeDef') + 14));
}; // 14 = length of '/qHyperCubeDef'


var SHORTEN_TD = function SHORTEN_TD(path) {
  return "".concat(path.substr(0, path.indexOf('/qTreeDataDef') + 13));
}; // 13 = length of '/qTreeDataDef'


function extractFieldFromId(id, layout) {
  var path = id;
  var dimensionIdx = -1;
  var measureIdx = -1;
  var pathToCube = '';

  var shortenizer = function shortenizer(p) {
    return p;
  };

  if (HC_RX.test(id)) {
    pathToCube = "".concat(path.substr(0, path.indexOf('qHyperCube') + 10)); // 10 = length of 'qHyperCube'

    shortenizer = SHORTEN_HC;
  } else if (TD_RX.test(id)) {
    pathToCube = "".concat(path.substr(0, path.indexOf('qTreeData') + 9)); // 9 = length of 'qTreeData'

    shortenizer = SHORTEN_TD;
  }

  var shortenPath = true;

  if (DIM_RX$1.test(id)) {
    dimensionIdx = +DIM_RX$1.exec(id)[1];
  }

  if (M_RX$1.test(id)) {
    measureIdx = +M_RX$1.exec(id)[1];
  }

  if (ATTR_DIM_RX$1.test(id)) {
    measureIdx = -1;
    dimensionIdx = 0;
    var attrCol = +ATTR_DIM_RX$1.exec(path)[2];

    if (!isNaN(attrCol)) {
      dimensionIdx = attrCol;
      path = path.replace(/\/\d+$/, '');
    }

    shortenPath = false;
  }

  if (ATTR_EXPR_RX$1.test(id)) {
    // depends on number of measures + number of attr expressions
    // in dimensions and measures before this one
    var offset = measureIdx;

    if (layout) {
      measureIdx = 0;
      var hc = resolve(pathToCube, layout); // offset by number of measures

      measureIdx += (hc.qMeasureInfo || []).length; // offset by total number of attr expr in dimensions
      // (assuming attr expr in dimensions are ordered first)

      if (dimensionIdx > -1) {
        measureIdx = hc.qDimensionInfo.slice(0, dimensionIdx).reduce(function (v, dim) {
          return v + dim.qAttrExprInfo.length;
        }, measureIdx);
        dimensionIdx = -1;
      } else {
        measureIdx = hc.qDimensionInfo.reduce(function (v, dim) {
          return v + dim.qAttrExprInfo.length;
        }, measureIdx); // offset by total number of attr expr in measures before 'index'

        measureIdx = hc.qMeasureInfo.slice(0, offset).reduce(function (v, meas) {
          return v + meas.qAttrExprInfo.length;
        }, measureIdx);
      } // offset by the actual column value for the attribute expression itself


      measureIdx += +ATTR_EXPR_RX$1.exec(path)[1];
    } else if (dimensionIdx > -1) {
      dimensionIdx = -1;
      measureIdx = +ATTR_EXPR_RX$1.exec(path)[1];
    } else {
      measureIdx += +ATTR_EXPR_RX$1.exec(path)[1] + 1;
    }
  }

  LAYOUT_TO_PROP.forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        v = _ref2[0],
        prop = _ref2[1];

    path = path.replace(v, prop);
  });

  if (shortenPath) {
    path = shortenizer(path);
  }

  if (path && path[0] !== '/') {
    path = "/".concat(path);
  }

  return {
    measureIdx: measureIdx,
    dimensionIdx: dimensionIdx,
    path: path
  };
}
/**
 * Helper method to generate suitable QIX selection methods and parameters based on a brush instance.
 * @alias brush
 * @memberof picasso.q
 * @param {brush} brush A brush instance
 * @param {object} [opts]
 * @param {boolean} [opts.byCells=false] Whether to prefer selection by row index.
 * @param {string} [opts.primarySource] Field source to extract row indices from. If not specified, indices from first source are used.
 * @param {object} [layout] QIX data layout. Needed only when brushing on attribute expressions, to be able to calculate the measure index.
 * @return {object[]} An array of relevant selections
 */

function qBrush(brush) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var layout = arguments.length > 2 ? arguments[2] : undefined;
  var byCells = opts.byCells;
  var primarySource = opts.primarySource;
  var selections = [];
  var methods = {};
  var isActive = brush.isActive();
  var hasValues = false;
  brush.brushes().forEach(function (b) {
    var info = extractFieldFromId(b.id, layout);

    if (b.type === 'range' && info.measureIdx > -1 && info.dimensionIdx > -1) {
      var ranges = b.brush.ranges();

      if (ranges.length) {
        hasValues = true;

        if (!methods.multiRangeSelectTreeDataValues) {
          methods.multiRangeSelectTreeDataValues = {
            path: info.path,
            ranges: []
          };
        }

        ranges.forEach(function (range) {
          return methods.multiRangeSelectTreeDataValues.ranges.push({
            qMeasureIx: info.measureIdx,
            qDimensionIx: info.dimensionIdx,
            qRange: {
              qMin: range.min,
              qMax: range.max,
              qMinInclEq: true,
              qMaxInclEq: true
            }
          });
        });
      }
    } else {
      if (b.type === 'range' && info.measureIdx > -1) {
        var _ranges = b.brush.ranges();

        if (_ranges.length) {
          hasValues = true;

          if (!methods.rangeSelectHyperCubeValues) {
            methods.rangeSelectHyperCubeValues = {
              path: info.path,
              ranges: []
            };
          }

          _ranges.forEach(function (range) {
            return methods.rangeSelectHyperCubeValues.ranges.push({
              qMeasureIx: info.measureIdx,
              qRange: {
                qMin: range.min,
                qMax: range.max,
                qMinInclEq: true,
                qMaxInclEq: true
              }
            });
          });
        }
      }

      if (b.type === 'range' && info.dimensionIdx > -1) {
        var _ranges2 = b.brush.ranges();

        if (_ranges2.length) {
          hasValues = true;

          if (!methods.selectHyperCubeContinuousRange) {
            methods.selectHyperCubeContinuousRange = {
              path: info.path,
              ranges: []
            };
          }

          _ranges2.forEach(function (range) {
            return methods.selectHyperCubeContinuousRange.ranges.push({
              qDimIx: info.dimensionIdx,
              qRange: {
                qMin: range.min,
                qMax: range.max,
                qMinInclEq: true,
                qMaxInclEq: false
              }
            });
          });
        }
      }

      if (b.type === 'value' && info.dimensionIdx > -1) {
        if (byCells) {
          if (layout && layout.qHyperCube && (layout.qHyperCube.qMode === 'P' || layout.qHyperCube.qMode === 'T' || layout.qHyperCube.qMode === 'K')) {
            var hyperCube = layout.qHyperCube;
            var noOfLeftDims = hyperCube.qNoOfLeftDims;
            var dimInterColSortIdx = hyperCube.qEffectiveInterColumnSortOrder.indexOf(info.dimensionIdx);

            if (!methods.selectPivotCells) {
              methods.selectPivotCells = {
                path: info.path,
                cells: []
              };
            }

            if (b.id === primarySource || !primarySource && methods.selectPivotCells.cells.length === 0) {
              var validValues = b.brush.values().map(function (s) {
                return +s;
              }).filter(function (v) {
                return !isNaN(v);
              });

              if ((noOfLeftDims === 0 || dimInterColSortIdx >= noOfLeftDims) && noOfLeftDims > -1) {
                validValues.forEach(function (val) {
                  methods.selectPivotCells.cells.push({
                    qType: 'T',
                    qCol: val,
                    qRow: dimInterColSortIdx - noOfLeftDims
                  });
                });
              } else {
                validValues.forEach(function (val) {
                  methods.selectPivotCells.cells.push({
                    qType: 'L',
                    qCol: info.dimensionIdx,
                    qRow: val
                  });
                });
              }

              hasValues = !!methods.selectPivotCells.cells.length;
            }
          } else {
            if (!methods.selectHyperCubeCells) {
              methods.selectHyperCubeCells = {
                path: info.path,
                cols: []
              };
            }

            methods.selectHyperCubeCells.cols.push(info.dimensionIdx);

            if (b.id === primarySource || !primarySource && !methods.selectHyperCubeCells.values) {
              methods.selectHyperCubeCells.values = b.brush.values().map(function (s) {
                return +s;
              }).filter(function (v) {
                return !isNaN(v);
              });
              hasValues = !!methods.selectHyperCubeCells.values.length;
            }
          }
        } else {
          var values = b.brush.values().map(function (s) {
            return +s;
          }).filter(function (v) {
            return !isNaN(v);
          });
          hasValues = !!values.length;
          selections.push({
            params: [info.path, info.dimensionIdx, values, false],
            method: 'selectHyperCubeValues'
          });
        }
      }
    }
  });

  if (!hasValues && isActive) {
    return [{
      method: 'resetMadeSelections',
      params: []
    }];
  }

  if (methods.rangeSelectHyperCubeValues) {
    selections.push({
      method: 'rangeSelectHyperCubeValues',
      params: [methods.rangeSelectHyperCubeValues.path, methods.rangeSelectHyperCubeValues.ranges, [], true]
    });
  }

  if (methods.selectHyperCubeContinuousRange) {
    selections.push({
      method: 'selectHyperCubeContinuousRange',
      params: [methods.selectHyperCubeContinuousRange.path, methods.selectHyperCubeContinuousRange.ranges]
    });
  }

  if (methods.selectHyperCubeCells) {
    selections.push({
      method: 'selectHyperCubeCells',
      params: [methods.selectHyperCubeCells.path, methods.selectHyperCubeCells.values, methods.selectHyperCubeCells.cols]
    });
  }

  if (methods.selectPivotCells) {
    selections.push({
      method: 'selectPivotCells',
      params: [methods.selectPivotCells.path, methods.selectPivotCells.cells]
    });
  }

  if (methods.multiRangeSelectTreeDataValues) {
    selections.push({
      method: 'multiRangeSelectTreeDataValues',
      params: [methods.multiRangeSelectTreeDataValues.path, methods.multiRangeSelectTreeDataValues.ranges]
    });
  }

  return selections;
}

function initialize(picasso) {
  q.util = picasso.data('matrix').util;
  picasso.data('q', q);
  picasso.formatter('q-number', formatter);
  picasso.formatter('q-time', formatter$1);
}
initialize.qBrushHelper = qBrush; // deprecated

initialize.selections = qBrush;

/* harmony default export */ __webpack_exports__["default"] = (initialize);
//# sourceMappingURL=picasso-q.esm.js.map

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(11)))

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function a(a,b){for(var c=0,d;c<b.length;c++){d=b[c];d.enumerable=d.enumerable||!1;d.configurable=!0;if("value"in d)d.writable=!0;Object.defineProperty(a,d.key,d)}}return function(b,c,d){if(c)a(b.prototype,c);if(d)a(b,d);return b}}();function _classCallCheck(a,b){if(!(a instanceof b)){throw new TypeError("Cannot call a class as a function")}}var colors=["rgba(0,0,0,0)","#ffffff","#46c646","#276e27","#b6d7ea","#7db8da","#4477aa","#8e477d","#ffcf02","#f8981d","#f93f17","#633d0c","#b0afae","#7b7a78","#545352","#000000"],colorseq=["#4477aa","#cc6677","#c3c3c3"],ThemeManager=function(){function a(){_classCallCheck(this,a)}_createClass(a,null,[{key:"setAppTheme",value:function c(b){a.qlikTheme=b}},{key:"getPicassoTheme",value:function a(){return{"$font-family":"\"QlikView Sans\", sans-serif","$font-color":"#595959"}}},{key:"colorFromPicker",value:function b(a){if(-1===a.index){return a.color}else{return this.colorFromTheme(a.index)}}},{key:"colorFromTheme",value:function c(b){//console.log("Return Color For Index:" + index);
//console.log(ThemeManager.qlikTheme);
if("undefined"!=typeof a.qlikTheme){return a.qlikTheme.properties.palettes.ui[0].colors[b-1]}else{return colors[b]}}},{key:"colorFromSeq",value:function c(b){if("undefined"!=typeof a.qlikTheme){return a.qlikTheme.properties.palettes.data[0].scale[1][b]}else{return colorseq[b]}}},{key:"colorOther",value:function b(){if("undefined"!=typeof a.qlikTheme){return a.qlikTheme.properties.dataColors.othersColor}else{return"#c3c3c3"}}}]);return a}();exports.default=ThemeManager;

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/*
* picasso.js v0.25.3
* Copyright (c) 2019 QlikTech International AB
* Released under the MIT license.
*/


var ARG_LENGTH = {
  a: 7,
  c: 6,
  h: 1,
  l: 2,
  m: 2,
  q: 4,
  s: 4,
  t: 2,
  v: 1,
  z: 0
};
var SEGMENT_PATTERN = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
var NUMBER = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;

function parseValues(args) {
  var numbers = args.match(NUMBER);
  return numbers ? numbers.map(Number) : [];
}
/**
 * parse an svg path data string. Generates an Array
 * of commands where each command is an Array of the
 * form `[command, arg1, arg2, ...]`
 *
 * https://www.w3.org/TR/SVG/paths.html#PathDataGeneralInformation
 * @ignore
 *
 * @param {string} path
 * @returns {array}
 */


function parse(path) {
  var data = [];
  var p = String(path).trim(); // A path data segment (if there is one) must begin with a "moveto" command

  if (p[0] !== 'M' && p[0] !== 'm') {
    return data;
  }

  p.replace(SEGMENT_PATTERN, function (_, command, args) {
    var type = command.toLowerCase();
    var theArgs = parseValues(args);
    var theCommand = command; // overloaded moveTo

    if (type === 'm' && theArgs.length > 2) {
      data.push([theCommand].concat(theArgs.splice(0, 2)));
      type = 'l';
      theCommand = theCommand === 'm' ? 'l' : 'L';
    } // Ignore invalid commands


    if (theArgs.length < ARG_LENGTH[type]) {
      return '';
    }

    data.push([theCommand].concat(theArgs.splice(0, ARG_LENGTH[type]))); // The command letter can be eliminated on subsequent commands if the
    // same command is used multiple times in a row (e.g., you can drop the
    // second "L" in "M 100 200 L 200 100 L -100 -200" and use
    // "M 100 200 L 200 100 -100 -200" instead).

    while (theArgs.length >= ARG_LENGTH[type] && theArgs.length && ARG_LENGTH[type]) {
      data.push([theCommand].concat(theArgs.splice(0, ARG_LENGTH[type])));
    }

    return '';
  });
  return data;
}

var parsePath = parse;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}
/**
 * Work around for https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8438884/
 * @ignore
 */


function supportsSvgPathArgument(window) {
  var canvas = window.document.createElement('canvas');
  var g = canvas.getContext('2d');
  var p = new window.Path2D('M0 0 L1 1');
  g.strokeStyle = 'red';
  g.lineWidth = 1;
  g.stroke(p);
  var imgData = g.getImageData(0, 0, 1, 1);
  return imgData.data[0] === 255; // Check if pixel is red
}

function rotatePoint(point, angle) {
  var nx = point.x * Math.cos(angle) - point.y * Math.sin(angle);
  var ny = point.y * Math.cos(angle) + point.x * Math.sin(angle);
  point.x = nx;
  point.y = ny;
}

function translatePoint(point, dx, dy) {
  point.x += dx;
  point.y += dy;
}

function scalePoint(point, s) {
  point.x *= s;
  point.y *= s;
}

function polyFillPath2D(window) {
  if (typeof window === 'undefined' || !window.CanvasRenderingContext2D) {
    return;
  }

  if (window.Path2D && supportsSvgPathArgument(window)) {
    return;
  }
  /**
     * Crates a Path2D polyfill object
     * @constructor
     * @ignore
     * @param {String} path
     */


  var Path2D =
  /*#__PURE__*/
  function () {
    function Path2D(path) {
      _classCallCheck(this, Path2D);

      this.segments = [];

      if (path && path instanceof Path2D) {
        var _this$segments;

        (_this$segments = this.segments).push.apply(_this$segments, _toConsumableArray(path.segments));
      } else if (path) {
        this.segments = parsePath(path);
      }
    }

    _createClass(Path2D, [{
      key: "addPath",
      value: function addPath(path) {
        if (path && path instanceof Path2D) {
          var _this$segments2;

          (_this$segments2 = this.segments).push.apply(_this$segments2, _toConsumableArray(path.segments));
        }
      }
    }, {
      key: "moveTo",
      value: function moveTo(x, y) {
        this.segments.push(['M', x, y]);
      }
    }, {
      key: "lineTo",
      value: function lineTo(x, y) {
        this.segments.push(['L', x, y]);
      }
    }, {
      key: "arc",
      value: function arc(x, y, r, start, end, ccw) {
        this.segments.push(['AC', x, y, r, start, end, !!ccw]);
      }
    }, {
      key: "arcTo",
      value: function arcTo(x1, y1, x2, y2, r) {
        this.segments.push(['AT', x1, y1, x2, y2, r]);
      }
    }, {
      key: "ellipse",
      value: function ellipse(x, y, rx, ry, angle, start, end, ccw) {
        this.segments.push(['E', x, y, rx, ry, angle, start, end, !!ccw]);
      }
    }, {
      key: "closePath",
      value: function closePath() {
        this.segments.push(['Z']);
      }
    }, {
      key: "bezierCurveTo",
      value: function bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
        this.segments.push(['C', cp1x, cp1y, cp2x, cp2y, x, y]);
      }
    }, {
      key: "quadraticCurveTo",
      value: function quadraticCurveTo(cpx, cpy, x, y) {
        this.segments.push(['Q', cpx, cpy, x, y]);
      }
    }, {
      key: "rect",
      value: function rect(x, y, width, height) {
        this.segments.push(['R', x, y, width, height]);
      }
    }]);

    return Path2D;
  }();

  var cFill = window.CanvasRenderingContext2D.prototype.fill;
  var cStroke = window.CanvasRenderingContext2D.prototype.stroke;

  function buildPath(canvas, segments) {
    var endAngle;
    var startAngle;
    var largeArcFlag;
    var sweepFlag;
    var endPoint;
    var midPoint;
    var angle;
    var lambda;
    var t1;
    var t2;
    var x;
    var x1;
    var y;
    var y1;
    var r;
    var rx;
    var ry;
    var w;
    var h;
    var pathType;
    var centerPoint;
    var cpx;
    var cpy;
    var qcpx;
    var qcpy;
    var ccw;
    var startPoint = {
      x: 0,
      y: 0
    };
    var currentPoint = {
      x: 0,
      y: 0
    };
    canvas.beginPath();

    for (var i = 0; i < segments.length; ++i) {
      var s = segments[i];
      pathType = s[0]; // Reset control point if command is not cubic

      if (pathType !== 'S' && pathType !== 's' && pathType !== 'C' && pathType !== 'c') {
        cpx = null;
        cpy = null;
      }

      if (pathType !== 'T' && pathType !== 't' && pathType !== 'Q' && pathType !== 'q') {
        qcpx = null;
        qcpy = null;
      }

      switch (pathType) {
        case 'm':
        case 'M':
          if (pathType === 'm') {
            x += s[1];
            y += s[2];
          } else {
            x = s[1];
            y = s[2];
          }

          if (pathType === 'M' || !startPoint) {
            startPoint = {
              x: x,
              y: y
            };
          }

          canvas.moveTo(x, y);
          break;

        case 'l':
          x += s[1];
          y += s[2];
          canvas.lineTo(x, y);
          break;

        case 'L':
          x = s[1];
          y = s[2];
          canvas.lineTo(x, y);
          break;

        case 'H':
          x = s[1];
          canvas.lineTo(x, y);
          break;

        case 'h':
          x += s[1];
          canvas.lineTo(x, y);
          break;

        case 'V':
          y = s[1];
          canvas.lineTo(x, y);
          break;

        case 'v':
          y += s[1];
          canvas.lineTo(x, y);
          break;

        case 'a':
        case 'A':
          if (pathType === 'a') {
            x += s[6];
            y += s[7];
          } else {
            x = s[6];
            y = s[7];
          }

          rx = s[1]; // rx

          ry = s[2]; // ry

          angle = s[3] * Math.PI / 180;
          largeArcFlag = !!s[4];
          sweepFlag = !!s[5];
          endPoint = {
            x: x,
            y: y
          }; // https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes

          midPoint = {
            x: (currentPoint.x - endPoint.x) / 2,
            y: (currentPoint.y - endPoint.y) / 2
          };
          rotatePoint(midPoint, -angle); // radius correction

          lambda = midPoint.x * midPoint.x / (rx * rx) + midPoint.y * midPoint.y / (ry * ry);

          if (lambda > 1) {
            lambda = Math.sqrt(lambda);
            rx *= lambda;
            ry *= lambda;
          }

          centerPoint = {
            x: rx * midPoint.y / ry,
            y: -(ry * midPoint.x) / rx
          };
          t1 = rx * rx * ry * ry;
          t2 = rx * rx * midPoint.y * midPoint.y + ry * ry * midPoint.x * midPoint.x;

          if (sweepFlag !== largeArcFlag) {
            scalePoint(centerPoint, Math.sqrt((t1 - t2) / t2) || 0);
          } else {
            scalePoint(centerPoint, -Math.sqrt((t1 - t2) / t2) || 0);
          }

          startAngle = Math.atan2((midPoint.y - centerPoint.y) / ry, (midPoint.x - centerPoint.x) / rx);
          endAngle = Math.atan2(-(midPoint.y + centerPoint.y) / ry, -(midPoint.x + centerPoint.x) / rx);
          rotatePoint(centerPoint, angle);
          translatePoint(centerPoint, (endPoint.x + currentPoint.x) / 2, (endPoint.y + currentPoint.y) / 2);
          canvas.save();
          canvas.translate(centerPoint.x, centerPoint.y);
          canvas.rotate(angle);
          canvas.scale(rx, ry);
          canvas.arc(0, 0, 1, startAngle, endAngle, !sweepFlag);
          canvas.restore();
          break;

        case 'C':
          cpx = s[3]; // Last control point

          cpy = s[4];
          x = s[5];
          y = s[6];
          canvas.bezierCurveTo(s[1], s[2], cpx, cpy, x, y);
          break;

        case 'c':
          canvas.bezierCurveTo(s[1] + x, s[2] + y, s[3] + x, s[4] + y, s[5] + x, s[6] + y);
          cpx = s[3] + x; // Last control point

          cpy = s[4] + y;
          x += s[5];
          y += s[6];
          break;

        case 'S':
          if (cpx === null || cpx === null) {
            cpx = x;
            cpy = y;
          }

          canvas.bezierCurveTo(2 * x - cpx, 2 * y - cpy, s[1], s[2], s[3], s[4]);
          cpx = s[1]; // last control point

          cpy = s[2];
          x = s[3];
          y = s[4];
          break;

        case 's':
          if (cpx === null || cpx === null) {
            cpx = x;
            cpy = y;
          }

          canvas.bezierCurveTo(2 * x - cpx, 2 * y - cpy, s[1] + x, s[2] + y, s[3] + x, s[4] + y);
          cpx = s[1] + x; // last control point

          cpy = s[2] + y;
          x += s[3];
          y += s[4];
          break;

        case 'Q':
          qcpx = s[1]; // last control point

          qcpy = s[2];
          x = s[3];
          y = s[4];
          canvas.quadraticCurveTo(qcpx, qcpy, x, y);
          break;

        case 'q':
          qcpx = s[1] + x; // last control point

          qcpy = s[2] + y;
          x += s[3];
          y += s[4];
          canvas.quadraticCurveTo(qcpx, qcpy, x, y);
          break;

        case 'T':
          if (qcpx === null || qcpx === null) {
            qcpx = x;
            qcpy = y;
          }

          qcpx = 2 * x - qcpx; // last control point

          qcpy = 2 * y - qcpy;
          x = s[1];
          y = s[2];
          canvas.quadraticCurveTo(qcpx, qcpy, x, y);
          break;

        case 't':
          if (qcpx === null || qcpx === null) {
            qcpx = x;
            qcpy = y;
          }

          qcpx = 2 * x - qcpx; // last control point

          qcpy = 2 * y - qcpy;
          x += s[1];
          y += s[2];
          canvas.quadraticCurveTo(qcpx, qcpy, x, y);
          break;

        case 'z':
        case 'Z':
          x = startPoint.x;
          y = startPoint.y;
          startPoint = undefined;
          canvas.closePath();
          break;

        case 'AC':
          // arc
          x = s[1];
          y = s[2];
          r = s[3];
          startAngle = s[4];
          endAngle = s[5];
          ccw = s[6];
          canvas.arc(x, y, r, startAngle, endAngle, ccw);
          break;

        case 'AT':
          // arcTo
          x1 = s[1];
          y1 = s[2];
          x = s[3];
          y = s[4];
          r = s[5];
          canvas.arcTo(x1, y1, x, y, r);
          break;

        case 'E':
          // ellipse
          x = s[1];
          y = s[2];
          rx = s[3];
          ry = s[4];
          angle = s[5];
          startAngle = s[6];
          endAngle = s[7];
          ccw = s[8];
          canvas.save();
          canvas.translate(x, y);
          canvas.rotate(angle);
          canvas.scale(rx, ry);
          canvas.arc(0, 0, 1, startAngle, endAngle, ccw);
          canvas.restore();
          break;

        case 'R':
          // rect
          x = s[1];
          y = s[2];
          w = s[3];
          h = s[4];
          startPoint = {
            x: x,
            y: y
          };
          canvas.rect(x, y, w, h);
          break;

        default: // throw new Error(`${pathType} is not implemented`); ?

      }

      currentPoint.x = x;
      currentPoint.y = y;
    }
  }

  window.CanvasRenderingContext2D.prototype.fill = function fill() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var fillRule = 'nonzero';

    if (args.length === 0 || args.length === 1 && typeof args[0] === 'string') {
      cFill.apply(this, args);
      return;
    }

    if (arguments.length === 2) {
      fillRule = args[1];
    }

    var path = args[0];
    buildPath(this, path.segments);
    cFill.call(this, fillRule);
  };

  window.CanvasRenderingContext2D.prototype.stroke = function stroke(path) {
    if (!path) {
      cStroke.call(this);
      return;
    }

    buildPath(this, path.segments);
    cStroke.call(this);
  };

  window.Path2D = Path2D;
}

var path2dPolyfill = polyFillPath2D;

if (typeof window !== 'undefined') {
  path2dPolyfill(window);
}
var parsePath_1 = parsePath;

var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var defineProperty = Object.defineProperty;
var gOPD = Object.getOwnPropertyDescriptor;

var isArray = function isArray(arr) {
	if (typeof Array.isArray === 'function') {
		return Array.isArray(arr);
	}

	return toStr.call(arr) === '[object Array]';
};

var isPlainObject = function isPlainObject(obj) {
	if (!obj || toStr.call(obj) !== '[object Object]') {
		return false;
	}

	var hasOwnConstructor = hasOwn.call(obj, 'constructor');
	var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
	if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
		return false;
	}

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for (key in obj) { /**/ }

	return typeof key === 'undefined' || hasOwn.call(obj, key);
};

// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
var setProperty = function setProperty(target, options) {
	if (defineProperty && options.name === '__proto__') {
		defineProperty(target, options.name, {
			enumerable: true,
			configurable: true,
			value: options.newValue,
			writable: true
		});
	} else {
		target[options.name] = options.newValue;
	}
};

// Return undefined instead of __proto__ if '__proto__' is not an own property
var getProperty = function getProperty(obj, name) {
	if (name === '__proto__') {
		if (!hasOwn.call(obj, name)) {
			return void 0;
		} else if (gOPD) {
			// In early versions of node, obj['__proto__'] is buggy when obj has
			// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
			return gOPD(obj, name).value;
		}
	}

	return obj[name];
};

var extend = function extend() {
	var options, name, src, copy, copyIsArray, clone;
	var target = arguments[0];
	var i = 1;
	var length = arguments.length;
	var deep = false;

	// Handle a deep copy situation
	if (typeof target === 'boolean') {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}
	if (target == null || (typeof target !== 'object' && typeof target !== 'function')) {
		target = {};
	}

	for (; i < length; ++i) {
		options = arguments[i];
		// Only deal with non-null/undefined values
		if (options != null) {
			// Extend the base object
			for (name in options) {
				src = getProperty(target, name);
				copy = getProperty(options, name);

				// Prevent never-ending loop
				if (target !== copy) {
					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone = src && isArray(src) ? src : [];
						} else {
							clone = src && isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						setProperty(target, { name: name, newValue: extend(deep, clone, copy) });

					// Don't bring in undefined values
					} else if (typeof copy !== 'undefined') {
						setProperty(target, { name: name, newValue: copy });
					}
				}
			}
		}
	}

	// Return the modified object
	return target;
};

var about = {
  version: '0.25.3'
};

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$1(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _toConsumableArray$1(arr) {
  return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _nonIterableSpread$1();
}

function _arrayWithoutHoles$1(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray$1(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableSpread$1() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

/**
 * Initilize a new dock configuration
 * @private
 * @param {object} [settings] - Settings object
 * @returns {object} A dock configuration instance
 * @example
 * let instance = dockConfig({
 *  dock: 'left',
 *  displayOrder: 2,
 *  prioOrder: 1,
 *  preferredSize: 33,
 *  minimumLayoutMode: 'L',
 *  show: true
 * });
 */
function dockConfig() {
  var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var callbackContext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var _settings$dock = settings.dock,
      _dock = _settings$dock === void 0 ? 'center' : _settings$dock,
      _settings$displayOrde = settings.displayOrder,
      _displayOrder = _settings$displayOrde === void 0 ? 0 : _settings$displayOrde,
      _settings$prioOrder = settings.prioOrder,
      _prioOrder = _settings$prioOrder === void 0 ? 0 : _settings$prioOrder,
      _settings$preferredSi = settings.preferredSize,
      preferredSize = _settings$preferredSi === void 0 ? 0 : _settings$preferredSi,
      _minimumLayoutMode = settings.minimumLayoutMode,
      _settings$show = settings.show,
      _show = _settings$show === void 0 ? true : _settings$show; // avoid empty string dock


  _dock = _dock || 'center';
  /**
   * @private
   */

  return {
    /**
     * Returns the preferred size of a component.
     * The return value of the function can either be a number representing the required size in the dock direction
     * or an object with a `size` and `edgeBleed` property.
     * @param {object} [inner]
     * @param {object} [outer]
     * @returns {number|object} Returns the computed preferred size
     * @example
     * dockConfig.computePreferredSize(() => 150); // Require a size of 150 in the dock direction
     *
     * dockConfig.computePreferredSize(() => ({
     *  size: 150,
     *  edgeBleed: {
     *    left: 50,
     *    right: 50
     *  }
     * })); // Require a size of 150 in the dock direction and a bleed size of 50 to the left and right dock direction
     */
    computePreferredSize: function computePreferredSize(_ref) {
      var inner = _ref.inner,
          outer = _ref.outer;

      if (typeof preferredSize === 'function') {
        return preferredSize({
          inner: inner,
          outer: outer,
          dock: this.dock()
        }, callbackContext);
      }

      return preferredSize;
    },

    /**
     * Set the dock direction, supported values are left | right | top | bottom. Any other value will be interpreted as center dock.
     * @param {string} [val=''] - Dock direction
     * @returns {this} The current context
     * @example
     * dockConfig.dock('left');
     */
    dock: function dock(val) {
      if (typeof val !== 'undefined') {
        _dock = val;
        return this;
      }

      return typeof _dock === 'function' ? _dock(callbackContext) : _dock;
    },

    /**
     * The `displayOrder` property is used by the layout engine to lay out components.
     * Components are interpreted in the ascending order of the `displayOrder` value. The layout engine apply the value in two ways,
     * the first is the order in which components are rendererd. The second is the area components are laid out in
     * when they have a direction, i.e. docked to either top, bottom, left or right.
     *
     * If docked at the same area, the component with a higher `displayOrder` will be rendered
     * on top of the component with a lower `displayOrder`. It can be seen as defining a z-index.
     * A lower `displayOrder` also means that a component will be laid out first in a given direction,
     * i.e. laid out closer to the central area (non-directional area) then a component with a higher `displayOrder`.
     * It can in this case be seen as the x-index or y-index.
     * @param {number} [val=0] - The display order
     * @returns {this|number} The current context or display order
     * @example
     * dockConfig.displayOrder(99);
     */
    displayOrder: function displayOrder(val) {
      if (typeof val !== 'undefined') {
        _displayOrder = val;
        return this;
      }

      return typeof _displayOrder === 'function' ? _displayOrder(callbackContext) : _displayOrder;
    },

    /**
     * The `prioOrder` property is used to define the order in which components are added to the layout engine,
     * this is done before any components are laid out. When there is not enough space to add any more components
     * to a given area, all components not all ready added, are then discarded. The `prioOrder` is interpreted
     * in the ascending order. Such that a lower value is added to the layout engine first.
     * @param {number} [val=0] - The prio order
     * @returns {this|number} The current context or prio order
     * @example
     * dockConfig.prioOrder(-1);
     */
    prioOrder: function prioOrder(val) {
      if (typeof val !== 'undefined') {
        _prioOrder = val;
        return this;
      }

      return typeof _prioOrder === 'function' ? _prioOrder(callbackContext) : _prioOrder;
    },

    /**
     * Ger or set the minimumLayoutMode
     * @param {string|object} [val] - The minimum layout mode
     * @returns {string|object|this} If no parameter is passed the current context is returned, else the current layout mode.
     * @example
     * dockConfig.minimumLayoutMode('L');
     * dockConfig.minimumLayoutMode({ width: 'S', height: 'L' });
     */
    minimumLayoutMode: function minimumLayoutMode(val) {
      if (typeof val !== 'undefined') {
        _minimumLayoutMode = val;
        return this;
      }

      return typeof _minimumLayoutMode === 'function' ? _minimumLayoutMode(callbackContext) : _minimumLayoutMode;
    },

    /**
     * Set the component visibility. If false the component is not added to the layout engine.
     * @param {boolean} [val=true] - Toggle visibility
     * @returns {this|boolean} The current context or show
     */
    show: function show(val) {
      if (typeof val !== 'undefined') {
        _show = val;
        return this;
      }

      return typeof _show === 'function' ? _show(callbackContext) : _show;
    }
  };
}

function roundRect(rect) {
  rect.x = Math.floor(rect.x);
  rect.y = Math.floor(rect.y);
  rect.width = Math.floor(rect.width);
  rect.height = Math.floor(rect.height);
}

function resolveContainerRects(rect, settings) {
  var containerRect = {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  };
  var logicalContainerRect = {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  }; // Check input object for size

  containerRect.width = rect.width || 0;
  containerRect.height = rect.height || 0;

  if (typeof settings.size !== 'undefined') {
    containerRect.width = isNaN(settings.size.width) ? containerRect.width : settings.size.width;
    containerRect.height = isNaN(settings.size.height) ? containerRect.height : settings.size.height;
  }

  if (typeof settings.logicalSize !== 'undefined') {
    logicalContainerRect.width = isNaN(settings.logicalSize.width) ? containerRect.width : settings.logicalSize.width;
    logicalContainerRect.height = isNaN(settings.logicalSize.height) ? containerRect.height : settings.logicalSize.height;
    logicalContainerRect.align = isNaN(settings.logicalSize.align) ? 0.5 : Math.min(Math.max(settings.logicalSize.align, 0), 1);
    logicalContainerRect.preserveAspectRatio = settings.logicalSize.preserveAspectRatio;
  } else {
    logicalContainerRect.width = containerRect.width;
    logicalContainerRect.height = containerRect.height;
    logicalContainerRect.preserveAspectRatio = false;
  }

  roundRect(logicalContainerRect);
  roundRect(containerRect);
  return {
    logicalContainerRect: logicalContainerRect,
    containerRect: containerRect
  };
}
function resolveSettings(s) {
  var settings = {
    center: {
      minWidthRatio: 0.5,
      minHeightRatio: 0.5,
      minWidth: 0,
      minHeight: 0
    }
  };
  extend(true, settings, s);
  settings.center.minWidthRatio = Math.min(Math.max(settings.center.minWidthRatio, 0), 1); // Only accept value between 0-1

  settings.center.minHeightRatio = Math.min(Math.max(settings.center.minHeightRatio, 0), 1); // Only accept value between 0-1

  settings.center.minWidth = Math.max(settings.center.minWidth, 0); // Consider <= 0 to be falsy and fallback to ratio

  settings.center.minHeight = Math.max(settings.center.minHeight, 0); // Consider <= 0 to be falsy and fallback to ratio

  return settings;
}

function isNumber(v) {
  return typeof v === 'number' && !isNaN(v);
}
function notNumber(value) {
  return typeof value !== 'number' || isNaN(value);
}

function getMinMax(points) {
  var num = points.length;
  var xMin = NaN;
  var xMax = NaN;
  var yMin = NaN;
  var yMax = NaN;

  for (var i = 0; i < num; i++) {
    xMin = isNaN(xMin) ? points[i].x : Math.min(xMin, points[i].x);
    xMax = isNaN(xMax) ? points[i].x : Math.max(xMax, points[i].x);
    yMin = isNaN(yMin) ? points[i].y : Math.min(yMin, points[i].y);
    yMax = isNaN(yMax) ? points[i].y : Math.max(yMax, points[i].y);
  }

  return [xMin, yMin, xMax, yMax];
}
/**
 * @ignore
 * @param {oject} line
 * @returns {point[]} Array of points
 */

function lineToPoints(line) {
  var x1 = line.x1 || 0;
  var y1 = line.y1 || 0;
  var x2 = line.x2 || 0;
  var y2 = line.y2 || 0;
  return [{
    x: x1,
    y: y1
  }, {
    x: x2,
    y: y2
  }];
}
/**
 * @ignore
 * @param {oject} rect
 * @returns {point[]} Array of points
 */

function rectToPoints(rect) {
  return [{
    x: rect.x,
    y: rect.y
  }, {
    x: rect.x + rect.width,
    y: rect.y
  }, {
    x: rect.x + rect.width,
    y: rect.y + rect.height
  }, {
    x: rect.x,
    y: rect.y + rect.height
  }];
}
function pointsToRect(points) {
  var _getMinMax = getMinMax(points),
      _getMinMax2 = _slicedToArray(_getMinMax, 4),
      xMin = _getMinMax2[0],
      yMin = _getMinMax2[1],
      xMax = _getMinMax2[2],
      yMax = _getMinMax2[3];

  return {
    x: xMin,
    y: yMin,
    width: xMax - xMin,
    height: yMax - yMin
  };
}
function pointsToCircle(points, r) {
  return {
    cx: points[0].x,
    cy: points[0].y,
    r: r
  };
}
function pointsToLine(points) {
  return {
    x1: points[0].x,
    y1: points[0].y,
    x2: points[1].x,
    y2: points[1].y
  };
}
/**
 * @ignore
 * @param {oject}
 * @returns {string} Type of geometry
 */

function getShapeType(shape) {
  var _ref = shape || {},
      x = _ref.x,
      y = _ref.y,
      width = _ref.width,
      height = _ref.height,
      x1 = _ref.x1,
      x2 = _ref.x2,
      y1 = _ref.y1,
      y2 = _ref.y2,
      cx = _ref.cx,
      cy = _ref.cy,
      r = _ref.r,
      vertices = _ref.vertices;

  if (isNumber(cx) && isNumber(cy) && isNumber(r)) {
    return 'circle';
  }

  if (isNumber(x1) && isNumber(x2) && isNumber(y1) && isNumber(y2)) {
    return 'line';
  }

  if (isNumber(x) && isNumber(y) && isNumber(width) && isNumber(height)) {
    return 'rect';
  }

  if (isNumber(x) && isNumber(y)) {
    return 'point';
  }

  if (Array.isArray(vertices)) {
    return 'polygon';
  }

  return null;
}
function expandRect(size, rect) {
  return {
    x: rect.x - size,
    y: rect.y - size,
    width: rect.width + size,
    height: rect.height + size
  };
}

function createRect(x, y, width, height, margin) {
  return {
    x: isNaN(x) ? 0 : x,
    y: isNaN(x) ? 0 : y,
    width: isNaN(x) ? 0 : width,
    height: isNaN(x) ? 0 : height,
    margin: isNaN(margin) ? 0 : margin
  };
}

function cacheSize(c, reducedRect, layoutRect) {
  if (typeof c.cachedSize === 'undefined') {
    var dock = c.config.dock();
    var size = c.comp.preferredSize({
      inner: reducedRect,
      outer: layoutRect,
      dock: dock
    }); // backwards compatibility

    if (!isNaN(size)) {
      size = {
        width: size,
        height: size
      };
    } else if (size && !isNaN(size.size)) {
      size.width = size.size;
      size.height = size.size;
    }

    var relevantSize;

    if (dock === 'top' || dock === 'bottom') {
      relevantSize = size.height;
    } else if (dock === 'right' || dock === 'left') {
      relevantSize = size.width;
    } else {
      relevantSize = Math.max(size.width, size.height);
    }

    c.cachedSize = Math.ceil(relevantSize);
    c.edgeBleed = size.edgeBleed || 0;
  }

  return c.cachedSize;
}

function validateReduceRect(rect, reducedRect, settings) {
  // Absolute value for width/height should have predence over relative value
  var minReduceWidth = Math.min(settings.center.minWidth, rect.width) || Math.max(rect.width * settings.center.minWidthRatio, 1);
  var minReduceHeight = Math.min(settings.center.minHeight, rect.height) || Math.max(rect.height * settings.center.minHeightRatio, 1);
  return reducedRect.width >= minReduceWidth && reducedRect.height >= minReduceHeight;
}

function reduceDocRect(reducedRect, c) {
  switch (c.config.dock()) {
    case 'top':
      reducedRect.y += c.cachedSize;
      reducedRect.height -= c.cachedSize;
      break;

    case 'bottom':
      reducedRect.height -= c.cachedSize;
      break;

    case 'left':
      reducedRect.x += c.cachedSize;
      reducedRect.width -= c.cachedSize;
      break;

    case 'right':
      reducedRect.width -= c.cachedSize;
      break;

    default:
  }
}

function addEdgeBleed(currentEdgeBleed, c) {
  var edgeBleed = c.edgeBleed;

  if (!edgeBleed) {
    return;
  }

  currentEdgeBleed.left = Math.max(currentEdgeBleed.left, edgeBleed.left || 0);
  currentEdgeBleed.right = Math.max(currentEdgeBleed.right, edgeBleed.right || 0);
  currentEdgeBleed.top = Math.max(currentEdgeBleed.top, edgeBleed.top || 0);
  currentEdgeBleed.bottom = Math.max(currentEdgeBleed.bottom, edgeBleed.bottom || 0);
}

function reduceEdgeBleed(layoutRect, reducedRect, edgeBleed) {
  if (reducedRect.x < edgeBleed.left) {
    reducedRect.width -= edgeBleed.left - reducedRect.x;
    reducedRect.x = edgeBleed.left;
  }

  var reducedRectRightBoundary = layoutRect.width - (reducedRect.x + reducedRect.width);

  if (reducedRectRightBoundary < edgeBleed.right) {
    reducedRect.width -= edgeBleed.right - reducedRectRightBoundary;
  }

  if (reducedRect.y < edgeBleed.top) {
    reducedRect.height -= edgeBleed.top - reducedRect.y;
    reducedRect.y = edgeBleed.top;
  }

  var reducedRectBottomBoundary = layoutRect.height - (reducedRect.y + reducedRect.height);

  if (reducedRectBottomBoundary < edgeBleed.bottom) {
    reducedRect.height -= edgeBleed.bottom - reducedRectBottomBoundary;
  }
}

function reduceSingleLayoutRect(layoutRect, reducedRect, edgeBleed, c, settings) {
  var newReduceRect = extend({}, reducedRect);
  var newEdgeBleed = extend({}, edgeBleed);
  reduceDocRect(newReduceRect, c);
  addEdgeBleed(newEdgeBleed, c);
  reduceEdgeBleed(layoutRect, newReduceRect, newEdgeBleed);
  var isValid = validateReduceRect(layoutRect, newReduceRect, settings);

  if (!isValid) {
    return false;
  }

  reduceDocRect(reducedRect, c);
  addEdgeBleed(edgeBleed, c);
  return true;
}
/**
 * Updates the visible and hidden components based on components that are docked to other components.
 * For example, assume a component called myRect:
 * {
 *  key: 'myRect',
 *  type: 'rect',
 *  dock: 'bottom'
 * }
 * and a component called myLine:
 * {
 *  key: 'myLine',
 *  type: 'line',
 *  dock: '@myRect'
 * }
 * if the layout engine decides to hide myRect, then myLine should be hidden as well.
 * @param {Array} visible - Components to be decided if they should be hidden or not.
 * @param {Array} hidden - Components that are already hidden.
 * @returns {Object} containing the new visible components and additional components to be hidden.
 * @ignore
 */


function filterReferencedDocks(visible, hidden) {
  if (hidden.length === 0) {
    return;
  }

  for (var i = 0; i < visible.length; ++i) {
    var v = visible[i];

    if (v.referencedDocks.length) {
      var isAllHidden = v.referencedDocks.every(function (refDock) {
        return hidden.some(function (h) {
          return h.key === refDock;
        });
      });

      if (isAllHidden) {
        hidden.push(visible.splice(i, 1)[0]);
      }
    }
  }
}

function reduceLayoutRect(_ref) {
  var layoutRect = _ref.layoutRect,
      visible = _ref.visible,
      hidden = _ref.hidden,
      settings = _ref.settings;
  var reducedRect = createRect(layoutRect.x, layoutRect.y, layoutRect.width, layoutRect.height);
  var edgeBleed = {
    left: 0,
    right: 0,
    top: 0,
    bottom: 0
  };
  var sortedComponents = visible.slice();
  sortedComponents.sort(function (a, b) {
    return a.config.prioOrder() - b.config.prioOrder();
  }); // lower prioOrder will have higher prio

  for (var i = 0; i < sortedComponents.length; ++i) {
    var c = sortedComponents[i];
    cacheSize(c, reducedRect, layoutRect);

    if (!reduceSingleLayoutRect(layoutRect, reducedRect, edgeBleed, c, settings)) {
      hidden.push(sortedComponents.splice(i, 1)[0]);
      --i;
    }
  }

  filterReferencedDocks(visible, hidden);
  var filteredUnsortedComps = visible.filter(function (c) {
    return sortedComponents.indexOf(c) !== -1;
  });
  visible.length = 0;
  visible.push.apply(visible, _toConsumableArray$1(filteredUnsortedComps));
  reduceEdgeBleed(layoutRect, reducedRect, edgeBleed);
  return reducedRect;
}

function computeRect(rect) {
  return {
    x: rect.margin.left + rect.x * rect.scaleRatio.x,
    y: rect.margin.top + rect.y * rect.scaleRatio.y,
    width: rect.width * rect.scaleRatio.x,
    height: rect.height * rect.scaleRatio.y
  };
}

function appendScaleRatio(rect, outerRect, layoutRect, containerRect) {
  var scaleRatio = {
    x: containerRect.width / layoutRect.width,
    y: containerRect.height / layoutRect.height
  };
  var margin = {
    left: 0,
    top: 0
  };

  if (layoutRect.preserveAspectRatio) {
    var xLessThenY = scaleRatio.x < scaleRatio.y; // To preserve the aspect ratio, take the smallest ratio and apply in both directions to "meet" the size of the container

    var minRatio = Math.min(scaleRatio.x, scaleRatio.y);
    scaleRatio.x = minRatio;
    scaleRatio.y = minRatio;
    var area = xLessThenY ? 'height' : 'width';
    var spread = (containerRect[area] - layoutRect[area] * scaleRatio.x) * layoutRect.align;
    margin.left = xLessThenY ? 0 : spread;
    margin.top = xLessThenY ? spread : 0;
  }

  rect.scaleRatio = scaleRatio;
  rect.margin = margin;
  outerRect.scaleRatio = scaleRatio;
  outerRect.margin = margin;
  layoutRect.scaleRatio = scaleRatio;
  layoutRect.margin = margin;
}

function boundingBox(rects) {
  var _ref2;

  var points = (_ref2 = []).concat.apply(_ref2, _toConsumableArray$1(rects.map(rectToPoints)));

  return pointsToRect(points);
}

function positionComponents(_ref3) {
  var visible = _ref3.visible,
      layoutRect = _ref3.layoutRect,
      reducedRect = _ref3.reducedRect,
      containerRect = _ref3.containerRect,
      translation = _ref3.translation;
  var vRect = createRect(reducedRect.x, reducedRect.y, reducedRect.width, reducedRect.height);
  var hRect = createRect(reducedRect.x, reducedRect.y, reducedRect.width, reducedRect.height);
  var referencedComponents = {};
  var referenceArray = visible.slice();
  var elementOrder = referenceArray.slice().sort(function (a, b) {
    return a.config.displayOrder() - b.config.displayOrder();
  });
  visible.sort(function (a, b) {
    if (b.referencedDocks.length > 0) {
      return -1;
    }

    if (a.referencedDocks.length > 0) {
      return 1;
    }

    var diff = a.config.displayOrder() - b.config.displayOrder();

    if (diff === 0) {
      return referenceArray.indexOf(a) - referenceArray.indexOf(b);
    }

    return diff;
  }).forEach(function (c) {
    var outerRect = {};
    var rect = {};
    var d = c.config.dock();

    switch (d) {
      case 'top':
        outerRect.height = rect.height = c.cachedSize;
        outerRect.width = layoutRect.width;
        rect.width = vRect.width;
        outerRect.x = layoutRect.x;
        rect.x = vRect.x;
        outerRect.y = rect.y = vRect.y - c.cachedSize;
        vRect.y -= c.cachedSize;
        vRect.height += c.cachedSize;
        break;

      case 'bottom':
        outerRect.x = layoutRect.x;
        rect.x = vRect.x;
        outerRect.y = rect.y = vRect.y + vRect.height;
        outerRect.width = layoutRect.width;
        rect.width = vRect.width;
        outerRect.height = rect.height = c.cachedSize;
        vRect.height += c.cachedSize;
        break;

      case 'left':
        outerRect.x = rect.x = hRect.x - c.cachedSize;
        outerRect.y = layoutRect.y;
        rect.y = hRect.y;
        outerRect.width = rect.width = c.cachedSize;
        outerRect.height = layoutRect.height;
        rect.height = hRect.height;
        hRect.x -= c.cachedSize;
        hRect.width += c.cachedSize;
        break;

      case 'right':
        outerRect.x = rect.x = hRect.x + hRect.width;
        outerRect.y = layoutRect.y;
        rect.y = hRect.y;
        outerRect.width = rect.width = c.cachedSize;
        outerRect.height = layoutRect.height;
        rect.height = hRect.height;
        hRect.width += c.cachedSize;
        break;

      case 'center':
        outerRect.x = rect.x = reducedRect.x;
        outerRect.y = rect.y = reducedRect.y;
        outerRect.width = rect.width = reducedRect.width;
        outerRect.height = rect.height = reducedRect.height;
        break;

      default:
        if (c.referencedDocks.length > 0) {
          var refs = c.referencedDocks.map(function (ref) {
            return referencedComponents[ref];
          }).filter(function (ref) {
            return !!ref;
          });

          if (refs.length > 0) {
            outerRect = boundingBox(refs.map(function (ref) {
              return ref.outerRect;
            }));
            rect = boundingBox(refs.map(function (ref) {
              return ref.r;
            }));
          }
        }

        break;
    }

    if (c.key) {
      referencedComponents[c.key] = {
        // store the size of this component
        r: rect,
        outerRect: outerRect
      };
    }

    appendScaleRatio(rect, outerRect, layoutRect, containerRect);
    rect.edgeBleed = c.edgeBleed;
    rect.computed = computeRect(rect);
    outerRect.edgeBleed = c.edgeBleed;
    outerRect.computed = computeRect(outerRect);
    rect.x += translation.x;
    rect.y += translation.y;
    outerRect.x += translation.x;
    outerRect.y += translation.y;
    c.comp.resize(rect, outerRect);
    c.cachedSize = undefined;
    c.edgeBleed = undefined;
  });
  return visible.map(function (c) {
    return elementOrder.indexOf(c);
  });
}

function checkShowSettings(strategySettings, dockSettings, logicalContainerRect) {
  var layoutModes = strategySettings.layoutModes || {};
  var minimumLayoutMode = dockSettings.minimumLayoutMode();
  var show = dockSettings.show();

  if (show && _typeof(minimumLayoutMode) === 'object') {
    show = layoutModes[minimumLayoutMode.width] && layoutModes[minimumLayoutMode.height] && logicalContainerRect.width >= layoutModes[minimumLayoutMode.width].width && logicalContainerRect.height >= layoutModes[minimumLayoutMode.height].height;
  } else if (show && minimumLayoutMode !== undefined) {
    show = layoutModes[minimumLayoutMode] && logicalContainerRect.width >= layoutModes[minimumLayoutMode].width && logicalContainerRect.height >= layoutModes[minimumLayoutMode].height;
  }

  return show;
}

function validateComponent(component) {
  if (!component.settings && !component.settings) {
    throw new Error('Invalid component settings');
  }

  if (!component.resize || typeof component.resize !== 'function') {
    throw new Error('Component is missing resize function');
  }

  if (!component.dockConfig && !component.preferredSize) {
    throw new Error('Component is missing preferredSize function');
  }
}

function filterComponents(components, settings, rect) {
  var visible = [];
  var hidden = []; // check show settings

  for (var i = 0; i < components.length; ++i) {
    var comp = components[i];
    validateComponent(comp); // backwards compatibility

    var config = void 0;

    if (comp.instance) {
      config = comp.instance.dockConfig();
    } else {
      config = dockConfig(comp.settings.layout);
    }

    var key = comp.settings.key;
    var d = config.dock();
    var referencedDocks = /@/.test(d) ? d.split(',').map(function (s) {
      return s.replace(/^\s*@/, '');
    }) : [];

    if (checkShowSettings(settings, config, rect)) {
      visible.push({
        comp: comp,
        key: key,
        config: config,
        referencedDocks: referencedDocks
      });
    } else {
      hidden.push({
        comp: comp,
        key: key,
        config: config,
        referencedDocks: referencedDocks
      });
    }
  }

  return [visible, hidden];
}
/**
 * @typedef {object} dock-layout-settings
 * @property {object} [logicalSize] - Logical size
 * @property {number} [logicalSize.width] - Width in pixels
 * @property {number} [logicalSize.height] - Height in pixels
 * @property {boolean} [logicalSize.preserveAspectRatio=false] - If true, takes the smallest ratio of width/height between logical and physical size ( physical / logical )
 * @property {number} [logicalSize.align=0.5] - Normalized value between 0-1. Defines how the space around the scaled axis is spread in the container, with 0.5 meaning the spread is equal on both sides. Only applicable if preserveAspectRatio is set to true
 * @property {object} [center] - Define how much space the center dock area requires
 * @property {number} [center.minWidthRatio=0.5] - Value between 0 and 1
 * @property {number} [center.minHeightRatio=0.5] - Value between 0 and 1
 * @property {number} [center.minWidth] - Width in pixels
 * @property {number} [center.minHeight] - Height in pixels
 * @property {object<string, {width: number, height: number}>} [layoutModes] Dictionary with named sizes
 */


function dockLayout(initialSettings) {
  var settings = resolveSettings(initialSettings);
  var docker = {};

  docker.layout = function layout(rect) {
    var components = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    if (!rect || isNaN(rect.x) || isNaN(rect.y) || isNaN(rect.width) || isNaN(rect.height)) {
      throw new Error('Invalid rect');
    }

    if (!components.length) {
      return {
        visible: [],
        hidden: []
      };
    }

    var _resolveContainerRect = resolveContainerRects(rect, settings),
        logicalContainerRect = _resolveContainerRect.logicalContainerRect,
        containerRect = _resolveContainerRect.containerRect;

    var _filterComponents = filterComponents(components, settings, logicalContainerRect),
        _filterComponents2 = _slicedToArray(_filterComponents, 2),
        visible = _filterComponents2[0],
        hidden = _filterComponents2[1];

    var reducedRect = reduceLayoutRect({
      layoutRect: logicalContainerRect,
      visible: visible,
      hidden: hidden,
      settings: settings
    });
    var translation = {
      x: rect.x,
      y: rect.y
    };
    var order = positionComponents({
      visible: visible,
      layoutRect: logicalContainerRect,
      reducedRect: reducedRect,
      containerRect: containerRect,
      translation: translation
    });
    hidden.forEach(function (c) {
      c.comp.visible = false; // set empty rects on hidden components

      var r = createRect();
      c.comp.resize(r, r);
    });
    return {
      visible: visible.map(function (v) {
        return v.comp;
      }),
      hidden: hidden.map(function (h) {
        return h.comp;
      }),
      order: order
    };
  };

  docker.settings = function settingsFn(s) {
    settings = resolveSettings(s);
  };

  return docker;
}

/* global navigator */
function detectTouchSupport(e) {
  if ('ontouchstart' in e && 'ontouchend' in e || navigator.maxTouchPoints > 1) {
    return true;
  }

  return false;
}
function isTouchEvent(e) {
  return !!e.changedTouches;
}
function isValidTapEvent(e, eventInfo) {
  var isTouch = isTouchEvent(e);
  var ee = isTouch ? e.changedTouches[0] : e;
  var dt = Date.now() - eventInfo.time;
  var dx = isNaN(eventInfo.x) ? 0 : Math.abs(ee.clientX - eventInfo.x);
  var dy = isNaN(eventInfo.y) ? 0 : Math.abs(ee.clientY - eventInfo.y);
  return (e.button === 0 || isTouch) && !eventInfo.multiTouch && dx <= 12 && dy <= 12 && dt <= 300;
}

// import types from './types';

/**
 * @ignore
 * @param {Array<data-source>} dataSources
 * @param {any} { logger }
 * @returns {function}
 */
function datasets(dataSources, _ref) {
  var types = _ref.types,
      logger = _ref.logger;
  var data = {};
  var sets = [];

  if (!Array.isArray(dataSources)) {
    logger.warn('Deprecated: "data-source" configuration"');
    sets.push(dataSources);
  } else {
    sets.push.apply(sets, _toConsumableArray$1(dataSources));
  }

  sets.forEach(function (d, i) {
    var datasetFactory = types(d.type);

    if (datasetFactory) {
      var key = d.key;

      if (typeof d.key === 'undefined') {
        logger.warn("Missing key for dataset. Using index '".concat(i, "' as key."));
        key = i;
      }

      var dataset = datasetFactory({
        key: key,
        data: d.data,
        config: d.config
      });
      data[key] = dataset;
    }
  });
  /**
   * Returns the `dataset` which has `key` as identifier
   * @ignore
   * @param {string} key - The dataset identifier
   * @returns {dataset}
   */

  var fn = function fn(key) {
    if (key) {
      return data[key];
    }

    return data[Object.keys(data)[0]];
  };

  return fn;
}
/**
 * @typedef {object} data-source
 * @property {string} key - Unique identifier for this data source
 * @property {string} type - The dataset type
 * @property {any} data
 */

var pi = Math.PI,
    tau = 2 * pi,
    epsilon = 1e-6,
    tauEpsilon = tau - epsilon;

function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null; // end of current subpath
  this._ = "";
}

function path() {
  return new Path;
}

Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x, y) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x, y) {
    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  quadraticCurveTo: function(x1, y1, x, y) {
    this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) {
    this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  arcTo: function(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x1,y1).
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon));

    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
    // Equivalently, is (x1,y1) coincident with (x2,y2)?
    // Or, is the radius zero? Line to (x1,y1).
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Otherwise, draw an arc!
    else {
      var x20 = x2 - x0,
          y20 = y2 - y0,
          l21_2 = x21 * x21 + y21 * y21,
          l20_2 = x20 * x20 + y20 * y20,
          l21 = Math.sqrt(l21_2),
          l01 = Math.sqrt(l01_2),
          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
          t01 = l / l01,
          t21 = l / l21;

      // If the start tangent is not coincident with (x0,y0), line to.
      if (Math.abs(t01 - 1) > epsilon) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }

      this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r;
    var dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x0,y0).
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    }

    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._ += "L" + x0 + "," + y0;
    }

    // Is this arc empty? We’re done.
    if (!r) return;

    // Does the angle go the wrong way? Flip the direction.
    if (da < 0) da = da % tau + tau;

    // Is this a complete circle? Draw two arcs to complete the circle.
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    }

    // Is this arc non-empty? Draw an arc!
    else if (da > epsilon) {
      this._ += "A" + r + "," + r + ",0," + (+(da >= pi)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
    }
  },
  rect: function(x, y, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
  },
  toString: function() {
    return this._;
  }
};

function constant(x) {
  return function constant() {
    return x;
  };
}

var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max = Math.max;
var min = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;

var epsilon$1 = 1e-12;
var pi$1 = Math.PI;
var halfPi = pi$1 / 2;
var tau$1 = 2 * pi$1;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi$1 : Math.acos(x);
}

function asin(x) {
  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
}

function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0,
      x32 = x3 - x2, y32 = y3 - y2,
      t = y32 * x10 - x32 * y10;
  if (t * t < epsilon$1) return;
  t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

function arc() {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = constant(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null;

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - halfPi,
        a1 = endAngle.apply(this, arguments) - halfPi,
        da = abs(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = path();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > epsilon$1)) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > tau$1 - epsilon$1) {
      context.moveTo(r1 * cos(a0), r1 * sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon$1) {
        context.moveTo(r0 * cos(a1), r0 * sin(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    }

    // Or is it a circular or annular sector?
    else {
      var a01 = a0,
          a11 = a1,
          a00 = a0,
          a10 = a1,
          da0 = da,
          da1 = da,
          ap = padAngle.apply(this, arguments) / 2,
          rp = (ap > epsilon$1) && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)),
          rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
          rc0 = rc,
          rc1 = rc,
          t0,
          t1;

      // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
      if (rp > epsilon$1) {
        var p0 = asin(rp / r0 * sin(ap)),
            p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p0 * 2) > epsilon$1) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon$1) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }

      var x01 = r1 * cos(a01),
          y01 = r1 * sin(a01),
          x10 = r0 * cos(a10),
          y10 = r0 * sin(a10);

      // Apply rounded corners?
      if (rc > epsilon$1) {
        var x11 = r1 * cos(a11),
            y11 = r1 * sin(a11),
            x00 = r0 * cos(a00),
            y00 = r0 * sin(a00),
            oc;

        // Restrict the corner radius according to the sector angle.
        if (da < pi$1 && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
          var ax = x01 - oc[0],
              ay = y01 - oc[1],
              bx = x11 - oc[0],
              by = y11 - oc[1],
              kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),
              lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = min(rc, (r0 - lc) / (kc - 1));
          rc1 = min(rc, (r1 - lc) / (kc + 1));
        }
      }

      // Is the sector collapsed to a line?
      if (!(da1 > epsilon$1)) context.moveTo(x01, y01);

      // Does the sector’s outer ring have rounded corners?
      else if (rc1 > epsilon$1) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the outer ring just a circular arc?
      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

      // Is there no inner ring, and it’s a circular sector?
      // Or perhaps it’s an annular sector collapsed due to padding?
      if (!(r0 > epsilon$1) || !(da0 > epsilon$1)) context.lineTo(x10, y10);

      // Does the sector’s inner ring (or point) have rounded corners?
      else if (rc0 > epsilon$1) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the inner ring just a circular arc?
      else context.arc(0, 0, r0, a10, a00, cw);
    }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$1 / 2;
    return [cos(a) * r, sin(a) * r];
  };

  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant(+_), arc) : innerRadius;
  };

  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant(+_), arc) : cornerRadius;
  };

  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant(+_), arc) : padRadius;
  };

  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), arc) : startAngle;
  };

  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), arc) : endAngle;
  };

  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), arc) : padAngle;
  };

  arc.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
  };

  return arc;
}

function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: this._context.lineTo(x, y); break;
    }
  }
};

function curveLinear(context) {
  return new Linear(context);
}

function x(p) {
  return p[0];
}

function y(p) {
  return p[1];
}

function line() {
  var x$1 = x,
      y$1 = y,
      defined = constant(true),
      context = null,
      curve = curveLinear,
      output = null;

  function line(data) {
    var i,
        n = data.length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x$1(d, i, data), +y$1(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function(_) {
    return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant(+_), line) : x$1;
  };

  line.y = function(_) {
    return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant(+_), line) : y$1;
  };

  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), line) : defined;
  };

  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
}

function area() {
  var x0 = x,
      x1 = null,
      y0 = constant(0),
      y1 = y,
      defined = constant(true),
      context = null,
      curve = curveLinear,
      output = null;

  function area(data) {
    var i,
        j,
        k,
        n = data.length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return line().defined(defined).curve(curve).context(context);
  }

  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), x1 = null, area) : x0;
  };

  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), area) : x0;
  };

  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : x1;
  };

  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), y1 = null, area) : y0;
  };

  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), area) : y0;
  };

  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : y1;
  };

  area.lineX0 =
  area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };

  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), area) : defined;
  };

  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
}

function descending(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}

function identity(d) {
  return d;
}

function pie() {
  var value = identity,
      sortValues = descending,
      sort = null,
      startAngle = constant(0),
      endAngle = constant(tau$1),
      padAngle = constant(0);

  function pie(data) {
    var i,
        n = data.length,
        j,
        k,
        sum = 0,
        index = new Array(n),
        arcs = new Array(n),
        a0 = +startAngle.apply(this, arguments),
        da = Math.min(tau$1, Math.max(-tau$1, endAngle.apply(this, arguments) - a0)),
        a1,
        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
        pa = p * (da < 0 ? -1 : 1),
        v;

    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum += v;
      }
    }

    // Optionally sort the arcs by previously-computed values or by data.
    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

    // Compute the arcs! They are stored in the original data's order.
    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }

    return arcs;
  }

  pie.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), pie) : value;
  };

  pie.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };

  pie.sort = function(_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };

  pie.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), pie) : startAngle;
  };

  pie.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), pie) : endAngle;
  };

  pie.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), pie) : padAngle;
  };

  return pie;
}

var slice = Array.prototype.slice;

function point(that, x, y) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x) / 6,
    (that._y0 + 4 * that._y1 + y) / 6
  );
}

function Basis(context) {
  this._context = context;
}

Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3: point(this, this._x1, this._y1); // proceed
      case 2: this._context.lineTo(this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function curveBasis(context) {
  return new Basis(context);
}

function point$1(that, x, y) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x),
    that._y2 + that._k * (that._y1 - y),
    that._x2,
    that._y2
  );
}

function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: point$1(this, this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
      case 2: this._point = 3; // proceed
      default: point$1(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var curveCardinal = (function custom(tension) {

  function cardinal(context) {
    return new Cardinal(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0);

function point$2(that, x, y) {
  var x1 = that._x1,
      y1 = that._y1,
      x2 = that._x2,
      y2 = that._y2;

  if (that._l01_a > epsilon$1) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }

  if (that._l23_a > epsilon$1) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
  }

  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: this.point(this._x2, this._y2); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; // proceed
      default: point$2(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var curveCatmullRom = (function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5);

function sign(x) {
  return x < 0 ? -1 : 1;
}

// Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}

// Calculate a one-sided slope.
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}

// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bézier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
function point$3(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX(context) {
  this._context = context;
}

MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 =
    this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x1, this._y1); break;
      case 3: point$3(this, this._t0, slope2(this, this._t0)); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    var t1 = NaN;

    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; point$3(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
      default: point$3(this, this._t0, t1 = slope3(this, x, y)); break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
};

function MonotoneY(context) {
  this._context = new ReflectContext(context);
}

(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
  MonotoneX.prototype.point.call(this, y, x);
};

function ReflectContext(context) {
  this._context = context;
}

ReflectContext.prototype = {
  moveTo: function(x, y) { this._context.moveTo(y, x); },
  closePath: function() { this._context.closePath(); },
  lineTo: function(x, y) { this._context.lineTo(y, x); },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
};

function monotoneX(context) {
  return new MonotoneX(context);
}

function monotoneY(context) {
  return new MonotoneY(context);
}

function Natural(context) {
  this._context = context;
}

Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        n = x.length;

    if (n) {
      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
      if (n === 2) {
        this._context.lineTo(x[1], y[1]);
      } else {
        var px = controlPoints(x),
            py = controlPoints(y);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
        }
      }
    }

    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
function controlPoints(x) {
  var i,
      n = x.length - 1,
      m,
      a = new Array(n),
      b = new Array(n),
      r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
  b[n - 1] = (x[n] + a[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
  return [a, b];
}

function curveNatural(context) {
  return new Natural(context);
}

function Step(context, t) {
  this._context = context;
  this._t = t;
}

Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y);
          this._context.lineTo(x, y);
        } else {
          var x1 = this._x * (1 - this._t) + x * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y);
        }
        break;
      }
    }
    this._x = x, this._y = y;
  }
};

function curveStep(context) {
  return new Step(context, 0.5);
}

function stepBefore(context) {
  return new Step(context, 0);
}

function stepAfter(context) {
  return new Step(context, 1);
}

function stackOffsetNone(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
}

function stackOrderNone(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0) o[n] = n;
  return o;
}

function stackValue(d, key) {
  return d[key];
}

function stack() {
  var keys = constant([]),
      order = stackOrderNone,
      offset = stackOffsetNone,
      value = stackValue;

  function stack(data) {
    var kz = keys.apply(this, arguments),
        i,
        m = data.length,
        n = kz.length,
        sz = new Array(n),
        oz;

    for (i = 0; i < n; ++i) {
      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
        si[j] = sij = [0, +value(data[j], ki, j, data)];
        sij.data = data[j];
      }
      si.key = ki;
    }

    for (i = 0, oz = order(sz); i < n; ++i) {
      sz[oz[i]].index = i;
    }

    offset(sz, oz);
    return sz;
  }

  stack.keys = function(_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : constant(slice.call(_)), stack) : keys;
  };

  stack.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), stack) : value;
  };

  stack.order = function(_) {
    return arguments.length ? (order = _ == null ? stackOrderNone : typeof _ === "function" ? _ : constant(slice.call(_)), stack) : order;
  };

  stack.offset = function(_) {
    return arguments.length ? (offset = _ == null ? stackOffsetNone : _, stack) : offset;
  };

  return stack;
}

function stackOffsetExpand(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
    for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
    if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
  }
  stackOffsetNone(series, order);
}

function stackOffsetDiverging(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
    for (yp = yn = 0, i = 0; i < n; ++i) {
      if ((dy = (d = series[order[i]][j])[1] - d[0]) >= 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn, d[0] = yn += dy;
      } else {
        d[0] = yp;
      }
    }
  }
}

function stackOffsetSilhouette(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
    for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
    s0[j][1] += s0[j][0] = -y / 2;
  }
  stackOffsetNone(series, order);
}

function stackOffsetWiggle(series, order) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order[i]],
          sij0 = si[j][1] || 0,
          sij1 = si[j - 1][1] || 0,
          s3 = (sij0 - sij1) / 2;
      for (var k = 0; k < i; ++k) {
        var sk = series[order[k]],
            skj0 = sk[j][1] || 0,
            skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j - 1][1] += s0[j - 1][0] = y;
    if (s1) y -= s2 / s1;
  }
  s0[j - 1][1] += s0[j - 1][0] = y;
  stackOffsetNone(series, order);
}

function appearance(series) {
  var peaks = series.map(peak);
  return stackOrderNone(series).sort(function(a, b) { return peaks[a] - peaks[b]; });
}

function peak(series) {
  var i = -1, j = 0, n = series.length, vi, vj = -Infinity;
  while (++i < n) if ((vi = +series[i][1]) > vj) vj = vi, j = i;
  return j;
}

function stackOrderAscending(series) {
  var sums = series.map(sum);
  return stackOrderNone(series).sort(function(a, b) { return sums[a] - sums[b]; });
}

function sum(series) {
  var s = 0, i = -1, n = series.length, v;
  while (++i < n) if (v = +series[i][1]) s += v;
  return s;
}

function stackOrderInsideOut(series) {
  var n = series.length,
      i,
      j,
      sums = series.map(sum),
      order = appearance(series),
      top = 0,
      bottom = 0,
      tops = [],
      bottoms = [];

  for (i = 0; i < n; ++i) {
    j = order[i];
    if (top < bottom) {
      top += sums[j];
      tops.push(j);
    } else {
      bottom += sums[j];
      bottoms.push(j);
    }
  }

  return bottoms.reverse().concat(tops);
}

function stackOrderReverse(series) {
  return stackOrderNone(series).reverse();
}

function registryFactory(parentRegistry) {
  var registerName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'unspecified';
  var logger = arguments.length > 2 ? arguments[2] : undefined;
  var defaultValue;
  var reg = {};
  var parent = parentRegistry || {
    get: function get() {
      return undefined;
    },
    has: function has() {
      return false;
    },
    default: function _default() {
      return undefined;
    }
  };
  defaultValue = parent.default();
  /**
   * @private
   * @param {string} key
   * @param {any} value
   * @throws {TypeError} Key must be a non-empty string
   * @returns {boolean} False if the given key already exists, true otherwise
   * @example
   * var r = registry();
   * r.add( "marker", function(args) {
   *   return new markers[args.type](args);
   * });
   *
   */

  function add(key, value) {
    if (!key || typeof key !== 'string') {
      throw new TypeError('Invalid argument: key must be a non-empty string');
    }

    if (key in reg) {
      return false;
    }

    reg[key] = value;
    return true;
  }

  function get(key) {
    return reg[key] || parent.get(key);
  }

  function has(key) {
    return !!reg[key] || parent.has(key);
  }

  function remove(key) {
    var d = reg[key];
    delete reg[key];
    return d;
  }

  function getKeys() {
    return Object.keys(reg);
  }

  function getValues() {
    return Object.keys(reg).map(function (key) {
      return reg[key];
    });
  }

  function deflt(d) {
    if (typeof d !== 'undefined') {
      defaultValue = d;
    }

    return defaultValue;
  }
  /**
   * @alias registry
   * @interface
   * @param {string} key
   * @param {any} value
   */


  function registry(key, value) {
    if (typeof value !== 'undefined') {
      return add(key, value);
    }

    var ret = get(key);

    if (logger && typeof ret === 'undefined') {
      logger.warn("".concat(key, " does not exist in ").concat(registerName, " registry"));
    }

    return ret || get(defaultValue);
  }

  registry.add = add;
  registry.get = get;
  registry.has = has;
  registry.remove = remove;
  registry.getKeys = getKeys;
  registry.getValues = getValues;
  registry.default = deflt;
  registry.register = add; // deprecated

  return registry;
}

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimal(1.23) returns ["123", 0].
function formatDecimal(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}

function exponent(x) {
  return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
}

function formatGroup(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
}

function formatNumerals(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  return new FormatSpecifier(specifier);
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  this.fill = match[1] || " ";
  this.align = match[2] || ">";
  this.sign = match[3] || "-";
  this.symbol = match[4] || "";
  this.zero = !!match[5];
  this.width = match[6] && +match[6];
  this.comma = !!match[7];
  this.precision = match[8] && +match[8].slice(1);
  this.trim = !!match[9];
  this.type = match[10] || "";
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width == null ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
      + (this.trim ? "~" : "")
      + this.type;
};

// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
function formatTrim(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      default: if (i0 > 0) { if (!+s[i]) break out; i0 = 0; } break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}

var prefixExponent;

function formatPrefixAuto(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}

function formatRounded(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

var formatTypes = {
  "%": function(x, p) { return (x * 100).toFixed(p); },
  "b": function(x) { return Math.round(x).toString(2); },
  "c": function(x) { return x + ""; },
  "d": function(x) { return Math.round(x).toString(10); },
  "e": function(x, p) { return x.toExponential(p); },
  "f": function(x, p) { return x.toFixed(p); },
  "g": function(x, p) { return x.toPrecision(p); },
  "o": function(x) { return Math.round(x).toString(8); },
  "p": function(x, p) { return formatRounded(x * 100, p); },
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
  "x": function(x) { return Math.round(x).toString(16); }
};

function identity$1(x) {
  return x;
}

var prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

function formatLocale(locale) {
  var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity$1,
      currency = locale.currency,
      decimal = locale.decimal,
      numerals = locale.numerals ? formatNumerals(locale.numerals) : identity$1,
      percent = locale.percent || "%";

  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!formatTypes[type]) precision == null && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = formatTypes[type],
        maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision == null ? 6
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Perform the initial formatting.
        var valueNegative = value < 0;
        value = formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = formatTrim(value);

        // If a negative value rounds to zero during formatting, treat as positive.
        if (valueNegative && +value === 0) valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer “value” part that can be
        // grouped, and fractional or exponential “suffix” part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}

var locale;
var format;
var formatPrefix;

defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  locale = formatLocale(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

function precisionFixed(step) {
  return Math.max(0, -exponent(Math.abs(step)));
}

function precisionPrefix(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
}

function precisionRound(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, exponent(max) - exponent(step)) + 1;
}

function formatter(pattern, thousand, decimal) {
  var locale, d3format;
  /**
   * Format a value according to the specified pattern created at construct
   * @private
   *
   * @param  {Number} value   The number to be formatted
   * @return {String}         [description]
   */

  function format(value) {
    return d3format(value);
  }
  /**
    * Set the locale for the formatter
    *
    * @param  {Object} args   Locale object for formatting
    * @return {Undefined}      Returns nothing
    */


  format.locale = function localeFn(settings) {
    locale = formatLocale(settings);
    d3format = locale.format(pattern);
    return this;
  };
  /**
   * Resets the formatter using format.locale
   * @ignore
   */


  function reset() {
    format.locale({
      decimal: decimal || '.',
      thousands: thousand || ',',
      grouping: [3],
      currency: ['$', '']
    });
  }

  reset();
  /**
    * Format a value according to a specific pattern
    * that is not the one specified in the constructor
    *
    * @param  {String} p   Pattern
    * @param  {Number} v   Value
    * @param  {String} t   Thousand
    * @param  {String} d   Decimal
    * @return {String}     Formatted value
    */

  format.format = function formatFn(p, v, t, d) {
    if (t || d) {
      thousand = t;
      decimal = d;
      reset();
    }

    return locale.format(p)(v);
  };
  /**
   * Change the pattern on existing formatter
   *
   * @param  {String} p     Pattern (optional)
   * @return {String}       Returns the pattern
   */


  format.pattern = function patternFn(p) {
    if (p) {
      pattern = p;
      d3format = locale.format(p);
    }

    return pattern;
  };

  return format;
}

var t0 = new Date,
    t1 = new Date;

function newInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = new Date(+date)), date;
  }

  interval.floor = interval;

  interval.ceil = function(date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function(date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function(date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function(start, stop, step) {
    var range = [], previous;
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range;
  };

  interval.filter = function(test) {
    return newInterval(function(date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function(date, step) {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
        }
      }
    });
  };

  if (count) {
    interval.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    interval.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null
          : !(step > 1) ? interval
          : interval.filter(field
              ? function(d) { return field(d) % step === 0; }
              : function(d) { return interval.count(0, d) % step === 0; });
    };
  }

  return interval;
}

var millisecond = newInterval(function() {
  // noop
}, function(date, step) {
  date.setTime(+date + step);
}, function(start, end) {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return newInterval(function(date) {
    date.setTime(Math.floor(date / k) * k);
  }, function(date, step) {
    date.setTime(+date + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};

var durationSecond = 1e3;
var durationMinute = 6e4;
var durationHour = 36e5;
var durationDay = 864e5;
var durationWeek = 6048e5;

var second = newInterval(function(date) {
  date.setTime(date - date.getMilliseconds());
}, function(date, step) {
  date.setTime(+date + step * durationSecond);
}, function(start, end) {
  return (end - start) / durationSecond;
}, function(date) {
  return date.getUTCSeconds();
});

var minute = newInterval(function(date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getMinutes();
});

var hour = newInterval(function(date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getHours();
});

var day = newInterval(function(date) {
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setDate(date.getDate() + step);
}, function(start, end) {
  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
}, function(date) {
  return date.getDate() - 1;
});

function weekday(i) {
  return newInterval(function(date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);

var month = newInterval(function(date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setMonth(date.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date) {
  return date.getMonth();
});

var year = newInterval(function(date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date) {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};

var utcMinute = newInterval(function(date) {
  date.setUTCSeconds(0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getUTCMinutes();
});

var utcHour = newInterval(function(date) {
  date.setUTCMinutes(0, 0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getUTCHours();
});

var utcDay = newInterval(function(date) {
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / durationDay;
}, function(date) {
  return date.getUTCDate() - 1;
});

function utcWeekday(i) {
  return newInterval(function(date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / durationWeek;
  });
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);

var utcMonth = newInterval(function(date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date) {
  return date.getUTCMonth();
});

var utcYear = newInterval(function(date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date) {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};

function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newYear(y) {
  return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
}

function formatLocale$1(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;

  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);

  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };

  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };

  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function(date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;

      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, newDate) {
    return function(string) {
      var d = newYear(1900),
          i = parseSpecifier(d, specifier, string += "", 0),
          week, day$1;
      if (i != string.length) return null;

      // If a UNIX timestamp is specified, return it.
      if ("Q" in d) return new Date(d.Q);

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newYear(d.y)), day$1 = week.getUTCDay();
          week = day$1 > 4 || day$1 === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = newDate(newYear(d.y)), day$1 = week.getDay();
          week = day$1 > 4 || day$1 === 0 ? monday.ceil(week) : monday(week);
          week = day.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day$1 = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day$1 + 5) % 7 : d.w + d.U * 7 - (day$1 + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return newDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() { return specifier; };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", localDate);
      p.toString = function() { return specifier; };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() { return specifier; };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier, utcDate);
      p.toString = function() { return specifier; };
      return p;
    }
  };
}

var pads = {"-": "", "_": " ", "0": "0"},
    numberRe = /^\s*\d+/, // note: ignores next directive
    percentRe = /^%/,
    requoteRe = /[\\^$*+?|[\]().{}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  var map = {}, i = -1, n = names.length;
  while (++i < n) map[names[i].toLowerCase()] = i;
  return map;
}

function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}

function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = (+n[0]) * 1000, i + n[0].length) : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + day.count(year(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}

function formatWeekNumberSunday(d, p) {
  return pad(sunday.count(year(d), d), p, 2);
}

function formatWeekNumberISO(d, p) {
  var day = d.getDay();
  d = (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
  return pad(thursday.count(year(d), d) + (year(d).getDay() === 4), p, 2);
}

function formatWeekdayNumberSunday(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(monday.count(year(d), d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+"))
      + pad(z / 60 | 0, "0", 2)
      + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + utcDay.count(utcYear(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(utcSunday.count(utcYear(d), d), p, 2);
}

function formatUTCWeekNumberISO(d, p) {
  var day = d.getUTCDay();
  d = (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
  return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
}

function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(utcMonday.count(utcYear(d), d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

function formatUnixTimestamp(d) {
  return +d;
}

function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1000);
}

var locale$1;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;

defaultLocale$1({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale$1(definition) {
  locale$1 = formatLocale$1(definition);
  timeFormat = locale$1.format;
  timeParse = locale$1.parse;
  utcFormat = locale$1.utcFormat;
  utcParse = locale$1.utcParse;
  return locale$1;
}

var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

function formatIsoNative(date) {
  return date.toISOString();
}

var formatIso = Date.prototype.toISOString
    ? formatIsoNative
    : utcFormat(isoSpecifier);

function parseIsoNative(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
}

var parseIso = +new Date("2000-01-01T00:00:00.000Z")
    ? parseIsoNative
    : utcParse(isoSpecifier);

function formatter$1(pattern) {
  // eslint-disable-line import/prefer-default-export
  var locale = formatLocale$1({
    dateTime: '%x, %X',
    date: '%-m/%-d/%Y',
    time: '%-I:%M:%S %p',
    periods: ['AM', 'PM'],
    days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
    shortDays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
    months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
    shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
  });
  var d3format = locale.format(pattern);
  /**
   * Format a value according to the specified pattern created at construct
   *
   * @param  {Date} value   The number to be formatted
   * @return {String}         [description]
   * @private
   */

  function format(value) {
    return d3format(value);
  }
  /**
    * Format a value according to a specific pattern
    * that is not the one specified in the constructor
    *
    * @param  {String} p   Pattern
    * @param  {Date} v   Value
    * @return {String}     Formatted value
    */


  format.format = function formatFn(p, v) {
    return locale.format(p)(v);
  };
  /**
   * Set the locale for the formatter
   *
   * @param  {Object} args   Locale object for formatting
   * @return {Undefined}      Returns nothing
   */


  format.locale = function localeFn() {
    locale = formatLocale$1.apply(void 0, arguments);
    d3format = locale.format(pattern);
    return this;
  };
  /**
   * Parse a string to a date according to a pattern
   *
   * @param  {String} p   Pattern
   * @param  {String} v   Value
   * @return {Date}     Date
   */


  format.parse = function parse(p, v) {
    return locale.parse(p)(v);
  };
  /**
   * Returns a parser that parses strings to date according to the pattern
   *
   * @param  {String} p   Pattern
   * @return {Function}   Parser
   */


  format.parsePattern = function parsePattern(p) {
    return locale.parse(p);
  };

  return format;
}

var formatterRegistry = registryFactory();
formatterRegistry('d3-number', formatter);
formatterRegistry('d3-time', formatter$1);

/* eslint no-return-assign: 0 */

var getFormatter = function getFormatter(data) {
  if (typeof data.formatter === 'function') {
    return data.formatter();
  }

  var f = data.formatter || {};
  return formatterRegistry(f.type || 'd3-number')(f.format || '');
};

var accessors = {
  id: function id(data) {
    return "".concat(data.source, "/").concat(data.key || data.title);
  },
  key: function key(data) {
    return String(data.key || data.title);
  },
  tags: function tags(data) {
    return data.tags;
  },
  min: function min(data) {
    return data.min;
  },
  max: function max(data) {
    return data.max;
  },
  type: function type(data) {
    return data.type;
  },
  title: function title(data) {
    return String(data.title);
  },
  values: function values(data) {
    return data.values;
  },
  value: function value(v) {
    return v;
  },
  label: function label(v) {
    return v;
  },
  formatter: function formatter(data) {
    return getFormatter(data);
  }
};
/**
 * Create a new field with default settings
 * @ignore
 * @return {field} Data field
 */

function field(data) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$id = _ref.id,
      _id = _ref$id === void 0 ? accessors.id : _ref$id,
      _ref$key = _ref.key,
      _key = _ref$key === void 0 ? accessors.key : _ref$key,
      _ref$min = _ref.min,
      _min = _ref$min === void 0 ? accessors.min : _ref$min,
      _ref$max = _ref.max,
      _max = _ref$max === void 0 ? accessors.max : _ref$max,
      _ref$type = _ref.type,
      _type = _ref$type === void 0 ? accessors.type : _ref$type,
      _ref$tags = _ref.tags,
      _tags = _ref$tags === void 0 ? accessors.tags : _ref$tags,
      _ref$title = _ref.title,
      _title = _ref$title === void 0 ? accessors.title : _ref$title,
      _ref$values = _ref.values,
      values = _ref$values === void 0 ? accessors.values : _ref$values,
      _ref$value = _ref.value,
      value = _ref$value === void 0 ? accessors.value : _ref$value,
      _ref$label = _ref.label,
      label = _ref$label === void 0 ? accessors.label : _ref$label,
      _ref$formatter = _ref.formatter,
      _formatter = _ref$formatter === void 0 ? accessors.formatter : _ref$formatter;

  /**
   * @alias field
   */
  var f = {
    /**
     * Returns this field's id
     * @returns {string}
     */
    id: function id() {
      return _id(data);
    },

    /**
     * Returns this field's key
     * @returns {string}
     */
    key: function key() {
      return _key(data);
    },

    /**
     * Returns the input data
     * @returns {any}
     */
    raw: function raw() {
      return data;
    },

    /**
     * Returns the tags.
     * @return {Array<string>}
     */
    tags: function tags() {
      return _tags(data);
    },

    /**
     * Returns this field's type: 'dimension' or 'measure'.
     * @return {string}
     */
    type: function type() {
      return _type(data);
    },

    /**
     * Returns the min value of this field.
     * @return {number}
     */
    min: function min() {
      return _min(data);
    },

    /**
     * Returns the max value of this field.
     * @return {number}
     */
    max: function max() {
      return _max(data);
    },

    /**
     * Returns this field's title.
     * @return {string}
     */
    title: function title() {
      return _title(data);
    },

    /**
     * Returns the values of this field.
     * @return {Array<datum-extract>}
     */
    items: function items() {
      return values(data);
    },

    /**
     * Returns a formatter adapted to the content of this field.
     */
    formatter: function formatter() {
      return _formatter(data);
    },
    value: value,
    label: label
  };
  return f;
}

var OFFSETS = {
  diverging: stackOffsetDiverging,
  none: stackOffsetNone,
  silhouette: stackOffsetSilhouette,
  expand: stackOffsetExpand,
  wiggle: stackOffsetWiggle
};
var ORDERS = {
  ascending: stackOrderAscending,
  insideout: stackOrderInsideOut,
  none: stackOrderNone,
  reverse: stackOrderReverse
};

function stacked(data, config, ds) {
  var stackIds = {};
  var stackFn = config.stackKey;
  var valueFn = config.value;
  var startProp = config.startProp || 'start';
  var endProp = config.endProp || 'end';
  var offset = config.offset || 'none';
  var order = config.order || 'none';
  var valueRef = config.valueRef || '';
  var maxStackCount = 0;
  var valueFields = {};

  for (var i = 0; i < data.items.length; i++) {
    var p = data.items[i];
    var sourceField = valueRef ? p[valueRef] : null;

    if (sourceField && sourceField.source) {
      var ff = "".concat(sourceField.source.key || '', "/").concat(sourceField.source.field);

      if (!valueFields[ff]) {
        valueFields[ff] = sourceField.source;
      }
    }

    var sid = stackFn(p);
    stackIds[sid] = stackIds[sid] || {
      items: []
    };
    stackIds[sid].items.push(p);
    maxStackCount = Math.max(maxStackCount, stackIds[sid].items.length);
  }

  var keys = Array.apply(null, {
    length: maxStackCount
  }).map(Number.call, Number); // eslint-disable-line

  var matrix = Object.keys(stackIds).map(function (sid) {
    return stackIds[sid].items;
  });
  var d3Stack = stack().keys(keys).value(function (s, key) {
    return s[key] ? valueFn(s[key]) : 0;
  }).order(ORDERS[order]).offset(OFFSETS[offset]);
  var series = d3Stack(matrix);
  var values = [];

  for (var _i = 0; _i < series.length; _i++) {
    var serie = series[_i];

    for (var s = 0; s < serie.length; s++) {
      var range = serie[s];
      var item = serie[s].data[serie.key];

      if (!item) {
        continue;
      }

      item[startProp] = {
        value: range[0]
      };
      item[endProp] = {
        value: range[1]
      };
      values.push(range[0], range[1]);
    }
  }

  var stackedFields = Object.keys(valueFields).map(function (f) {
    var dSource = ds(valueFields[f].key);
    return dSource ? dSource.field(valueFields[f].field) : null;
  }).filter(function (f) {
    return !!f;
  });
  var field$1 = field({
    title: stackedFields.map(function (f) {
      return f.title();
    }).join(', '),
    min: Math.min.apply(Math, values),
    max: Math.max.apply(Math, values),
    type: 'measure',
    formatter: stackedFields[0] ? stackedFields[0].formatter : undefined
  });
  data.fields.push(field$1);
}

function extract(dataConfig) {
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var extracted = {// items: [],
    // fields: [],
    // source: null,
    // value: null,
    // label: null,
    // children: null,
    // root: null,
    // graph: null
  };
  var logger = opts.logger;

  if (Array.isArray(dataConfig)) {
    // if data is an array, assume it's manual data input -> normalize
    extracted.items = dataConfig.map(function (v) {
      return {
        value: v,
        label: String(v)
      };
    });
  } else if (dataConfig) {
    if ('collection' in dataConfig) {
      extracted = _objectSpread({}, data.collection(dataConfig.collection));
    } else {
      var source = data.dataset ? data.dataset(dataConfig.source) : null;

      var valueFn = dataConfig.value || function (d) {
        return d;
      };

      var labelFn = dataConfig.label || function (d) {
        return d;
      };

      if (dataConfig.groupBy || dataConfig.mapTo) {
        // DEPRECATION
        logger.warn('Deprecated "data" configuration', dataConfig);
        extracted.items = [];
      } else if (dataConfig.hierarchy) {
        extracted.root = source.hierarchy ? source.hierarchy(dataConfig.hierarchy) : null;
        extracted.fields = source.fields();
      } else if (dataConfig.items) {
        extracted.items = dataConfig.items.map(function (v) {
          return {
            value: valueFn(v),
            label: String(labelFn(v))
          };
        });
      } else if (dataConfig.extract) {
        var extractionsConfigs = Array.isArray(dataConfig.extract) ? dataConfig.extract : [dataConfig.extract];
        extracted.items = [];
        var sourceFields = [];
        extractionsConfigs.forEach(function (cfg) {
          var _extracted$items;

          var s = cfg.source ? data.dataset(cfg.source) : source;

          if (!s) {
            return;
          }

          (_extracted$items = extracted.items).push.apply(_extracted$items, _toConsumableArray$1(s.extract(cfg)));

          if (typeof cfg.field !== 'undefined') {
            sourceFields.push(s.field(cfg.field));
          }
        });

        if (sourceFields.length) {
          extracted.fields = sourceFields;
        }

        if (dataConfig.amend && Array.isArray(dataConfig.amend)) {
          var _extracted$items2;

          (_extracted$items2 = extracted.items).push.apply(_extracted$items2, _toConsumableArray$1(dataConfig.amend));
        }
      } else if (typeof dataConfig.field !== 'undefined' && source) {
        var f = source.field(dataConfig.field);

        if (f) {
          if (!extracted.fields) {
            extracted.fields = [];
          }

          extracted.fields.push(f);

          if (!('value' in dataConfig)) {
            valueFn = f.value || function (v) {
              return v;
            };

            labelFn = f.label || function (v) {
              return v;
            };

            extracted.value = valueFn;
          }

          extracted.items = f.items().map(function (v) {
            return {
              value: valueFn(v),
              label: String(labelFn(v)),
              source: {
                field: dataConfig.field
              }
            };
          }); // TODO - add source: { key: dataConfig.source, field: dataConfig.field, data: v }
        }
      } else if (dataConfig.fields) {
        dataConfig.fields.forEach(function (obj) {
          var s = _typeof(obj) === 'object' && obj.source ? data.dataset(obj.source) : source;

          if (!s) {
            return;
          }

          var f;

          if (_typeof(obj) === 'object' && typeof obj.field !== 'undefined') {
            f = s.field(obj.field);
          } else {
            f = s.field(obj);
          }

          if (f) {
            if (!extracted.fields) {
              extracted.fields = [];
            }

            extracted.fields.push(f);
          }
        });
      }

      if (extracted.items && dataConfig.map) {
        extracted.items = extracted.items.map(dataConfig.map);
      }
    }

    if (dataConfig && dataConfig.stack) {
      stacked(extracted, dataConfig.stack, data.dataset);
    }
  }

  if (dataConfig && !Array.isArray(dataConfig) && typeof dataConfig.filter === 'function' && extracted.items) {
    extracted.items = extracted.items.filter(dataConfig.filter);
  }

  if (dataConfig && !Array.isArray(dataConfig) && typeof dataConfig.sort === 'function' && extracted.items) {
    extracted.items = extracted.items.sort(dataConfig.sort);
  }

  return extracted;
}

function create(config, d, opts) {
  var extractor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : extract;
  var collections = {};
  (config || []).forEach(function (cfg) {
    if (!cfg.key) {
      throw new Error('Data collection is missing "key" property');
    }

    if (_typeof(cfg.data) === 'object' && 'collection' in cfg.data) {
      throw new Error('Data config for collections may not reference other collections');
    }

    collections[cfg.key] = function () {
      return extractor(cfg.data, d, opts);
    };
  });

  var fn = function fn(key) {
    var k;
    var cfg;

    if (typeof key === 'string') {
      k = key;
    } else if (_typeof(key) === 'object') {
      k = key.key;
      cfg = key;
    }

    if (!(k in collections)) {
      throw new Error("Unknown data collection: ".concat(k));
    }

    if (typeof collections[k] === 'function') {
      collections[k] = collections[k]();
    }

    var coll = collections[k];

    if (cfg) {
      if (cfg.fields && cfg.fields.filter) {
        var filtered = coll.fields.filter(cfg.fields.filter);

        if (coll.fields.length !== filtered.length) {
          coll = extend(coll, {
            fields: filtered
          });
        }
      }
    }

    return coll;
  };

  return fn;
}

function create$1(options, data, deps) {
  var extractor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : extract;

  if (options.data) {
    var d = extractor(options.data, data, deps);

    if (d && d.fields && d.fields[0]) {
      // TODO Have some magic to handle and merge formatters from multiple sources
      return d.fields[0].formatter();
    }
  }

  var formatterType;

  if (options.formatter) {
    formatterType = "".concat(options.formatter, "-").concat(options.type || 'number');
  } else {
    formatterType = options.type || 'd3-number';
  }

  if (deps.formatter.has(formatterType)) {
    var f = deps.formatter.get(formatterType)(options.format || '');
    return f;
  }

  throw new Error("Formatter of type '".concat(formatterType, "' was not found"));
}
function collection(formattersConfig, data, deps) {
  var fn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : create$1;
  var formatters = {};
  return {
    get: function get(def) {
      var key;

      if (typeof def === 'string' && formattersConfig[def]) {
        key = def;
      } else if (_typeof(def) === 'object' && 'formatter' in def && formattersConfig[def.formatter]) {
        key = def.formatter;
      } else if (_typeof(def) === 'object' && 'type' in def && formattersConfig[def.type]) {
        key = def.type;
      }

      if (key) {
        formatters[key] = formatters[key] || fn(formattersConfig[key], data, deps);
        return formatters[key];
      }

      return fn(def || {}, data, deps);
    },
    all: function all() {
      Object.keys(formattersConfig).forEach(this.get);
      return formatters;
    }
  };
}

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function bisector(compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
}

function ascendingComparator(f) {
  return function(d, x) {
    return ascending(f(d), x);
  };
}

var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;

function sequence(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
}

var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

function ticks(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;

  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    while (++i < n) ticks[i] = (start + i) * step;
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));
    while (++i < n) ticks[i] = (start - i) / step;
  }

  if (reverse) ticks.reverse();

  return ticks;
}

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0
      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}

function initRange(domain, range) {
  switch (arguments.length) {
    case 0: break;
    case 1: this.range(domain); break;
    default: this.range(range).domain(domain); break;
  }
  return this;
}

var prefix = "$";

function Map() {}

Map.prototype = map.prototype = {
  constructor: Map,
  has: function(key) {
    return (prefix + key) in this;
  },
  get: function(key) {
    return this[prefix + key];
  },
  set: function(key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function(key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function() {
    for (var property in this) if (property[0] === prefix) delete this[property];
  },
  keys: function() {
    var keys = [];
    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
    return keys;
  },
  values: function() {
    var values = [];
    for (var property in this) if (property[0] === prefix) values.push(this[property]);
    return values;
  },
  entries: function() {
    var entries = [];
    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
    return entries;
  },
  size: function() {
    var size = 0;
    for (var property in this) if (property[0] === prefix) ++size;
    return size;
  },
  empty: function() {
    for (var property in this) if (property[0] === prefix) return false;
    return true;
  },
  each: function(f) {
    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
  }
};

function map(object, f) {
  var map = new Map;

  // Copy constructor.
  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });

  // Index array by numeric index or specified key function.
  else if (Array.isArray(object)) {
    var i = -1,
        n = object.length,
        o;

    if (f == null) while (++i < n) map.set(i, object[i]);
    else while (++i < n) map.set(f(o = object[i], i, object), o);
  }

  // Convert object to map.
  else if (object) for (var key in object) map.set(key, object[key]);

  return map;
}

function Set() {}

var proto = map.prototype;

Set.prototype = set.prototype = {
  constructor: Set,
  has: proto.has,
  add: function(value) {
    value += "";
    this[prefix + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};

function set(object, f) {
  var set = new Set;

  // Copy constructor.
  if (object instanceof Set) object.each(function(value) { set.add(value); });

  // Otherwise, assume it’s an array.
  else if (object) {
    var i = -1, n = object.length;
    if (f == null) while (++i < n) set.add(object[i]);
    else while (++i < n) set.add(f(object[i], i, object));
  }

  return set;
}

var array = Array.prototype;

var map$1 = array.map;
var slice$1 = array.slice;

var implicit = {name: "implicit"};

function ordinal() {
  var index = map(),
      domain = [],
      range = [],
      unknown = implicit;

  function scale(d) {
    var key = d + "", i = index.get(key);
    if (!i) {
      if (unknown !== implicit) return unknown;
      index.set(key, i = domain.push(d));
    }
    return range[(i - 1) % range.length];
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = map();
    var i = -1, n = _.length, d, key;
    while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
    return scale;
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice$1.call(_), scale) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return ordinal(domain, range).unknown(unknown);
  };

  initRange.apply(scale, arguments);

  return scale;
}

function band() {
  var scale = ordinal().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      range = [0, 1],
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;

  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = range[1] < range[0],
        start = range[reverse - 0],
        stop = range[1 - reverse];
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = sequence(n).map(function(i) { return start + step * i; });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function(_) {
    return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = [+_[0], +_[1]], round = true, rescale();
  };

  scale.bandwidth = function() {
    return bandwidth;
  };

  scale.step = function() {
    return step;
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };

  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };

  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };

  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function() {
    return band(domain(), range)
        .round(round)
        .paddingInner(paddingInner)
        .paddingOuter(paddingOuter)
        .align(align);
  };

  return initRange.apply(rescale(), arguments);
}

function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}

function extend$1(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex3 = /^#([0-9a-f]{3})$/,
    reHex6 = /^#([0-9a-f]{6})$/,
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

define(Color, color, {
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: function() {
    return this.rgb().hex();
  },
  toString: function() {
    return this.rgb() + "";
  }
});

function color(format) {
  var m;
  format = (format + "").trim().toLowerCase();
  return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1)) // #f00
      : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format])
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

define(Rgb, rgb, extend$1(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return (0 <= this.r && this.r <= 255)
        && (0 <= this.g && this.g <= 255)
        && (0 <= this.b && this.b <= 255)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: function() {
    return "#" + hex(this.r) + hex(this.g) + hex(this.b);
  },
  toString: function() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "rgb(" : "rgba(")
        + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.b) || 0))
        + (a === 1 ? ")" : ", " + a + ")");
  }
}));

function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hsl, hsl, extend$1(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  }
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}

var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;

// https://beta.observablehq.com/@mbostock/lab-and-rgb
var K = 18,
    Xn = 0.96422,
    Yn = 1,
    Zn = 0.82521,
    t0$1 = 4 / 29,
    t1$1 = 6 / 29,
    t2 = 3 * t1$1 * t1$1,
    t3 = t1$1 * t1$1 * t1$1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) {
    if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
    var h = o.h * deg2rad;
    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
  }
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y; else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

define(Lab, lab, extend$1(Color, {
  brighter: function(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0$1;
}

function lab2xyz(t) {
  return t > t1$1 ? t * t * t : t2 * (t - t0$1);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * rad2deg;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hcl, hcl, extend$1(Color, {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return labConvert(this).rgb();
  }
}));

var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Cubehelix, cubehelix, extend$1(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new Rgb(
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));

function constant$1(x) {
  return function() {
    return x;
  };
}

function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant$1(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant$1(isNaN(a) ? b : a);
}

var interpolateRgb = (function rgbGamma(y) {
  var color = gamma(y);

  function rgb$1(start, end) {
    var r = color((start = rgb(start)).r, (end = rgb(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb$1.gamma = rgbGamma;

  return rgb$1;
})(1);

function array$1(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = interpolateValue(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}

function date(a, b) {
  var d = new Date;
  return a = +a, b -= a, function(t) {
    return d.setTime(a + b * t), d;
  };
}

function interpolateNumber(a, b) {
  return a = +a, b -= a, function(t) {
    return a + b * t;
  };
}

function interpolateObject(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = interpolateValue(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
}

var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

function string(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: interpolateNumber(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
}

function interpolateValue(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant$1(b)
      : (t === "number" ? interpolateNumber
      : t === "string" ? ((c = color(b)) ? (b = c, interpolateRgb) : string)
      : b instanceof color ? interpolateRgb
      : b instanceof Date ? date
      : Array.isArray(b) ? array$1
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? interpolateObject
      : interpolateNumber)(a, b);
}

function interpolateRound(a, b) {
  return a = +a, b -= a, function(t) {
    return Math.round(a + b * t);
  };
}

var degrees = 180 / Math.PI;

var rho = Math.SQRT2;

function constant$2(x) {
  return function() {
    return x;
  };
}

function number(x) {
  return +x;
}

var unit = [0, 1];

function identity$2(x) {
  return x;
}

function normalize(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : constant$2(isNaN(b) ? NaN : 0.5);
}

function clamper(domain) {
  var a = domain[0], b = domain[domain.length - 1], t;
  if (a > b) t = a, a = b, b = t;
  return function(x) { return Math.max(a, Math.min(b, x)); };
}

// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
function bimap(domain, range, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}

function polymap(domain, range, interpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate(range[i], range[i + 1]);
  }

  return function(x) {
    var i = bisectRight(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp())
      .unknown(source.unknown());
}

function transformer() {
  var domain = unit,
      range = unit,
      interpolate = interpolateValue,
      transform,
      untransform,
      unknown,
      clamp = identity$2,
      piecewise,
      output,
      input;

  function rescale() {
    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
  }

  scale.invert = function(y) {
    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));
  };

  scale.domain = function(_) {
    return arguments.length ? (domain = map$1.call(_, number), clamp === identity$2 || (clamp = clamper(domain)), rescale()) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice$1.call(_), rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = slice$1.call(_), interpolate = interpolateRound, rescale();
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = _ ? clamper(domain) : identity$2, scale) : clamp !== identity$2;
  };

  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}

function continuous(transform, untransform) {
  return transformer()(transform, untransform);
}

function tickFormat(start, stop, count, specifier) {
  var step = tickStep(start, stop, count),
      precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}

function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function(count) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function(count, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
  };

  scale.nice = function(count) {
    if (count == null) count = 10;

    var d = domain(),
        i0 = 0,
        i1 = d.length - 1,
        start = d[i0],
        stop = d[i1],
        step;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }

    step = tickIncrement(start, stop, count);

    if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
      step = tickIncrement(start, stop, count);
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
      step = tickIncrement(start, stop, count);
    }

    if (step > 0) {
      d[i0] = Math.floor(start / step) * step;
      d[i1] = Math.ceil(stop / step) * step;
      domain(d);
    } else if (step < 0) {
      d[i0] = Math.ceil(start * step) / step;
      d[i1] = Math.floor(stop * step) / step;
      domain(d);
    }

    return scale;
  };

  return scale;
}

function linear$1() {
  var scale = continuous(identity$2, identity$2);

  scale.copy = function() {
    return copy(scale, linear$1());
  };

  initRange.apply(scale, arguments);

  return linearish(scale);
}

function threshold() {
  var domain = [0.5],
      range = [0, 1],
      unknown,
      n = 1;

  function scale(x) {
    return x <= x ? range[bisectRight(domain, x, 0, n)] : unknown;
  }

  scale.domain = function(_) {
    return arguments.length ? (domain = slice$1.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice$1.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return threshold()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return initRange.apply(scale, arguments);
}

function applyFormat(formatter) {
  return typeof formatter === 'undefined' ? function (t) {
    return t;
  } : function (t) {
    return formatter(t);
  };
}

function clamp(val) {
  return Math.max(0, Math.min(1, val));
}

function isObject(obj) {
  return _typeof(obj) === 'object';
}

function minorTicksGenerator(count, start, end) {
  var r = Math.abs(start - end);
  var interval = r / (count + 1);
  var ticks = [];

  for (var i = 1; i <= count; i++) {
    var v = i * interval;
    ticks.push(start < end ? start + v : start - v);
  }

  return ticks;
}

function appendMinorTicks(majorTicks, minorCount, scale) {
  if (majorTicks.length === 1) {
    return majorTicks;
  }

  var ticks = majorTicks.concat([]);

  for (var i = 0; i < majorTicks.length; i++) {
    var start = majorTicks[i];
    var end = majorTicks[i + 1];

    if (i === 0 && start !== scale.start()) {
      // Before and after first major tick
      ticks.push.apply(ticks, _toConsumableArray$1(minorTicksGenerator(minorCount, start, end)));
      start -= end - start;
      end = majorTicks[i];
      ticks.push.apply(ticks, _toConsumableArray$1(minorTicksGenerator(minorCount, start, end)));
    } else if (i === majorTicks.length - 1 && end !== scale.end()) {
      // After last major tick
      end = start + (start - majorTicks[i - 1]);
      ticks.push.apply(ticks, _toConsumableArray$1(minorTicksGenerator(minorCount, start, end)));
    } else {
      ticks.push.apply(ticks, _toConsumableArray$1(minorTicksGenerator(minorCount, start, end)));
    }
  }

  return ticks.filter(function (t) {
    return t >= scale.min() && t <= scale.max();
  });
}
/**
* Generate ticks based on a distance, for each 100th unit, one additional tick may be added
* @private
* @param  {Number} distance       Distance between each tick
* @param  {Number} scale         The scale instance
* @param  {Number} [minorCount=0]     Number of tick added between each distance
* @param  {Number} [unitDivider=100]   Number to divide distance with
* @return {Array}               Array of ticks
*/


function looseDistanceBasedGenerator(_ref) {
  var distance = _ref.distance,
      scale = _ref.scale,
      _ref$minorCount = _ref.minorCount,
      minorCount = _ref$minorCount === void 0 ? 0 : _ref$minorCount,
      _ref$unitDivider = _ref.unitDivider,
      unitDivider = _ref$unitDivider === void 0 ? 100 : _ref$unitDivider,
      _ref$formatter = _ref.formatter,
      formatter = _ref$formatter === void 0 ? undefined : _ref$formatter;
  var step = !notNumber(unitDivider) && !notNumber(distance) ? Math.max(distance / unitDivider, 2) : 2;
  var count = Math.min(1000, Math.round(step)); // safe guard against huge numbers

  var majorTicks = scale.ticks(count);

  if (majorTicks.length <= 1) {
    majorTicks = scale.ticks(count + 1);
  }

  var ticks = minorCount > 0 ? appendMinorTicks(majorTicks, minorCount, scale) : majorTicks;
  ticks.sort(function (a, b) {
    return a - b;
  });
  var ticksFormatted = ticks.map(applyFormat(formatter));
  return ticks.map(function (tick, i) {
    var position = scale(tick);
    return {
      position: position,
      start: position,
      end: position,
      label: ticksFormatted[i],
      value: tick,
      isMinor: majorTicks.indexOf(tick) === -1
    };
  });
}
/**
* Generate ticks based on a distance, for each 100th unit, one additional tick may be added.
* Will attempt to round the bounds of domain to even values and generate ticks hitting the domain bounds.
* @private
* @param  {Number} distance       Distance between each tick
* @param  {Number} scale         The scale instance
* @param  {Number} [minorCount=0]     Number of tick added between each distance
* @param  {Number} [unitDivider=100]   Number to divide distance with
* @return {Array}               Array of ticks
*/

function tightDistanceBasedGenerator(_ref2) {
  var distance = _ref2.distance,
      scale = _ref2.scale,
      _ref2$minorCount = _ref2.minorCount,
      minorCount = _ref2$minorCount === void 0 ? 0 : _ref2$minorCount,
      _ref2$unitDivider = _ref2.unitDivider,
      unitDivider = _ref2$unitDivider === void 0 ? 100 : _ref2$unitDivider,
      _ref2$formatter = _ref2.formatter,
      formatter = _ref2$formatter === void 0 ? undefined : _ref2$formatter;
  var step = !notNumber(unitDivider) && !notNumber(distance) ? Math.max(distance / unitDivider, 2) : 2;
  var count = Math.min(1000, Math.round(step)); // safe guard against huge numbers

  var n = count > 10 ? 10 : count;
  scale.nice(n);
  var majorTicks = scale.ticks(count);
  var ticks = minorCount > 0 ? appendMinorTicks(majorTicks, minorCount, scale) : majorTicks;
  ticks.sort(function (a, b) {
    return a - b;
  });
  var ticksFormatted = ticks.map(applyFormat(formatter));
  return ticks.map(function (tick, i) {
    var position = scale(tick);
    return {
      position: position,
      start: position,
      end: position,
      label: ticksFormatted[i],
      value: tick,
      isMinor: majorTicks.indexOf(tick) === -1
    };
  });
}

function ticksByCount(_ref3) {
  var count = _ref3.count,
      minorCount = _ref3.minorCount,
      scale = _ref3.scale,
      formatter = _ref3.formatter;
  return scale.ticks((count - 1) * minorCount + count).map(function (tick, i) {
    var position = scale(tick);
    return {
      position: position,
      start: position,
      end: position,
      label: formatter(tick),
      isMinor: i % (minorCount + 1) !== 0,
      value: tick
    };
  });
}

function ticksByValue(_ref4) {
  var values = _ref4.values,
      scale = _ref4.scale,
      _ref4$formatter = _ref4.formatter,
      formatter = _ref4$formatter === void 0 ? function (v) {
    return v;
  } : _ref4$formatter;
  return values.sort(function (a, b) {
    return (isObject(a) ? a.value : a) - (isObject(b) ? b.value : b);
  }).filter(function (v, i, ary) {
    var val = isObject(v) ? v.value : v;
    return val <= scale.max() && val >= scale.min() && ary.indexOf(v) === i;
  }).map(function (v) {
    var isObj = isObject(v);
    var value = isObj ? v.value : v;
    var position = scale(value);
    return {
      position: position,
      value: value,
      label: isObj && typeof v.label !== 'undefined' ? v.label : formatter(value),
      isMinor: isObj ? !!v.isMinor : false,
      start: isObj && !isNaN(v.start) ? clamp(scale(v.start)) : position,
      // TODOHandle end < start?
      end: isObj && !isNaN(v.end) ? clamp(scale(v.end)) : position // TODO Handle start > end?

    };
  });
}

function forceTicksAtBounds(ticks, scale, formatter) {
  var ticksP = ticks.map(function (t) {
    return t.position;
  });
  var range = scale.range();

  if (ticksP.indexOf(range[0]) === -1) {
    ticks.splice(0, 0, {
      position: range[0],
      start: range[0],
      end: range[0],
      label: formatter(scale.start()),
      isMinor: false,
      value: scale.start()
    });
  } else if (ticks[0] && ticks[0].isMinor) {
    ticks[0].isMinor = false; // Convert to major tick
  }

  var lastTick = ticks[ticks.length - 1];

  if (ticksP.indexOf(range[1]) === -1) {
    ticks.push({
      position: range[1],
      start: range[1],
      end: range[1],
      label: formatter(scale.end()),
      isMinor: false,
      value: scale.end()
    });
  } else if (lastTick && lastTick.isMinor) {
    lastTick.isMinor = false; // Convert to major tick
  }
}

function generateContinuousTicks(_ref5) {
  var settings = _ref5.settings,
      scale = _ref5.scale,
      distance = _ref5.distance,
      _ref5$formatter = _ref5.formatter,
      formatter = _ref5$formatter === void 0 ? function (val) {
    return val;
  } : _ref5$formatter;
  var ticks;
  var minorCount = settings.minorTicks && !notNumber(settings.minorTicks.count) ? Math.min(100, settings.minorTicks.count) : 0;

  if (Array.isArray(settings.ticks.values)) {
    var values = settings.ticks.values.filter(function (v) {
      return _typeof(v) === 'object' ? !notNumber(v.value) : !notNumber(v);
    });
    ticks = ticksByValue({
      values: values,
      scale: scale.copy(),
      formatter: formatter
    });
  } else if (!notNumber(settings.ticks.count)) {
    var count = Math.min(1000, settings.ticks.count);
    ticks = ticksByCount({
      count: count,
      minorCount: minorCount,
      scale: scale.copy(),
      formatter: formatter
    });
  } else {
    var tickGen = settings.ticks.tight ? tightDistanceBasedGenerator : looseDistanceBasedGenerator;
    ticks = tickGen({
      distance: distance,
      minorCount: minorCount,
      unitDivider: settings.ticks.distance,
      scale: scale,
      formatter: formatter
    });

    if (settings.ticks.forceBounds) {
      forceTicksAtBounds(ticks, scale, formatter);
    }
  }

  return ticks;
}
function generateDiscreteTicks(_ref6) {
  var scale = _ref6.scale;
  var domain = scale.domain();
  var values = domain;
  var dataItems = scale.data().items;
  var labels = scale.labels ? scale.labels() : values;
  var bandwidth = scale.bandwidth();
  return values.map(function (d, i) {
    var start = scale(d);
    return {
      position: start + bandwidth / 2,
      label: "".concat(labels[i]),
      data: dataItems ? dataItems[i] : undefined,
      start: start,
      end: start + bandwidth
    };
  });
}

function resolveSettings$1() {
  var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var defaultSettings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var stngs = {};
  Object.keys(defaultSettings).forEach(function (key) {
    var type = _typeof(settings[key]);

    if (type === 'function') {
      stngs[key] = settings[key](context);
    } else if (type === 'undefined') {
      stngs[key] = defaultSettings[key];
    } else {
      stngs[key] = settings[key];
    }
  });
  return stngs;
}

var DEFAULT_SETTINGS = {
  min: NaN,
  max: NaN,
  expand: NaN,
  include: [],
  invert: false
};
var DEFAULT_TICKS_SETTINGS = {
  tight: false,
  forceBounds: false,
  values: undefined,
  count: NaN,
  distance: 100
};
var DEFAULT_MINORTICKS_SETTINGS = {
  count: NaN
};
/**
 * @typedef {object} scale--linear
 * @property {string} [type='linear']
 * @property {number} [expand] - Expand the output range
 * @property {boolean} [invert=false] - Invert the output range
 * @property {number[]} [include] - Include specified numbers in the output range
 * @property {object} [ticks]
 * @property {boolean} [ticks.tight = false]
 * @property {boolean} [ticks.forceBounds = false]
 * @property {number} [ticks.distance = 100]  - Approximate distance between each tick
 * @property {number[]|object[]} [ticks.values] - If set, ticks are no longer generated but instead equal to this set
 * @property {number} [ticks.count]
 * @property {object} [minorTicks]
 * @property {number} [minorTicks.count = 3]
 * @property {number} [min] - Set an explicit minimum value
 * @property {number} [max] - Set an explicit maximum value
 */

function getMinMax$1(settings, fields) {
  var min = +settings.min;
  var max = +settings.max;
  var fieldMin = 0;
  var fieldMax = 1;

  if (fields && fields[0]) {
    var minValues = fields.map(function (m) {
      return m.min();
    }).filter(function (v) {
      return !isNaN(v);
    });
    var maxValues = fields.map(function (m) {
      return m.max();
    }).filter(function (v) {
      return !isNaN(v);
    });
    fieldMin = minValues.length ? Math.min.apply(Math, _toConsumableArray$1(minValues)) : Number.NaN;
    fieldMax = maxValues.length ? Math.max.apply(Math, _toConsumableArray$1(maxValues)) : Number.NaN;

    if (isNaN(fieldMin) || isNaN(fieldMax)) {
      fieldMin = -1;
      fieldMax = 1;
    } else if (fieldMin === fieldMax && fieldMin === 0) {
      fieldMin = -1;
      fieldMax = 1;
    } else if (fieldMin === fieldMax && fieldMin) {
      fieldMin -= Math.abs(fieldMin * 0.1);
      fieldMax += Math.abs(fieldMax * 0.1);
    } else if (!isNaN(settings.expand)) {
      var range = fieldMax - fieldMin;
      fieldMin -= range * settings.expand;
      fieldMax += range * settings.expand;
    }

    if (Array.isArray(settings.include)) {
      var i = settings.include.filter(function (n) {
        return !isNaN(n);
      });
      fieldMin = Math.min.apply(Math, _toConsumableArray$1(i).concat([fieldMin]));
      fieldMax = Math.max.apply(Math, _toConsumableArray$1(i).concat([fieldMax]));
    }
  }

  return {
    mini: !isNaN(min) ? min : fieldMin,
    maxi: !isNaN(max) ? max : fieldMax
  };
}

function initNormScale(normScale, scale) {
  if (normScale.instance) {
    return;
  }

  normScale.instance = scale.copy();
  normScale.instance.domain([scale.start(), scale.end()]);
  normScale.instance.clamp(true);
  normScale.instance.range(normScale.invert ? [1, 0] : [0, 1]);
}
/**
 * @alias scaleLinear
 * @private
 * @param { object } settings
 * @param { field[] } [fields]
 * @return { linear }
 */


function scaleLinear() {
  var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var resources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var d3Scale = linear$1();
  var normScale = {
    instance: null,
    invert: false
  };
  var ctx = {
    data: data,
    resources: resources
  };
  var stgns = resolveSettings$1(settings, DEFAULT_SETTINGS, ctx);
  stgns.ticks = resolveSettings$1(settings.ticks, DEFAULT_TICKS_SETTINGS, ctx);
  stgns.minorTicks = resolveSettings$1(settings.minorTicks, DEFAULT_MINORTICKS_SETTINGS, ctx);
  var tickCache;
  /**
   * @alias linear
   * @private
   * @param { Object } value
   * @return { number }
   */

  function fn(v) {
    if (notNumber(v)) {
      return NaN;
    }

    return d3Scale(v);
  }

  fn.data = function () {
    return data;
  };
  /**
   * {@link https://github.com/d3/d3-scale#continuous_invert }
   * @param { number } value The inverted value
   * @return { number } The inverted scaled value
   */


  fn.invert = function invert(value) {
    return d3Scale.invert(value);
  };
  /**
   * {@link https://github.com/d3/d3-scale#continuous_rangeRound }
   * @param { number[] } values Range values
   * @return { linear } The instance this method was called on
   */


  fn.rangeRound = function rangeRound(values) {
    d3Scale.rangeRound(values);
    return fn;
  };
  /**
   * {@link https://github.com/d3/d3-scale#continuous_clamp }
   * @param { boolean } [ value=true ] TRUE if clamping should be enabled
   * @return { linear } The instance this method was called on
   */


  fn.clamp = function clamp() {
    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    d3Scale.clamp(value);
    return fn;
  };
  /**
   * Get cached ticks (if any)
   * @return { number | undefined }
   */


  fn.cachedTicks = function fnCachedTicks() {
    return tickCache;
  };
  /**
   * Clear the tick cache
   * @return {number | undefined}
   */


  fn.clearTicksCache = function fnClearTicks() {
    tickCache = undefined;
    return this;
  };
  /**
   * {@link https://github.com/d3/d3-scale#continuous_ticks }
   * @param { Object } input Number of ticks to generate or an object passed to tick generator
   * @return { number[] | Object } Array of ticks or any type the custom tick generator returns
   */


  fn.ticks = function ticks(input) {
    if (input !== null && _typeof(input) === 'object') {
      input.settings = input.settings || {}; // TODO Discontinue support for custom ticks settings as argument

      input.settings = extend(true, {}, stgns, input.settings);
      input.scale = fn;
      tickCache = generateContinuousTicks(input);
      return tickCache;
    }

    tickCache = d3Scale.ticks(input);
    return tickCache;
  };
  /**
   * {@link https://github.com/d3/d3-scale#continuous_nice }
   * @param { number } count
   * @return { linear } The instance this method was called on
   */


  fn.nice = function nice(count) {
    d3Scale.nice(count);
    return fn;
  }; // TODO Support this?


  fn.tickFormat = function tickFormat(count, format) {
    return d3Scale.tickFormat(count, format);
  }; // TODO Support this?


  fn.interpolate = function interpolate(func) {
    d3Scale.interpolate(func);
    return fn;
  };
  /**
   * @param { number[] } [values] Set or Get domain values
   * @return { linear | Number[] } The instance this method was called on if a parameter is provided, otherwise the current domain is returned
   */


  fn.domain = function domain(values) {
    if (arguments.length) {
      d3Scale.domain(values);

      if (normScale.instance) {
        normScale.instance.domain([fn.start(), fn.end()]);
      }

      return fn;
    }

    return d3Scale.domain();
  };
  /**
   * @param { number[] } [values] Set or Get range values
   * @return { linear | number[] } The instance this method was called on if a parameter is provided, otherwise the current range is returned
   */


  fn.range = function range(values) {
    if (arguments.length) {
      d3Scale.range(values);
      return fn;
    }

    return d3Scale.range();
  };
  /**
   * Get the first value of the domain
   * @return { number }
   */


  fn.start = function start() {
    return fn.domain()[0];
  };
  /**
   * Get the last value of the domain
   * @return { number }
   */


  fn.end = function end() {
    return fn.domain()[this.domain().length - 1];
  };
  /**
   * Get the minimum value of the domain
   * @return { number }
   */


  fn.min = function min() {
    return Math.min(this.start(), this.end());
  };
  /**
   * Get the maximum value of the domain
   * @return { number }
   */


  fn.max = function max() {
    return Math.max(this.start(), this.end());
  };
  /**
   * Divides the domain and range into uniform segments, based on start and end value
   * @param  { number } segments The number of segments
   * @return { function } The instance this method was called on
   * @example
   * let s = linear();
   * s.domain([0, 10]);
   * s.range([0, 1]);
   * s.classify( 2 );
   * s.domain(); // [10, 5, 5, 0]
   * s.range(); // [0.75, 0.75, 0.25, 0.25]
   */


  fn.classify = function classify(segments) {
    var valueRange = (fn.start() - fn.end()) / segments,
        domain = [fn.end()],
        range = [],
        samplePos = valueRange / 2;

    for (var i = 0; i < segments; i++) {
      var lastVal = domain[domain.length - 1] || 0,
          calIntervalPos = lastVal + valueRange,
          calSamplePos = lastVal + samplePos,
          sampleColValue = fn(calSamplePos);
      domain.push.apply(domain, [calIntervalPos, calIntervalPos]);
      range.push.apply(range, [sampleColValue, sampleColValue]);
    }

    domain.pop();
    fn.domain(domain);
    fn.range(range);
    return fn;
  };

  fn.copy = function copy() {
    var cop = scaleLinear(settings, data, resources);
    cop.domain(fn.domain());
    cop.range(fn.range());
    cop.clamp(d3Scale.clamp());
    return cop;
  };
  /**
   * @param {number} d - A domain value
   * @return {number} A normalized range output given in range 0-1
   * @example
   * const scale = scaleLinear().domain([0, 10]).range([0, 10000]);
   * scale.norm(5); // Returns 0.5
   * scale(5); // Returns 5000
   *
   * scale.domain([0, 2, 10]);
   * scale.norm(5); // Returns 0.5
   */


  fn.norm = function norm(d) {
    initNormScale(normScale, fn);
    return normScale.instance(d);
  };
  /**
   * @param {number} d - A normalized value in range 0-1
   * @return {number} A corresponding domain value
   * @example
   * const scale = scaleLinear().domain([0, 10]).range([0, 10000]);
   * scale.normInvert(0.5); // Returns 5
   * scale.invert(5000); // Returns 5
   */


  fn.normInvert = function norm(t) {
    initNormScale(normScale, fn);
    return normScale.instance.invert(t);
  };

  var _getMinMax = getMinMax$1(stgns, data ? data.fields : []),
      mini = _getMinMax.mini,
      maxi = _getMinMax.maxi;

  fn.domain([mini, maxi]);
  fn.range(stgns.invert ? [1, 0] : [0, 1]);
  normScale.invert = stgns.invert;
  return fn;
}

var DEFAULT_SETTINGS$1 = {
  padding: 0,
  paddingInner: NaN,
  paddingOuter: NaN,
  align: 0.5,
  invert: false,
  maxPxStep: NaN,
  range: [0, 1]
};
/**
 * @typedef {object} scale--band
 * @property {string} [type='band']
 * @property {number} [padding] - {@link https://github.com/d3/d3-scale#band_padding}
 * @property {number} [paddingInner] - {@link https://github.com/d3/d3-scale#band_paddingInner}
 * @property {number} [paddingOuter] - {@link https://github.com/d3/d3-scale#band_paddingOuter}
 * @property {number} [align] - {@link https://github.com/d3/d3-scale#band_align}
 * @property {boolean} [invert=false] - Invert the output range
 * @property {number} [maxPxStep] - Explicitly limit the bandwidth to a pixel value
 * @property {function} [label] - Callback label function, applied on each datum
 * @property {function} [value] - Callback value function, applied on each datum
 * @property {array<number>|function} [range=[0, 1]] - Set range explicitly (ignored when maxPxStep takes effect)
 */

/**
 * @alias scaleBand
 * @memberof picasso
 * @private
 * @param { Object } settings
 * @param { fields[] } [fields]
 * @param { dataset } [dataset]
 * @return { band }
 */

function scaleBand() {
  var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var resources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  /**
   * An augmented {@link https://github.com/d3/d3-scale#_band|d3 band scale}
   * @alias band
   * @private
   * @kind function
   * @param { Object } value
   * @return { number }
   */
  var band$1 = band();
  var ctx = {
    data: data,
    resources: resources
  };
  var stgns = resolveSettings$1(settings, DEFAULT_SETTINGS$1, ctx);
  var items = data.items || [];
  var domainToDataMapping = {};
  var values = [];
  var labels = []; // I would like to define this outside of scaleBand but it cause the documentation to be in the wrong order

  function augmentScaleBand(band, settings) {
    // eslint-disable-line no-shadow
    band.data = function () {
      return data;
    };

    band.datum = function (domainValue) {
      return items[domainToDataMapping[domainValue]];
    };
    /**
     * Get the first value of the domain
     * @return { number }
     */


    band.start = function start() {
      return band.domain()[0];
    };
    /**
     * Get the last value of the domain
     * @return { number }
     */


    band.end = function end() {
      return band.domain()[band.domain().length - 1];
    };

    band.labels = function () {
      return labels;
    };
    /**
     * Generate discrete ticks
     * @return {Object[]} Array of ticks
     */


    band.ticks = function ticks() {
      var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      input.scale = band;
      return generateDiscreteTicks(input, settings.trackBy || 'label');
    };
  }

  augmentScaleBand(band$1, settings);
  /**
   * if required creates a new scale with a restricted range
   * so that step size is at most maxPxStep
   * otherwise it returns itself
   * @param { number } size
   * @return { band }
   */

  band$1.pxScale = function pxScale(size) {
    var max = stgns.maxPxStep;

    if (isNaN(max)) {
      return band$1;
    }

    var n = band$1.domain().length;
    var sizeRelativeToStep = Math.max(1, n - band$1.paddingInner() + 2 * band$1.paddingOuter());

    if (sizeRelativeToStep * max >= size) {
      return band$1;
    }

    var newBand = band$1.copy();
    newBand.type = band$1.type;
    augmentScaleBand(newBand, settings);
    var t = sizeRelativeToStep * max / size;
    var offset = (1 - t) * band$1.align();
    newBand.range(stgns.invert ? [t + offset, offset] : [offset, t + offset]);
    return newBand;
  };

  var valueFn = typeof settings.value === 'function' ? settings.value : function (d) {
    return d.datum.value;
  };
  var labelFn = typeof settings.label === 'function' ? settings.label : function (d) {
    return d.datum.label;
  };

  for (var i = 0; i < items.length; i++) {
    var arg = extend({
      datum: items[i]
    }, ctx);
    var v = valueFn(arg, i);

    if (values.indexOf(v) === -1) {
      values.push(v);
      labels.push(labelFn(arg, i));
      domainToDataMapping[v] = i;
    }
  }

  band$1.domain(values);
  band$1.range(stgns.invert ? stgns.range.slice().reverse() : stgns.range);
  band$1.padding(isNaN(stgns.padding) ? 0 : stgns.padding);

  if (!isNaN(stgns.paddingInner)) {
    band$1.paddingInner(stgns.paddingInner);
  }

  if (!isNaN(stgns.paddingOuter)) {
    band$1.paddingOuter(stgns.paddingOuter);
  }

  band$1.align(isNaN(stgns.align) ? 0.5 : stgns.align);
  return band$1;
}

var DEFAULT_TICKS_SETTINGS$1 = {
  depth: 0
};

function keyGen(node, valueFn, ctx) {
  return node.ancestors().map(function (a) {
    return valueFn(extend({
      datum: a.data
    }, ctx));
  }).reverse().slice(1) // Delete root node
  .toString();
}

function flattenTree(rootNode, settings, ctx) {
  var ticksDepth = settings.ticks.depth;
  var valueFn = settings.value;
  var labelFn = settings.label;
  var values = [];
  var labels = [];
  var items = {};
  var ticks = [];
  var expando = 0;

  if (!rootNode) {
    return {
      values: values,
      labels: labels,
      items: items,
      ticks: ticks
    };
  }

  rootNode.eachAfter(function (node) {
    if (node.depth > 0) {
      var key = keyGen(node, valueFn, ctx);
      var leaves = node.leaves() || [node]; // If leaf node returns itself

      var value = valueFn(extend({
        datum: node.data
      }, ctx));
      var label = labelFn(extend({
        datum: node.data
      }, ctx));
      var isBranch = Array.isArray(node.children);
      var item = {
        key: key,
        count: leaves.length,
        value: value,
        label: label,
        leftEdge: keyGen(leaves[0], valueFn, ctx),
        rightEdge: keyGen(leaves[Math.max(leaves.length - 1, 0)], valueFn, ctx),
        node: node // isTick: ticksDepth === null ? !isBranch : node.depth === ticksDepth

      };

      if (isBranch) {
        values.push("SPACER_".concat(expando, "_SPACER"));
        expando++;
      } else {
        values.push(key);
        labels.push(label);
      }

      if (ticksDepth <= 0 && !isBranch || node.depth === ticksDepth) {
        ticks.push(item);
      }

      items[key] = item;
    }
  });
  var spill = rootNode.height - 1;

  if (spill > 0) {
    values.splice(-spill);
  }

  return {
    values: values,
    labels: labels,
    items: items,
    ticks: ticks
  };
}
/**
 * @typedef {object} scale-hBand.settings
 * @private
 * @property {number} [padding=0] - Exposes {@link https://github.com/d3/d3-scale#band_padding}
 * @property {boolean} [paddingOuter=0] - Exposes {@link https://github.com/d3/d3-scale#band_paddingOuter}
 * @property {number[]} [paddingInner=0] - Exposes {@link https://github.com/d3/d3-scale#band_paddingInner}
 * @property {object} [align=0.5] - Exposes {@link https://github.com/d3/d3-scale#band_align}
 * @property {boolean} [invert=false] - Invert the output range
 */

/**
  * Hierarchical band scale, that is an augmented band scale, that takes hierarchical data as input
 * @alias scaleHierarchicalBand
 * @private
 * @param { Object } settings
 * @param { fields[] } [fields]
 * @param { dataset } [dataset] - With a root property that is an instance of D3.js Hierarchy
 * @return { h-band }
 */


function scaleHierarchicalBand() {
  var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var resources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var ctx = {
    data: data,
    resources: resources
  };
  var stgns = resolveSettings$1(settings, DEFAULT_SETTINGS$1, ctx);
  stgns.ticks = resolveSettings$1(settings.ticks, DEFAULT_TICKS_SETTINGS$1, ctx);
  stgns.value = typeof settings.value === 'function' ? settings.value : function (d) {
    return d.datum.value;
  };
  stgns.label = typeof settings.label === 'function' ? settings.label : function (d) {
    return d.datum.value;
  };
  var bandInstance = scaleBand(stgns);

  var _flattenTree = flattenTree(data.root, stgns, ctx),
      values = _flattenTree.values,
      labels = _flattenTree.labels,
      items = _flattenTree.items,
      ticks = _flattenTree.ticks;
  /**
   * @alias h-band
   * @private
   * @kind function
   * @param { Object[] } value - Array where each value is a reference to a node, going from depth 1 to n.
   * @return { number }
   */


  var hBand = function fn(val) {
    var strVal = String(val);
    var item = items[strVal];

    if (item) {
      return bandInstance(stgns.invert ? item.rightEdge : item.leftEdge);
    }

    return bandInstance(strVal);
  };

  extend(true, hBand, bandInstance);
  /**
   * Wrapped {@link https://github.com/d3/d3-scale#band_bandwidth}
   * @param { Object[] } [val] - Array where each value is a reference to a node, going from depth 1 to n. If omitted, bandwidth for the leaf nodes is return.
   * @return { number }
   */

  hBand.bandwidth = function bandwidth(val) {
    var item = items[String(val)];
    var bw = bandInstance.bandwidth();

    if (item && !item.isLeaf) {
      var left = hBand(item.leftEdge);
      var right = hBand(item.rightEdge);
      return Math.abs(left - right) + bw;
    }

    return bw;
  };
  /**
   * Wrapped {@link https://github.com/d3/d3-scale#band_step}
   * @param { Object[] } [val] - Array where each value is a reference to a node, going from depth 1 to n. If omitted, step size for the leaf nodes is return.
   * @return { number }
   */


  hBand.step = function step(val) {
    var item = items[String(val)];
    var leafCount = item ? item.count : 1;
    var stepSize = bandInstance.step();
    stepSize *= leafCount;
    return stepSize;
  };
  /**
   * @return { dataset }
   */


  hBand.data = function () {
    return data;
  };
  /**
   * Return datum for a given node
   * @param { Object[] } val - Array where each value is a reference to a node, going from depth 1 to n.
   * @return { Object } The datum
   */


  hBand.datum = function (val) {
    var item = items[String(val)];

    if (item) {
      return item.node.data;
    }

    return null;
  };

  hBand.copy = function () {
    return scaleHierarchicalBand(settings, data, resources);
  };
  /**
   * @return { Object[] } Labels for each leaf node
   */


  hBand.labels = function () {
    return labels;
  };
  /**
   * Generate discrete ticks
   * @return { Object[] } Ticks for each leaf node
   */


  hBand.ticks = function () {
    // eslint-disable-line arrow-body-style
    return ticks.map(function (item) {
      var start = hBand(item.key);
      var bandwidth = hBand.bandwidth(item.key);
      return {
        position: start + bandwidth / 2,
        label: item.label,
        data: item.node.data,
        start: start,
        end: start + bandwidth
      };
    });
  };

  var orgPxScale = bandInstance.pxScale;

  hBand.pxScale = function pxScale(size) {
    bandInstance = orgPxScale(size);
    return hBand;
  };

  hBand.domain(values);
  return hBand;
}

var minAccessor = function minAccessor(v) {
  return v.min();
};

var maxAccessor = function maxAccessor(v) {
  return v.max();
};
/**
 * Calculate the min/max value based on various inputs.
 *
 * Provided min/max setting takes presedence over all other inputs. If not provided, the respective values are calculated
 * from the given arr input, where each item in the array is expected to have a min/max accessor.
 *
 * @private
 * @param {object} [settings]
 * @param {number} [settings.min] The minimum value. Defaults to 0 if not provided.
 * @param {number} [settings.max] The maximum value. Defaults to 1 if not provided.
 * @param {object} [arr]
 * @returns { object[] } An array containing the min and max values.
 *
 * @example
 * minmax(); // [0, 1]
 *
 * minmax({}, [
 * { min: () => 13, max: () => 15 },
 * { min: () => NaN, max: () => 17 },
 * ]); // [13, 17]
 *
 * minmax({ min: -5, max: 4 }, [
 * { min: () => -20, max: () => 15 },
 * ]); // [-5, 4]
 */


function minmax(settings, arr) {
  // const definedMin = settings && typeof settings.min !== 'undefined';
  // const definedMax = settings && typeof settings.max !== 'undefined';
  var definedMin = settings && !isNaN(settings.min);
  var definedMax = settings && !isNaN(settings.max);
  var min = definedMin ? +settings.min : 0;
  var max = definedMax ? +settings.max : 1;

  if (arr && arr.length) {
    if (!definedMin) {
      var arrMin = arr.map(minAccessor).filter(isNumber);
      min = arrMin.length ? Math.min.apply(Math, _toConsumableArray$1(arrMin)) : min;
    }

    if (!definedMax) {
      var arrMax = arr.map(maxAccessor).filter(isNumber);
      max = arrMax.length ? Math.max.apply(Math, _toConsumableArray$1(arrMax)) : max;
    }
  }

  return [min, max];
}

var DEFAULT_SETTINGS$2 = {
  domain: [],
  range: [],
  invert: false,
  min: NaN,
  max: NaN
};

function generateDomain(range, min, max) {
  var len = range.length;

  if (len === 2) {
    return [min, max];
  }

  var domain = [];
  var part = (max - min) / (len - 1);
  domain.push(min);

  for (var i = 1; i < len - 1; i++) {
    domain.push(min + part * i);
  }

  domain.push(max);
  return domain;
}
/**
 * @typedef {object} scale--sequential-color
 * @property {string} [type='sequential-color']
 * @property {string[]} [range] - CSS color values of the output range
 * @property {boolean} [invert=false] - Invert range
 * @property {number} [min] - Set an explicit minimum value
 * @property {number} [max] - Set an explicit maximum value
 */

/**
 * @alias scaleSequentialColor
 * @private
 * @param { Object } [settings] Settings for this scale. If both range and domain are specified, they have to fulfill range.length === domain.length, otherwise they will be overriden.
 * @param { number[] } [settings.domain] Numeric values indicating stop limits between start and end values.
 * @param { color[] } [settings.range] CSS color values indicating stop colors between start and end values.
 * @param { field[] } [fields] Fields to dynamically calculate the domain extent.
 * @return { sequentialColor }
 *
 * @example
 * picasso.scaleSequentialColor({
 *  range: ['red', '#fc6', 'green'],
 *  domain: [-40, 0, 100]
 * });
 */


function scaleSequentialColor() {
  var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var resources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var s = scaleLinear(settings, data, resources).clamp(true).interpolate(interpolateRgb);
  var stgns = resolveSettings$1(settings, DEFAULT_SETTINGS$2, {
    data: data,
    resources: resources
  });
  var isDomain = Array.isArray(stgns.domain) && stgns.domain.length;
  var isRange = Array.isArray(stgns.range) && stgns.range.length;
  /**
   * @alias sequentialColor
   * @private
   * @kind function
   * @param { Object } v Object containing a 'value' property
   * @return { string } The blended color
   */

  var fn = s;
  extend(true, fn, s);

  var _minmax = minmax(stgns, data ? data.fields : []),
      _minmax2 = _slicedToArray(_minmax, 2),
      min = _minmax2[0],
      max = _minmax2[1];

  var num = isDomain ? stgns.domain.length : -1;
  var DEFAULT_COLORS = resources.theme ? resources.theme.palette('sequential', num > 0 ? num : 2) : [];
  var range = isRange ? stgns.range : DEFAULT_COLORS;
  fn.range(stgns.invert ? range.slice().reverse() : range.slice());
  fn.domain(isDomain ? stgns.domain : generateDomain(fn.range(), min, max));
  return fn;
}

var DEFAULT_SETTINGS$3 = {
  domain: [],
  range: [],
  invert: false,
  min: NaN,
  max: NaN,
  nice: false
};

function generateDomain$1(range, min, max) {
  var len = range.length;

  if (len === 2) {
    return [min + (max - min) / 2];
  }

  var domain = [];
  var part = (max - min) / len;

  for (var i = 1; i < len; i++) {
    domain.push(min + part * i);
  }

  return domain;
}

function getBreaks(domain) {
  var ret = [];

  for (var i = 0; i < domain.length - 1; i++) {
    ret.push((domain[i] + domain[i + 1]) / 2);
  }

  return ret;
}

function generateRange(domain, colors, min, max) {
  min = domain[0];
  max = domain && domain.length >= 2 ? domain[domain.length - 1] : max;
  var seq = scaleSequentialColor().domain([min, max]).range(colors);
  var values = [min].concat(_toConsumableArray$1(getBreaks(domain)), [max]);
  return values.map(function (v) {
    return seq(v);
  });
}

function generateNiceDomain(range, min, max) {
  var numPoints = range.length === 2 ? 10 : Math.max(1, range.length);
  var lin = linear$1().domain([min, max]).nice(numPoints);
  var domain = lin.ticks(numPoints);

  if (!range || !range.length) {
    return domain;
  } // remove values from endpoints


  var num = Math.max(0, range.length - 1);

  while (domain.length > num) {
    if (domain[0] - min <= max - domain[domain.length - 1]) {
      domain.shift();
    } else {
      domain.pop();
    }
  }

  return domain;
}
/**
 * @typedef {object} scale--threshold-color
 * @property {string} [type='threshold-color']
 * @property {number[]} [domain] Values defining the thresholds
 * @property {string[]} [range] - CSS color values of the output range
 * @property {boolean} [invert=false] - Invert range
 * @property {number} [min] - Set an explicit minimum value
 * @property {number} [max] - Set an explicit maximum value
 * @property {boolean} [nice=false] If set to true, will generate 'nice' domain values. Ignored if domain is set.
 */

/**
 * @alias scaleThresholdColor
 * @private
 * @param { object } [settings] Settings for this scale. If both domain and range are specified, they have to fulfill domain.length === range.length + 1,  otherwise they will be overriden.
 * @param { number[] } [settings.domain] Values defining the thresholds.
 * @param { color[] } [settings.range] CSS color values of the output range.
 * @param { boolean } [settings.nice=false] If set to true, will generate 'nice' domain values. Ignored if domain is set.
 * @param { number } [settings.min] Minimum value to generate domain extent from. Ignored if domain is set.
 * @param { number } [settings.max] Maximum value to generate domain extend from. Ignored if domain is set.
 * @param { field[] } [fields] Fields to dynamically calculate the domain extent from. Ignored if min/max are set.
 * @return { thresholdColor }
 *
 * @example
 * let t = threshold({
 *   range: ['black', 'white'],
 *   domain: [25,50,75],
 *   max: 100,
 *   min: 0
 * });
 * t.domain(); // [25,50,75]
 * t.range(); // Generates from colors and domain: ['rgb(0,0,0)','rgb(85,85,85)','rgb(170,170,170)','rgb(255,255,255)']
 */


function scaleThresholdColor() {
  var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var resources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var d3Scale = threshold();
  var stgns = resolveSettings$1(settings, DEFAULT_SETTINGS$3, {
    data: data,
    resources: resources
  });
  var isDomain = Array.isArray(stgns.domain) && stgns.domain.length;
  var isRange = Array.isArray(stgns.range) && stgns.range.length;
  /**
   * @alias thresholdColor
   * @private
   * @param { object } v Object literal containing a 'value' property.
   * @return { string } A CSS color from the scale's range.
   */

  function fn(v) {
    if (notNumber(v)) {
      return NaN;
    }

    return d3Scale(v);
  }

  Object.keys(d3Scale).forEach(function (key) {
    return fn[key] = d3Scale[key];
  });
  var fields = data.fields;

  var _minmax = minmax(stgns, fields),
      _minmax2 = _slicedToArray(_minmax, 2),
      min = _minmax2[0],
      max = _minmax2[1];

  var num = isDomain ? stgns.domain.length : -1;
  var DEFAULT_COLORS = resources.theme ? resources.theme.palette('sequential', num > 0 ? num : 2) : [];
  var range = isRange ? stgns.range : DEFAULT_COLORS;
  var domain = [];

  if (isDomain) {
    domain = stgns.domain;
  } else if (stgns.nice) {
    domain = generateNiceDomain(range, min, max);
  } else {
    domain = [min + (max - min) / 2];
  }

  if (range.length > domain.length + 1) {
    // Generate limits from range
    domain = generateDomain$1(range, min, max);
  } else if (range.length < domain.length + 1) {
    // Generate additional colors
    range = generateRange(domain, range, min, max);
  }

  fn.data = function () {
    return data;
  };

  fn.range(stgns.invert ? range.slice().reverse() : range);
  fn.domain(domain);
  return fn;
}

var DEFAULT_SETTINGS$4 = {
  domain: [],
  range: []
};
/**
 * @alias scaleOrdinal
 * @private
 * @param { Object } settings
 * @param { field[] } [fields]
 * @param { dataset } data
 * @return { ordinal }
 */

function ordinal$1() {
  var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var resources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  /**
   * An augmented {@link https://github.com/d3/d3-scale#_ordinal|d3 ordinal scale}
   * @private
   * @alias ordinal
   * @param { Object }
   * @return { number }
   */
  var fn = ordinal();
  var ctx = {
    data: data,
    resources: resources
  };
  var stgns = resolveSettings$1(settings, DEFAULT_SETTINGS$4, ctx);
  var valueFn = typeof settings.value === 'function' ? settings.value : function (d) {
    return d.datum.value;
  };
  var labelFn = typeof settings.label === 'function' ? settings.label : function (d) {
    return d.datum.label;
  };
  var items = data.items || [];
  var domainToDataMapping = {};
  var values = [];
  var labels = [];

  for (var i = 0; i < items.length; i++) {
    var arg = extend({
      datum: items[i]
    }, ctx);
    var v = valueFn(arg, i);

    if (values.indexOf(v) === -1) {
      values.push(v);
      labels.push(labelFn(arg, i));
      domainToDataMapping[v] = i;
    }
  }

  fn.data = function () {
    return data;
  };

  fn.labels = function () {
    return labels;
  };

  fn.label = function (domainValue) {
    return labels[values.indexOf(domainValue)];
  };

  fn.datum = function (domainValue) {
    return items[domainToDataMapping[domainValue]];
  };

  fn.range(stgns.range);

  if (Array.isArray(stgns.domain) && stgns.domain.length) {
    fn.domain(stgns.domain);
  } else {
    fn.domain(values);
  }

  return fn;
}

var DEFAULT_SETTINGS$5 = {
  domain: [],
  range: [],
  unknown: undefined
};
var DEFAULT_EXPLICIT_SETTINGS = {
  domain: [],
  range: [],
  override: false
};
/**
 * @typedef {object} scale--categorical-color
 * @property {string} [type='categorical-color']
 * @property {string[]} [range=false] - CSS color values of the output range
 * @property {string} [unknown] - {@link https://github.com/d3/d3-scale#ordinal_unknown}
 * @property {object} [explicit] - Explicitly bind values to an output
 * @property {object[]} [explicit.domain[]] - Values to bind
 * @property {string[]} [explicit.range[]] - Output range
 */

/**
 * An ordinal scale with the output range set to default colors, as defined by *scaleCategorical.range*
 * @alias scaleCategorical
 * @private
 * @param { Object } settings
 * @param { field[] } [fields]
 * @param { dataset } [dataset]
 * @return { ordinal }
 */

function scaleCategorical() {
  var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var resources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var s = ordinal$1(settings, data, resources);
  var theme = resources.theme;
  var stgns = resolveSettings$1(settings, DEFAULT_SETTINGS$5, {
    data: data,
    resources: resources
  });
  stgns.explicit = resolveSettings$1(settings.explicit, DEFAULT_EXPLICIT_SETTINGS, {
    data: data,
    resources: resources
  });
  var range;

  if (!Array.isArray(stgns.range) || stgns.range.length === 0) {
    range = theme ? theme.palette('categorical', s.domain().length).slice() : [];
  } else {
    range = stgns.range.slice();
  }

  if (stgns.unknown) {
    s.unknown(stgns.unknown);
  } else if (theme && theme.palette('unknown')) {
    var un = theme.palette('unknown');
    s.unknown(un[0]);
  }

  if (Array.isArray(stgns.explicit.domain) && stgns.explicit.domain.length) {
    var domain = s.domain().slice();
    var explicitDomain = stgns.explicit.domain;
    var explicitRange = Array.isArray(stgns.explicit.range) ? stgns.explicit.range : []; // duplicate range values to cover entire domain

    var numCopies = Math.floor(domain.length / range.length);

    for (var i = 1; i < numCopies + 1; i *= 2) {
      range = range.concat(range);
    }

    if (stgns.explicit.override) {
      for (var _i = 0; _i < explicitDomain.length; _i++) {
        var index = domain.indexOf(explicitDomain[_i]);

        if (index > -1) {
          range[index] = explicitRange[_i];
        }
      }
    } else {
      // inject explicit colors
      var order = explicitDomain.map(function (d, i) {
        return [domain.indexOf(d), d, explicitRange[i]];
      }).sort(function (a, b) {
        return a[0] - b[0];
      });
      order.forEach(function (v) {
        var idx = domain.indexOf(v[1]);

        if (idx !== -1) {
          range.splice(idx, 0, v[2]);
        }
      });
    } // cutoff excess range values


    range.length = domain.length;
  }

  s.range(range);
  return s;
}

var scaleRegistry = registryFactory();
scaleRegistry('linear', scaleLinear);
scaleRegistry('band', scaleBand);
scaleRegistry('h-band', scaleHierarchicalBand);
scaleRegistry('sequential-color', scaleSequentialColor);
scaleRegistry('threshold-color', scaleThresholdColor);
scaleRegistry('categorical-color', scaleCategorical);

function getTypeFromMeta(fields) {
  var types = fields.map(function (field) {
    return field.type() === 'dimension' ? 'band' : 'linear';
  });
  return types.indexOf('linear') !== -1 ? 'linear' : 'band';
}

function deduceScaleTypeFromData(data) {
  if (data.root) {
    return 'h-band';
  }

  if (data.fields && data.fields[0]) {
    return getTypeFromMeta(data.fields);
  }

  return 'linear';
}

function create$2(options, d, deps) {
  var dataSourceConfig = options.data;

  if (options.source) {
    // DEPRECATION
    deps.logger.warn('Deprecated: Scale data source configuration');
    dataSourceConfig = {
      extract: []
    };
    (Array.isArray(options.source) ? options.source : [options.source]).forEach(function (source) {
      dataSourceConfig.extract.push({
        field: source
      });
    });
  }

  var data = extract(dataSourceConfig, d, deps);
  var type = options.type || deduceScaleTypeFromData(data);
  var s;

  if (type === 'color') {
    if (data.fields && data.fields[0] && data.fields[0].type() === 'dimension') {
      type = 'categorical-color';
    } else {
      type = 'sequential-color';
    }
  }

  if (deps.scale.has(type)) {
    s = deps.scale.get(type);
    s = s(options, data, {
      theme: deps.theme,
      logger: deps.logger
    });
    s.type = type;
  }

  return s;
}
function collection$1(scalesConfig, data, deps) {
  var fn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : create$2;
  var scales = {};
  return {
    get: function get(def) {
      var key;

      if (typeof def === 'string' && scalesConfig[def]) {
        key = def;
      } else if (_typeof(def) === 'object' && 'scale' in def && scalesConfig[def.scale]) {
        key = def.scale;
      }

      if (key) {
        scales[key] = scales[key] || fn(scalesConfig[key], data, deps);
        return scales[key];
      }

      return fn(def, data, deps);
    },
    all: function all() {
      Object.keys(scalesConfig).forEach(this.get);
      return scales;
    }
  };
}

/**
 * Utility functions
 */

var util = {};

util.isObject = function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
};

util.isNumber = function isNumber(arg) {
  return typeof arg === 'number';
};

util.isUndefined = function isUndefined(arg) {
  return arg === void 0;
};

util.isFunction = function isFunction(arg){
  return typeof arg === 'function';
};


/**
 * EventEmitter class
 */

function EventEmitter() {
  EventEmitter.init.call(this);
}
var nodeEventEmitter = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

EventEmitter.init = function() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!util.isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error' && !this._events.error) {
    er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      throw Error('Uncaught, unspecified "error" event.');
    }
    return false;
  }

  handler = this._events[type];

  if (util.isUndefined(handler))
    return false;

  if (util.isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (util.isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!util.isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              util.isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (util.isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (util.isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!util.isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;

      if (util.isFunction(console.error)) {
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      this._events[type].length);
      }
      if (util.isFunction(console.trace))
        console.trace();
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!util.isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!util.isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (util.isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (util.isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (util.isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (Array.isArray(listeners)) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (util.isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (util.isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

var EventEmitter$1 = {
  /**
   * Function used to add event handling to objects passed in.
   * @private
   * @param {Object} obj Object instance that will get event handling.
   */
  mixin: function mixin(obj) {
    Object.keys(nodeEventEmitter.prototype).forEach(function (key) {
      obj[key] = nodeEventEmitter.prototype[key];
    });
    nodeEventEmitter.init(obj);
    return obj;
  }
};

function scrollApi() {
  var min = 0;
  var max = 0;
  var start = 0;
  var viewSize = 0;
  start = start || min;
  /**
   * The scroll api
   * @private
   * @alias scroll
   */

  var s = {
    /**
     * Move the current scroll
     * @param {number} value
     * @emits update
     */
    move: function move(value) {
      this.moveTo(start + value);
    },

    /**
     * Change the current scroll to a specific value
     * @param {number} value
     * @emits update
     */
    moveTo: function moveTo(value) {
      var newStart = Math.max(min, Math.min(max - viewSize, value));

      if (start !== newStart) {
        start = newStart;
        s.emit('update');
      }
    },

    /**
     * Update scroll settings
     * @param {number} [settings.min]
     * @param {number} [settings.max]
     * @param {number} [settings.viewSize]
     * @emits update
     */
    update: function update(settings) {
      var triggerUpdate = false;
      var _settings$min = settings.min;
      min = _settings$min === void 0 ? min : _settings$min;
      var _settings$max = settings.max;
      max = _settings$max === void 0 ? max : _settings$max;

      if (settings.viewSize !== undefined && settings.viewSize !== viewSize) {
        viewSize = settings.viewSize;
        triggerUpdate = true;
      } // update scroll to be within the new bounds


      var newStart = Math.max(min, Math.min(max - viewSize, start));

      if (start !== newStart) {
        start = newStart;
        triggerUpdate = true;
      }

      if (triggerUpdate) {
        s.emit('update');
      }
    },

    /**
     * Get the current scroll state
     * @return {object} with min, max, start & viewSize
     */
    getState: function getState() {
      return {
        min: min,
        max: max,
        start: start,
        viewSize: viewSize
      };
    }
  };
  EventEmitter$1.mixin(s);
  return s;
}

function createOrUpdate(options, oldApi) {
  var min = options.min || 0;
  var max = options.max || 0;
  var viewSize = options.viewSize || 0;
  var s = oldApi || scrollApi();
  s.update({
    min: min,
    max: max,
    viewSize: viewSize
  });
  return s;
}
function builder(obj, oldScrollApis) {
  var scrollApis = {};

  for (var n in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, n)) {
      scrollApis[n] = createOrUpdate(obj[n], oldScrollApis ? oldScrollApis[n] : null);
    }
  }

  return scrollApis;
}
function getOrCreateScrollApi(v, scrollApis) {
  if (!scrollApis[v]) {
    scrollApis[v] = scrollApi();
  }

  return scrollApis[v];
}

function lessThanOrEqual(value, limit) {
  return value <= limit;
}

function lessThan(value, limit) {
  return value < limit;
}

function index(boundaries, point, after) {
  var i = 0;

  while (i < boundaries.length && point > boundaries[i]) {
    ++i;
  }

  if (boundaries[i] === point && after) {
    ++i;
  }

  return i;
}

function contains(boundaries, point, minCondition, maxCondition) {
  var len = boundaries.length;

  for (var i = 1; i < len; i += 2) {
    if (minCondition(boundaries[i - 1], point) && maxCondition(point, boundaries[i])) {
      return true;
    }
  }

  return false;
}

function rangeCollection() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var maxCondition;
  var minCondition;
  var boundaries = [];

  function fn() {}

  fn.configure = function () {
    var c = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var _c$includeMax = c.includeMax,
        includeMax = _c$includeMax === void 0 ? true : _c$includeMax,
        _c$includeMin = c.includeMin,
        includeMin = _c$includeMin === void 0 ? true : _c$includeMin;
    maxCondition = includeMax ? lessThanOrEqual : lessThan;
    minCondition = includeMin ? lessThanOrEqual : lessThan;
  };

  fn.add = function (_ref) {
    var _boundaries;

    var min = _ref.min,
        max = _ref.max;
    var i0 = index(boundaries, min);
    var i1 = index(boundaries, max, true);
    var args = [i0, i1 - i0];

    if (i0 % 2 === 0) {
      args.push(min);
    }

    if (i1 % 2 === 0) {
      args.push(max);
    }

    var before = boundaries.join(',');

    (_boundaries = boundaries).splice.apply(_boundaries, args);

    var after = boundaries.join(',');
    return before !== after;
  };

  fn.remove = function (_ref2) {
    var _boundaries2;

    var min = _ref2.min,
        max = _ref2.max;
    var i0 = index(boundaries, min);
    var i1 = index(boundaries, max, true);
    var args = [i0, i1 - i0];

    if (i0 % 2 === 1) {
      args.push(min);
    }

    if (i1 % 2 === 1) {
      args.push(max);
    }

    var before = boundaries.join(',');

    (_boundaries2 = boundaries).splice.apply(_boundaries2, args);

    var after = boundaries.join(',');
    return before !== after;
  };

  fn.set = function (range) {
    var before = boundaries.join(',');
    boundaries = [];

    if (Array.isArray(range)) {
      range.forEach(fn.add);
    } else {
      fn.add(range);
    }

    var after = boundaries.join(',');
    return before !== after;
  };

  fn.clear = function () {
    var before = boundaries.length > 0;
    boundaries = [];
    return before;
  };

  fn.containsValue = function (value) {
    return contains(boundaries, value, minCondition, maxCondition);
  };

  fn.containsRange = function (_ref3) {
    var min = _ref3.min,
        max = _ref3.max;
    var i0 = index(boundaries, min, true);
    var i1 = index(boundaries, max);
    return i0 === i1 && i1 % 2 === 1;
  };

  fn.toggle = function (range) {
    if (fn.containsRange(range)) {
      return fn.remove(range);
    }

    return fn.add(range);
  };

  fn.ranges = function () {
    var collection = [];

    for (var i = 1; i < boundaries.length; i += 2) {
      collection.push({
        min: boundaries[i - 1],
        max: boundaries[i]
      });
    }

    return collection;
  };

  fn.configure(config);
  return fn;
}

function valueCollection() {
  var values = [];

  function vc() {}

  vc.add = function (value) {
    if (values.indexOf(value) === -1) {
      values.push(value);
      return true;
    }

    return false;
  };

  vc.remove = function (value) {
    var idx = values.indexOf(value);

    if (idx !== -1) {
      values.splice(idx, 1);
      return true;
    }

    return false;
  };

  vc.contains = function (value) {
    return values.indexOf(value) !== -1;
  };

  vc.values = function () {
    return values.slice();
  };

  vc.clear = function () {
    return values = [];
  };

  vc.toString = function () {
    return values.join(';');
  };

  return vc;
}

/**
 * @typedef {object} brush-config
 * @property {Array<brush-config--ranges>} [ranges] - Range configurations
 */

/**
 * @typedef {object}
 * @alias brush-config--ranges
 */

var DEFAULT_RANGE_CONFIG = {
  /**
   * An identifier that represents the data source of the value
   * @type {string=}
   */
  key: undefined,

  /**
   * Whether or not the minimum value of a range should be included when determening if a value is brushed.
   * @type {boolean=} */
  includeMin: true,

  /**
   * Whether or not the maximum value of a range should be included when determening if a value is brushed.
   * @type {boolean=} */
  includeMax: true
};

function add(_ref) {
  var items = _ref.items,
      collection = _ref.collection,
      vc = _ref.vc;
  var changedMap = {};
  var changed = [];
  var key;
  var values;

  for (var i = 0, num = items.length; i < num; i++) {
    key = items[i].key;

    if (!collection[key]) {
      collection[key] = vc();
    }

    values = items[i].values || [items[i].value];

    for (var vi = 0; vi < values.length; vi++) {
      if (collection[key].add(values[vi])) {
        changedMap[key] = changedMap[key] || [];
        changedMap[key].push(values[vi]);
      }
    }
  }

  var keys = Object.keys(changedMap);

  for (var _i = 0, _num = keys.length; _i < _num; _i++) {
    key = keys[_i];
    changed.push({
      id: key,
      values: changedMap[key]
    });
  }

  return changed;
}

function remove(_ref2) {
  var items = _ref2.items,
      collection = _ref2.collection;
  var changedMap = {};
  var changed = [];
  var key;
  var values;

  for (var i = 0, num = items.length; i < num; i++) {
    key = items[i].key;

    if (!collection[key]) {
      continue;
    }

    values = items[i].values || [items[i].value];

    for (var vi = 0; vi < values.length; vi++) {
      if (collection[key].remove(values[vi])) {
        changedMap[key] = changedMap[key] || [];
        changedMap[key].push(values[vi]);
      }
    }
  }

  var keys = Object.keys(changedMap);

  for (var _i2 = 0, _num2 = keys.length; _i2 < _num2; _i2++) {
    key = keys[_i2];
    changed.push({
      id: key,
      values: changedMap[key]
    });
  }

  return changed;
}

function collectUnique(items) {
  var filteredSet = {};
  var key;
  var values;

  for (var i = 0, num = items.length; i < num; i++) {
    key = items[i].key;
    values = items[i].values || [items[i].value];

    if (!filteredSet[key]) {
      filteredSet[key] = [];
    }

    for (var vi = 0; vi < values.length; vi++) {
      var idx = filteredSet[key].indexOf(values[vi]);

      if (idx === -1) {
        filteredSet[key].push(values[vi]);
      }
    }
  }

  return filteredSet;
}

function createValueCollection(_ref3) {
  var key = _ref3.key,
      collection = _ref3.collection,
      obj = _ref3.obj,
      fn = _ref3.fn,
      value = _ref3.value;

  if (!collection[key]) {
    collection[key] = fn();
  }

  obj[key] = obj[key] || [];
  obj[key].push(value);
  collection[key].add(value);
}

function toggle(_ref4) {
  var items = _ref4.items,
      values = _ref4.values,
      vc = _ref4.vc;
  var addedMap = {};
  var removedMap = {};
  var added = [];
  var removed = [];
  var filteredSet = collectUnique(items);
  var key;
  var value;
  var fs;
  var setKeys = Object.keys(filteredSet);

  for (var i = 0, num = setKeys.length; i < num; i++) {
    key = setKeys[i];
    fs = filteredSet[key];

    for (var k = 0, len = fs.length; k < len; k++) {
      value = fs[k];

      if (!values[key] || !values[key].contains(value)) {
        createValueCollection({
          key: key,
          value: value,
          collection: values,
          obj: addedMap,
          fn: vc
        });
      } else if (values[key] && values[key].contains(value)) {
        removedMap[key] = removedMap[key] || [];
        removedMap[key].push(value);
        values[key].remove(value);
      }
    }
  }

  var addedKeys = Object.keys(addedMap);

  for (var _i3 = 0, _num3 = addedKeys.length; _i3 < _num3; _i3++) {
    key = addedKeys[_i3];
    added.push({
      id: key,
      values: addedMap[key]
    });
  }

  var removedKeys = Object.keys(removedMap);

  for (var _i4 = 0, _num4 = removedKeys.length; _i4 < _num4; _i4++) {
    key = removedKeys[_i4];
    removed.push({
      id: key,
      values: removedMap[key]
    });
  }

  return [added, removed];
}

function diff(old, current) {
  var changed = [];
  var keys = Object.keys(old);
  var key;
  var changedValues;

  var filterFn = function filterFn(v) {
    return current[key].indexOf(v) === -1;
  };

  for (var i = 0, num = keys.length; i < num; i++) {
    key = keys[i];

    if (!current[key]) {
      changed.push({
        id: key,
        values: old[key]
      });
    } else {
      changedValues = old[key].filter(filterFn);

      if (changedValues.length) {
        changed.push({
          id: key,
          values: changedValues
        });
      }
    }
  }

  return changed;
}

function set$1(_ref5) {
  var items = _ref5.items,
      vCollection = _ref5.vCollection,
      vc = _ref5.vc;
  var addedMap = {};
  var filteredSet = collectUnique(items);
  var added = [];
  var removed = [];
  var key;
  var oldMap = {};
  var vcKeys = Object.keys(vCollection);

  for (var i = 0, num = vcKeys.length; i < num; i++) {
    key = vcKeys[i];
    oldMap[key] = vCollection[key].values().slice();
    delete vCollection[key];
  }

  var createValueCollectionFn = function createValueCollectionFn(value) {
    if (!vCollection[key] || !vCollection[key].contains(value)) {
      createValueCollection({
        key: key,
        value: value,
        collection: vCollection,
        obj: addedMap,
        fn: vc
      });
    }
  };

  var fsKeys = Object.keys(filteredSet);

  for (var _i5 = 0, _num5 = fsKeys.length; _i5 < _num5; _i5++) {
    key = fsKeys[_i5];
    filteredSet[key].forEach(createValueCollectionFn);
  }

  removed = diff(oldMap, addedMap);
  added = diff(addedMap, oldMap);
  return [added, removed];
}

function applyAliases(items, aliases) {
  if (!Object.keys(aliases).length) {
    return items;
  }

  var len = items.length;
  var its = Array(len);

  for (var i = 0; i < len; i++) {
    its[i] = items[i].key in aliases ? extend({}, items[i], {
      key: aliases[items[i].key]
    }) : items[i];
  }

  return its;
}

function intercept(handlers, items, aliases) {
  var its = applyAliases(items, aliases);
  return handlers && handlers.length ? handlers.reduce(function (value, interceptor) {
    return interceptor(value);
  }, its) : its;
}

function toCamelCase(s) {
  return s.replace(/(-[a-z])/g, function ($1) {
    return $1.toUpperCase().replace('-', '');
  });
}

function toSnakeCase(s) {
  return s.replace(/([A-Z])/g, function ($1) {
    return "-".concat($1.toLowerCase());
  });
}

function updateRange(items, action, _ref6) {
  var ranges = _ref6.ranges,
      interceptors = _ref6.interceptors,
      rc = _ref6.rc,
      aliases = _ref6.aliases,
      rangeConfig = _ref6.rangeConfig;
  var inter = "".concat(action, "Ranges");
  var its = intercept(interceptors[inter], items, aliases);
  var changed = false;
  its.forEach(function (item) {
    var key = item.key;

    if (!ranges[key]) {
      ranges[key] = rc(rangeConfig.sources[key] || rangeConfig.default);
    }

    if (action === 'set') {
      changed = ranges[key][action](item.ranges || item.range) || changed;
    } else {
      var rangeValues = item.ranges || [item.range];

      for (var i = 0; i < rangeValues.length; i++) {
        changed = ranges[key][action](rangeValues[i]) || changed;
      }
    }
  });
  return changed;
}

function brush() {
  var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref7$vc = _ref7.vc,
      vc = _ref7$vc === void 0 ? valueCollection : _ref7$vc,
      _ref7$rc = _ref7.rc,
      rc = _ref7$rc === void 0 ? rangeCollection : _ref7$rc;

  var activated = false;
  var ranges = {};
  var values = {};
  var aliases = {};
  var rangeConfig = {
    sources: {},
    default: extend({}, DEFAULT_RANGE_CONFIG)
  };
  var interceptors = {
    addValues: [],
    removeValues: [],
    toggleValues: [],
    setValues: [],
    addRanges: [],
    setRanges: [],
    removeRanges: [],
    toggleRanges: []
  };

  var getState = function getState() {
    var state = {
      values: {},
      ranges: {}
    };
    Object.keys(values).forEach(function (key) {
      state.values[key] = values[key].values();
    });
    Object.keys(ranges).forEach(function (key) {
      state.ranges[key] = ranges[key].ranges();
    });
    return state;
  };

  var links = {
    ls: [],
    clear: function clear() {
      this.ls.forEach(function (b) {
        return b.clear();
      });
    },
    start: function start() {
      this.ls.forEach(function (b) {
        return b.start();
      });
    },
    end: function end() {
      this.ls.forEach(function (b) {
        return b.end();
      });
    },
    update: function update() {
      var s = getState();
      this.ls.forEach(function (b) {
        return b._state(s);
      });
    },
    updateValues: function updateValues() {
      var s = getState();
      this.ls.forEach(function (b) {
        return b._state({
          values: s.values
        });
      });
    },
    updateRanges: function updateRanges() {
      var s = getState();
      this.ls.forEach(function (b) {
        return b._state({
          ranges: s.ranges
        });
      });
    }
  };
  /**
   * A brush context
   * @alias brush
   * @interface
   */

  var fn = {};
  /**
   * Triggered when this brush is activated
   * @event brush#start
   * @type {string}
   */

  /**
   * Triggered when this brush is updated
   * @event brush#update
   * @type {string}
   * @param {Array<object>} added - The added items
   * @param {Array<object>} removed - The removed items
   */

  /**
   * Triggered when this brush is deactivated
   * @event brush#end
   * @type {string}
   */

  /**
    * Configure the brush instance.
    *
    * @param {brush-config} config
    * @example
    * brushInstance.configure({
    *   ranges: [
    *     { key: 'some key', includeMax: false },
    *     { includeMax: true, includeMin: true },
    *   ]
    * })
    */

  fn.configure = function () {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (Array.isArray(config.ranges) && config.ranges.length) {
      rangeConfig = {
        sources: {},
        default: extend({}, DEFAULT_RANGE_CONFIG)
      };
      config.ranges.forEach(function (cfg) {
        var c = {};
        Object.keys(DEFAULT_RANGE_CONFIG).filter(function (attr) {
          return attr !== 'key';
        }).forEach(function (attr) {
          c[attr] = typeof cfg[attr] !== 'undefined' ? cfg[attr] : DEFAULT_RANGE_CONFIG[attr];
        });

        if (typeof cfg.key !== 'undefined') {
          rangeConfig.sources[cfg.key] = c;
        } else {
          rangeConfig.default = c;
        }
      });
      Object.keys(ranges).forEach(function (key) {
        return ranges[key].configure(rangeConfig.sources[key] || rangeConfig.default);
      }); // TODO only emit update if config has changed

      fn.emit('update', [], []);
    }
  };
  /**
   * Link this brush to another brush instance.
   *
   * When linked, the `target` will receive updates whenever this brush changes.
   * @param {brush} target - The brush instance to link to
   */


  fn.link = function (target) {
    if (fn === target) {
      throw new Error('Can\'t link to self');
    }

    links.ls.push(target);

    target._state(getState());
  };

  fn._state = function (s) {
    if (!s) {
      return getState();
    }

    if (s.values) {
      var arr = [];
      Object.keys(s.values).forEach(function (key) {
        if (!values[key] || s.values[key].join(';') !== values[key].toString()) {
          arr.push({
            key: key,
            values: s.values[key]
          });
        }
      });
      Object.keys(values).forEach(function (key) {
        if (!s.values[key]) {
          arr.push({
            key: key,
            values: []
          });
        }
      });

      if (arr.length) {
        fn.setValues(arr);
      }
    }

    if (s.ranges) {
      var _arr = [];
      Object.keys(s.ranges).forEach(function (key) {
        if (!ranges[key] || s.ranges[key].join(';') !== ranges[key].toString()) {
          _arr.push({
            key: key,
            ranges: s.ranges[key]
          });
        }
      });
      Object.keys(ranges).forEach(function (key) {
        if (!s.ranges[key]) {
          _arr.push({
            key: key,
            ranges: []
          });
        }
      });

      if (_arr.length) {
        fn.setRanges(_arr);
      }
    }

    return undefined;
  };
  /**
   * Starts this brush context
   *
   * Starts this brush context and emits a 'start' event if it is not already started.
   * @emits brush#start
   */


  fn.start = function () {
    if (!activated) {
      activated = true;
      fn.emit('start');
      links.start();
    }
  };
  /**
   * Ends this brush context
   *
   * Ends this brush context and emits an 'end' event if it is not already ended.
   * @emits brush#end
   */


  fn.end = function () {
    if (!activated) {
      return;
    }

    activated = false;
    ranges = {};
    values = {};
    fn.emit('end');
    links.end();
  };
  /**
   * Checks if this brush is activated
   *
   * Returns true if started, false otherwise
   * @return {boolean}
   */


  fn.isActive = function () {
    return activated;
  };
  /**
   * Clears this brush context
   */


  fn.clear = function () {
    var removed = fn.brushes().filter(function (b) {
      return b.type === 'value' && b.brush.values().length;
    }).map(function (b) {
      return {
        id: b.id,
        values: b.brush.values()
      };
    });
    var hasChanged = Object.keys(ranges).length > 0 || removed.length;
    ranges = {};
    values = {};

    if (hasChanged) {
      fn.emit('update', [], removed); // TODO - do not emit update if state hasn't changed

      links.clear();
    }
  };
  /**
   * Returns all brushes within this context
   * @return {object}
   */


  fn.brushes = function () {
    var result = [];
    result = result.concat(Object.keys(ranges).map(function (key) {
      return {
        type: 'range',
        id: key,
        brush: ranges[key]
      };
    }));
    result = result.concat(Object.keys(values).map(function (key) {
      return {
        type: 'value',
        id: key,
        brush: values[key]
      };
    }));
    return result;
  };
  /**
   * Adds a primitive value to this brush context
   *
   * If this brush context is not started, a 'start' event is emitted.
   * If the state of the brush changes, ie. if the added value does not already exist, an 'update' event is emitted.
   *
   * @param {string} key  An identifier that represents the data source of the value
   * @param {string|number} value The value to add
   * @emits brush#start
   * @emits brush#update
   * @example
   * brush.addValue('countries', 'Sweden');
   * brush.addValue('/qHyperCube/qDimensionInfo/0', 3);
   */


  fn.addValue = function (key, value) {
    fn.addValues([{
      key: key,
      value: value
    }]);
  };
  /**
   * @param {object[]} items Items to add
   */


  fn.addValues = function (items) {
    var its = intercept(interceptors.addValues, items, aliases);
    var added = add({
      vc: vc,
      collection: values,
      items: its
    });
    fn.emit('add-values', its);

    if (added.length) {
      if (!activated) {
        activated = true;
        fn.emit('start');
      }

      fn.emit('update', added, []);
      links.updateValues();
    }
  };
  /**
   * @param {object[]} items Items to set
   */


  fn.setValues = function (items) {
    var its = intercept(interceptors.setValues, items, aliases);
    var changed = set$1({
      items: its,
      vCollection: values,
      vc: vc
    });
    fn.emit('set-values', its);

    if (changed[0].length > 0 || changed[1].length > 0) {
      if (!activated) {
        activated = true;
        fn.emit('start');
      }

      fn.emit('update', changed[0], changed[1]);
      links.updateValues();
    }
  };
  /**
   * Removes a primitive values from this brush context
   *
   * If the state of the brush changes, ie. if the removed value does exist, an 'update' event is emitted.
   *
   * @param  {string} key  An identifier that represents the data source of the value
   * @param  {string|number} value The value to remove
   * @example
   * brush.removeValue('countries', 'Sweden');
   */


  fn.removeValue = function (key, value) {
    fn.removeValues([{
      key: key,
      value: value
    }]);
  };
  /**
   * @param {object[]} items Items to remove
   */


  fn.removeValues = function (items) {
    var its = intercept(interceptors.removeValues, items, aliases);
    var removed = remove({
      collection: values,
      items: its
    });
    fn.emit('remove-values', its);

    if (removed.length) {
      fn.emit('update', [], removed);
      links.updateValues(); // TODO - emit 'end' event if there are no remaining active brushes
    }
  };
  /**
   * Add and remove values in a single operation
   * almost the same as calling addValues and removeValues but only triggers one 'update' event
   *
   * If the state of the brush changes, an 'update' event is emitted.
   *
   * @param {object[]} addItems Items to add
   * @param {object[]} removeItems Items to remove
   */


  fn.addAndRemoveValues = function (addItems, removeItems) {
    var addIts = intercept(interceptors.addValues, addItems, aliases);
    var removeIts = intercept(interceptors.removeValues, removeItems, aliases);
    var added = add({
      vc: vc,
      collection: values,
      items: addIts
    });
    var removed = remove({
      collection: values,
      items: removeIts
    });
    fn.emit('add-values', addIts);
    fn.emit('remove-values', removeIts);

    if (added.length || removed.length) {
      if (!activated) {
        activated = true;
        fn.emit('start');
      }

      fn.emit('update', added, removed);
      links.updateValues();
    }
  };
  /**
   * Toggles a primitive value in this brush context
   *
   * If the given value exist in this brush context, it will be removed. If it does not exist it will be added.
   *
   * @param  {string} key  An identifier that represents the data source of the value
   * @param  {string|number} value The value to toggle
   * @example
   * brush.toggleValue('countries', 'Sweden');
   */


  fn.toggleValue = function (key, value) {
    fn.toggleValues([{
      key: key,
      value: value
    }]);
  };
  /**
   * @param {object[]} items Items to toggle
   */


  fn.toggleValues = function (items) {
    var its = intercept(interceptors.toggleValues, items, aliases);
    var toggled = toggle({
      items: its,
      values: values,
      vc: vc
    });
    fn.emit('toggle-values', its);

    if (toggled[0].length > 0 || toggled[1].length > 0) {
      if (!activated) {
        activated = true;
        fn.emit('start');
      }

      fn.emit('update', toggled[0], toggled[1]);
      links.updateValues();
    }
  };
  /**
   * Checks if a certain value exists in this brush context
   *
   * Returns true if the values exists for the provided key, returns false otherwise.
   *
   * @param  {string} key  An identifier that represents the data source of the value
   * @param  {string|number} value The value to check for
   * @return {boolean}
   * @example
   * brush.addValue('countries', 'Sweden');
   * brush.containsValue('countries', 'Sweden'); // true
   * brush.toggleValue('countries', 'Sweden'); // remove 'Sweden'
   * brush.containsValue('countries', 'Sweden'); // false
   */


  fn.containsValue = function (key, value) {
    var k = aliases[key] || key;

    if (!values[k]) {
      return false;
    }

    return values[k].contains(value);
  };
  /**
   * Adds a numeric range to this brush context
   *
   * @param {string} key - An identifier that represents the data source of the range
   * @param {object} range - The range to add to this brush
   * @param {number} range.min - Min value of the range
   * @param {number} range.max - Max value of the range
   * @example
   * brush.addRange('Sales', { min: 20, max: 50 });
   */


  fn.addRange = function (key, range) {
    fn.addRanges([{
      key: key,
      range: range
    }]);
  };
  /**
   * @see {brush.addRange}
   * @param {object[]} items - Items containing the ranges to remove
   * @param {string} items[].key
   * @param {object} items[].range
   */


  fn.addRanges = function (items) {
    var changed = updateRange(items, 'add', {
      ranges: ranges,
      rc: rc,
      interceptors: interceptors,
      aliases: aliases,
      rangeConfig: rangeConfig
    });

    if (!changed) {
      return;
    }

    if (!activated) {
      activated = true;
      fn.emit('start');
    }

    fn.emit('update', [], []);
    links.updateRanges();
  };
  /**
   * Removes a numeric range from this brush context
   *
   * @param {string} key - An identifier that represents the data source of the range
   * @param {object} range - The range to remove from this brush
   * @param {number} range.min - Min value of the range
   * @param {number} range.max - Max value of the range
   */


  fn.removeRange = function (key, range) {
    fn.removeRanges([{
      key: key,
      range: range
    }]);
  };
  /**
   * @see {brush.removeRange}
   * @param {object[]} items - Items containing the ranges to remove
   */


  fn.removeRanges = function (items) {
    var changed = updateRange(items, 'remove', {
      ranges: ranges,
      rc: rc,
      interceptors: interceptors,
      aliases: aliases,
      rangeConfig: rangeConfig
    });

    if (!changed) {
      return;
    }

    if (!activated) {
      activated = true;
      fn.emit('start');
    }

    fn.emit('update', [], []);
    links.updateRanges();
  };
  /**
   * Sets a numeric range to this brush context
   *
   * Overwrites any active ranges identified by `key`
   *
   * @param {string} key - An identifier that represents the data source of the range
   * @param {object} range - The range to set on this brush
   * @param {number} range.min - Min value of the range
   * @param {number} range.max - Max value of the range
   */


  fn.setRange = function (key, range) {
    fn.setRanges([{
      key: key,
      range: range
    }]);
  };
  /**
   * @see {brush.setRange}
   * @param {object[]} items - Items containing the ranges to set
   */


  fn.setRanges = function (items) {
    var changed = updateRange(items, 'set', {
      ranges: ranges,
      rc: rc,
      interceptors: interceptors,
      aliases: aliases,
      rangeConfig: rangeConfig
    });

    if (!changed) {
      return;
    }

    if (!activated) {
      activated = true;
      fn.emit('start');
    }

    fn.emit('update', [], []);
    links.updateRanges();
  };
  /**
   * Toggles a numeric range in this brush context
   *
   * Removes the range if it's already contained within the given identifier,
   * otherwise the given range is added to the brush.
   *
   * @param {string} key - An identifier that represents the data source of the range
   * @param {object} range - The range to toggle in this brush
   * @param {number} range.min - Min value of the range
   * @param {number} range.max - Max value of the range
   */


  fn.toggleRange = function (key, range) {
    fn.toggleRanges([{
      key: key,
      range: range
    }]);
  };
  /**
   * @see {brush.toggleRange}
   * @param {object[]} items - Items containing the ranges to toggle
   */


  fn.toggleRanges = function (items) {
    var changed = updateRange(items, 'toggle', {
      ranges: ranges,
      rc: rc,
      interceptors: interceptors,
      aliases: aliases,
      rangeConfig: rangeConfig
    });

    if (!changed) {
      return;
    }

    if (!activated) {
      activated = true;
      fn.emit('start');
    }

    fn.emit('update', [], []);
    links.updateRanges();
  };
  /**
   * Checks if a value is contained within a range in this brush context
   *
   * Returns true if the values exists for the provided key, returns false otherwise.
   *
   * @param  {string} key - An identifier that represents the data source of the value
   * @param  {number} value - The value to check for
   * @return {boolean}
   * @example
   * brush.addRange('Sales', { min: 10, max: 50 });
   * brush.containsRangeValue('Sales', 30); // true
   * brush.containsRangeValue('Sales', 5); // false
   */


  fn.containsRangeValue = function (key, value) {
    var k = aliases[key] || key;

    if (!ranges[k]) {
      return false;
    }

    return ranges[k].containsValue(value);
  };
  /**
   * Checks if a range segment is contained within this brush context
   *
   * Returns true if the range segment exists for the provided key, returns false otherwise.
   *
   * @param {string} key - An identifier that represents the data source of the value
   * @param {object} range - The range to check for
   * @param {number} range.min - Min value of the range
   * @param {number} range.max - Max value of the range
   * @return {boolean}
   * @example
   * brush.addRange('Sales', { min: 10, max: 50 });
   * brush.containsRange('Sales', { min: 15, max: 20 }); // true - the range segment is fully contained within [10, 50]
   * brush.containsRange('Sales', { min: 5, max: 20 }); // false - part of the range segment is outside [10, 50]
   * brush.containsRange('Sales', { min: 30, max: 80 }); // false - part of the range segment is outside [10, 50]
   */


  fn.containsRange = function (key, range) {
    var k = aliases[key] || key;

    if (!ranges[k]) {
      return false;
    }

    return ranges[k].containsRange(range);
  };

  fn.containsMappedData = function (d, props, mode) {
    var status = [];
    var keys = Object.keys(d);
    var key;
    var item;
    var source;
    var value;

    for (var i = 0, num = keys.length; i < num; i++) {
      key = keys[i];

      if (key === 'value') {
        item = d;
        status[i] = {
          key: '',
          i: i,
          bool: false
        };
      } else if (key === 'source') {
        continue;
      } else {
        item = d[key];
        status[i] = {
          key: key,
          i: i,
          bool: false
        };
      }

      source = item.source && item.source.field;

      if (typeof source === 'undefined') {
        continue;
      }

      if (typeof item.source.key !== 'undefined') {
        source = "".concat(item.source.key, "/").concat(source);
      }

      if (source in aliases) {
        source = aliases[source];
      }

      value = item.value;

      if (ranges[source]) {
        status[i].bool = Array.isArray(value) ? ranges[source].containsRange({
          min: value[0],
          max: value[1]
        }) : ranges[source].containsValue(value);
      } else if (values[source] && values[source].contains(value)) {
        status[i].bool = true;
      }
    }

    if (props) {
      status = status.filter(function (b) {
        return props.indexOf(b.key) !== -1;
      });

      if (mode === 'and') {
        return !!status.length && !status.some(function (s) {
          return s.bool === false;
        });
      }

      if (mode === 'xor') {
        return !!status.length && status.some(function (s) {
          return s.bool;
        }) && status.some(function (s) {
          return s.bool === false;
        });
      } // !mode || mode === 'or'


      return status.some(function (s) {
        return s.bool;
      });
    }

    return status.some(function (s) {
      return s.bool;
    });
  };
  /**
   * Adds an event interceptor
   *
   * @param {string} name Name of the event to intercept
   * @param {function} ic Handler to call before event is triggered
   * @example
   * brush.intercept('add-values', items => {
   *  console.log('about to add the following items', items);
   *  return items;
   * });
   */


  fn.intercept = function (name, ic) {
    var s = toCamelCase(name);

    if (!interceptors[s]) {
      return;
    }

    interceptors[s].push(ic);
  };
  /**
   * Removes an interceptor
   *
   * @param {string} name Name of the event to intercept
   * @param {function} ic Handler to remove
   */


  fn.removeInterceptor = function (name, ic) {
    var s = toCamelCase(name);

    if (!interceptors[s]) {
      return;
    }

    var idx = interceptors[s].indexOf(ic);

    if (idx !== -1) {
      interceptors[s].splice(idx, 1);
    }
  };
  /**
   * Removes all interceptors
   *
   * @param {string} [name] Name of the event to remove interceptors for. If not provided, removes all interceptors.
   */


  fn.removeAllInterceptors = function (name) {
    var toRemove = [];

    if (name) {
      var s = toCamelCase(name);

      if (interceptors[s] && interceptors[s].length) {
        toRemove.push({
          name: name,
          handlers: interceptors[s]
        });
      }
    } else {
      Object.keys(interceptors).forEach(function (n) {
        if (interceptors[n].length) {
          toRemove.push({
            name: toSnakeCase(n),
            handlers: interceptors[n]
          });
        }
      });
    }

    toRemove.forEach(function (ic) {
      var interceptorHandlers = ic.handlers.slice();
      interceptorHandlers.forEach(function (handler) {
        return fn.removeInterceptor(ic.name, handler);
      });
    });
  };
  /**
   * Adds an alias to the given key
   *
   * @param {string} key - Value to be replaced
   * @param {string} alias - Value to replace key with
   * @example
   * brush.addKeyAlias('BadFieldName', 'Region');
   * brush.addValue('BadFieldName', 'Sweden'); // 'BadFieldName' will be stored as 'Region'
   * brush.containsValue('Region', 'Sweden'); // true
   * brush.containsValue('BadFieldName', 'Sweden'); // true
   */


  fn.addKeyAlias = function (key, alias) {
    aliases[key] = alias;
  };
  /**
   * Removes an alias
   *
   * This will only remove the key to alias mapping for new manipulations of the brush,
   * no changes will be made to the current state of this brush.
   *
   * @param {string} key - Value to remove as alias
   * @example
   * brush.removeKeyAlias('BadFieldName');
   */


  fn.removeKeyAlias = function (key) {
    delete aliases[key];
  };

  EventEmitter$1.mixin(fn);
  return fn;
}

var reg = registryFactory();

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

var pi$2 = Math.PI;

var tau$2 = 2 * Math.PI,
    amplitude = 1,
    period = 0.3;

var elasticOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau$2);

  function elasticOut(t) {
    return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);
  }

  elasticOut.amplitude = function(a) { return custom(a, p * tau$2); };
  elasticOut.period = function(p) { return custom(a, p); };

  return elasticOut;
})(amplitude, period);

/* globals window */

function nodeId(node, i) {
  if (node.data) {
    return node.data.value;
  }

  if (node.type === 'text') {
    return node.text;
  }

  return i;
}

function tween(_ref, _ref2, config) {
  var old = _ref.old,
      current = _ref.current;
  var renderer = _ref2.renderer;
  var ticker; // let staticNodes = [];

  var toBeUpdated = [];
  var entered = {
    nodes: [],
    ips: []
  };
  var exited = {
    nodes: [],
    ips: []
  };
  var updated = {
    nodes: [],
    ips: []
  };
  var stages = [];
  var trackBy = config.trackBy || nodeId;
  var tweener = {
    start: function start() {
      var ids = {};
      old.forEach(function (node, i) {
        var id = trackBy(node, i);
        ids[id] = node;
      });
      current.forEach(function (node, i) {
        var id = trackBy(node, i);

        if (ids[id]) {
          updated.ips.push(interpolateObject(ids[id], node));
          updated.nodes.push(node);
          toBeUpdated.push(ids[id]);
          ids[id] = false;
        } else {
          entered.nodes.push(node);
          entered.ips.push(interpolateObject({
            r: 0.001,
            opacity: 0
          }, node));
        }
      });
      Object.keys(ids).forEach(function (key) {
        if (ids[key]) {
          exited.nodes.push(ids[key]);
          exited.ips.push(interpolateObject(ids[key], extend({}, ids[key], {
            r: 0.0001,
            opacity: 0
          })));
        }
      });

      if (exited.ips.length) {
        stages.push({
          easing: cubicInOut,
          duration: 200,
          tweens: exited.ips,
          nodes: [].concat(toBeUpdated)
        });
      }

      if (updated.ips.length) {
        stages.push({
          easing: cubicInOut,
          duration: 400,
          tweens: updated.ips,
          nodes: []
        });
      }

      if (entered.ips.length) {
        stages.push({
          easing: elasticOut,
          duration: 1200,
          tweens: entered.ips,
          nodes: _toConsumableArray$1(updated.nodes)
        });
      } // console.log(stages);


      if (stages.length) {
        stages[0].started = Date.now();

        if (typeof window !== 'undefined') {
          ticker = window.requestAnimationFrame(tweener.tick);
        }
      }
    },
    tick: function tick() {
      var currentStage = stages[0];

      if (!currentStage) {
        tweener.stop();
      }

      if (!currentStage.started) {
        currentStage.started = Date.now();
      }

      var t = (Date.now() - currentStage.started) / currentStage.duration;
      var currentNodes = [];
      var tweenedNodes = currentStage.tweens.map(function (ip) {
        return ip(currentStage.easing(Math.min(1, t)));
      });
      currentNodes.push.apply(currentNodes, _toConsumableArray$1(tweenedNodes));
      currentNodes.push.apply(currentNodes, _toConsumableArray$1(currentStage.nodes)); // currentNodes.push(...staticNodes);
      // stages.slice(1).forEach(stage => currentNodes.push(...stage.nodes));

      renderer.render(currentNodes);

      if (t >= 1) {
        // staticNodes.push(...currentStage.nodes);
        stages.shift();

        if (!stages.length) {
          tweener.stop();
        }
      }

      if (ticker) {
        ticker = window.requestAnimationFrame(tweener.tick);
      }
    },
    stop: function stop() {
      if (ticker) {
        window.cancelAnimationFrame(ticker);
        ticker = false;
      }
    }
  };
  return tweener;
}

var GLOBAL_DEFAULTS = {
  fontFamily: 'Arial',
  fontSize: '13px',
  color: '#595959',
  backgroundColor: '#ffffff',
  stroke: '#000000',
  strokeWidth: 0,
  $fill: '#333333'
};
var REF_RX = /^\$/;

function isPrimitive(x) {
  var type = _typeof(x);

  return type !== 'object' && type !== 'function' && type !== 'undefined';
}
/**
 * @callback datum-accessor
 * @param {datum-extract} d
 */

/**
 * @typedef {object} datum-config
 * @property {string} [scale]
 * @property {datum-accessor} fn
 * @property {string} ref - A reference to a datum-extract property
 */

/**
 * @typedef {string|datum-config|datum-accessor} datum-string
 */

/**
 * @typedef {number|datum-config|datum-accessor} datum-number
 */

/**
 * Normalizes property settings
 *
 * @ignore
 * @export
 * @param {any} settings
 * @param {any} defaults
 * @param {any} chart
 * @returns {any}
 */


function normalizeSettings(settings, defaults, chart) {
  var composition = extend({}, settings);
  var defs = extend({}, defaults);
  Object.keys(composition).forEach(function (key) {
    defs[key] = {};
    var v = composition[key];

    var vType = _typeof(v);

    if (typeof v === 'function') {
      defs[key].fn = v;
    } else if (isPrimitive(v)) {
      var defaultValue = defaults[key];

      if (typeof defaultValue === 'string' && REF_RX.test(defaultValue)) {
        defaultValue = GLOBAL_DEFAULTS[defaultValue];
      }

      var defaultType = _typeof(defaultValue);

      if (defaultType === 'undefined') {
        // if property has no default, assign provided value
        defs[key] = v;
      } else {
        // assign provided value if it's of same type as default, otherwise use default
        defs[key] = defaultType === vType ? v : defaultValue;
      }
    } else if (v && _typeof(v) === 'object') {
      if (typeof v.fn === 'function') {
        defs[key].fn = v.fn;
      }

      if (typeof v.scale !== 'undefined') {
        defs[key].scale = chart.scale(v.scale);
      }

      if (typeof v.ref === 'string') {
        defs[key].ref = v.ref;
      }
    }
  });
  Object.keys(defaults).forEach(function (key) {
    if (key in composition) {
      // don't process same props again
      return;
    }

    var v = defaults[key];

    var defaultType = _typeof(v);

    if (defaultType === 'string' && REF_RX.test(v)) {
      defs[key] = GLOBAL_DEFAULTS[v];
    } else {
      defs[key] = v;
    }
  });
  return defs;
}
function resolveForItem(context, normalized, idx) {
  var ret = {};
  var keys = Object.keys(normalized);
  var len = keys.length;
  var fallbackData = context.datum;
  var datum = context.datum;

  for (var i = 0; i < len; i++) {
    var key = keys[i];
    var normalizedProp = normalized[key];
    var exists = _typeof(datum) === 'object' && typeof normalizedProp !== 'undefined';
    var hasExplicitDataProp = exists && typeof normalizedProp.ref === 'string';
    var hasImplicitDataProp = exists && key in datum;
    var propData = hasExplicitDataProp ? datum[normalizedProp.ref] : hasImplicitDataProp ? datum[key] : fallbackData; // eslint-disable-line

    if (isPrimitive(normalizedProp)) {
      ret[key] = normalizedProp;
    } else if (exists && normalizedProp.fn) {
      // callback function
      if (normalizedProp.scale) {
        context.scale = normalizedProp.scale;
      }

      ret[key] = normalizedProp.fn.call(null, context, idx);
    } else if (exists && normalizedProp.scale && propData) {
      ret[key] = normalizedProp.scale(propData.value);

      if (normalizedProp.scale.bandwidth) {
        ret[key] += normalizedProp.scale.bandwidth() / 2;
      }
    } else if (hasExplicitDataProp && propData) {
      ret[key] = propData.value;
    } else if (normalizedProp.fn) {
      ret[key] = normalizedProp.fn.call(null, context, idx);
    } else {
      ret[key] = normalizedProp;
    }
  }

  return ret;
}

function updateScaleSize(object, path, size) {
  var o = object[path];

  if (o && o.scale && o.scale.pxScale) {
    o.scale = o.scale.pxScale(size);
  } else if (o && o.pxScale) {
    object[path] = o.pxScale(size);
  }
}
function scaleWithSize(scale, size) {
  return scale.pxScale ? scale.pxScale(size) : scale;
}

var externals = {
  normalizeSettings: normalizeSettings,
  resolveForItem: resolveForItem,
  updateScaleSize: updateScaleSize
};
function settingsResolver (resources) {
  var deps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : externals;
  var cache = {};

  function resolve(_ref) {
    var data = _ref.data,
        settings = _ref.settings,
        _ref$defaults = _ref.defaults,
        defaults = _ref$defaults === void 0 ? {} : _ref$defaults,
        scaled = _ref.scaled;
    var norm = cache.norm = deps.normalizeSettings(settings, defaults, resources.chart);
    var res = {
      scale: resources.chart.scale,
      formatter: resources.chart.formatter
    };

    if (scaled) {
      Object.keys(scaled).forEach(function (key) {
        if (norm[key]) {
          deps.updateScaleSize(norm, key, scaled[key]);
        }
      });
    }

    var resolved = [];

    if (data && Array.isArray(data.items)) {
      var context;

      for (var i = 0, len = data.items.length; i < len; i++) {
        context = {
          datum: data.items[i],
          data: data,
          resources: res
        };
        var obj = deps.resolveForItem(context, cache.norm, i);
        obj.data = data.items[i];
        resolved.push(obj);
      }
    } else {
      var _context = {
        data: data,
        resources: res
      };

      var _obj = deps.resolveForItem(_context, cache.norm, -1);

      return {
        settings: cache.norm,
        item: _obj
      };
    }

    return {
      settings: cache.norm,
      items: resolved
    };
  }

  return {
    resolve: resolve
  };
}

/**
 * Flatten the array of nodes by removing any containers as they do not support styling, thus unable to brush them.
 * @param {array} nodes
 * @ignore
 */

function reduceToLeafNodes() {
  var nodes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return nodes.reduce(function (ary, node) {
    if (Array.isArray(node.children)) {
      ary.push.apply(ary, _toConsumableArray$1(reduceToLeafNodes(node.children)));
      return ary;
    }

    ary.push(node);
    return ary;
  }, []);
}
function styler(obj, _ref) {
  var context = _ref.context,
      data = _ref.data,
      style = _ref.style,
      filter = _ref.filter,
      mode = _ref.mode;
  var brusher = obj.chart.brush(context);
  var dataProps = data;
  var active = style.active || {};
  var inactive = style.inactive || {};
  var styleProps = [];
  Object.keys(active).forEach(function (key) {
    styleProps.push(key);
  });
  Object.keys(inactive).forEach(function (key) {
    if (styleProps.indexOf(key) === -1) {
      styleProps.push(key);
    }
  });
  var activeNodes = [];
  var globalActivation = false; // track when we need to loop through all nodes, not just the active ones

  var getNodes = function getNodes() {
    var nodes = reduceToLeafNodes(obj.nodes);

    if (typeof filter === 'function') {
      nodes = nodes.filter(filter);
    }

    return nodes;
  };

  var update = function update() {
    // TODO - render nodes only once, i.e. don't render for each brush, update nodes for all brushes and then render
    var nodes = getNodes();
    var len = nodes.length;
    var nodeData;
    var globalChanged = false;

    var _loop = function _loop(i) {
      // TODO - update only added and removed nodes
      nodeData = nodes[i].data;

      if (!nodeData) {
        return "continue";
      }

      if (!nodes[i].__style) {
        nodes[i].__style = {};
        styleProps.forEach(function (s) {
          nodes[i].__style[s] = nodes[i][s]; // store original value
        });
      }

      var isActive = brusher.containsMappedData(nodeData, dataProps, mode);
      var activeIdx = activeNodes.indexOf(nodes[i]);
      var changed = false;

      if (isActive && activeIdx === -1) {
        // activated
        activeNodes.push(nodes[i]);
        changed = true;
      } else if (!isActive && activeIdx !== -1) {
        // was active
        activeNodes.splice(activeIdx, 1);
        changed = true;
      }

      if (changed || globalActivation) {
        var original = extend({}, nodes[i], nodes[i].__style);
        styleProps.forEach(function (s) {
          if (isActive && s in active) {
            nodes[i][s] = typeof active[s] === 'function' ? active[s].call(null, original) : active[s];
          } else if (!isActive && s in inactive) {
            nodes[i][s] = typeof inactive[s] === 'function' ? inactive[s].call(null, original) : inactive[s];
          } else {
            nodes[i][s] = nodes[i].__style[s];
          }
        });
        globalChanged = true;
      }
    };

    for (var i = 0; i < len; i++) {
      var _ret = _loop(i);

      if (_ret === "continue") continue;
    }

    globalActivation = false;
    return globalChanged;
  };

  var onStart = function onStart() {
    var nodes = getNodes();
    var len = nodes.length;

    var _loop2 = function _loop2(i) {
      if (!nodes[i].data) {
        return "continue";
      }

      nodes[i].__style = nodes[i].__style || {};
      styleProps.forEach(function (s) {
        nodes[i].__style[s] = nodes[i][s]; // store original value

        if (s in inactive) {
          nodes[i][s] = typeof inactive[s] === 'function' ? inactive[s].call(null, nodes[i]) : inactive[s];
        }
      });
    };

    for (var i = 0; i < len; i++) {
      var _ret2 = _loop2(i);

      if (_ret2 === "continue") continue;
    }

    globalActivation = true;
    activeNodes.length = 0;
    obj.renderer.render(obj.nodes);
  };

  var onEnd = function onEnd() {
    var nodes = getNodes();
    var len = nodes.length;

    var _loop3 = function _loop3(i) {
      if (nodes[i].__style) {
        Object.keys(nodes[i].__style).forEach(function (s) {
          nodes[i][s] = nodes[i].__style[s];
        });
        nodes[i].__style = undefined;
      }
    };

    for (var i = 0; i < len; i++) {
      _loop3(i);
    }

    activeNodes.length = 0;
    obj.renderer.render(obj.nodes);
  };

  var onUpdate = function onUpdate()
  /* added, removed */
  {
    var changed = update();

    if (changed) {
      obj.renderer.render(obj.nodes);
    }
  };

  var externalUpdate = function externalUpdate() {
    activeNodes.length = 0;
    globalActivation = true;
    update();
  };

  brusher.on('start', onStart);
  brusher.on('end', onEnd);
  brusher.on('update', onUpdate);

  function cleanUp() {
    brusher.removeListener('start', onStart);
    brusher.removeListener('end', onEnd);
    brusher.removeListener('update', onUpdate);
  }

  return {
    isActive: function isActive() {
      return brusher.isActive();
    },
    update: externalUpdate,
    cleanUp: cleanUp
  };
}
function brushDataPoints(_ref2) {
  var dataPoints = _ref2.dataPoints,
      action = _ref2.action,
      chart = _ref2.chart,
      trigger = _ref2.trigger;

  if (!trigger) {
    return;
  }

  var dataProps = trigger.data || [''];
  var rangeBrush = {
    items: [],
    actionFn: 'toggleRanges'
  };
  var valueBrush = {
    items: [],
    actionFn: 'toggleValues'
  };

  if (['add', 'remove', 'set', 'toggle'].indexOf(action) !== -1) {
    rangeBrush.actionFn = "".concat(action, "Ranges");
    valueBrush.actionFn = "".concat(action, "Values");
  }

  var _loop4 = function _loop4(i) {
    var dataPoint = dataPoints[i];

    if (!dataPoint) {
      return "continue";
    }

    dataProps.forEach(function (p) {
      var d = dataPoint && !p ? dataPoint : dataPoint[p];

      if (d) {
        var it = {
          key: d.source.field
        };

        if (typeof d.source.key !== 'undefined') {
          it.key = "".concat(d.source.key, "/").concat(d.source.field);
        }

        if (Array.isArray(d.value)) {
          it.range = {
            min: d.value[0],
            max: d.value[1]
          };
          rangeBrush.items.push(it);
        } else {
          it.value = d.value;
          valueBrush.items.push(it);
        }
      }
    });
  };

  for (var i = 0; i < dataPoints.length; i++) {
    var _ret3 = _loop4(i);

    if (_ret3 === "continue") continue;
  }

  trigger.contexts.forEach(function (c) {
    if (rangeBrush.items.length) {
      chart.brush(c)[rangeBrush.actionFn](rangeBrush.items);
    } else {
      chart.brush(c)[valueBrush.actionFn](valueBrush.items); // call action even if there are items to potentially clear what is currently in the brush
    }
  });
}
function brushFromSceneNodes(_ref3) {
  var nodes = _ref3.nodes,
      action = _ref3.action,
      chart = _ref3.chart,
      trigger = _ref3.trigger;
  var dataPoints = [];

  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    var nodeData = node.data;

    if (nodeData !== null) {
      dataPoints.push(nodeData);
    }
  }

  brushDataPoints({
    dataPoints: dataPoints,
    action: action,
    chart: chart,
    trigger: trigger
  });
}
function resolveEvent(_ref4) {
  var collisions = _ref4.collisions,
      t = _ref4.t,
      config = _ref4.config,
      action = _ref4.action;
  var brushCollisions = [];
  var resolved = false;

  if (collisions.length > 0) {
    brushCollisions = collisions;
    resolved = true;

    if (t.propagation === 'stop') {
      brushCollisions = [collisions[collisions.length - 1]];
    }
  }

  var nodes = brushCollisions.map(function (c) {
    return c.node;
  });
  brushFromSceneNodes({
    nodes: nodes,
    action: action,
    chart: config.chart,
    data: config.data,
    trigger: t
  });
  return resolved;
}

function touchSingleContactPoint(e, rect) {
  if (e.changedTouches.length !== 1) {
    return null;
  }

  return {
    x: e.changedTouches[0].clientX - rect.left,
    y: e.changedTouches[0].clientY - rect.top
  };
}

function singleContactPoint(e, rect) {
  return {
    x: e.clientX - rect.left,
    y: e.clientY - rect.top
  };
}

function resolveCollisions(e, t, renderer) {
  var rect = renderer.element().getBoundingClientRect();
  var p = isTouchEvent(e) ? touchSingleContactPoint(e, rect) : singleContactPoint(e, rect);

  if (p === null || p.x < 0 || p.y < 0 || p.x > rect.width || p.y > rect.height) {
    // TODO include radius in this check?
    return [];
  }

  if (t.touchRadius > 0 && isTouchEvent(e)) {
    p = {
      cx: p.x,
      cy: p.y,
      r: t.touchRadius // TODO Use touch event radius/width value (Need to handle dpi scaling as well)

    };
  }

  return renderer.itemsAt(p);
}

function resolveAction(action, e, def) {
  if (action) {
    if (typeof action === 'function') {
      return action(e);
    }

    return action;
  }

  return def;
}

function resolveTapEvent(_ref5) {
  var e = _ref5.e,
      t = _ref5.t,
      config = _ref5.config;
  var collisions = resolveCollisions(e, t, config.renderer);
  return resolveEvent({
    collisions: collisions,
    t: t,
    config: config,
    action: resolveAction(t.action, e, 'toggle')
  });
}
function resolveOverEvent(_ref6) {
  var e = _ref6.e,
      t = _ref6.t,
      config = _ref6.config;
  var collisions = resolveCollisions(e, t, config.renderer);
  return resolveEvent({
    collisions: collisions,
    t: t,
    config: config,
    action: resolveAction(t.action, e, 'set')
  });
}

/**
 * A list of supported attributes in lower camelCase notation mapped to corresponding kebab-case notation.
 * The kebab-case notations are a sub-set of SVG attributes (https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute).
 * @ignore
 */
var mappedAttributes = {
  fill: 'fill',
  stroke: 'stroke',
  opacity: 'opacity',
  strokeWidth: 'stroke-width',
  strokeLinejoin: 'stroke-linejoin',
  fontFamily: 'font-family',
  fontSize: 'font-size',
  baseline: 'dominant-baseline',
  // Special case where we have defined our own attribute name
  dominantBaseline: 'dominant-baseline',
  anchor: 'text-anchor',
  // Special case where we have defined our own attribute name
  textAnchor: 'text-anchor',
  maxWidth: 'maxWidth',
  transform: 'transform',
  strokeDasharray: 'stroke-dasharray',
  id: 'id'
};
/**
 * Takes a target object and assign each supported attribute from a source object to that target.
 * Each supported attributes is converted to a mapped kebab-case notation.
 * @ignore
 *
 * @param {object} target - Target object on which to assign mapped attribute values
 * @param {object} source - Source object
 */

function assignMappedAttribute(target, source) {
  Object.keys(mappedAttributes).forEach(function (key) {
    var sourceValue = source[key];

    if (typeof sourceValue !== 'undefined') {
      var mappedKey = mappedAttributes[key];
      target[mappedKey] = sourceValue;
    }
  });
}

/**
 * @extends symbol-config
 * @typedef {object} symbol--circle
 */
function circle(options) {
  return {
    type: 'circle',
    fill: 'black',
    cx: options.x,
    cy: options.y,
    r: options.size / 2
  };
}

function pointsToPath(points) {
  var close = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var d = '';

  for (var i = 0; i < points.length; i++) {
    var p = points[i];

    if (i === 0) {
      d += "M".concat(p.x, " ").concat(p.y);
    } else {
      d += "L".concat(p.x, " ").concat(p.y);
    }

    d += ' ';
  }

  if (close) {
    d += 'Z';
  }

  return d;
}

/**
 * @extends symbol-config
 * @typedef {object} symbol--diamond
 */

function diamond(options) {
  var size = options.size;
  var left = options.x - size / 2;
  var top = options.y - size / 2;
  var points = [{
    x: left,
    y: top + size / 2
  }, {
    x: left + size / 2,
    y: top
  }, {
    x: left + size,
    y: top + size / 2
  }, {
    x: left + size / 2,
    y: top + size
  }, {
    x: left,
    y: top + size / 2
  }];
  return {
    type: 'path',
    fill: 'black',
    d: pointsToPath(points)
  };
}

function generateCrossPoints(x, y, size, barWidth) {
  var r = size / 2;
  var innerLeft = x - barWidth / 2;
  var innerTop = y - barWidth / 2;
  var left = x - r;
  var top = y - r;
  return [{
    x: innerLeft,
    y: innerTop
  }, // Top
  {
    x: innerLeft,
    y: top
  }, {
    x: innerLeft + barWidth,
    y: top
  }, {
    x: innerLeft + barWidth,
    y: innerTop
  }, // Right
  {
    x: left + size,
    y: innerTop
  }, {
    x: left + size,
    y: innerTop + barWidth
  }, {
    x: innerLeft + barWidth,
    y: innerTop + barWidth
  }, // Bottom
  {
    x: innerLeft + barWidth,
    y: top + size
  }, {
    x: innerLeft,
    y: top + size
  }, {
    x: innerLeft,
    y: innerTop + barWidth
  }, // Left
  {
    x: left,
    y: innerTop + barWidth
  }, {
    x: left,
    y: innerTop
  }];
}
/**
 * @extends symbol-config
 * @typedef {object} symbol--cross
 * @property {number} [width] - Width of the diagonals
 */

function cross(options) {
  var x = options.x;
  var y = options.y;
  var r = options.size / 2;
  var width = isNaN(options.width) ? r / 2 : options.width;
  var barWidth = Math.min(width, r);
  var points = generateCrossPoints(x, y, options.size, barWidth);
  return {
    type: 'path',
    fill: 'black',
    d: pointsToPath(points)
  };
}

/**
 * Get x1, y1, x2, y2 point from angle
 * Source: {@link https://codepen.io/NV/pen/jcnmK}
 * @private
 *
 * @param  {number} angle Radians
 * @return {object}       Point with x1, y2, x2, y2.
 */
function angleToPoints(angle) {
  var segment = Math.floor(angle / Math.PI * 2) + 2;
  var diagonal = (0.5 * segment + 0.25) * Math.PI;
  var op = Math.cos(Math.abs(diagonal - angle)) * Math.sqrt(2);
  var x = op * Math.cos(angle);
  var y = op * Math.sin(angle);
  return {
    x1: x < 0 ? 1 : 0,
    y1: y < 0 ? 1 : 0,
    x2: x >= 0 ? x : x + 1,
    y2: y >= 0 ? y : y + 1
  };
}
/**
 * Turns degrees into radians
 * @private
 *
 * @param  {number} degrees Degrees
 * @return {number}         Radians
 */

function toRadians(d) {
  return -d / 180 * Math.PI;
}
/**
 * Get x1, y1, x2, y2 point from degree
 * @private
 *
 * @param  {number} d Degree
 * @return {object}   Point with x1, y2, x2, y2.
 */

function degreesToPoints(d) {
  return angleToPoints(toRadians(d));
}

function add$1(v1, v2) {
  return {
    x: v1.x + v2.x,
    y: v1.y + v2.y
  };
}
function sub(v1, v2) {
  return {
    x: v1.x - v2.x,
    y: v1.y - v2.y
  };
}
function scalarMultiply(v, s) {
  return {
    x: v.x * s,
    y: v.y * s
  };
}
function distanceX(v1, v2) {
  return v1.x - v2.x;
}
function distanceY(v1, v2) {
  return v1.y - v2.y;
}
function sqrDistance(v1, v2) {
  return Math.pow(distanceX(v1, v2), 2) + Math.pow(distanceY(v1, v2), 2);
}
function distance(v1, v2) {
  return Math.sqrt(sqrDistance(v1, v2));
}
function dot(v1, v2) {
  return v1.x * v2.x + v1.y * v2.y;
}
function projectOnto(v1, v2) {
  var m = dot(v1, v2) / dot(v2, v2) || 1;
  return {
    x: v2.x * m,
    y: v2.y * m
  };
}
function rotate(v, radians) {
  var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    x: 0,
    y: 0
  };
  var cos = Math.cos(radians);
  var sin = Math.sin(radians);
  var t1 = sub(v, origin);
  var t2 = {
    x: cos * t1.x - sin * t1.y,
    y: sin * t1.x + cos * t1.y
  };
  return add$1(t2, origin);
}

/**
 * @extends symbol-config
 * @typedef {object} symbol--saltire
 * @property {number} [width] - Width of the diagonals
 */

function saltire(options) {
  var radians = toRadians(45);
  var r = options.size / 2;
  var width = isNaN(options.width) ? r / 2 : options.width;
  var barWidth = Math.min(width, r);
  var adjustedSize = options.size; // Adjust for the barwidth and rotation angle, so that the visual part is always inside the symbol area

  var h = Math.sin(Math.asin(-radians)) * (barWidth / 2);
  var c = r / Math.sin(-radians);
  adjustedSize += (c - r) * 2;
  adjustedSize -= h * 2;
  var centroid = {
    x: options.x,
    y: options.y
  };
  var points = generateCrossPoints(options.x, options.y, adjustedSize, barWidth).map(function (p) {
    return rotate(p, radians, centroid);
  });
  return {
    type: 'path',
    fill: 'black',
    d: pointsToPath(points)
  };
}

/**
 * @extends symbol-config
 * @typedef {object} symbol--square
 */
function square(options) {
  var size = options.size;
  return {
    type: 'rect',
    fill: 'black',
    x: options.x - size / 2,
    y: options.y - size / 2,
    width: size,
    height: size
  };
}

var DIRECTION_TO_ANGLE = {
  up: 0,
  down: 180,
  left: 90,
  right: -90
};
/**
 * @extends symbol-config
 * @typedef {object} symbol--triangle
 * @property {string} [direction='up'] - Direction of the triangle ('up'|'down'|'left'|'right')
 */

function triangle(options) {
  var size = options.size;
  var p = {
    x: options.x,
    y: options.y
  };
  var directionAngle = DIRECTION_TO_ANGLE[options.direction] || 0;
  var halfSize = size / 2;
  var left = options.x - halfSize;
  var top = options.y - halfSize;
  var points = [{
    x: left,
    y: top + size
  }, {
    x: left + halfSize,
    y: top
  }, {
    x: left + size,
    y: top + size
  }, {
    x: left,
    y: top + size
  }];
  var radians = toRadians(directionAngle);
  points = points.map(function (pp) {
    return rotate(pp, radians, p);
  });
  return {
    type: 'path',
    fill: 'black',
    d: pointsToPath(points)
  };
}

function createRectCollider(_ref) {
  var x = _ref.x,
      y = _ref.y,
      size = _ref.size;
  var r = size / 2;
  return {
    type: 'rect',
    x: x - r,
    y: y - r,
    width: size,
    height: size
  };
}
/**
 * @extends symbol-config
 * @typedef {object} symbol--line
 * @property {string} [direction='horizontal'] - Direction of line ('horizontal'|'vertical').
 */


function line$1(options) {
  var isVertical = options.direction === 'vertical';
  var r = options.size / 2;
  var x = options.x;
  var y = options.y;
  return {
    type: 'line',
    stroke: 'black',
    strokeWidth: 1,
    x1: x - (isVertical ? 0 : r),
    y1: y - (isVertical ? r : 0),
    x2: x + (isVertical ? 0 : r),
    y2: y + (isVertical ? r : 0),
    collider: createRectCollider(options) // TODO Use visual collider?

  };
}

/**
 * @extends symbol-config
 * @typedef {object} symbol--star
 * @property {number} [points=5] - Number of points on the star
 * @property {number} [startAngle=90] - Start drawing angle
 * @property {number} [innerRadius=size/2] - Size of the star core. My not exceed size of symbol.
 */

function star(options) {
  var size = options.size;
  var points = [];
  var outerRadius = size / 2;
  var drawPoints = options.points || 5;
  var innerRadius = Math.min(options.innerRadius || size / 2, size) / 2;
  var startAngle = isNaN(options.startAngle) ? 90 : options.startAngle;
  var angle = 360 / drawPoints;

  for (var i = 1; i <= drawPoints; i++) {
    var pAngle = angle * i + startAngle;
    var radians = toRadians(pAngle);
    var innerRadians = toRadians(pAngle + angle / 2);
    var y = Math.sin(radians);
    var x = Math.cos(radians);
    var iy = Math.sin(innerRadians);
    var ix = Math.cos(innerRadians);
    points.push({
      x: options.x + x * outerRadius,
      y: options.y + y * outerRadius
    });
    points.push({
      x: options.x + ix * innerRadius,
      y: options.y + iy * innerRadius
    });
  }

  return {
    type: 'path',
    fill: 'black',
    d: pointsToPath(points)
  };
}

/**
 * @extends symbol-config
 * @typedef {object} symbol--n-polygon
 * @property {object} [sides=6] - Number of sides on the regular polygon
 * @property {object} [startAngle=0] - Start drawing angle
 */

function nPolygon(options) {
  var points = [];
  var radius = options.size / 2;
  var drawPoints = Math.max(isNaN(options.sides) ? 6 : options.sides, 3);
  var angle = 360 / drawPoints;
  var startAngle = isNaN(options.startAngle) ? 0 : options.startAngle;

  for (var i = 1; i <= drawPoints; i++) {
    var radians = toRadians(angle * i + startAngle);
    var y = Math.sin(radians);
    var x = Math.cos(radians);
    points.push({
      x: options.x + x * radius,
      y: options.y + y * radius
    });
  }

  return {
    type: 'path',
    fill: 'black',
    d: pointsToPath(points)
  };
}

/**
 * @extends symbol-config
 * @typedef {object} symbol--bar
 * @property {string} [direction='horizontal'] - Direction of bar ('horizontal'|'vertical').
 */

function bar(options) {
  var p = {
    x: options.x,
    y: options.y
  };
  var isVertical = options.direction === 'vertical';
  var r = options.size / 2;
  var width = r / 2;
  var halfWidth = width / 2;
  var points = [{
    x: p.x - r,
    y: p.y + halfWidth
  }, {
    x: p.x - r,
    y: p.y - halfWidth
  }, {
    x: p.x + r,
    y: p.y - halfWidth
  }, {
    x: p.x + r,
    y: p.y + halfWidth
  }];

  if (isVertical) {
    var radians = toRadians(90);
    points = points.map(function (pp) {
      return rotate(pp, radians, p);
    });
  }

  var rect = pointsToRect(points);
  rect.type = 'rect';
  rect.fill = 'black';
  return rect;
}

var reg$1 = registryFactory();
reg$1.add('circle', circle);
reg$1.add('diamond', diamond);
reg$1.add('saltire', saltire);
reg$1.add('square', square);
reg$1.add('triangle', triangle);
reg$1.add('line', line$1);
reg$1.add('star', star);
reg$1.add('n-polygon', nPolygon);
reg$1.add('cross', cross);
reg$1.add('bar', bar);

function applyOpts(obj) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  Object.keys(opts).forEach(function (key) {
    if (typeof mappedAttributes[key] !== 'undefined' && key !== 'transform') {
      obj[key] = opts[key];
    }
  });
}
/**
 * Factory function for symbols.
 * Options object is passed to symbols function.
 * @private
 * @param {symbol--bar|symbol--circle|symbol--cross|symbol--diamond|symbol--line|symbol--n-polygon|symbol--saltire|symbol--square|symbol--star|symbol--triangle} options - Options definition may contain any of the supported display-object attributes
 * @returns {object} A node definition
 */


function create$3() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  // TODO handle reserverd properties x, y, size, data, etc..
  var fn = reg$1.get(options.type);

  if (fn) {
    var s = fn(options);
    applyOpts(s, options);

    if (typeof options.data !== 'undefined') {
      s.data = options.data;
    }

    return s;
  }

  return fn;
}
/**
 * Mandatory symbol config
 * @typedef {object} symbol-config
 * @property {object} options - Options definition may contain any of the supported display-object attributes
 * @property {string} options.type - Type of symbol
 * @property {number} options.x - x-coordinate
 * @property {number} options.y - y-coordinate
 * @property {number} options.size
 * @property {object} [options.data]
 */

var isReservedProperty = function isReservedProperty(prop) {
  return ['on', 'preferredSize', 'created', 'beforeMount', 'mounted', 'resize', 'beforeUpdate', 'updated', 'beforeRender', 'render', 'beforeUnmount', 'beforeDestroy', 'destroyed', 'defaultSettings', 'data', 'settings', 'formatter', 'scale', 'chart', 'dockConfig', 'mediator', 'style', 'resolver', 'registries', '_DO_NOT_USE_getInfo', 'symbol', 'isVisible'].some(function (name) {
    return name === prop;
  });
};

function prepareContext(ctx, definition, opts) {
  var _definition$require = definition.require,
      require = _definition$require === void 0 ? [] : _definition$require;

  var mediatorSettings = definition.mediator || {};
  var settings = opts.settings,
      formatter = opts.formatter,
      scale = opts.scale,
      data = opts.data,
      renderer = opts.renderer,
      chart = opts.chart,
      dockConfig = opts.dockConfig,
      mediator = opts.mediator,
      instance = opts.instance,
      rect = opts.rect,
      style = opts.style,
      registries = opts.registries,
      resolver = opts.resolver,
      update = opts.update,
      _DO_NOT_USE_getInfo = opts._DO_NOT_USE_getInfo,
      symbol = opts.symbol,
      isVisible = opts.isVisible;

  ctx.emit = function () {};

  if (isVisible) {
    ctx.isVisible = isVisible;
  } // TODO add setters and log warnings / errors to console


  Object.defineProperty(ctx, 'settings', {
    get: settings
  });
  Object.defineProperty(ctx, 'data', {
    get: data
  });
  Object.defineProperty(ctx, 'formatter', {
    get: formatter
  });
  Object.defineProperty(ctx, 'scale', {
    get: scale
  });
  Object.defineProperty(ctx, 'mediator', {
    get: mediator
  });
  Object.defineProperty(ctx, 'style', {
    get: style
  });
  Object.defineProperty(ctx, 'registries', {
    get: registries
  });

  if (rect) {
    Object.defineProperty(ctx, 'rect', {
      get: rect
    });
  } // TODO _DO_NOT_USE_getInfo is a temporary solution to expose info from a component
  // It should replace ASAP with a proper solution.
  // The only component activaly in need of it is the legend-cat


  if (_DO_NOT_USE_getInfo) {
    ctx._DO_NOT_USE_getInfo = _DO_NOT_USE_getInfo;
  }

  Object.keys(definition).forEach(function (key) {
    if (!isReservedProperty(key)) {
      // Add non-lifecycle methods to the context
      if (typeof definition[key] === 'function') {
        ctx[key] = definition[key].bind(ctx);
      } else {
        ctx[key] = definition[key];
      }
    }
  }); // Add properties to context

  require.forEach(function (req) {
    if (req === 'renderer') {
      Object.defineProperty(ctx, 'renderer', {
        get: renderer
      });
    } else if (req === 'chart') {
      Object.defineProperty(ctx, 'chart', {
        get: chart
      });
    } else if (req === 'dockConfig') {
      Object.defineProperty(ctx, 'dockConfig', {
        get: dockConfig
      });
    } else if (req === 'instance') {
      Object.defineProperty(ctx, 'instance', {
        get: instance
      });
    } else if (req === 'update' && update) {
      Object.defineProperty(ctx, 'update', {
        get: update
      });
    } else if (req === 'resolver') {
      Object.defineProperty(ctx, 'resolver', {
        get: resolver
      });
    } else if (req === 'symbol') {
      Object.defineProperty(ctx, 'symbol', {
        get: symbol
      });
    }
  });

  Object.keys(mediatorSettings).forEach(function (eventName) {
    ctx.mediator.on(eventName, mediatorSettings[eventName].bind(ctx));
  });
}

function createDockDefinition(settings, preferredSize, logger) {
  var getLayoutProperty = function getLayoutProperty(propName) {
    if (settings[propName]) {
      logger.warn("Deprecation Warning the ".concat(propName, " property should be moved into layout: {} property")); // eslint-disable-line no-console

      return settings[propName];
    }

    return settings.layout ? settings.layout[propName] : undefined;
  };

  var def = {};
  def.displayOrder = getLayoutProperty('displayOrder');
  def.dock = getLayoutProperty('dock');
  def.prioOrder = getLayoutProperty('prioOrder');
  def.minimumLayoutMode = getLayoutProperty('minimumLayoutMode'); // move layout properties to layout object

  settings.layout = settings.layout || {};
  settings.layout.displayOrder = typeof def.displayOrder !== 'undefined' ? def.displayOrder : settings.layout.displayOrder;
  settings.layout.prioOrder = typeof def.prioOrder !== 'undefined' ? def.prioOrder : settings.layout.prioOrder;
  settings.layout.dock = def.dock || settings.layout.dock;
  settings.layout.minimumLayoutMode = def.minimumLayoutMode || settings.layout.minimumLayoutMode; // not directly a dock layout property

  def.show = settings.show;
  def.preferredSize = preferredSize;
  return def;
}

function setUpEmitter(ctx, emitter, settings) {
  // Object.defineProperty(ctx, 'emitter', )
  Object.keys(settings.on || {}).forEach(function (event) {
    ctx.eventListeners = ctx.eventListeners || [];
    var listener = settings.on[event].bind(ctx);
    ctx.eventListeners.push({
      event: event,
      listener: listener
    });
    emitter.on(event, listener);
  });

  ctx.emit = function (name) {
    for (var _len = arguments.length, event = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      event[_key - 1] = arguments[_key];
    }

    return emitter.emit.apply(emitter, [name].concat(event));
  };
}

function tearDownEmitter(ctx, emitter) {
  if (ctx.eventListeners) {
    ctx.eventListeners.forEach(function (_ref) {
      var event = _ref.event,
          listener = _ref.listener;
      emitter.removeListener(event, listener);
    });
    ctx.eventListeners.length = 0;
  }

  ctx.emit = function () {};
} // First render
// preferredSize -> resize -> beforeRender -> render -> mounted
// Normal update
// beforeUpdate -> preferredSize -> resize -> beforeRender -> render -> updated
// Update without relayout
// beforeUpdate -> beforeRender -> render -> updated
// TODO support es6 classes


function componentFactory(definition) {
  var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var _definition$defaultSe = definition.defaultSettings,
      defaultSettings = _definition$defaultSe === void 0 ? {} : _definition$defaultSe,
      _definition$_DO_NOT_U = definition._DO_NOT_USE_getInfo,
      _DO_NOT_USE_getInfo = _definition$_DO_NOT_U === void 0 ? function () {
    return {};
  } : _definition$_DO_NOT_U;

  var _chart = context.chart,
      container = context.container,
      _mediator = context.mediator,
      _registries = context.registries,
      theme = context.theme,
      renderer = context.renderer;
  var emitter = EventEmitter$1.mixin({});
  var config = context.settings || {};

  var _settings = extend(true, {}, defaultSettings, config);

  var _data = [];

  var _scale;

  var _formatter;

  var element;
  var size;

  var _style;

  var _resolver = settingsResolver({
    chart: _chart
  });

  var _isVisible = false;
  var brushArgs = {
    nodes: [],
    chart: _chart,
    config: _settings.brush || {},
    renderer: null
  };
  var brushTriggers = {
    tap: [],
    over: []
  };
  var brushStylers = [];
  var definitionContext = {};
  var instanceContext = extend({}, config); // Create a callback that calls lifecycle functions in the definition and config (if they exist).

  function createCallback(method) {
    var defaultMethod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};
    var canBeValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    return function cb() {
      var inDefinition = typeof definition[method] !== 'undefined';
      var inConfig = typeof config[method] !== 'undefined';
      var returnValue;

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      if (inDefinition) {
        if (typeof definition[method] === 'function') {
          var _definition$method;

          returnValue = (_definition$method = definition[method]).call.apply(_definition$method, [definitionContext].concat(args));
        } else if (canBeValue) {
          returnValue = definition[method];
        }
      }

      if (inConfig) {
        if (typeof config[method] === 'function') {
          var _config$method;

          returnValue = (_config$method = config[method]).call.apply(_config$method, [instanceContext].concat(args));
        } else if (canBeValue) {
          returnValue = config[method];
        }
      }

      if (!inDefinition && !inConfig) {
        returnValue = defaultMethod.call.apply(defaultMethod, [definitionContext].concat(args));
      }

      return returnValue;
    };
  }

  var preferredSize = createCallback('preferredSize', function () {
    return 0;
  }, true);
  var resize = createCallback('resize', function (_ref2) {
    var inner = _ref2.inner;
    return inner;
  });
  var created = createCallback('created');
  var beforeMount = createCallback('beforeMount');
  var mounted = createCallback('mounted');
  var beforeUnmount = createCallback('beforeUnmount');
  var beforeUpdate = createCallback('beforeUpdate');
  var updated = createCallback('updated');
  var beforeRender = createCallback('beforeRender');
  var beforeDestroy = createCallback('beforeDestroy');
  var destroyed = createCallback('destroyed');
  var render = definition.render; // Do not allow overriding of this function

  var addBrushStylers = function addBrushStylers() {
    if (_settings.brush) {
      (_settings.brush.consume || []).forEach(function (b) {
        if (b.context && b.style) {
          brushStylers.push(styler(brushArgs, b));
        }
      });
    }
  };

  var addBrushTriggers = function addBrushTriggers() {
    if (_settings.brush) {
      (_settings.brush.trigger || []).forEach(function (t) {
        if (t.on === 'over') {
          brushTriggers.over.push(t);
        } else {
          brushTriggers.tap.push(t);
        }
      });
    }
  };

  Object.defineProperty(brushArgs, 'data', {
    get: function get() {
      return _data;
    }
  });
  var rendString = _settings.renderer || definition.renderer;
  var rend = rendString ? renderer || _registries.renderer(rendString)() : renderer || _registries.renderer()();
  brushArgs.renderer = rend;
  var dockConfigCallbackContext = {
    resources: _chart.logger ? {
      logger: _chart.logger()
    } : {}
  };

  var _dockConfig = dockConfig(createDockDefinition(_settings, preferredSize, _chart.logger()), dockConfigCallbackContext);

  var appendComponentMeta = function appendComponentMeta(node) {
    node.key = _settings.key;
    node.element = rend.element();
  };

  var fn = function fn() {};

  fn.dockConfig = function () {
    return _dockConfig;
  }; // Set new settings - will trigger mapping of data and creation of scale / formatter.


  fn.set = function () {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (opts.settings) {
      config = opts.settings;
      _settings = extend(true, {}, defaultSettings, opts.settings);
      _dockConfig = dockConfig(createDockDefinition(_settings, preferredSize, _chart.logger()), dockConfigCallbackContext);
    }

    if (_settings.scale) {
      _scale = _chart.scale(_settings.scale);
    }

    if (_settings.data) {
      _data = extract(_settings.data, {
        dataset: _chart.dataset,
        collection: _chart.dataCollection
      }, {
        logger: _chart.logger()
      }, _chart.dataCollection);
    } else if (_scale) {
      _data = _scale.data();
    } else {
      _data = [];
    }

    if (typeof _settings.formatter === 'string') {
      _formatter = _chart.formatter(_settings.formatter);
    } else if (_typeof(_settings.formatter) === 'object') {
      _formatter = _chart.formatter(_settings.formatter);
    } else if (_scale && _scale.data().fields) {
      _formatter = _scale.data().fields[0].formatter();
    }

    _style = theme.style(_settings.style || {});
  };

  fn.resize = function () {
    var inner = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var outer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var newSize = resize({
      inner: inner,
      outer: outer
    });

    if (newSize) {
      size = rend.size(newSize);
    } else {
      size = rend.size(inner);
    }

    instanceContext.rect = extend(true, {
      computedPhysical: size.computedPhysical,
      computedOuter: outer.computed || outer,
      computedInner: inner.computed || inner
    }, inner);
    size = extend(true, {
      computedOuter: outer.computed || outer,
      computedInner: inner.computed || inner
    }, size);
  };

  fn.getRect = function () {
    return instanceContext.rect;
  };

  var getRenderArgs = function getRenderArgs() {
    var renderArgs = rend.renderArgs ? rend.renderArgs.slice(0) : [];
    renderArgs.push({
      data: _data
    });
    return renderArgs;
  };

  fn.beforeMount = beforeMount;

  fn.beforeRender = function () {
    beforeRender({
      size: size
    });
  };

  var currentNodes;

  fn.render = function () {
    var nodes = brushArgs.nodes = render.call.apply(render, [definitionContext].concat(_toConsumableArray$1(getRenderArgs())));
    rend.render(nodes);
    currentNodes = nodes;
  };

  fn.hide = function () {
    fn.unmount();
    rend.size({
      x: 0,
      y: 0,
      width: 0,
      height: 0
    });
    rend.clear();
  };

  fn.beforeUpdate = function () {
    beforeUpdate({
      settings: _settings,
      data: _data
    });
  };

  var currentTween;

  fn.update = function () {
    if (currentTween) {
      currentTween.stop();
    }

    var nodes = brushArgs.nodes = render.call.apply(render, [definitionContext].concat(_toConsumableArray$1(getRenderArgs()))); // Reset brush stylers and triggers

    brushStylers.forEach(function (b) {
      return b.cleanUp();
    });
    brushStylers.length = 0;
    brushTriggers.tap = [];
    brushTriggers.over = [];

    if (_settings.brush) {
      addBrushStylers();
      addBrushTriggers();
    }

    brushStylers.forEach(function (bs) {
      if (bs.isActive()) {
        bs.update();
      }
    });

    if (currentNodes && _settings.animations && _settings.animations.enabled) {
      currentTween = tween({
        old: currentNodes,
        current: nodes
      }, {
        renderer: rend
      }, _settings.animations);
      currentTween.start();
    } else {
      rend.render(nodes);
    }

    currentNodes = nodes;

    if (rend.setKey && typeof config.key === 'string') {
      rend.setKey(config.key);
    }
  };

  fn.updated = updated;

  fn.destroy = function () {
    fn.unmount();
    beforeDestroy(element);
    rend.destroy();
    destroyed();
    element = null;
  };
  /**
   * Update active nodes. For now this can be used as a way update and apply brushing on nodes.
   * Ex: if a component have changed the nodes since its initial render.
   * @param {Nodes[]} nodes
   * @deprecated
   * @ignore
   */


  var updateNodes = function updateNodes(nodes) {
    brushArgs.nodes = nodes;
    brushStylers.forEach(function (bs) {
      if (bs.isActive()) {
        bs.update();
      }
    });
    rend.render(nodes);
  }; // Set contexts, note that the definition and instance need different contexts (for example if they have different 'require' props)


  prepareContext(definitionContext, definition, {
    settings: function settings() {
      return _settings;
    },
    data: function data() {
      return _data;
    },
    scale: function scale() {
      return _scale;
    },
    formatter: function formatter() {
      return _formatter;
    },
    renderer: function renderer() {
      return rend;
    },
    chart: function chart() {
      return _chart;
    },
    dockConfig: function dockConfig() {
      return _dockConfig;
    },
    mediator: function mediator() {
      return _mediator;
    },
    instance: function instance() {
      return instanceContext;
    },
    rect: function rect() {
      return instanceContext.rect;
    },
    style: function style() {
      return _style;
    },
    update: function update() {
      return updateNodes;
    },
    registries: function registries() {
      return _registries;
    },
    resolver: function resolver() {
      return _resolver;
    },
    symbol: function symbol() {
      return create$3;
    }
  });
  prepareContext(instanceContext, config, {
    settings: function settings() {
      return _settings;
    },
    data: function data() {
      return _data;
    },
    scale: function scale() {
      return _scale;
    },
    formatter: function formatter() {
      return _formatter;
    },
    renderer: function renderer() {
      return rend;
    },
    chart: function chart() {
      return _chart;
    },
    dockConfig: function dockConfig() {
      return _dockConfig;
    },
    mediator: function mediator() {
      return _mediator;
    },
    style: function style() {
      return _style;
    },
    _DO_NOT_USE_getInfo: _DO_NOT_USE_getInfo.bind(definitionContext),
    isVisible: function isVisible() {
      return _isVisible;
    }
  });

  fn.getBrushedShapes = function getBrushedShapes(brushCtx, mode, props) {
    var shapes = [];

    if (_settings.brush && _settings.brush.consume) {
      var brusher = _chart.brush(brushCtx);

      var sceneNodes = rend.findShapes('*');

      _settings.brush.consume.filter(function (t) {
        return t.context === brushCtx;
      }).forEach(function (consume) {
        for (var i = 0; i < sceneNodes.length; i++) {
          var node = sceneNodes[i];

          if (node.data && brusher.containsMappedData(node.data, props || consume.data, mode)) {
            appendComponentMeta(node);
            shapes.push(node);
            sceneNodes.splice(i, 1);
            i--;
          }
        }
      });
    }

    return shapes;
  };

  fn.findShapes = function (selector) {
    var shapes = rend.findShapes(selector);

    for (var i = 0, num = shapes.length; i < num; i++) {
      appendComponentMeta(shapes[i]);
    }

    return shapes;
  };

  fn.shapesAt = function (shape) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var items = rend.itemsAt(shape);
    var shapes;

    if (opts && opts.propagation === 'stop' && items.length > 0) {
      shapes = [items.pop().node];
    } else {
      shapes = items.map(function (i) {
        return i.node;
      });
    }

    for (var i = 0, num = shapes.length; i < num; i++) {
      appendComponentMeta(shapes[i]);
    }

    return shapes;
  };

  fn.brushFromShapes = function (shapes) {
    var trigger = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    trigger.contexts = Array.isArray(trigger.contexts) ? trigger.contexts : [];
    var action = trigger.action || 'toggle';
    brushFromSceneNodes({
      nodes: shapes,
      action: action,
      trigger: trigger,
      chart: _chart,
      data: brushArgs.data
    });
  };

  fn.mount = function () {
    element = rend.element && rend.element() ? element : rend.appendTo(container);

    if (rend.setKey && typeof config.key === 'string') {
      rend.setKey(config.key);
    }

    if (_settings.brush) {
      addBrushStylers();
      addBrushTriggers();
    }

    setUpEmitter(instanceContext, emitter, config);
    setUpEmitter(definitionContext, emitter, definition);
    _isVisible = true;
  };

  fn.mounted = function () {
    return mounted(element);
  };

  fn.unmount = function () {
    [instanceContext, definitionContext].forEach(function (ctx) {
      tearDownEmitter(ctx, emitter);
    });
    brushTriggers.tap = [];
    brushTriggers.over = [];
    brushStylers.forEach(function (bs) {
      bs.cleanUp();
    });
    brushStylers.length = 0;
    beforeUnmount();
    _isVisible = false;
  };

  fn.onBrushTap = function (e) {
    brushTriggers.tap.forEach(function (t) {
      if (resolveTapEvent({
        e: e,
        t: t,
        config: brushArgs
      }) && t.globalPropagation === 'stop') {
        _chart.toggleBrushing(true);
      }
    });
  };

  fn.onBrushOver = function (e) {
    brushTriggers.over.forEach(function (t) {
      if (resolveOverEvent({
        e: e,
        t: t,
        config: brushArgs
      }) && t.globalPropagation === 'stop') {
        _chart.toggleBrushing(true);
      }
    });
  };
  /**
   * Expose definition on instance
   * @private
   * @experimental
   */


  fn.def = definitionContext;
  /**
   * Expose instanceCtx on "instance"
   * @private
   * @experimental
   */

  fn.ctx = instanceContext;

  fn.renderer = function () {
    return rend;
  };

  fn.set({
    settings: config
  });
  created();
  return fn;
}

function mediator() {
  var instance = {};
  EventEmitter$1.mixin(instance);
  return instance;
}

var EPSILON = 1e-12;
function closestPointToLine(start, end, p) {
  var startToPoint = sub(p, start);
  var startToEnd = sub(end, start);
  var pointOnLine = add$1(projectOnto(startToPoint, startToEnd), start);
  return pointOnLine;
}
function isPointOnLine(start, end, p) {
  return distance(start, p) + distance(end, p) - distance(start, end) < EPSILON;
}
/**
 * Check if rectangle a is located inside rectangle b or if they are the same rectangle.
 * @param {rect} a - An rect containing (x,y) coordinates, width and height. The origin is assumed to be top left.
 * @param {rect} b - An rect containing (x,y) coordinates, width and height. The origin is assumed to be top left.
 * @ignore
 */

function rectContainsRect(a, b) {
  return a.x >= b.x && a.x + a.width <= b.x + b.width && a.y >= b.y && a.y + a.height <= b.y + b.height;
}

function lineHasNoLength(line) {
  return line.x1 === line.x2 && line.y1 === line.y2;
}

function rectHasNoSize(rect) {
  return rect.width <= 0 || rect.height <= 0;
}

function circleHasNoSize(circle) {
  return circle.r <= 0;
}

function toFewEdges(polygon) {
  return polygon.edges.length <= 2;
}
/**
   * Test if a Circle contains a point. If so, returns true and false otherwise.
   * Circle muse have a radius greater then 0.
   * @private
   * @param {object} circle
   * @param {number} circle.cx - center x-coordinate
   * @param {number} circle.cy - center y-coordinate
   * @param {number} circle.r - circle radius
   * @param {object} point
   * @param {number} point.x - x-coordinate
   * @param {number} point.y - y-coordinate
   * @return {boolean} true if circle contains point
   */


function testCirclePoint(circle, point) {
  if (circleHasNoSize(circle)) {
    return false;
  }

  var center = {
    x: circle.cx,
    y: circle.cy
  };
  var sqrDist = sqrDistance(center, point);

  if (sqrDist <= Math.pow(circle.r, 2)) {
    return true;
  }

  return false;
}
/**
   * Test if a Circle collide with a rectangle. If so, returns true and false otherwise.
   * Circle muse have a radius greater then 0.
   * Rectangle must have a width and height greather then 0.
   * @private
   * @param {object} circle
   * @param {number} circle.cx - center x-coordinate
   * @param {number} circle.cy - center y-coordinate
   * @param {number} circle.r - circle radius
   * @param {object} rect
   * @param {number} rect.x - x-coordinate
   * @param {number} rect.y - y-coordinate
   * @param {number} rect.width - width
   * @param {number} rect.height - height
   * @return {boolean} true if circle collide with rectangle
  */

function testCircleRect(circle, rect) {
  if (rectHasNoSize(rect) || circleHasNoSize(circle)) {
    return false;
  }

  var rX = rect.width / 2;
  var rY = rect.height / 2;
  var rcX = rect.x + rX;
  var rcY = rect.y + rY;
  var r = circle.r;
  var cx = circle.cx;
  var cy = circle.cy;
  var dX = Math.abs(cx - rcX);
  var dY = Math.abs(cy - rcY);

  if (dX > rX + r || dY > rY + r) {
    return false;
  }

  if (dX <= rX || dY <= rY) {
    return true;
  }

  var sqrDist = Math.pow(dX - rX, 2) + Math.pow(dY - rY, 2);
  return sqrDist <= Math.pow(r, 2);
}
/**
   * Test if a Circle collide with a line segment. If so, returns true and false otherwise.
   * Circle muse have a radius greater then 0.
   * Line must have a length greater then 0.
   * @private
   * @param {object} circle
   * @param {number} circle.cx - center x-coordinate
   * @param {number} circle.cy - center y-coordinate
   * @param {number} circle.r - circle radius
   * @param {object} line
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @return {boolean} true if circle collide with line
  */

function testCircleLine(circle, line) {
  if (circleHasNoSize(circle) || lineHasNoLength(line)) {
    return false;
  }

  var _lineToPoints = lineToPoints(line),
      _lineToPoints2 = _slicedToArray(_lineToPoints, 2),
      p1 = _lineToPoints2[0],
      p2 = _lineToPoints2[1];

  if (testCirclePoint(circle, p1) || testCirclePoint(circle, p2)) {
    return true;
  }

  var center = {
    x: circle.cx,
    y: circle.cy
  };
  var pointOnLine = closestPointToLine(p1, p2, center);
  var dist = sqrDistance(pointOnLine, center);
  return dist <= Math.pow(circle.r, 2) && isPointOnLine(p1, p2, pointOnLine);
}
/**
   * Test if a Circle collide with another Circle. If so, returns true and false otherwise.
   * Both circles muse have a radius greater then 0.
   * @private
   * @param {object} circle
   * @param {number} circle.cx - center x-coordinate
   * @param {number} circle.cy - center y-coordinate
   * @param {number} circle.r - circle radius
   * @param {object} circle
   * @param {number} circle.cx - center x-coordinate
   * @param {number} circle.cy - center y-coordinate
   * @param {number} circle.r - circle radius
   * @return {boolean} true if circle collide with circle
  */

function testCircleCircle(circle1, circle2) {
  if (circleHasNoSize(circle1) || circleHasNoSize(circle2)) {
    return false;
  }

  var dx = circle1.cx - circle2.cx;
  var dy = circle1.cy - circle2.cy;
  var sqrDist = Math.pow(dx, 2) + Math.pow(dy, 2);

  if (sqrDist <= Math.pow(circle1.r + circle2.r, 2)) {
    return true;
  }

  return false;
}
/**
   * Test if a Circle collide with Polygon. If so, returns true and false otherwise.
   * Circle muse have a radius greater then 0.
   * Polygon must contain at least 2 vertices
   * @private
   * @param {object} circle
   * @param {number} circle.cx - center x-coordinate
   * @param {number} circle.cy - center y-coordinate
   * @param {number} circle.r - circle radius
   * @param {object} polygon
   * @param {Array} polygon.vertices - Array of vertices
   * @param {object} polygon.vertices.vertex
   * @param {number} polygon.vertices.vertex.x - x-coordinate
   * @param {number} polygon.vertices.vertex.y - y-coordinate
   * @param {Array} polygon.edges - Array of edges
   * @param {Array} polygon.edges.edge - Array of points
   * @param {object} polygon.edges.edge.point
   * @param {number} polygon.edges.edge.point.x - x-coordinate
   * @param {number} polygon.edges.edge.point.y - y-coordinate
   * @return {boolean} true if circle collide with polygon
  */

function testCirclePolygon(circle, polygon) {
  // TODO handle polygon that is a straight line, current impl will interrept it is a true, if radius is extended onto any of the edges
  if (toFewEdges(polygon) || circleHasNoSize(circle)) {
    return false;
  }

  var center = {
    x: circle.cx,
    y: circle.cy
  };

  if (testPolygonPoint(polygon, center)) {
    return true;
  }

  var num = polygon.edges.length;

  for (var i = 0; i < num; i++) {
    var edge = pointsToLine(polygon.edges[i]);

    if (testCircleLine(circle, edge)) {
      return true;
    }
  }

  return false;
}
/**
   * Test if a Polygon contains a Point. If so, returns true and false otherwise.
   * Polygon must contain at least 2 vertices
   * @private
   * @param {object} polygon
   * @param {Array} polygon.vertices - Array of vertices
   * @param {object} polygon.vertices.vertex
   * @param {number} polygon.vertices.vertex.x - x-coordinate
   * @param {number} polygon.vertices.vertex.y - y-coordinate
   * @param {Array} polygon.edges - Array of edges
   * @param {Array} polygon.edges.edge - Array of points
   * @param {object} polygon.edges.edge.point
   * @param {number} polygon.edges.edge.point.x - x-coordinate
   * @param {number} polygon.edges.edge.point.y - y-coordinate
   * @param {object} point
   * @param {number} point.x - x-coordinate
   * @param {number} point.y - y-coordinate
   * @return {boolean} true if polygon conatins point
  */

function testPolygonPoint(polygon, point) {
  // TODO handle polygon that is a straight line, current impl gives a non-deterministic output, that is depending on number of vertices
  if (toFewEdges(polygon) || !testRectPoint(polygon.boundingRect(), point)) {
    return false;
  }

  var even = true;
  var num = polygon.vertices.length;
  var rayStart = {
    x: polygon.xMin - 1,
    y: point.y
  };

  for (var i = 0; i < num - 1; i++) {
    var edge = pointsToLine(polygon.edges[i]);

    if (!(edge.y1 < point.y && edge.y2 < point.y) && !(edge.y1 > point.y && edge.y2 > point.y)) {
      // filterout any edges that does not cross the ray
      even = testLineLine(edge, pointsToLine([rayStart, point])) ? !even : even;
    }
  }

  return !even;
}
/**
   * Test if a Polygon collider with a line. If so, returns true and false otherwise.
   * Polygon must contain at least 3 edges.
   * Line must have length greater then 0.
   * @private
   * @param {object} polygon
   * @param {Array} polygon.vertices - Array of vertices
   * @param {object} polygon.vertices.vertex
   * @param {number} polygon.vertices.vertex.x - x-coordinate
   * @param {number} polygon.vertices.vertex.y - y-coordinate
   * @param {Array} polygon.edges - Array of edges
   * @param {Array} polygon.edges.edge - Array of points
   * @param {object} polygon.edges.edge.point
   * @param {number} polygon.edges.edge.point.x - x-coordinate
   * @param {number} polygon.edges.edge.point.y - y-coordinate
   * @param {object} line
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @return {boolean} true if polygon collider with line
  */

function testPolygonLine(polygon, line) {
  // TODO handle polygon that is a straight line, current impl gives a non-deterministic output, that is depending on number of vertices
  if (toFewEdges(polygon)) {
    return false;
  }

  for (var i = 0, num = polygon.edges.length; i < num; i++) {
    var edge = pointsToLine(polygon.edges[i]);

    if (testLineLine(line, edge)) {
      return true;
    }
  }

  var _lineToPoints3 = lineToPoints(line),
      _lineToPoints4 = _slicedToArray(_lineToPoints3, 2),
      p1 = _lineToPoints4[0],
      p2 = _lineToPoints4[1];

  return testPolygonPoint(polygon, p1) || testPolygonPoint(polygon, p2);
}
/**
   * Test if a Polygon collider with a rectangle. If so, returns true and false otherwise.
   * Polygon must contain at least 3 edges.
   * Rectangle must width and height greater then 0.
   * @private
   * @param {object} polygon
   * @param {Array} polygon.vertices - Array of vertices
   * @param {object} polygon.vertices.vertex
   * @param {number} polygon.vertices.vertex.x - x-coordinate
   * @param {number} polygon.vertices.vertex.y - y-coordinate
   * @param {Array} polygon.edges - Array of edges
   * @param {Array} polygon.edges.edge - Array of points
   * @param {object} polygon.edges.edge.point
   * @param {number} polygon.edges.edge.point.x - x-coordinate
   * @param {number} polygon.edges.edge.point.y - y-coordinate
   * @param {object} rect
   * @param {number} rect.x - x-coordinate
   * @param {number} rect.y - y-coordinate
   * @param {number} rect.width - width
   * @param {number} rect.height - height
   * @return {boolean} true if polygon collider with rect
  */

function testPolygonRect(polygon, rect) {
  // TODO handle polygon that is a straight line, current impl gives a non-deterministic output, that is depending on number of vertices
  if (toFewEdges(polygon)) {
    return false;
  }

  for (var i = 0, num = polygon.edges.length; i < num; i++) {
    var edge = pointsToLine(polygon.edges[i]);

    if (testRectLine(rect, edge)) {
      return true;
    }
  }

  var _rectToPoints = rectToPoints(rect),
      _rectToPoints2 = _slicedToArray(_rectToPoints, 4),
      p1 = _rectToPoints2[0],
      p2 = _rectToPoints2[1],
      p3 = _rectToPoints2[2],
      p4 = _rectToPoints2[3];

  return testPolygonPoint(polygon, p1) || testPolygonPoint(polygon, p2) || testPolygonPoint(polygon, p3) || testPolygonPoint(polygon, p4);
}
/**
   * Test if a Rectangle collide with another rectangle. If so, returns true and false otherwise.
   * Both rectangles must have a width and height greather then 0.
   * @private
   * @param {object} rect
   * @param {number} rect.x - x-coordinate
   * @param {number} rect.y - y-coordinate
   * @param {number} rect.width - width
   * @param {number} rect.height - height
   * @param {object} rect
   * @param {number} rect.x - x-coordinate
   * @param {number} rect.y - y-coordinate
   * @param {number} rect.width - width
   * @param {number} rect.height - height
   * @return {boolean} true if rectangle collide with rectangle
  */

function testRectRect(rect1, rect2) {
  if (rectHasNoSize(rect1) || rectHasNoSize(rect2)) {
    return false;
  }

  return rect1.x <= rect2.x + rect2.width && rect2.x <= rect1.x + rect1.width && rect1.y <= rect2.y + rect2.height && rect2.y <= rect1.y + rect1.height;
}
/**
   * Test if a Rectangle contains a Point. If so, returns true and false otherwise.
   * Rectangle must have a width and height greather then 0.
   * @private
   * @param {object} rect
   * @param {number} rect.x - x-coordinate
   * @param {number} rect.y - y-coordinate
   * @param {number} rect.width - width
   * @param {number} rect.height - height
   * @param {object} point
   * @param {number} point.x - x-coordinate
   * @param {number} point.y - y-coordinate
   * @return {boolean} true if rectangle contains point
  */

function testRectPoint(rect, point) {
  if (rectHasNoSize(rect)) {
    return false;
  }

  return point.x >= rect.x && point.x <= rect.x + rect.width && point.y >= rect.y && point.y <= rect.y + rect.height;
}
/**
   * Test if a Rectangle collider with a line. If so, returns true and false otherwise.
   * Rectangle must have a width and height greather then 0.
   * Line must have length greater then 0.
   * @private
   * @param {object} rect
   * @param {number} rect.x - x-coordinate
   * @param {number} rect.y - y-coordinate
   * @param {number} rect.width - width
   * @param {number} rect.height - height
   * @param {object} line
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @return {boolean} true if rectangle collide with line
  */

function testRectLine(rect, line) {
  if (lineHasNoLength(line) || rectHasNoSize(rect)) {
    return false;
  }

  var _lineToPoints5 = lineToPoints(line),
      _lineToPoints6 = _slicedToArray(_lineToPoints5, 2),
      p1 = _lineToPoints6[0],
      p2 = _lineToPoints6[1];

  if (testRectPoint(rect, p1) || testRectPoint(rect, p2)) {
    return true;
  }

  var rectEdges = rectToPoints(rect);
  var num = rectEdges.length;

  for (var i = 0; i < num; i++) {
    var edge = pointsToLine([rectEdges[i], rectEdges[i !== 3 ? i + 1 : 0]]);

    if (testLineLine(edge, line)) {
      return true;
    }
  }

  return false;
}
/**
   * Test if a Line collider with another line. If so, returns true and false otherwise.
   * Both lines must have length greater then 0.
   * @private
   * @param {object} line
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @param {object} line
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @return {boolean} true if line collide with line
  */

function testLineLine(line1, line2) {
  var _lineToPoints7 = lineToPoints(line1),
      _lineToPoints8 = _slicedToArray(_lineToPoints7, 2),
      p1 = _lineToPoints8[0],
      p2 = _lineToPoints8[1];

  var _lineToPoints9 = lineToPoints(line2),
      _lineToPoints10 = _slicedToArray(_lineToPoints9, 2),
      p3 = _lineToPoints10[0],
      p4 = _lineToPoints10[1];

  var dx1 = distanceX(p2, p1);
  var dy1 = distanceY(p2, p1);
  var dx2 = distanceX(p4, p3);
  var dy2 = distanceY(p4, p3);
  var dx3 = distanceX(p1, p3);
  var dy3 = distanceY(p1, p3);
  var ub = dy2 * dx1 - dx2 * dy1;
  var uat = dx2 * dy3 - dy2 * dx3;
  var ubt = dx1 * dy3 - dy1 * dx3;
  var t1;
  var t2;

  if (dx1 === 0 && dy1 === 0) {
    // Line segment has no length
    return false;
  }

  if (dx2 === 0 && dy2 === 0) {
    // Line segment has no length
    return false;
  }

  if (ub === 0) {
    if (uat === 0 && ubt === 0) {
      // COINCIDENT;
      if (dx1 === 0) {
        if (dy1 === 0) {
          // p1 = p2
          return p1.x === p2.x && p1.y === p2.y;
        }

        t1 = distanceY(p3, p1) / dy1;
        t2 = distanceY(p4, p1) / dy1;
      } else {
        t1 = (p3.x - p1.x) / dx1;
        t2 = (p4.x - p1.x) / dx1;
      }

      if (t1 < 0 && t2 < 0 || t1 > 1 && t2 > 1) {
        return false;
      }

      return true;
    }

    return false; // PARALLEL;
  }

  var ua = uat / ub;
  ub = ubt / ub;

  if (ua >= 0.0 && ua <= 1.0 && ub >= 0.0 && ub <= 1.0) {
    return true;
  }

  return false;
}
/**
   * Test if a Line contains a Point. If so, returns true and false otherwise.
   * Line must have length greater then 0.
   * @private
   * @param {object} line
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @param {object} point
   * @param {number} point.x - x-coordinate
   * @param {number} point.y - y-coordinate
   * @return {boolean} true if line contains point
  */

function testLinePoint(line, point) {
  if (lineHasNoLength(line)) {
    return false;
  }

  var _lineToPoints11 = lineToPoints(line),
      _lineToPoints12 = _slicedToArray(_lineToPoints11, 2),
      p1 = _lineToPoints12[0],
      p2 = _lineToPoints12[1];

  return isPointOnLine(p1, p2, point);
}

var VARIABLE_RX = /^\$/;
var EXTEND = '@extend';

function throwCyclical(s) {
  throw new Error("Cyclical reference for \"".concat(s, "\""));
}

function res(style, references, path) {
  if (typeof style === 'string') {
    var value = references[style];

    if (path.indexOf(style) !== -1) {
      throwCyclical(style);
    }

    if (VARIABLE_RX.test(value)) {
      path.push(style);
      return res(value, references, path);
    }

    return value;
  }

  var computed = style;
  var refs = extend(true, {}, references, style);
  var s = {};

  if (style[EXTEND]) {
    var extendFrom = style[EXTEND];

    if (path.indexOf(extendFrom) !== -1) {
      throwCyclical(extendFrom);
    }

    var pext = path.slice();
    pext.push(extendFrom);
    computed = extend(true, {}, res(refs[extendFrom], references, pext), style);
  }

  Object.keys(computed).forEach(function (key) {
    var p = path.slice();

    if (key === EXTEND || VARIABLE_RX.test(key)) {
      return;
    }

    s[key] = computed[key];
    var value = s[key];

    if (VARIABLE_RX.test(value) && value in refs) {
      if (path.indexOf(value) !== -1) {
        throwCyclical(value);
      }

      p.push(value);
      value = refs[value];

      if (_typeof(value) === 'object') {
        s[key] = res(value, refs, p);
      } else if (VARIABLE_RX.test(value) && value in refs) {
        s[key] = res(value, refs, p);
      } else {
        s[key] = value;
      }
    } else if (_typeof(value) === 'object') {
      s[key] = res(value, refs, p);
    }
  });
  return s;
}
/**
 * Resolve style references
 * @private
 * @param {style-object} style
 * @param {style-object} references
 * @returns {object} The resolved style
 * @example
 * resolve({
 *   label: '$label--big'
 * }, {
 *   '$size--m': '12px',
 *   '$label--big': {
 *     fontFamily: 'Arial',
 *     fontSize: '$size--m'
 *   }
 * }); // { label: { fontFamily: 'Arial', fontSize: '12px' } }
 */


function resolve(style, references) {
  return res(style, references, []);
}

function themeFn() {
  var _style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var palettes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var pals = {};

  var setPalettes = function setPalettes(p) {
    p.forEach(function (palette) {
      var pal = Array.isArray(palette.colors[0]) ? palette.colors : [palette.colors];
      pals[palette.key] = {
        colors: pal,
        sizes: pal.map(function (colors) {
          return colors ? colors.length : 0;
        })
      };
    });
  };

  var getPalette = function getPalette(key, num) {
    var palette = pals[key];

    if (!palette) {
      return [];
    }

    var sizes = palette.sizes; // find the first color set containing at least 'num' colors

    for (var i = 0; i < sizes.length; i++) {
      if (num <= sizes[i]) {
        return palette.colors[i];
      }
    }

    return palette.colors[sizes.length - 1];
  };
  /**
   * Theme API
   * @private
   * @experimental
   */


  var theme = {
    /**
     * Get an array of colors
     * @param {string} name - Name of the color palette
     * @param {number} [num] - The minimum number of colors to get from the palette
     */
    palette: function palette(name, num) {
      return getPalette(name, num);
    },
    setPalettes: setPalettes,

    /**
     * Resolve style references
     * @param {style-object} s - Object containing
     */
    style: function style(s) {
      return resolve(s, _style);
    }
  };
  setPalettes(palettes);
  return theme;
}

/**
 * @typedef {object} component-settings
 * @property {string} type - Component type (ex: axis, point, ...)
 * @property {function} [preferredSize] - Function returning the preferred size
 * @property {function} [created]
 * @property {function} [beforeMount]
 * @property {function} [mounted]
 * @property {function} [beforeUpdate]
 * @property {function} [updated]
 * @property {function} [beforeRender]
 * @property {function} [beforeDestroy]
 * @property {function} [destroyed]
 * @property {brush-setting} [brush] see [brushing](./brushing.md)
 * @property {object} [layout] Layout settings
 * @property {number} [layout.displayOrder = 0]
 * @property {number} [layout.prioOrder = 0]
 * @property {string | {width: string, height: string}} [layout.minimumLayoutMode] Refer to layout sizes defined by layoutModes in `strategy`
 * @property {string} [layout.dock] left, right, top or bottom
 * @property {boolean} [show = true] If the component should be rendered
 * @property {string} [scale] Named scale. Will be provided to the component if it ask for it.
 * @property {string} [formatter] Named formatter. Fallback to create formatter from scale. Will be provided to the component if it ask for it.
 */

function addComponentDelta(shape, containerBounds, componentBounds) {
  var dx = containerBounds.left - componentBounds.left;
  var dy = containerBounds.top - componentBounds.top;
  var type = getShapeType(shape);
  var deltaShape = extend(true, {}, shape);

  switch (type) {
    case 'circle':
      deltaShape.cx += dx;
      deltaShape.cy += dy;
      break;

    case 'polygon':
      for (var i = 0, num = deltaShape.vertices.length; i < num; i++) {
        var v = deltaShape.vertices[i];
        v.x += dx;
        v.y += dy;
      }

      break;

    case 'line':
      deltaShape.x1 += dx;
      deltaShape.y1 += dy;
      deltaShape.x2 += dx;
      deltaShape.y2 += dy;
      break;

    case 'point':
    case 'rect':
      deltaShape.x += dx;
      deltaShape.y += dy;
      break;

    default:
      break;
  }

  return deltaShape;
}

var moveToPosition = function moveToPosition(element, comp, index) {
  var el = comp.instance.renderer().element();

  if (isNaN(index) || !el || !element || !element.children) {
    return;
  }

  var nodes = element.children;
  var i = Math.max(0, index);
  var node = nodes[i];

  if (el === node) {
    return;
  }

  var additionalEl = comp.instance.def.additionalElements && comp.instance.def.additionalElements().filter(Boolean);

  if (element.insertBefore && typeof node !== 'undefined') {
    element.insertBefore(el, node);

    if (additionalEl) {
      additionalEl.forEach(function (ae) {
        element.insertBefore(ae, el);
      });
    }
  } else {
    if (additionalEl) {
      additionalEl.forEach(function (ae) {
        element.appendChild(ae, el);
      });
    }

    element.appendChild(el);
  }
};

function orderComponents(element, visibleComponents, order) {
  var elToIdx = [];
  var numElements = 0;
  var ordered = order ? visibleComponents.slice().sort(function (a, b) {
    return order[visibleComponents.indexOf(a)] - order[visibleComponents.indexOf(b)];
  }) : visibleComponents;
  ordered.forEach(function (comp) {
    elToIdx.push(numElements); // assume each component has at least one element

    numElements++; // check additional elements

    var additionalEl = comp.instance.def.additionalElements && comp.instance.def.additionalElements();

    if (additionalEl) {
      numElements += additionalEl.length;
    }
  });
  ordered.forEach(function (comp, i) {
    return moveToPosition(element, comp, elToIdx[i]);
  });
}

function chartFn(definition, context) {
  /**
   * @typedef {object} chart-definition
   */
  var element = definition.element,
      _definition$data = definition.data,
      data = _definition$data === void 0 ? [] : _definition$data,
      _definition$settings = definition.settings,
      settings = _definition$settings === void 0 ? {} : _definition$settings,
      _definition$on = definition.on,
      on = _definition$on === void 0 ? {} : _definition$on;
  var registries = context.registries;
  var logger = context.logger;
  var theme = themeFn(context.style, context.palettes);
  var listeners = [];
  /**
   * @alias chart
   * @interface
   */

  var instance = extend({}, definition);
  var mediator$1 = mediator();
  var currentComponents = []; // Augmented components

  var visibleComponents = [];
  var currentScales = null; // Built scales

  var currentFormatters = null; // Built formatters

  var currentScrollApis = null; // Build scroll apis

  var currentInteractions = [];

  var dataset = function dataset() {};

  var dataCollection = function dataCollection() {};

  var brushes = {};
  var stopBrushing = false;

  var createComponent = function createComponent(compSettings, container) {
    if (!registries.component.has(compSettings.type)) {
      logger.warn("Unknown component: ".concat(compSettings.type));
      return false;
    }

    var componentDefinition = registries.component(compSettings.type);
    var compInstance = componentFactory(componentDefinition, {
      settings: compSettings,
      chart: instance,
      mediator: mediator$1,
      registries: registries,
      theme: theme,
      container: container
    });
    return {
      instance: compInstance,
      settings: extend(true, {}, compSettings),
      key: compSettings.key,
      hasKey: typeof compSettings.key !== 'undefined'
    };
  }; // Create a callback that calls lifecycle functions in the definition and config (if they exist).


  function createCallback(method) {
    var defaultMethod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};
    return function cb() {
      var inDefinition = typeof definition[method] === 'function';
      var returnValue;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (inDefinition) {
        var _definition$method;

        returnValue = (_definition$method = definition[method]).call.apply(_definition$method, [instance].concat(args));
      } else {
        returnValue = defaultMethod.call.apply(defaultMethod, [instance].concat(args));
      }

      return returnValue;
    };
  }

  var findComponent = function findComponent(componentInstance) {
    for (var i = 0; i < currentComponents.length; i++) {
      if (currentComponents[i].instance === componentInstance) {
        return currentComponents[i];
      }
    }

    return null;
  };

  var findComponentIndexByKey = function findComponentIndexByKey(key) {
    for (var i = 0; i < currentComponents.length; i++) {
      var currComp = currentComponents[i];

      if (currComp.hasKey && currComp.key === key) {
        return i;
      }
    }

    return -1;
  };

  function getElementRect(el) {
    if (typeof el.getBoundingClientRect === 'function') {
      var _el$getBoundingClient = el.getBoundingClientRect(),
          width = _el$getBoundingClient.width,
          height = _el$getBoundingClient.height;

      return {
        x: 0,
        y: 0,
        width: width,
        height: height
      };
    }

    return {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  }

  var layout = function layout(components) {
    var vcomponents = components.map(function (c) {
      var dockConfig = c.instance.dockConfig();
      return {
        instance: c.instance,
        resize: c.instance.resize,
        preferredSize: dockConfig.computePreferredSize.bind(dockConfig),
        settings: c.settings,
        layoutComponents: function layoutComponents() {}
      };
    });
    var layoutSettings;

    if (settings.dockLayout) {
      logger.warn('Deprecation Warning: "dockLayout" property should be renamed to "strategy"');
      layoutSettings = settings.dockLayout;
    } else {
      layoutSettings = settings.strategy;
    }

    var dockLayout$1 = dockLayout(layoutSettings);
    var rect = getElementRect(element);

    var _dockLayout$layout = dockLayout$1.layout(rect, vcomponents),
        visible = _dockLayout$layout.visible,
        hidden = _dockLayout$layout.hidden,
        order = _dockLayout$layout.order;

    return {
      visible: visible.map(function (v) {
        return findComponent(v.instance);
      }),
      hidden: hidden.map(function (h) {
        return findComponent(h.instance);
      }),
      order: order
    };
  };

  var created = createCallback('created');
  var beforeMount = createCallback('beforeMount');
  var mounted = createCallback('mounted');
  var beforeUpdate = createCallback('beforeUpdate');
  var updated = createCallback('updated');
  var beforeRender = createCallback('beforeRender');
  var beforeDestroy = createCallback('beforeDestroy');
  var destroyed = createCallback('destroyed');

  var set = function set(_data, _settings) {
    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        partialData = _ref.partialData;

    var _settings$formatters = _settings.formatters,
        formatters = _settings$formatters === void 0 ? {} : _settings$formatters,
        _settings$scales = _settings.scales,
        scales = _settings$scales === void 0 ? {} : _settings$scales,
        _settings$scroll = _settings.scroll,
        scroll = _settings$scroll === void 0 ? {} : _settings$scroll;
    dataset = datasets(_data, {
      logger: logger,
      types: registries.data
    });

    if (!partialData) {
      Object.keys(brushes).forEach(function (b) {
        return brushes[b].clear();
      });
    }

    if (_settings.palettes) {
      theme.setPalettes(_settings.palettes);
    }

    dataCollection = create(_settings.collections, {
      dataset: dataset
    }, {
      logger: logger
    });
    var deps = {
      theme: theme,
      logger: logger
    };
    currentScales = collection$1(scales, {
      dataset: dataset,
      collection: dataCollection
    }, _objectSpread({}, deps, {
      scale: registries.scale
    }));
    currentFormatters = collection(formatters, {
      dataset: dataset,
      collection: dataCollection
    }, _objectSpread({}, deps, {
      formatter: registries.formatter
    }));
    currentScrollApis = builder(scroll, currentScrollApis);
  };

  var render = function render() {
    var _settings2 = settings,
        _settings2$components = _settings2.components,
        components = _settings2$components === void 0 ? [] : _settings2$components;
    beforeRender();
    set(data, settings);
    currentComponents = components.map(function (compSettings) {
      return createComponent(compSettings, element);
    }).filter(function (c) {
      return !!c;
    });

    var _layout = layout(currentComponents),
        visible = _layout.visible,
        hidden = _layout.hidden,
        order = _layout.order;

    visibleComponents = visible;
    hidden.forEach(function (comp) {
      comp.instance.hide();
      comp.visible = false;
    });
    visible.forEach(function (comp) {
      return comp.instance.beforeMount();
    });
    visible.forEach(function (comp) {
      return comp.instance.mount();
    });
    visible.forEach(function (comp) {
      return comp.instance.beforeRender();
    });
    visible.forEach(function (comp) {
      return comp.instance.render();
    });
    visible.forEach(function (comp) {
      return comp.instance.mounted();
    });
    visible.forEach(function (comp) {
      comp.visible = true;
    });
    orderComponents(element, visibleComponents, order);
  };

  function setInteractions() {
    var interactions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var current = {};
    var newKeys = interactions.filter(function (it) {
      return !!it.key;
    }).map(function (it) {
      return it.key;
    });
    currentInteractions.forEach(function (cit) {
      if (cit.key && newKeys.indexOf(cit.key) !== -1) {
        // keep old instance
        current[cit.key] = cit;
      } else {
        cit.destroy();
      }
    });
    currentInteractions = interactions.map(function (intSettings) {
      var intDefinition = intSettings.key && current[intSettings.key] ? current[intSettings.key] : registries.interaction(intSettings.type)(instance, mediator$1, element);
      intDefinition.set(intSettings);
      return intDefinition;
    });
  }

  var componentsFromPoint = function componentsFromPoint(p) {
    var br = element.getBoundingClientRect();
    var x = 'clientX' in p ? p.clientX : p.x;
    var y = 'clientY' in p ? p.clientY : p.y;
    var tp = {
      x: x - br.left,
      y: y - br.top
    };
    var ret = [];
    visibleComponents.forEach(function (c) {
      var r = c.instance.getRect(); // Do test on physical rect and use computed rect if available, otherwise fallback to computing a new rect for legacy support

      if (testRectPoint(r.computedPhysical ? r.computedPhysical : {
        x: r.margin.left + r.x * r.scaleRatio.x,
        y: r.margin.top + r.y * r.scaleRatio.y,
        width: r.width * r.scaleRatio.x,
        height: r.height * r.scaleRatio.y
      }, tp)) {
        ret.push(c);
      }
    });
    return ret;
  };

  var addDefaultEventListeners = function addDefaultEventListeners() {
    if (listeners.length || !element) {
      return;
    }

    Object.keys(on).forEach(function (key) {
      var listener = on[key].bind(instance);
      element.addEventListener(key, listener);
      listeners.push({
        key: key,
        listener: listener
      });
    });
    var eventInfo = {};

    var onTapDown = function onTapDown(e) {
      if (e.touches) {
        eventInfo.x = e.touches[0].clientX;
        eventInfo.y = e.touches[0].clientY;
        eventInfo.multiTouch = e.touches.length > 1;
      } else {
        eventInfo.x = e.clientX;
        eventInfo.y = e.clientY;
        eventInfo.multiTouch = false;
      }

      eventInfo.time = Date.now();
      eventInfo.comps = componentsFromPoint(eventInfo);
    };

    var onBrushTap = function onBrushTap(e) {
      var comps = eventInfo.comps || componentsFromPoint(e);

      if (comps.every(function (c) {
        return c.instance.def.disableTriggers;
      })) {
        return;
      }

      if (e.type === 'touchend') {
        e.preventDefault();
      }

      if (!isValidTapEvent(e, eventInfo)) {
        return;
      }

      for (var i = comps.length - 1; i >= 0; i--) {
        var comp = comps[i];
        comp.instance.onBrushTap(e);

        if (stopBrushing) {
          stopBrushing = false;
          break;
        }
      }
    };

    var onBrushOver = function onBrushOver(e) {
      var comps = componentsFromPoint(e);

      for (var i = comps.length - 1; i >= 0; i--) {
        var comp = comps[i];
        comp.instance.onBrushOver(e);

        if (stopBrushing) {
          stopBrushing = false;
          break;
        }
      }
    };

    var brushEventList = [];
    brushEventList.push({
      key: 'mousedown',
      listener: onTapDown
    });
    brushEventList.push({
      key: 'mouseup',
      listener: onBrushTap
    });

    if (detectTouchSupport(element)) {
      brushEventList.push({
        key: 'touchstart',
        listener: onTapDown
      });
      brushEventList.push({
        key: 'touchend',
        listener: onBrushTap
      });
    }

    brushEventList.push({
      key: 'mousemove',
      listener: onBrushOver
    });
    brushEventList.forEach(function (event) {
      element.addEventListener(event.key, event.listener);
      listeners.push(event);
    });
  };

  var removeDefaultEventListeners = function removeDefaultEventListeners() {
    listeners.forEach(function (_ref2) {
      var key = _ref2.key,
          listener = _ref2.listener;
      return element.removeEventListener(key, listener);
    });
    listeners.length = 0;
  }; // Browser only


  var mount = function mount() {
    element.innerHTML = '';
    render();
    addDefaultEventListeners();
    setInteractions(settings.interactions);
  };

  var unmount = function unmount() {
    removeDefaultEventListeners();
    setInteractions();
  };
  /**
   * Update the chart with new settings and / or data
   * @param {chart-definition} [chart] - Chart definition
   */


  instance.update = function () {
    var newProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var partialData = newProps.partialData,
        _newProps$excludeFrom = newProps.excludeFromUpdate,
        excludeFromUpdate = _newProps$excludeFrom === void 0 ? [] : _newProps$excludeFrom;
    var visibleOrder;

    if (newProps.data) {
      data = newProps.data;
    }

    if (newProps.settings) {
      settings = newProps.settings;
      setInteractions(newProps.settings.interactions);
    }

    beforeUpdate();
    set(data, settings, {
      partialData: partialData
    });
    var _settings3 = settings,
        formatters = _settings3.formatters,
        scales = _settings3.scales,
        _settings3$components = _settings3.components,
        components = _settings3$components === void 0 ? [] : _settings3$components;

    var _loop = function _loop(i) {
      var currComp = currentComponents[i]; // TODO warn when there is no key

      if (!components.some(function (c) {
        return currComp.hasKey && currComp.key === c.key;
      })) {
        // Component is removed
        currentComponents.splice(i, 1);
        currComp.instance.destroy();
      }
    };

    for (var i = currentComponents.length - 1; i >= 0; i--) {
      _loop(i);
    } // Let the "components" array determine order of components


    currentComponents = components.map(function (comp) {
      var idx = findComponentIndexByKey(comp.key); // Component should not be updated

      if (excludeFromUpdate.indexOf(comp.key) > -1) {
        return currentComponents[idx];
      }

      if (idx === -1) {
        // Component is added
        return createComponent(comp, element);
      } // Component is (potentially) updated


      currentComponents[idx].updateWith = {
        formatters: formatters,
        scales: scales,
        data: data,
        settings: comp
      };
      return currentComponents[idx];
    }).filter(function (c) {
      return !!c;
    });
    currentComponents.forEach(function (comp) {
      if (comp.updateWith) {
        comp.instance.set(comp.updateWith);
      }
    });
    currentComponents.forEach(function (comp) {
      if (comp.updateWith) {
        comp.instance.beforeUpdate();
      }
    });
    var toUpdate = [];
    var toRender = [];
    var toRenderOrUpdate;

    if (partialData) {
      currentComponents.forEach(function (comp) {
        if (comp.updateWith && comp.visible) {
          toUpdate.push(comp);
        }
      });
      toRenderOrUpdate = toUpdate;
    } else {
      var _layout2 = layout(currentComponents),
          visible = _layout2.visible,
          hidden = _layout2.hidden,
          order = _layout2.order; // Relayout


      visibleComponents = visible;
      toRenderOrUpdate = visible;
      visibleOrder = order;
      visible.forEach(function (comp) {
        if (comp.updateWith && comp.visible) {
          toUpdate.push(comp);
        } else {
          toRender.push(comp);
        }
      });
      hidden.forEach(function (comp) {
        comp.instance.hide();
        comp.visible = false;
        delete comp.updateWith;
      });
    }

    toRender.forEach(function (comp) {
      return comp.instance.beforeMount();
    });
    toRender.forEach(function (comp) {
      return comp.instance.mount();
    });
    toRenderOrUpdate.forEach(function (comp) {
      return comp.instance.beforeRender();
    });
    toRenderOrUpdate.forEach(function (comp) {
      if (comp.updateWith && comp.visible) {
        comp.instance.update();
      } else {
        comp.instance.render();
      }
    }); // Ensure that displayOrder is keept, only do so on re-layout update.
    // Which is only the case if partialData is false.

    if (!partialData) {
      orderComponents(element, visibleComponents, visibleOrder);
    }

    toRender.forEach(function (comp) {
      return comp.instance.mounted();
    });
    toUpdate.forEach(function (comp) {
      return comp.instance.updated();
    });
    visibleComponents.forEach(function (comp) {
      delete comp.updateWith;
      comp.visible = true;
    });
    updated();
  };
  /**
   * Destroy the chart instance.
   */


  instance.destroy = function () {
    beforeDestroy();
    currentComponents.forEach(function (comp) {
      return comp.instance.destroy();
    });
    currentComponents = [];
    unmount();
    delete instance.update;
    delete instance.destroy;
    destroyed();
  };
  /**
   * Get all shapes associated with the provided context
   * @param {string} context The brush context
   * @param {string} mode Property comparasion mode.
   * @param {Array<string>} props Which specific data properties to compare
   * @param {string} key Which component to get shapes from. Default gives shapes from all components.
   * @return {Array<object>} Array of objects containing shape and parent element
   */


  instance.getAffectedShapes = function (ctx) {
    var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'and';
    var props = arguments.length > 2 ? arguments[2] : undefined;
    var key = arguments.length > 3 ? arguments[3] : undefined;
    var shapes = [];
    currentComponents.filter(function (comp) {
      return key === undefined || key === null || comp.key === key;
    }).forEach(function (comp) {
      shapes.push.apply(shapes, _toConsumableArray$1(comp.instance.getBrushedShapes(ctx, mode, props)));
    });
    return shapes;
  };
  /**
   * Get all nodes matching the provided selector
   * @param {string} selector CSS selector [type, attribute, universal, class]
   * @returns {Array<SceneNode>} Array of objects containing matching nodes
   *
   * @example
   * chart.findShapes('Circle') // [<CircleNode>, <CircleNode>]
   * chart.findShapes('Circle[fill="red"][stroke!="black"]') // [CircleNode, CircleNode]
   * chart.findShapes('Container Rect') // [Rect, Rect]
   */


  instance.findShapes = function (selector) {
    var shapes = [];
    visibleComponents.forEach(function (c) {
      shapes.push.apply(shapes, _toConsumableArray$1(c.instance.findShapes(selector)));
    });
    return shapes;
  };
  /**
   * Get components overlapping a point.
   * @param {point} p - Point with x- and y-cooridnate. The coordinate is relative to the browser viewport.
   * @returns {Array<component-context>} Array of component contexts
   */


  instance.componentsFromPoint = function (p) {
    return componentsFromPoint(p).map(function (comp) {
      return comp.instance.ctx;
    });
  };
  /**
   * Get all nodes colliding with a geometrical shape (circle, line, rectangle, point, polygon).
   *
   * The input shape is identified based on the geometrical attributes in the following order: circle => line => rectangle => point => polygon.
   * Note that not all nodes on a scene have collision detection enabled.
   * @param {line|rect|point|circle} shape - A geometrical shape. Coordinates are relative to the top-left corner of the chart instance container.
   * @param {object} opts - Options
   * @param {object[]} [opts.components] - Array of components to include in the lookup. If no components are specified, all components will be included.
   * @param {string} [opts.components[].component.key] - Component key
   * @param {string} [opts.components[].component.propagation] - if set to `stop`, will start lookup on top visible shape and propagate downwards until a shape is found.
   * @param {string} [opts.propagation] - if set to `stop`, will start lookup on top visible component and propagate downwards until a component has at least a match.
   * @returns {Array<SceneNode>} Array of objects containing colliding nodes
   *
   * @example
   * chart.shapesAt(
   *  {
   *    x: 0,
   *    y: 0,
   *    width: 100,
   *    height: 100
   *  },
   *  {
   *    components: [
   *      { key: 'key1', propagation: 'stop' },
   *      { key: 'key2' }
   *    ],
   *    propagation: 'stop'
   *  }
   * );
   */


  instance.shapesAt = function (shape) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var result = [];
    var containerBounds = element.getBoundingClientRect();
    var comps = visibleComponents; // Assume that visibleComponents is ordererd according to displayOrder

    if (Array.isArray(opts.components) && opts.components.length > 0) {
      var compKeys = opts.components.map(function (c) {
        return c.key;
      });
      comps = visibleComponents.filter(function (c) {
        return compKeys.indexOf(c.key) !== -1;
      }).map(function (c) {
        return {
          instance: c.instance,
          opts: opts.components[compKeys.indexOf(c.key)]
        };
      });
    }

    for (var i = comps.length - 1; i >= 0; i--) {
      var c = comps[i];
      var componentBounds = c.instance.renderer().element().getBoundingClientRect();
      var deltaShape = addComponentDelta(shape, containerBounds, componentBounds);
      var shapes = c.instance.shapesAt(deltaShape, c.opts);
      var stopPropagation = shapes.length > 0 && opts.propagation === 'stop';
      result.push.apply(result, _toConsumableArray$1(shapes));

      if (result.length > 0 && stopPropagation) {
        return result;
      }
    }

    return result;
  };
  /**
   * Brush data by providing a collection of data bound shapes.
   * @param {SceneNode[]} shapes - An array of data bound shapes.
   * @param {object} config - Options
   * @param {Array<object>} opts.components - Array of components to include in the lookup.
   * @param {string} [opts.components.component.key] - Component key
   * @param {Array<string>} [opts.components.component.contexts] - Name of the brushing contexts to affect
   * @param {Array<string>} [opts.components.component.data] - The mapped data properties to add to the brush
   * @param {string} [opts.components.component.action] - Type of action to respond with
   *
   * @example
   * const shapes = chartInstance.shapesAt(...);
   * const config = {
   *  components:[
   *    {
   *      key: 'key1',
   *      contexts: ['myContext'],
   *      data: [''],
   *      action: 'add'
   *    }
   *  ]
   * };
   * chartInstance.brushFromShapes(shapes, config);
   */


  instance.brushFromShapes = function (shapes) {
    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      components: []
    };

    var _loop2 = function _loop2(i) {
      var iKey = config.components[i].key;
      visibleComponents.filter(function (c) {
        return iKey === c.key;
      }).forEach(function (c) {
        var compShapes = shapes.filter(function (shape) {
          return shape.key === c.key;
        });
        c.instance.brushFromShapes(compShapes, config.components[i]);
      });
    };

    for (var i = 0; i < config.components.length; i++) {
      _loop2(i);
    }
  };
  /**
   * @param {string} name - Name of scroll api
   * @returns {scroll}
   */


  instance.scroll = function scroll() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';
    return getOrCreateScrollApi(name, currentScrollApis);
  };
  /**
   * Get
   * @param {string} key - Get the dataset identified by `key`
   * @returns {dataset}
   */


  instance.dataset = function (key) {
    return dataset(key);
  };

  instance.dataCollection = function (key) {
    return dataCollection(key);
  };
  /**
   * Get all registered scales
   * @returns {Object<string,scale>}
   */


  instance.scales = function scales() {
    return currentScales.all();
  };
  /**
   * Get all registered formatters
   * @returns {Object<string,formatter>}
   */


  instance.formatters = function formatters() {
    return currentFormatters.all();
  };
  /**
   * Get or create brush context for this chart
   * @param {string} name - Name of the brush context. If no match is found, a new brush context is created and returned.
   * @returns {brush}
   */


  instance.brush = function brushFn() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';

    if (!brushes[name]) {
      brushes[name] = brush();
    }

    return brushes[name];
  };
  /**
   * Get or create a scale for this chart
   * @param {string|object} v - Scale reference or scale options
   * @returns {scale}
   * @example
   * instance.scale('nameOfMyScale'); // Fetch an existing scale by name
   * instance.scale({ scale: 'nameOfMyScale' }); // Fetch an existing scale by name
   * instance.scale({ source: '0/1', type: 'linear' }); // Create a new scale
   */


  instance.scale = function scale(v) {
    return currentScales.get(v);
  };
  /**
   * Get or create a formatter for this chart
   * @param {string|object} v - Formatter reference or formatter options
   * @returns {formatter}
   * @example
   * instance.formatter('nameOfMyFormatter'); // Fetch an existing formatter by name
   * instance.formatter({ formatter: 'nameOfMyFormatter' }); // Fetch an existing formatter by name
   * instance.formatter({ type: 'q' }); // Fetch an existing formatter by type
   * instance.formatter({
   *  formatter: 'd3',
   *  type: 'number',
   *  format: '1.0.%'
   * }); // Create a new formatter
   */


  instance.formatter = function formatter(v) {
    return currentFormatters.get(v);
  };
  /**
   * @param {boolean} [val] - Toggle brushing on or off. If value is omitted, a toggle action is applied to the current state.
   */


  instance.toggleBrushing = function toggleBrushing(val) {
    if (typeof val !== 'undefined') {
      stopBrushing = val;
    } else {
      stopBrushing = !stopBrushing;
    }
  };
  /**
   * Get a component context
   * @param {string} key - Component key
   * @returns {component-context} Component context
   */


  instance.component = function (key) {
    var idx = findComponentIndexByKey(key);

    if (idx !== -1) {
      return currentComponents[idx].instance.ctx;
    }

    return undefined;
  };

  instance.logger = function () {
    return logger;
  };

  instance.theme = function () {
    return theme;
  };
  /**
   * Get the all interactions instances
   * @name chart.interactions
   * @type {object}
   * @example
   * chart.interactions.instances; // Array of all interaction instances
   * chart.interactions.on(); // Toggle on all interactions instances
   * chart.interactions.off(); // Toggle off all interactions instances
   */


  Object.defineProperty(instance, 'interactions', {
    get: function get() {
      return (
        /** @lends chart.interactions */
        {
          /** @type Array<interaction> */
          instances: currentInteractions,

          /** Enable all interaction instances */
          on: function on() {
            addDefaultEventListeners();
            currentInteractions.forEach(function (i) {
              return i.on();
            });
          },

          /** Disable all interaction instances */
          off: function off() {
            removeDefaultEventListeners();
            currentInteractions.forEach(function (i) {
              return i.off();
            });
          }
        }
      );
    }
  });
  created();

  if (element) {
    beforeMount();
    mount(element);
    mounted(element);
    instance.element = element;
  }

  return instance;
}

var rendererRegistry = function rendererRegistry(reg) {
  var f = registryFactory(reg);

  f.prio = function (p) {
    return p ? f.default(p[0]) : [f.default()];
  };

  f.types = function () {
    return f.getKeys();
  };

  return f;
};

var componentRegistry = registryFactory();

function findField(query, _ref) {
  var cache = _ref.cache;

  if (typeof query === 'number') {
    return cache.fields[query];
  } // Find by key first


  for (var i = 0; i < cache.fields.length; i++) {
    if (cache.fields[i].key() === query) {
      return cache.fields[i];
    }
  } // find by title


  for (var _i = 0; _i < cache.fields.length; _i++) {
    if (cache.fields[_i].title() === query) {
      return cache.fields[_i];
    }
  }

  return null;
}
var filters = {
  numeric: function numeric(values) {
    return values.filter(function (v) {
      return typeof v === 'number' && !isNaN(v);
    });
  }
};
var unfilteredReducers = {
  sum: function sum(values) {
    return values.reduce(function (a, b) {
      return a + b;
    }, 0);
  }
}; // function isPrimitive(x) {
//   const type = typeof x;
//   return (type !== 'object' && type !== 'function');
// }

/**
 * [reducers description]
 * @type {Object}
 * @private
 */

var reducers = {
  first: function first(values) {
    return values[0];
  },
  last: function last(values) {
    return values[values.length - 1];
  },
  min: function min(values) {
    var filtered = filters.numeric(values);
    return !filtered.length ? NaN : Math.min.apply(null, filtered);
  },
  max: function max(values) {
    var filtered = filters.numeric(values);
    return !filtered.length ? NaN : Math.max.apply(null, filtered);
  },
  sum: function sum(values) {
    var filtered = filters.numeric(values);
    return !filtered.length ? NaN : filtered.reduce(function (a, b) {
      return a + b;
    }, 0);
  },
  avg: function avg(values) {
    var filtered = filters.numeric(values);
    var len = filtered.length;
    return !len ? NaN : unfilteredReducers.sum(filtered) / len;
  }
};

function normalizeProperties(cfg, dataset, dataProperties, main) {
  // console.log('======', cfg, main, dataset);
  var props = {};
  var mainField = main.field || (typeof cfg.field !== 'undefined' ? dataset.field(cfg.field) : null);
  Object.keys(dataProperties).forEach(function (key) {
    var pConfig = dataProperties[key];
    var prop = props[key] = {};

    if (['number', 'string', 'boolean'].indexOf(_typeof(pConfig)) !== -1) {
      prop.type = 'primitive';
      prop.value = pConfig;
    } else if (typeof pConfig === 'function') {
      prop.type = 'function';
      prop.value = pConfig;
      prop.label = pConfig;
      prop.field = mainField;
    } else if (_typeof(pConfig) === 'object') {
      if (pConfig.fields) {
        prop.fields = pConfig.fields.map(function (ff) {
          return normalizeProperties(cfg, dataset, {
            main: ff
          }, main).main;
        });
      } else if (typeof pConfig.field !== 'undefined') {
        prop.type = 'field';
        prop.field = dataset.field(pConfig.field);
        prop.value = prop.field.value;
        prop.label = prop.field.label;
      } else if (mainField) {
        prop.value = mainField.value;
        prop.label = mainField.label;
        prop.field = mainField;
      }

      if (typeof pConfig.filter === 'function') {
        prop.filter = pConfig.filter;
      }

      if (typeof pConfig.value !== 'undefined') {
        prop.value = pConfig.value;
      }

      if (typeof pConfig.label !== 'undefined') {
        prop.label = pConfig.label;
      }

      if (typeof pConfig.reduce === 'function') {
        prop.reduce = pConfig.reduce;
      } else if (pConfig.reduce) {
        prop.reduce = reducers[pConfig.reduce];
      } else if (prop.field && prop.field.reduce) {
        prop.reduce = typeof prop.field.reduce === 'string' ? reducers[prop.field.reduce] : prop.field.reduce;
      }

      if (typeof pConfig.reduceLabel === 'function') {
        prop.reduceLabel = pConfig.reduceLabel;
      } else if (pConfig.reduceLabel) {
        prop.reduceLabel = reducers[pConfig.reduceLabel];
      } else if (prop.field && prop.field.reduceLabel) {
        prop.reduceLabel = typeof prop.field.reduceLabel === 'string' ? reducers[prop.field.reduceLabel] : prop.field.reduceLabel;
      }
    }
  });
  return props;
}
/*
example of configuration input
cfg = {
  field: 'State', // the 'top level' values are extracted from field state
  value: d => d.qText, // the value of the output
  props: { // additional data properties ammended to each item
    a: 3, // constant value
    b: d => d.qElemNumber, // function will receive the original field value
    c: {
      field: 'Country', // reference to another field
      value: d => d.qText // extract the qText value from the referenced field
    },
    d: {
      value: d => d.qRow //  extract qRow from field 'State'
    }
  }
}

// output
[{
  value: 'CA', source: { field: 'State' },
  a: { value: 3 },
  b: { value: 26, source: 'State' },
  c: { value: 'USA', source: 'Country' },
  d: { value: 131, source: 'State' }
},
...]
*/


function getPropsInfo(cfg, dataset) {
  // console.log('222', cfg);
  var _normalizeProperties = normalizeProperties(cfg, dataset, {
    main: {
      value: cfg.value,
      label: cfg.label,
      reduce: cfg.reduce,
      filter: cfg.filter
    }
  }, {}),
      main = _normalizeProperties.main;

  var props = normalizeProperties(cfg, dataset, cfg.props || {}, main);
  return {
    props: props,
    main: main
  };
}

function collectItems(items, cfg, formatter, prop) {
  var values = Array(items.length);
  var labels = Array(items.length);
  var it;

  for (var i = 0; i < items.length; i++) {
    it = prop ? items[i][prop] : items[i];
    values[i] = it.value;
    labels[i] = it.label;
  }

  var reduce = cfg.reduce;
  var reduceLabel = cfg.reduceLabel;
  var v = reduce ? reduce(values) : values;
  var b = reduceLabel ? reduceLabel(labels, v) : formatter ? formatter(v) : String(v); // eslint-disable-line no-nested-ternary
  // // ret[prop].label = String(propsFormatters[prop](ret[prop].value));

  var ret = {
    value: v,
    label: b
  };

  if (prop && items[0][prop].source) {
    ret.source = items[0][prop].source;
    return ret;
  }

  if (!prop && items[0].source) {
    ret.source = items[0].source;
    return ret;
  }

  return ret;
} // collect items that have been grouped and reduce per group and property


function collect(trackedItems, _ref2) {
  var main = _ref2.main,
      propsArr = _ref2.propsArr,
      props = _ref2.props;
  var dataItems = [];
  var mainFormatter = main.field.formatter(); // || (v => v);

  var propsFormatters = {};
  propsArr.forEach(function (prop) {
    propsFormatters[prop] = props[prop].field ? props[prop].field.formatter() : function (v) {
      return v;
    };
  });
  dataItems.push.apply(dataItems, _toConsumableArray$1(trackedItems.map(function (t) {
    var ret = collectItems(t.items, main, mainFormatter);
    propsArr.forEach(function (prop) {
      ret[prop] = collectItems(t.items, props[prop], propsFormatters[prop], prop);
    });
    return ret;
  })));
  return dataItems;
}
function track(_ref3) {
  var cfg = _ref3.cfg,
      itemData = _ref3.itemData,
      obj = _ref3.obj,
      target = _ref3.target,
      tracker = _ref3.tracker,
      trackType = _ref3.trackType;
  var trackId = trackType === 'function' ? cfg.trackBy(itemData) : itemData[cfg.trackBy];
  var trackedItem = tracker[trackId];

  if (!trackedItem) {
    trackedItem = tracker[trackId] = {
      items: [],
      id: trackId
    };
    target.push(trackedItem);
  }

  trackedItem.items.push(obj);
}

function datumExtract(propCfg, cell, _ref) {
  var key = _ref.key;
  var datum = {
    value: typeof propCfg.value === 'function' ? propCfg.value(cell) : typeof propCfg.value !== 'undefined' ? propCfg.value : cell // eslint-disable-line no-nested-ternary

  };
  datum.label = typeof propCfg.label === 'function' ? propCfg.label(cell) : typeof propCfg.label !== 'undefined' ? String(propCfg.label) : String(datum.value); // eslint-disable-line no-nested-ternary

  if (propCfg.field) {
    datum.source = {
      key: key,
      field: propCfg.field.key()
    };
  }

  return datum;
}

function extract$1(config, dataset) {
  var cfgs = Array.isArray(config) ? config : [config];
  var dataItems = [];
  cfgs.forEach(function (cfg) {
    if (typeof cfg.field !== 'undefined') {
      (function () {
        var f = dataset.field(cfg.field);
        var sourceKey = dataset.key();

        if (!f) {
          throw Error("Field '".concat(cfg.field, "' not found"));
        }

        var _getPropsInfo = getPropsInfo(cfg, dataset),
            props = _getPropsInfo.props,
            main = _getPropsInfo.main;

        var propsArr = Object.keys(props);
        var track$1 = !!cfg.trackBy;

        var trackType = _typeof(cfg.trackBy);

        var tracker = {};
        var trackedItems = [];
        var items = f.items();
        var mapped = [];

        var _loop = function _loop(idx) {
          var mainCell = items[idx];
          var exclude = main.filter && !main.filter(mainCell);

          if (exclude) {
            return "continue";
          }

          var ret = datumExtract(main, mainCell, {
            key: sourceKey
          }); // loop through all props that need to be mapped and
          // assign 'value' and 'source' to each property

          propsArr.forEach(function (prop) {
            var p = props[prop];
            var propCell = p.field ? p.field.items()[idx] : mainCell;
            ret[prop] = datumExtract(p, propCell, {
              key: sourceKey
            });
          }); // collect items based on the trackBy value
          // items with the same trackBy value are placed in an array and reduced later

          if (track$1) {
            track({
              cfg: cfg,
              itemData: mainCell,
              obj: ret,
              target: trackedItems,
              tracker: tracker,
              trackType: trackType
            });
          }

          mapped.push(ret);
        };

        for (var idx = 0; idx < items.length; idx++) {
          var _ret = _loop(idx);

          if (_ret === "continue") continue;
        } // reduce if items have been grouped


        if (track$1) {
          dataItems.push.apply(dataItems, _toConsumableArray$1(collect(trackedItems, {
            main: main,
            propsArr: propsArr,
            props: props
          })));
        } else {
          dataItems.push.apply(dataItems, mapped);
        }
      })();
    }
  });
  return dataItems;
}

var filters$1 = {
  numeric: function numeric(values) {
    return values.filter(function (v) {
      return typeof v === 'number' && !isNaN(v);
    });
  }
};

function createFields(_ref) {
  var source = _ref.source,
      data = _ref.data,
      cache = _ref.cache,
      config = _ref.config;
  var headers;
  var content = data;
  var parse = config && config.parse;

  if (Array.isArray(data[0])) {
    // assume 2d matrix of data
    if (parse && parse.headers === false) {
      headers = data[0].map(function (v, i) {
        return i;
      });
    } else {
      headers = data[0];
      content = data.slice(1);
    }
  } else {
    headers = Object.keys(data[0]);
  }

  var rowFn = !!parse && typeof parse.row === 'function' && parse.row;
  var flds = headers;

  if (parse && typeof parse.fields === 'function') {
    flds = parse.fields(flds.slice());
  } else {
    flds = headers.map(function (h) {
      return {
        key: h,
        title: h
      };
    });
  }

  var fieldValues;

  if (Array.isArray(data[0])) {
    fieldValues = flds.map(function () {
      return [];
    });
  } else {
    fieldValues = {};
    flds.forEach(function (f) {
      fieldValues[f.key] = [];
    });
  }

  for (var r = 0; r < content.length; r++) {
    var row = rowFn ? rowFn(content[r], r, flds) : content[r];

    if (!row) {
      continue;
    }

    if (Array.isArray(row)) {
      for (var c = 0; c < flds.length; c++) {
        fieldValues[c].push(row[c]);
      }
    } else {
      for (var _c = 0; _c < flds.length; _c++) {
        fieldValues[flds[_c].key].push(row[flds[_c].key]);
      }
    }
  }

  var fv = Array.isArray(fieldValues) ? function (i) {
    return fieldValues[i];
  } : function (i) {
    return fieldValues[flds[i].key];
  };

  for (var _c2 = 0; _c2 < flds.length; _c2++) {
    var values = fv(_c2);
    var numericValues = filters$1.numeric(values);
    var isMeasure = numericValues.length > 0;
    var type = isMeasure ? 'measure' : 'dimension';
    var min = isMeasure ? Math.min.apply(Math, _toConsumableArray$1(numericValues)) : NaN;
    var max = isMeasure ? Math.max.apply(Math, _toConsumableArray$1(numericValues)) : NaN;
    cache.fields.push(field(extend({
      source: source,
      key: _c2,
      title: flds[_c2].title,
      values: values,
      min: min,
      max: max,
      type: type
    }, flds[_c2]), {
      value: flds[_c2].value,
      label: flds[_c2].label
    }));
  }
}

var dsv = function dsv(_ref2) {
  var data = _ref2.data,
      config = _ref2.config;
  var rows = data.split('\n');
  var row0 = rows[0];
  var row1 = rows[1];
  var delimiter = ',';

  if (config && config.parse && config.parse.delimiter) {
    delimiter = config.parse.delimiter;
  } else if (row0) {
    // guess delimiter
    var guesses = [/,/, /\t/, /;/];

    for (var i = 0; i < guesses.length; i++) {
      var d = guesses[i];

      if (row0 && row1) {
        if (d.test(row0) && d.test(row1) && row0.split(d).length === row1.split(d).length) {
          delimiter = d;
          break;
        }
      } else if (d.test(row0)) {
        delimiter = d;
      }
    }
  }

  return rows.map(function (row) {
    return row.split(delimiter);
  });
};

var parseData = function parseData(_ref3) {
  var key = _ref3.key,
      data = _ref3.data,
      cache = _ref3.cache,
      config = _ref3.config;

  if (!data) {
    return;
  }

  var dd = data;

  if (typeof dd === 'string') {
    // assume dsv
    dd = dsv({
      data: data,
      config: config
    });
  }

  if (!Array.isArray(dd)) {
    return; // warn?
  }

  createFields({
    data: dd,
    cache: cache,
    source: key,
    config: config
  });
};
/**
 * Create a new dataset with default settings
 * @private
 * @return {dataset}
 */


function ds() {
  var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _key = _ref4.key,
      data = _ref4.data,
      config = _ref4.config;

  var cache = {
    fields: []
  };
  /**
   * @alias dataset
   * @interface
   */

  var dataset = {
    /**
     * Get the key identifying this dataset
     * @returns {string}
     */
    key: function key() {
      return _key;
    },

    /**
     * Get the raw data
     * @returns {any}
     */
    raw: function raw() {
      return data;
    },

    /**
     * Find a field within this dataset
     * @param {string} query - The field to find
     * @returns {field}
     */
    field: function field(query) {
      return findField(query, {
        cache: cache,
        matrix: data
      });
    },

    /**
     * Get all fields within this dataset
     * @returns {Array<field>}
     */
    fields: function fields() {
      return cache.fields.slice();
    },

    /**
     * Extract data items from this dataset
     * @param {data-extract-config} config
     * @returns {Array<datum-extract>}
     */
    extract: function extract(cfg) {
      return extract$1(cfg, dataset, cache);
    },

    /**
     * @returns {null}
     */
    hierarchy: function hierarchy() {
      return null;
    }
  };
  parseData({
    key: _key,
    data: data,
    config: config,
    cache: cache
  });
  return dataset;
}

ds.util = {
  normalizeConfig: getPropsInfo,
  collect: collect,
  track: track
};
/**
 * @typedef {object} data-extract-config
 * @property {string} field - The field to extract data from
 * @property {data-extract-config~valueFn} [value] - The field value accessor
 * @property {data-extract-config~labelFn} [label] - The field label accessor
 * @property {data-extract-config~trackByFn} [trackBy] - Track by value accessor
 * @property {data-extract-config~reduceFn} [reduce] - Reducer function
 * @property {data-extract-config~reduceLabelFn} [reduceLabel] - Label reducer function
 * @property {data-extract-config~filterFn} [filter] - Filter function
 * @property {object} [props] - Additional properties to add to the extracted item
 */

/**
 * @callback data-extract-config~valueFn
 * @param {any} cell The field cell
 * @returns {any}
 */

/**
 * @callback data-extract-config~labelFn
 * @param {any} cell The field cell
 * @returns {string}
 */

/**
 * @callback data-extract-config~filterFn
 * @param {any} cell The field cell
 * @returns {boolean}
 */

/**
 * @callback data-extract-config~trackByFn
 * @param {any} cell The field cell
 * @returns {any}
 */

/**
 * @callback data-extract-config~reduceFn
 * @param {any[]} values The collected values to reduce
 * @returns {any}
 */

/**
 * @callback data-extract-config~reduceLabelFn
 * @param {any[]} labels The collected labels to reduce
 * @param {any} value Reduced value
 * @returns {string}
 */

/**
 * @typedef {object} datum-extract
 * @property {any} value - The extracted value
 * @property {string} label - The extracted value as a string
 * @property {object} source - The data source of the extracted data
 * @property {string} source.key - The data-source key
 * @property {string} source.field - The source field
 */

var dataRegistry = registryFactory();
dataRegistry.default('matrix');
dataRegistry('matrix', ds);
dataRegistry('default', ds); // deprecated

/**
 * Manages event handlers for native events
 * @private
 */
function native(chart, mediator, element) {
  var instance = {
    chart: chart,
    mediator: mediator,
    element: element
  };
  var nativeEvents = [];
  var settings;
  var itKey;
  var isOn = true;
  /**
   * Set default settings
   * @private
   */

  function setDefaultSettings(newSettings) {
    itKey = newSettings.key;
    settings = newSettings;
    settings.events = settings.events || [];

    if (settings.enable === undefined) {
      settings.enable = true;
    }
  }
  /**
   * Add native events based on settings
   * @private
   */


  function addEvents() {
    if (typeof settings.enable === 'function') {
      settings.enable = settings.enable.bind(instance)();
    }

    if (!settings.enable) {
      return; // interaction is disabled
    }

    Object.keys(settings.events).forEach(function (key) {
      var listener = settings.events[key].bind(instance);
      element.addEventListener(key, listener);
      nativeEvents.push({
        key: key,
        listener: listener
      });
    });
  }
  /**
   * Removes all added native events
   * @private
   */


  function removeAddedEvents() {
    // remove added native events
    nativeEvents.forEach(function (_ref) {
      var key = _ref.key,
          listener = _ref.listener;
      element.removeEventListener(key, listener);
    });
    nativeEvents = [];
  }

  return {
    /**
     * Getter for the key.
     * @private
     */
    get key() {
      return itKey;
    },

    /**
     * Updates this with new settings
     * @private
     * @param {object} newSettings
     * @param {string} [newSettings.type] - The interaction type. Is 'native' for this component
     * @param {boolean|function} [newSettings.enable=true] - Should the interactions defined here be enabled or not.
     * This is only run when adding event handlers. In effect at startup, update or during on/off.
     * It does not run during every event loop.
     * @param {array} [newSettings.gestures] - The keys in this object is the names of native events
     * that should be added to the chart element and they should all point to function which
     * will be the corresponding event handler.
     */
    set: function set(newSettings) {
      setDefaultSettings(newSettings);
      removeAddedEvents();

      if (isOn) {
        addEvents();
      }
    },

    /**
     * Turns off interactions
     * @private
     */
    off: function off() {
      isOn = false;
      removeAddedEvents();
    },

    /**
     * Turns off interactions
     * @private
     */
    on: function on() {
      isOn = true;

      if (nativeEvents.length === 0) {
        addEvents();
      }
    },

    /**
     * Destroys and unbinds all event handlers
     * @private
     */
    destroy: function destroy() {
      removeAddedEvents();
      instance = null;
      settings = null;
    }
  };
}

var reg$2 = registryFactory();
reg$2('native', native);

/**
 * Short-hand for max(min())
 *
 * @param {number} min Minimum allowed value
 * @param {number} max Maximum allowed value
 * @param {number} value The actual value to cap
 * @ignore
 */
function cap(min, max, value) {
  return Math.max(min, Math.min(max, value));
}
/**
 * Resolve a diff, i.e. resolveDiff(0.2, 0.6, 1, 100) = 20
 *
 * @param {object} params parameters
 * @param {number} params.start Normalized start value
 * @param {number} params.end Normalized end value
 * @param {number} params.minPx The minimum number of pixels
 * @param {number} params.maxPx Maximum number of pixels, i.e. the width or height
 * @ignore
 */

function resolveDiff(_ref) {
  var start = _ref.start,
      end = _ref.end,
      _ref$minPx = _ref.minPx,
      minPx = _ref$minPx === void 0 ? 0.1 : _ref$minPx,
      _ref$maxPx = _ref.maxPx,
      maxPx = _ref$maxPx === void 0 ? 1 : _ref$maxPx;
  var high = Math.max(start, end);
  var low = Math.min(start, end);
  var highModified = cap(-0.1, 1.2, high);
  var lowModified = cap(-0.1, 1.2, low);
  var wantedDiff = highModified * maxPx - lowModified * maxPx;
  var actualDiff = Math.max(minPx, wantedDiff);
  var startModifier = (actualDiff - wantedDiff) / 2;
  var actualLow = lowModified * maxPx - startModifier;
  return {
    actualDiff: actualDiff,
    startModifier: startModifier,
    actualLow: actualLow
  };
}

/**
 * Out of bounds shape
 * @param {object} params parameters
 * @param {object} params.item Resolved styling item from box component with item.major
 * @param {number} params.value 0 or 1 depending on where to render the oob shape
 * @param {number} params.boxWidth Un-calculated box width in relative/normalized format
 * @param {number} params.boxPadding Un-calculated box padding in relative/normalized format
 * @param {number} params.rendWidth The pixel width of the area to render upon
 * @param {number} params.rendHeight The pixel height of the area to render upon
 * @param {boolean} params.flipXY Wether or not to flip X and Y coordinates together with Width and Height
 * @param {function} params.symbol Symbol library function from component
 * @ignore
 */

function oob(_ref) {
  var _extend;

  var item = _ref.item,
      value = _ref.value,
      boxCenter = _ref.boxCenter,
      rendWidth = _ref.rendWidth,
      rendHeight = _ref.rendHeight,
      flipXY = _ref.flipXY,
      symbol = _ref.symbol;
  var x = 'x';
  var y = 'y';
  var calcwidth = rendWidth;
  var calcheight = rendHeight;
  var startAngle = value < 0.5 ? 90 : -90;

  if (flipXY) {
    x = 'y';
    y = 'x';
    calcwidth = rendHeight;
    calcheight = rendWidth;
    startAngle = value < 0.5 ? 180 : 0;
  }

  return symbol(extend({}, item.oob, (_extend = {}, _defineProperty(_extend, x, boxCenter * calcwidth), _defineProperty(_extend, y, Math.max(item.oob.size / 2, Math.min(value * calcheight, calcheight - item.oob.size / 2))), _defineProperty(_extend, "startAngle", startAngle), _extend)));
}
/**
 * Box shape calculation function
 * @param {object} params parameters
 * @param {object} params.item Resolved styling item from box component with item.major
 * @param {number} params.boxWidth Un-calculated box width in relative/normalized format
 * @param {number} params.boxPadding Un-calculated box padding in relative/normalized format
 * @param {number} params.rendWidth The pixel width of the area to render upon
 * @param {number} params.rendHeight The pixel height of the area to render upon
 * @param {boolean} params.flipXY wether or not to flip X and Y coordinates together with Width and Height
 * @ignore
 */

function box(_ref2) {
  var _extend2;

  var item = _ref2.item,
      boxWidth = _ref2.boxWidth,
      boxPadding = _ref2.boxPadding,
      rendWidth = _ref2.rendWidth,
      rendHeight = _ref2.rendHeight,
      flipXY = _ref2.flipXY;
  var x = 'x';
  var y = 'y';
  var width = 'width';
  var height = 'height';
  var calcwidth = rendWidth;
  var calcheight = rendHeight;

  if (flipXY) {
    x = 'y';
    y = 'x';
    width = 'height';
    height = 'width';
    calcwidth = rendHeight;
    calcheight = rendWidth;
  }

  var _resolveDiff = resolveDiff({
    start: item.start,
    end: item.end,
    minPx: item.box.minHeightPx,
    maxPx: calcheight
  }),
      actualDiff = _resolveDiff.actualDiff,
      actualLow = _resolveDiff.actualLow;

  return extend({}, item.box, (_extend2 = {
    type: 'rect'
  }, _defineProperty(_extend2, x, (boxPadding + item.major) * calcwidth), _defineProperty(_extend2, y, actualLow), _defineProperty(_extend2, height, actualDiff), _defineProperty(_extend2, width, boxWidth * calcwidth), _defineProperty(_extend2, "data", item.data || {}), _defineProperty(_extend2, "collider", {
    type: null
  }), _extend2));
}
/**
 * A vertical line shape (for start - min, end - max values)
 * @param {object} params parameters
 * @param {object} params.item Resolved styling item from box component with item.major
 * @param {number} params.from Normalized from value
 * @param {number} params.to Normalized to value
 * @param {number} params.boxCenter Center coordinate for the box
 * @param {number} params.rendWidth The pixel width of the area to render upon
 * @param {number} params.rendHeight The pixel height of the area to render upon
 * @param {boolean} params.flipXY wether or not to flip X and Y coordinates together with Width and Height
 * @ignore
 */

function verticalLine(_ref3) {
  var _extend3;

  var item = _ref3.item,
      from = _ref3.from,
      to = _ref3.to,
      boxCenter = _ref3.boxCenter,
      rendWidth = _ref3.rendWidth,
      rendHeight = _ref3.rendHeight,
      flipXY = _ref3.flipXY;
  var x1 = 'x1';
  var y1 = 'y1';
  var x2 = 'x2';
  var y2 = 'y2';
  var calcwidth = rendWidth;
  var calcheight = rendHeight;

  if (flipXY) {
    x1 = 'y1';
    y1 = 'x1';
    x2 = 'y2';
    y2 = 'x2';
    calcwidth = rendHeight;
    calcheight = rendWidth;
  }

  return extend({}, item.line, (_extend3 = {
    type: 'line'
  }, _defineProperty(_extend3, y2, Math.floor(from * calcheight)), _defineProperty(_extend3, x1, boxCenter * calcwidth), _defineProperty(_extend3, y1, Math.floor(to * calcheight)), _defineProperty(_extend3, x2, boxCenter * calcwidth), _defineProperty(_extend3, "data", item.data || {}), _defineProperty(_extend3, "collider", {
    type: null
  }), _extend3));
}
/**
 * A horizontal line shape (for median and whiskers)
 * @param {object} params parameters
 * @param {object} params.item Resolved styling item from box component with item.major
 * @param {string} params.key Which key to use as style base in the item object
 * @param {number} params.position At which "height" (X) to position the horizontal line
 * @param {number} params.width Width of the horizontal line (i.e. box width or a multiple of it)
 * @param {number} params.boxCenter Center coordinate for the box
 * @param {number} params.rendWidth The pixel width of the area to render upon
 * @param {number} params.rendHeight The pixel height of the area to render upon
 * @param {boolean} params.flipXY wether or not to flip X and Y coordinates together with Width and Height
 * @ignore
 */

function horizontalLine(_ref4) {
  var _extend4;

  var item = _ref4.item,
      key = _ref4.key,
      position = _ref4.position,
      width = _ref4.width,
      boxCenter = _ref4.boxCenter,
      rendWidth = _ref4.rendWidth,
      rendHeight = _ref4.rendHeight,
      flipXY = _ref4.flipXY;
  var x1 = 'x1';
  var y1 = 'y1';
  var x2 = 'x2';
  var y2 = 'y2';
  var calcwidth = rendWidth;
  var calcheight = rendHeight;

  if (flipXY) {
    x1 = 'y1';
    y1 = 'x1';
    x2 = 'y2';
    y2 = 'x2';
    calcwidth = rendHeight;
    calcheight = rendWidth;
  }

  var halfWidth = width / 2;
  return extend({
    type: 'line'
  }, item[key], (_extend4 = {}, _defineProperty(_extend4, y1, Math.floor(position * calcheight)), _defineProperty(_extend4, x1, (boxCenter - halfWidth) * calcwidth), _defineProperty(_extend4, y2, Math.floor(position * calcheight)), _defineProperty(_extend4, x2, (boxCenter + halfWidth) * calcwidth), _defineProperty(_extend4, "r", halfWidth * calcwidth), _defineProperty(_extend4, "cx", boxCenter * calcwidth), _defineProperty(_extend4, "cy", position * calcheight), _defineProperty(_extend4, "width", width * calcwidth), _defineProperty(_extend4, "data", item.data || {}), _defineProperty(_extend4, "collider", {
    type: null
  }), _extend4));
}
/**
 * A horizontal line shape (for median and whiskers)
 * @param {number} bandwidth The current bandwidth for this item
 * @param {object} item A resolved style item to render with major and box width variables, minWidthPx and maxWidthPx
 * @param {number} maxMajorWidth The actual maximum major width
 * @ignore
 */

function getBoxWidth(bandwidth, item, maxMajorWidth) {
  var _item$box = item.box,
      width = _item$box.width,
      maxWidthPx = _item$box.maxWidthPx,
      minWidthPx = _item$box.minWidthPx;
  var sign = bandwidth >= 0 ? 1 : -1;
  var boxWidth = Math.min(sign * bandwidth * width, isNaN(maxWidthPx) ? maxMajorWidth : maxWidthPx / maxMajorWidth);
  boxWidth = isNaN(minWidthPx) ? boxWidth : Math.max(minWidthPx / maxMajorWidth, boxWidth);
  return boxWidth * sign;
}

function buildShapes(_ref) {
  var width = _ref.width,
      height = _ref.height,
      flipXY = _ref.flipXY,
      resolved = _ref.resolved,
      keys = _ref.keys,
      symbol = _ref.symbol;
  // if (!settings || !settings.major || !settings.major.scale || !settings.minor || !settings.minor.scale) {
  //   return [];
  // }
  var output = [];
  var majorItems = resolved.major.items;

  if (!majorItems.length) {
    return output;
  }

  var rendWidth = width;
  var rendHeight = height;
  var maxMajorWidth = flipXY ? height : width;
  var majorSettings = resolved.major.settings;
  var minorProps = ['start', 'end', 'min', 'max', 'med'].filter(function (prop) {
    return typeof resolved.minor.settings[prop] !== 'undefined';
  });
  var numMinorProps = minorProps.length;
  var nonOobKeys = keys.filter(function (key) {
    return key !== 'oob';
  });
  var children;
  var major;
  var minorItem;
  var boxWidth;
  var boxPadding;
  var boxCenter;
  var isLowerOutOfBounds;
  var isHigherOutOfBounds;
  var isOutOfBounds;
  var numKeys = keys ? keys.length : 0;
  var numNonOobKeys = nonOobKeys ? nonOobKeys.length : 0;

  function addBox() {
    /* THE BOX */
    if (minorItem.box && isNumber(minorItem.start) && isNumber(minorItem.end)) {
      children.push(box({
        item: minorItem,
        boxWidth: boxWidth,
        boxPadding: boxPadding,
        rendWidth: rendWidth,
        rendHeight: rendHeight,
        flipXY: flipXY
      }));
    }
  }

  function addLine() {
    /* LINES MIN - START, END - MAX */
    if (isNumber(minorItem.min) && isNumber(minorItem.start)) {
      children.push(verticalLine({
        item: minorItem,
        from: minorItem.min,
        to: minorItem.start,
        boxCenter: boxCenter,
        rendWidth: rendWidth,
        rendHeight: rendHeight,
        flipXY: flipXY
      }));
    }

    if (isNumber(minorItem.max) && isNumber(minorItem.end)) {
      children.push(verticalLine({
        item: minorItem,
        from: minorItem.max,
        to: minorItem.end,
        boxCenter: boxCenter,
        rendWidth: rendWidth,
        rendHeight: rendHeight,
        flipXY: flipXY
      }));
    }
  }

  function addMedian() {
    /* MEDIAN */
    if (minorItem.median && isNumber(minorItem.med)) {
      children.push(horizontalLine({
        item: minorItem,
        key: 'median',
        position: minorItem.med,
        width: boxWidth,
        boxCenter: boxCenter,
        rendWidth: rendWidth,
        rendHeight: rendHeight,
        flipXY: flipXY
      }));
    }
  }

  function addWhisker() {
    /* WHISKERS */
    if (minorItem.whisker) {
      var whiskerWidth = boxWidth * minorItem.whisker.width;

      if (isNumber(minorItem.min)) {
        children.push(horizontalLine({
          item: minorItem,
          key: 'whisker',
          position: minorItem.min,
          width: whiskerWidth,
          boxCenter: boxCenter,
          rendWidth: rendWidth,
          rendHeight: rendHeight,
          flipXY: flipXY
        }));
      }

      if (isNumber(minorItem.max)) {
        children.push(horizontalLine({
          item: minorItem,
          key: 'whisker',
          position: minorItem.max,
          width: whiskerWidth,
          boxCenter: boxCenter,
          rendWidth: rendWidth,
          rendHeight: rendHeight,
          flipXY: flipXY
        }));
      }
    }
  }

  function addOutOfBounds() {
    /* OUT OF BOUNDS */
    if (isLowerOutOfBounds) {
      children.push(oob({
        item: minorItem,
        value: 0,
        boxCenter: boxCenter,
        rendWidth: rendWidth,
        rendHeight: rendHeight,
        flipXY: flipXY,
        symbol: symbol
      }));
    } else if (isHigherOutOfBounds) {
      children.push(oob({
        item: minorItem,
        value: 1,
        boxCenter: boxCenter,
        rendWidth: rendWidth,
        rendHeight: rendHeight,
        flipXY: flipXY,
        symbol: symbol
      }));
    }
  }

  var addMarkerList = {
    box: addBox,
    line: addLine,
    median: addMedian,
    whisker: addWhisker
  };

  function checkOutOfBounds() {
    var value;
    var max = -Number.MAX_VALUE;
    var min = Number.MAX_VALUE;

    for (var n = 0; n < numMinorProps; n++) {
      value = minorItem[minorProps[n]];

      if (isNumber(value)) {
        if (max < value) {
          max = value;
        }

        if (min > value) {
          min = value;
        }
      }
    }

    isLowerOutOfBounds = max < 0 && max !== -Number.MAX_VALUE;
    isHigherOutOfBounds = min > 1 && min !== Number.MAX_VALUE;
    isOutOfBounds = isLowerOutOfBounds || isHigherOutOfBounds;
  }

  for (var i = 0, len = majorItems.length; i < len; i++) {
    children = [];
    major = null;
    var majorItem = majorItems[i];
    var d = majorItem.data;
    var majorVal = null;
    var majorEndVal = null;

    if (typeof majorSettings.binStart !== 'undefined') {
      // if start and end is defined
      majorVal = majorItem.binStart;
      majorEndVal = majorItem.binEnd;
      major = majorSettings.binStart.scale;
    } else {
      major = majorSettings.major.scale;
      majorVal = major ? majorItem.major : 0;
    }

    var bandwidth = 0;

    if (!major) {
      bandwidth = 1;
    } else if (major.bandwidth) {
      bandwidth = major.bandwidth();
      majorVal -= bandwidth / 2;
    } else {
      bandwidth = majorEndVal - majorVal;
    }

    minorItem = extend({}, {
      major: majorVal,
      majorEnd: majorEndVal
    }, resolved.minor.items[i]);

    for (var j = 0; j < numKeys; j++) {
      minorItem[keys[j]] = resolved[keys[j]].items[i];
    }

    boxWidth = getBoxWidth(bandwidth, minorItem, maxMajorWidth);
    boxPadding = (bandwidth - boxWidth) / 2;
    boxCenter = boxPadding + minorItem.major + boxWidth / 2;
    checkOutOfBounds();

    if (!isOutOfBounds) {
      for (var k = 0; k < numNonOobKeys; k++) {
        addMarkerList[nonOobKeys[k]]();
      }
    } else if (minorItem.oob) {
      addOutOfBounds();
    }

    var container = {
      type: 'container',
      data: d,
      collider: {
        type: 'bounds'
      },
      children: children
    };
    output.push(container);
  }

  return output;
}

/**
 * Resolve a complex object using the built-in resolver from this.resolver in component
 * @ignore
 */

function complexResolver(_ref) {
  var keys = _ref.keys,
      data = _ref.data,
      defaultSettings = _ref.defaultSettings,
      style = _ref.style,
      settings = _ref.settings,
      width = _ref.width,
      height = _ref.height,
      resolver = _ref.resolver;
  var defaults = extend(true, {}, defaultSettings || {}, style || {});
  var scaled = {
    major: settings.orientation === 'horizontal' ? height : width,
    minor: settings.orientation === 'horizontal' ? width : height
  };
  var majorSettings = settings.major;
  var majorResolved;

  if (_typeof(majorSettings) === 'object' && _typeof(majorSettings.ref) === 'object' && typeof majorSettings.ref.start !== 'undefined' && typeof majorSettings.ref.end !== 'undefined') {
    // temporary backwards compatibility
    majorResolved = resolver.resolve({
      data: data,
      defaults: {
        start: 0,
        end: 1
      },
      scaled: scaled,
      settings: extend(true, {}, {
        binStart: {
          scale: settings.major.scale,
          ref: settings.major.ref.start
        },
        binEnd: {
          scale: settings.major.scale,
          ref: settings.major.ref.end
        }
      })
    });
  } else if (_typeof(majorSettings) === 'object' && typeof majorSettings.binStart !== 'undefined' && typeof majorSettings.binEnd !== 'undefined') {
    majorResolved = resolver.resolve({
      data: data,
      defaults: {
        start: 0,
        end: 1
      },
      scaled: scaled,
      settings: extend(true, {}, {
        binStart: {
          scale: settings.major.scale,
          ref: 'binStart'
        },
        binEnd: {
          scale: settings.major.scale,
          ref: 'binEnd'
        }
      }, settings.major)
    });
  } else {
    majorResolved = resolver.resolve({
      data: data,
      scaled: scaled,
      defaults: {
        major: 0.5
      },
      settings: {
        major: settings.major
      }
    });
  }

  var minorSettings = settings.minor || {};
  var defaultMinorSettings = {};
  ['start', 'end', 'min', 'max', 'med'].forEach(function (prop) {
    if (minorSettings[prop] || data.items && data.items.length && data.items[0][prop]) {
      defaultMinorSettings[prop] = {
        scale: minorSettings.scale,
        ref: prop
      };
    }
  });
  var minorResolved = resolver.resolve({
    data: data,
    defaults: {
      start: 0,
      end: 1
    },
    scaled: scaled,
    settings: extend(true, {}, defaultMinorSettings, minorSettings)
  });
  var key;
  var ext = {
    major: majorResolved,
    minor: minorResolved
  };

  for (var ki = 0, len = keys.length; ki < len; ki++) {
    if (!settings[key] || settings[key].show !== false) {
      key = keys[ki];
      ext[key] = resolver.resolve({
        data: data,
        defaults: defaults[key],
        settings: settings[key],
        scaled: scaled
      });
    }
  }

  return ext;
}

var DEFAULT_DATA_SETTINGS = {
  oob: {
    show: true,
    type: 'n-polygon',
    fill: '#999',
    stroke: '#000',
    strokeWidth: 0,
    size: 10,
    sides: 3,
    startAngle: -90
  },
  box: {
    show: true,
    fill: '#fff',
    stroke: '#000',
    strokeWidth: 1,
    strokeLinejoin: 'miter',
    width: 1,
    maxWidthPx: undefined,
    minWidthPx: 1,
    minHeightPx: 1
  },
  line: {
    show: true,
    stroke: '#000',
    strokeWidth: 1
  },
  median: {
    show: true,
    stroke: '#000',
    strokeWidth: 1
  },
  whisker: {
    show: true,
    stroke: '#000',
    strokeWidth: 1,
    fill: '',
    type: 'line',
    width: 1
  }
};
var dataKeys = Object.keys(DEFAULT_DATA_SETTINGS);
var component = {
  require: ['chart', 'resolver', 'symbol'],
  defaultSettings: {
    settings: {},
    data: {},
    style: {
      box: '$shape',
      line: '$shape-guide',
      whisker: '$shape-guide',
      median: '$shape-guide--inverted'
    }
  },
  created: function created() {
    this.state = {};
  },
  render: function render(_ref) {
    var _this = this;

    var data = _ref.data;
    var _this$rect = this.rect,
        width = _this$rect.width,
        height = _this$rect.height;
    var flipXY = this.settings.settings.orientation === 'horizontal';
    var style = this.style,
        resolver = this.resolver,
        symbol = this.symbol;
    var keys = dataKeys.filter(function (key) {
      return !_this.settings.settings[key] || _this.settings.settings[key].show !== false;
    });
    var defaultSettings = {};
    keys.forEach(function (key) {
      return defaultSettings[key] = DEFAULT_DATA_SETTINGS[key];
    });
    var resolved = complexResolver({
      keys: keys,
      data: data,
      defaultSettings: defaultSettings,
      style: style,
      settings: this.settings.settings,
      width: width,
      height: height,
      resolver: resolver
    });
    var settings = resolved.settings,
        items = resolved.items;
    var shapes = buildShapes({
      items: items,
      settings: settings,
      width: width,
      height: height,
      flipXY: flipXY,
      resolved: resolved,
      keys: keys,
      symbol: symbol
    });
    return shapes;
  }
};

function box$1(picasso) {
  picasso.component('box', component);
  picasso.component('box-marker', component); // temporary backwards compatibility - DEPRECATED
}
/**
 * @typedef {object} component--box
 * @property {string} type - "box"
 * @property {component--box~data} data Box data
 * @property {component--box~settings} settings Box settings
 * @example
 * {
 *   type: "box",
 *   data: {
 *    mapTo: {
 *      min: { source: "/qHyperCube/qMeasureInfo/0" },
 *      start: { source: "/qHyperCube/qMeasureInfo/1" },
 *      med: { source: "/qHyperCube/qMeasureInfo/2" },
 *      end: { source: "/qHyperCube/qMeasureInfo/3" },
 *      max: { source: "/qHyperCube/qMeasureInfo/4" },
 *    },
 *    groupBy: {
 *      source: "/qHyperCube/qDimensionInfo/0"
 *    }
 *  },
 *  settings: {
 *    major: {
 *      scale: { source: "/qHyperCube/qDimensionInfo/0" }
 *    },
 *    minor: {
 *      scale: { source: ["/qHyperCube/qMeasureInfo/0",
 *               "/qHyperCube/qMeasureInfo/1",
 *               "/qHyperCube/qMeasureInfo/2",
 *               "/qHyperCube/qMeasureInfo/3",
 *               "/qHyperCube/qMeasureInfo/4"] }
 *    }
 *  }
 * }
 */

/**
 * @typedef {object} component--box~settings
 * @property {object} major
 * @property {string} major.scale The scale to use along the major (dimension) axis
 * @property {string|component--box~settings~majorReference} [major.ref='self'] Reference to the data property along the major axis
 * @property {object} minor
 * @property {string} minor.scale The scale to use along the minor (measure) axis
 * @property {string} [orientation='vertical'] Which orientation to use (vertical or horizontal)
 * @property {object} [box] Visual properties for the box shape in the box marker
 * @property {boolean} [box.show=true] Boolean for showing the box shape
 * @property {string} [box.fill='#fff']
 * @property {string} [box.stroke='#000']
 * @property {number} [box.strokeWidth=1]
 * @property {string} [box.strokeLinejoin='miter']
 * @property {number} [box.width=1]
 * @property {number} [box.maxWidthPx=100] Maximum width of the box in pixels (not applicable when using major start and end)
 * @property {number} [box.minWidthPx=1] Minimum width of the box in pixels (not applicable when using major start and end)
 * @property {number} [box.minHeightPx=1] Minimum height of the box shape
 * @property {object} [line] Visual properties for lines between min-start, end-max.
 * @property {boolean} [line.show=true]
 * @property {string} [line.stroke='#000']
 * @property {number} [line.strokeWidth=1]
 * @property {object} [whisker] All the visual properties for whiskers at min and max.
 * @property {boolean} [whisker.show=true]
 * @property {string} [whisker.stroke='#000']
 * @property {number} [whisker.strokeWidth=1]
 * @property {number} [whisker.width=1]
 * @property {object} [median] Visual properties for the median
 * @property {number} [median.show=true]
 * @property {string} [median.stroke='#000']
 * @property {number} [median.strokeWidth=1]
 * @property {object} [oob] EXPERIMENTAL: Out of bounds symbol utilizing the symbol API
 * @property {number} [oob.show=true]
 * @property {string} [oob.type='n-polygon'] Type of the symbol to be used
 * @property {string} [oob.fill='#999'] Fill color of the symbol
 * @property {string} [oob.stroke='#000'] Stroke color
 * @property {number} [oob.strokeWidth=0] Stroke width
 * @property {number} [oob.size=10] Size/width of the symbol in pixels
 * @property {number} [oob.sides=3] Number of sides for a n-polygon (3 for triangle)
 */

/**
 * @typedef {object} component--box~settings~majorReference
 * @property {string} start Reference to the data property of the start value along the major axis
 * @property {string} end Reference to the data property of the end value along the major axis
 */

/**
 * @typedef {object} component--box~data
 * @property {number} [min] Min
 * @property {number} [max] Max
 * @property {number} [start] Start of box
 * @property {number} [end] End of box
 * @property {number} [med] Median
 */

var DEFAULT_ERROR_SETTINGS = {
  errorShape: {
    shape: 'saltire',
    width: 2,
    size: 0.5,
    fill: '#333',
    stroke: '#333',
    strokeWidth: 0
  }
};
/**
  * @typedef {object}
  * @alias component--point.settings
  */

var DEFAULT_DATA_SETTINGS$1 = {
  /** Type of shape
   * @type {datum-string=} */
  shape: 'circle',
  label: '',

  /** Fill color
   * @type {datum-string=} */
  fill: '#333',

  /** Stroke color
   * @type {datum-string=} */
  stroke: '#ccc',

  /** Stroke width
   * @type {datum-number=} */
  strokeWidth: 0,

  /** Stroke line join
   * @type {string=} */
  strokeLinejoin: 'miter',

  /** Opacity of shape
   * @type {datum-number=} */
  opacity: 1,

  /** Normalized x coordinate
   * @type {datum-number=} */
  x: 0.5,

  /** Normalized y coordinate
   * @type {datum-number=} */
  y: 0.5,

  /** Normalized size of shape
   * @type {datum-number=} */
  size: 1,
  strokeDasharray: ''
};
/**
  * @typedef {object}
  * @alias component--point.settings.sizeLimits
  */

var SIZE_LIMITS = {
  /** Maximum size of shape, in pixels
   * @type {number=} */
  maxPx: 10000,

  /** Minimum size of shape, in pixels
   * @type {number=} */
  minPx: 1,

  /** Maximum size relative linear scale extent
   * @type {number=} */
  maxRelExtent: 0.1,

  /** Minimum size relative linear scale extent
   * @type {number=} */
  minRelExtent: 0.01,

  /** Maximum size relative discrete scale banwidth
   * @type {number=} */
  maxRelDiscrete: 1,

  /** Minimum size relative discrete scale banwidth
   * @type {number=} */
  minRelDiscrete: 0.1
};

function getPxSpaceFromScale(s, space) {
  if (s && typeof s.bandwidth === 'function') {
    // some kind of ordinal scale
    return {
      isBandwidth: true,
      value: Math.max(1, s.bandwidth() * space)
    };
  }

  return {
    isBandwidth: false,
    value: Math.max(1, space)
  };
}

function getPointSizeLimits(x, y, width, height, limits) {
  var xSpacePx = getPxSpaceFromScale(x ? x.scale : undefined, width, limits);
  var ySpacePx = getPxSpaceFromScale(y ? y.scale : undefined, height, limits);
  var maxSizePx = Math.min(xSpacePx.value * limits[xSpacePx.isBandwidth ? 'maxRelDiscrete' : 'maxRelExtent'], ySpacePx.value * limits[ySpacePx.isBandwidth ? 'maxRelDiscrete' : 'maxRelExtent']);
  var minSizePx = Math.min(xSpacePx.value * limits[xSpacePx.isBandwidth ? 'minRelDiscrete' : 'minRelExtent'], ySpacePx.value * limits[ySpacePx.isBandwidth ? 'minRelDiscrete' : 'minRelExtent']);
  var min = Math.max(1, Math.floor(minSizePx));
  var max = Math.max(1, Math.floor(maxSizePx));
  return {
    min: min,
    max: max,
    maxGlobal: limits.maxPx,
    minGlobal: limits.minPx
  };
}

function createDisplayPoints(dataPoints, _ref, pointSize, shapeFn) {
  var width = _ref.width,
      height = _ref.height;
  return dataPoints.filter(function (p) {
    return !isNaN(p.x + p.y);
  }).map(function (p) {
    var s = notNumber(p.size) ? DEFAULT_ERROR_SETTINGS.errorShape : p;
    var size = pointSize.min + s.size * (pointSize.max - pointSize.min);
    var shapeSpec = {
      type: s.shape === 'rect' ? 'square' : s.shape,
      label: p.label,
      x: p.x * width,
      y: p.y * height,
      fill: s.fill,
      size: Math.min(pointSize.maxGlobal, Math.max(pointSize.minGlobal, size)),
      stroke: s.stroke,
      strokeWidth: s.strokeWidth,
      strokeDasharray: s.strokeDasharray,
      opacity: s.opacity
    };

    if (s === p.errorShape) {
      shapeSpec.width = s.width;
    }

    var shape = shapeFn(shapeSpec);
    shape.data = p.data;
    return shape;
  });
}

var component$1 = {
  require: ['chart', 'resolver'],
  defaultSettings: {
    settings: {},
    data: {},
    animations: {
      enabled: false,
      trackBy: function trackBy(node) {
        return node.data.value;
      }
    },
    style: {
      item: '$shape'
    }
  },
  render: function render(_ref2) {
    var data = _ref2.data;
    var resolved = this.resolver.resolve({
      data: data,
      defaults: extend({}, DEFAULT_DATA_SETTINGS$1, this.style.item),
      settings: this.settings.settings,
      scaled: {
        x: this.rect.width,
        y: this.rect.height
      }
    });
    var _this$rect = this.rect,
        width = _this$rect.width,
        height = _this$rect.height;
    var limits = extend({}, SIZE_LIMITS, this.settings.settings.sizeLimits);
    var points = resolved.items;
    var pointSize = getPointSizeLimits(resolved.settings.x, resolved.settings.y, width, height, limits);
    return createDisplayPoints(points, this.rect, pointSize, this.settings.shapeFn || create$3);
  }
};

/**
 * @typedef {object} component--point
 */

/**
 * @type {string}
 * @memberof component--point
 */

var type = 'point';
function pointMarker(picasso) {
  picasso.component(type, component$1);
  picasso.component('point-marker', component$1); // temporary backwards compatibility - DEPRECATED
}

/**
 * @typedef {object}
 * @alias component--pie-settings
 */

var DEFAULT_DATA_SETTINGS$2 = {
  /** Start angle of the pie, in radians
   * @type {number=} */
  startAngle: 0,

  /** End angle of the pie, in radians
   * @type {number=} */
  endAngle: 2 * Math.PI,

  /**
   * @typedef {object}
   */
  slice: {
    label: '',

    /** Absolute value of the slice's arc length
     * @type {number=} */
    arc: 1,

    /** Visibility of the slice
     * @type {boolean=} */
    show: true,

    /** Fill color of the slice
     * @type {string=} */
    fill: '#333',

    /** Stroke color of the slice
     * @type {string=} */
    stroke: '#ccc',

    /** Stroke width of the slice
     * @type {number=} */
    strokeWidth: 1,

    /** Stroke line join
     * @type {string=} */
    strokeLinejoin: 'round',

    /** Opacity of the slice
     * @type {number=} */
    opacity: 1,

    /** Inner radius of the slice
     * @type {number=} */
    innerRadius: 0,

    /** Outer radius of the slice
     * @type {number=} */
    outerRadius: 0.8,

    /** Corner radius of the slice, in pixels
     * @type {number=} */
    cornerRadius: 0,

    /** Radial offset of the slice
     * @type {number=} */
    offset: 0
  }
};
/**
 * @typedef {object} component--pie
 * @property {string} [type='pie']
 * @example
 * {
 *   type: 'pie',
 *   data: {
 *     extract: {
 *       field: 'Region',
 *       props: {
 *         num: { field: 'Population' }
 *       }
 *     }
 *   },
 *   settings: {
 *     startAngle: Math.PI / 2,
 *     endAngle: -Math.PI / 2,
 *     slice: {
 *       arc: { ref: 'num' },
 *       fill: 'green',
 *       stroke: 'red',
 *       strokeWidth: 2,
 *       strokeLinejoin: 'round',
 *       innerRadius: 0.6,
 *       outerRadius 0.8,
 *       opacity: 0.8,
 *       offset: 0.2
 *     }
 *   }
 * }
 */

function offsetSlice(centroid, offset, outerRadius, innerRadius) {
  var _centroid = _slicedToArray(centroid, 2),
      vx = _centroid[0],
      vy = _centroid[1];

  var vlen = Math.sqrt(vx * vx + vy * vy);
  vx /= vlen;
  vy /= vlen;
  var diff = outerRadius - innerRadius;
  return {
    x: vx * offset * diff,
    y: vy * offset * diff
  };
}

function createDisplayPies(arcData, _ref, slices, sum) {
  var x = _ref.x,
      y = _ref.y,
      width = _ref.width,
      height = _ref.height;
  var arcGen = arc();
  var center = {
    x: x + width / 2,
    y: y + height / 2
  };
  var innerRadius = Math.min(width, height) / 2;
  var outerRadius = Math.min(width, height) / 2;
  var cornerRadius = outerRadius / 100;
  return arcData.map(function (a, i) {
    var slice = slices[i];
    slice.type = 'path';
    var or = outerRadius * slice.outerRadius;
    var ir = innerRadius * slice.innerRadius;
    arcGen.innerRadius(ir);
    arcGen.outerRadius(or);
    arcGen.cornerRadius(cornerRadius * slice.cornerRadius);
    slice.d = arcGen(a);
    var centroid = arcGen.centroid(a);
    var offset = slice.offset ? offsetSlice(centroid, slice.offset, or, ir) : {
      x: 0,
      y: 0
    };
    slice.transform = "translate(".concat(offset.x, ", ").concat(offset.y, ") translate(").concat(center.x, ", ").concat(center.y, ")");
    slice.desc = {
      share: a.value / sum,
      slice: {
        start: a.startAngle,
        end: a.endAngle,
        innerRadius: ir,
        outerRadius: or,
        offset: {
          x: center.x + offset.x,
          y: center.y + offset.y
        }
      }
    };
    return slice;
  });
}

function arcValue(stngs, item) {
  if (stngs.slice && 'arc' in stngs.slice) {
    return item.arc;
  }

  return item.data.value;
}
var pieComponent = {
  require: ['chart', 'resolver'],
  defaultSettings: {
    settings: {
      startAngle: 0,
      endAngle: 2 * Math.PI,
      padAngle: 0,
      slice: {}
    },
    style: {
      slice: '$shape'
    },
    data: {}
  },
  render: function render(_ref2) {
    var data = _ref2.data;
    var arcValues = [];
    var slices = [];
    var stngs = this.settings.settings;

    var _this$resolver$resolv = this.resolver.resolve({
      data: data,
      defaults: extend({}, DEFAULT_DATA_SETTINGS$2.slice, this.style.slice),
      settings: stngs.slice
    }),
        items = _this$resolver$resolv.items;

    var sum = 0;

    for (var i = 0, len = items.length; i < len; i++) {
      var val = arcValue(stngs, items[i]);

      if (val > 0 && items[i].outerRadius >= items[i].innerRadius) {
        arcValues.push(val);
        slices.push(items[i]);
        sum += val;
      }
    }

    var pieGen = pie().sortValues(null);
    pieGen.startAngle(stngs.startAngle);
    pieGen.endAngle(stngs.endAngle);
    pieGen.padAngle(stngs.padAngle);
    var arcData = pieGen(arcValues);
    return createDisplayPies(arcData, extend({}, this.rect, {
      x: 0,
      y: 0
    }), slices, sum);
  }
};

function pie$1(picasso) {
  picasso.component('pie', pieComponent);
}

/**
 * Create a crispifier
 * @ignore
 *
 * @param  {Object} [crispMap] Optional crispmap if you need custom crisping.
 * @return {Function}          crispItem function
 *
 * @example
 * import { crispifierFactory } from "core/crispifier";
 *
 * let crispify = crispifierFactory(customCrispMap);
 *
 * // For a single item
 * crispify(myItem);
 *
 * // For multiple items
 * crispify.multiple(myArrayOfItems);
 */
function crispifierFactory(crispMap) {
  // Define the crispMap
  if (crispMap === undefined) {
    crispMap = {};
    crispMap.line = {
      append: ['x1', 'x2', 'y1', 'y2'],
      round: [],
      condition: function condition(item) {
        return item.x1 === item.x2 || item.y1 === item.y2;
      },
      conditionAppend: function conditionAppend(item) {
        return item.strokeWidth % 2 !== 0;
      }
    };
    crispMap.rect = {
      append: ['x', 'y'],
      round: ['width', 'height'],
      condition: function condition() {
        return true;
      },
      conditionAppend: function conditionAppend(item) {
        return item.strokeWidth % 2 !== 0;
      }
    };
  } // Re-map the crispmap


  Object.keys(crispMap).forEach(function (type) {
    var self = crispMap[type];
    self.items = [];
    self.append.forEach(function (toAppend) {
      self.items.push({
        key: toAppend,
        type: 'append'
      });
    });
    self.round.forEach(function (toAppend) {
      self.items.push({
        key: toAppend,
        type: 'round'
      });
    });
  });
  /**
   * Crispify a single item
   * @ignore
   * @param  {Object} item  Item with renderer variables such as X, Y, and type.
   * @return {Undefined}    Returns nothing, modifies the original item instead
   */

  function crispItem(item) {
    if (crispMap[item.type] && crispMap[item.type].condition(item)) {
      var self = crispMap[item.type];
      var doAppend = self.conditionAppend === undefined || self.conditionAppend(item);
      self.items.forEach(function (i) {
        var rounded = Math.round(item[i.key]);
        var diff = item[i.key] - rounded;
        item[i.key] = rounded;

        if (doAppend && i.type === 'append') {
          if (diff > 0) {
            item[i.key] += 0.5;
          } else {
            item[i.key] -= 0.5;
          }
        }
      });
    }
  }
  /**
   * Crispify multiple items
   * @ignore
   *
   * @param  {Array} items  Array of objects to crispify
   * @return {Undefined}    Returns nothing, modifies the original item instead
   */


  crispItem.multiple = function (items) {
    return items.forEach(function (item) {
      return crispItem(item);
    });
  };

  return crispItem;
}
var crispifier = crispifierFactory();

var Transposer =
/*#__PURE__*/
function () {
  /**
   * @private
   */
  function Transposer() {
    _classCallCheck$1(this, Transposer);

    this.reset();
    this.push.apply(this, arguments);
  }
  /**
   * Evaluate a key for a transposed coordinate
   *
   * @param  {String} key   Key
   * @return {String}         Actual key
   */


  _createClass$1(Transposer, [{
    key: "transposeCoordinate",

    /**
     * Transpose a coordinate according to this.flipXY and
     * the available rendering area
     *
     * @param  {String} key        The key of the coordinate to transpose
     * @param  {Number} coordinate The coordinate
     * @return {Number}            The actual location of the coordinate
     */
    value: function transposeCoordinate(key, coordinate, flipXY) {
      if (typeof coordinate === 'number' && isFinite(coordinate)) {
        var firstChar = key.substring(0, 1);

        if (firstChar === 'x' || key === 'cx') {
          return coordinate * this.width;
        }

        if (key === 'width') {
          return coordinate * this.width;
        }

        if (key === 'r') {
          return coordinate * (!flipXY ? this.width : this.height);
        }

        if (firstChar === 'y' || key === 'cy') {
          return coordinate * this.height;
        }

        if (key === 'height') {
          return coordinate * this.height;
        }
      }

      return coordinate;
    }
    /**
     * Push an item into the storage of the transposer
     *
     * @param  {Object} items An item to be drawed
     * @return {Object}       Can be chained
     */

  }, {
    key: "push",
    value: function push() {
      var _this$storage;

      (_this$storage = this.storage).push.apply(_this$storage, arguments);

      return this;
    }
  }, {
    key: "processItem",
    value: function processItem(item) {
      var newItem = {};
      var flipXY = typeof item.flipXY !== 'undefined' ? item.flipXY : this.flipXY;
      var crisp = typeof item.crisp !== 'undefined' ? item.crisp : this.crisp;

      if (item.fn && typeof item.fn === 'function') {
        var width = flipXY ? this.height : this.width;
        var height = flipXY ? this.width : this.height;
        item = item.fn({
          width: width,
          height: height,
          flipXY: flipXY
        });
        var objectKeys = Object.keys(item);

        for (var ki = 0, kl = objectKeys.length; ki < kl; ki++) {
          var key = objectKeys[ki];
          var nkey = Transposer.evaluateKey(key, flipXY);
          newItem[nkey] = item[key];
        }
      } else {
        var _objectKeys = Object.keys(item);

        for (var _ki = 0, _kl = _objectKeys.length; _ki < _kl; _ki++) {
          var _key = _objectKeys[_ki];

          var _nkey = Transposer.evaluateKey(_key, flipXY);

          var nval = this.transposeCoordinate(_nkey, item[_key], flipXY);
          newItem[_nkey] = nval;
        }
      }

      if (crisp) {
        crispifier(newItem);
      }

      return newItem;
    }
    /**
     * Get the output of the transposer
     *
     * @return {Array}   Array of objects
     */

  }, {
    key: "output",
    value: function output() {
      var items = [];

      for (var i = 0, l = this.storage.length; i < l; i++) {
        var newItem = this.processItem(this.storage[i]);
        items.push(newItem);
      }

      return items;
    }
    /**
     * Reset the transposer
     *
     * @return {Undefined}  Does not return anything
     */

  }, {
    key: "reset",
    value: function reset() {
      this.storage = [];
      this.flipXY = false;
      this.crisp = false;
      this.width = 0;
      this.height = 0;
    }
  }], [{
    key: "evaluateKey",
    value: function evaluateKey(key, flipXY) {
      if (flipXY) {
        var firstChar = key.substring(0, 1);
        var rest = key.substring(1);

        if (firstChar === 'x') {
          return "y".concat(rest);
        }

        if (firstChar === 'y') {
          return "x".concat(rest);
        }

        if (key === 'cx') {
          return 'cy';
        }

        if (key === 'cy') {
          return 'cx';
        }

        if (key === 'width') {
          return 'height';
        }

        if (key === 'height') {
          return 'width';
        }
      }

      return key;
    }
  }]);

  return Transposer;
}();

function transposer() {
  for (var _len = arguments.length, items = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
    items[_key2] = arguments[_key2];
  }

  return _construct(Transposer, items);
}

/**
 * Generate array of lines (ticks) from scale
 *
 * @param {object} scale - A scale supplied by the chart
 * @param {object} settings - The settings object from the grid line component
 * @param {object} rect - The rect containing width and height to renderer in
 * @returns {array} - Returns an array of ticks
 * @ignore
 */

function lineGen(scale, distance) {
  if (!scale || !distance) {
    return [];
  }

  return scale.cachedTicks && scale.cachedTicks() || scale.ticks({
    distance: distance
  });
}

var gridLineComponent = {
  created: function created() {},
  require: ['chart', 'renderer', 'resolver'],
  defaultSettings: {
    layout: {
      displayOrder: 0
    },
    style: {
      // Theming style
      ticks: '$guide-line',
      minorTicks: '$guide-line--minor'
    }
  },
  beforeRender: function beforeRender() {
    this.blueprint = transposer();
    this.blueprint.width = this.rect.width;
    this.blueprint.height = this.rect.height;
    this.blueprint.x = this.rect.x;
    this.blueprint.y = this.rect.y;
    this.blueprint.crisp = true;
  },
  render: function render() {
    var _this = this;

    // Setup scales
    this.x = this.settings.x ? this.chart.scale(this.settings.x) : null;
    this.y = this.settings.y ? this.chart.scale(this.settings.y) : null;
    updateScaleSize(this, 'x', this.rect.width);
    updateScaleSize(this, 'y', this.rect.height); // Return an empty array to abort rendering when no scales are available to renderer

    if (!this.x && !this.y) {
      return [];
    }

    this.settings.ticks = extend({
      show: true
    }, this.style.ticks, this.settings.ticks || {});
    this.settings.minorTicks = extend({
      show: false
    }, this.style.minorTicks, this.settings.minorTicks || {}); // Setup lines for X and Y

    this.lines = {
      x: [],
      y: []
    }; // Use the lineGen function to generate appropriate ticks

    this.lines.x = lineGen(this.x, this.rect.width);
    this.lines.y = lineGen(this.y, this.rect.height); // Set all Y lines to flipXY by default
    // This makes the transposer flip them individually

    this.lines.y = this.lines.y.map(function (i) {
      return extend(i, {
        flipXY: true
      });
    });

    var addTicks = function addTicks(_ref) {
      var dir = _ref.dir,
          isMinor = _ref.isMinor;

      var items = _this.lines[dir].filter(function (tick) {
        return !!tick.isMinor === isMinor;
      });

      var settings = isMinor ? _this.settings.minorTicks : _this.settings.ticks;

      var ticks = _this.resolver.resolve({
        settings: settings,
        data: {
          items: items,
          dir: dir
        }
      }).items;

      ticks.forEach(function (style) {
        var p = style.data; // If the style's show is falsy, don't renderer this item (to respect axis settings).

        if (style.show) {
          // Use the transposer to handle actual positioning
          _this.blueprint.push({
            type: 'line',
            x1: p.position,
            y1: 0,
            x2: p.position,
            y2: 1,
            stroke: style.stroke || 'black',
            strokeWidth: typeof style.strokeWidth !== 'undefined' ? style.strokeWidth : 1,
            strokeDasharray: typeof style.strokeDasharray !== 'undefined' ? style.strokeDasharray : undefined,
            flipXY: p.flipXY || false // This flips individual points (Y-lines)

          });
        }
      });
    };

    addTicks({
      dir: 'x',
      isMinor: false
    });
    addTicks({
      dir: 'x',
      isMinor: true
    });
    addTicks({
      dir: 'y',
      isMinor: false
    });
    addTicks({
      dir: 'y',
      isMinor: true
    });
    return this.blueprint.output();
  }
};

/**
 * @typedef {object} component--grid-line-settings
 * @property {object} x
 * @property {string} x.scale - The scale to use along x
 * @property {object} y
 * @property {string} y.scale - The scale to use along y
 * @property {object} [ticks]
 * @property {boolean} [ticks.show=true]
 * @property {string} [ticks.stroke='black']
 * @property {number} [ticks.strokeWidth='1']
 * @property {string} [ticks.strokeDasharray]
 * @property {object} [minorTicks]
 * @property {boolean} [minorTicks.show=true]
 * @property {string} [minorTicks.stroke='black']
 * @property {number} [minorTicks.strokeWidth='1']
 * @property {string} [minorTicks.strokeDasharray]
 */

function gridLine(picasso) {
  picasso.component('grid-line', gridLineComponent);
}

/**
 * Return a D property for a SVG path to get a direction marker
 *
 * @param {number} x - X coordinate
 * @param {number} y - Y coordinate
 * @param {number} r - Radius
 * @param {string} [d='bottom'] - Direction
 * @returns {string} - Finished D property
 * @ignore
 */
function directionMarker(x, y, r) {
  var d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'bottom';
  r *= 0.8;

  if (d === 'left' || d === 'right') {
    var right = d === 'right';
    return "\n      M ".concat(x, " ").concat(y - r, "\n      A ").concat(r * 1.25, " ").concat(r * 1.25, ", 0, 1, ").concat(right ? 0 : 1, ", ").concat(x, " ").concat(y + r, "\n      L ").concat(right ? x + r : x - r, " ").concat(y, " Z\n    ");
  }

  var bottom = d === 'bottom';
  return "\n    M ".concat(x - r, " ").concat(y, "\n    A ").concat(r * 1.25, " ").concat(r * 1.25, ", 0, 1, ").concat(bottom ? 1 : 0, ", ").concat(x + r, " ").concat(y, "\n    L ").concat(x, " ").concat(bottom ? y + r : y - r, " Z\n  ");
}

function directionTriangle(x, y, r) {
  var d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'bottom';
  r *= 0.75;

  if (d === 'left' || d === 'right') {
    var right = d === 'right';
    x += right ? r * 1.5 : -(r * 1.5);
    return "\n      M ".concat(x, " ").concat(y - r, "\n      L ").concat(x, " ").concat(y + r, "\n      L ").concat(right ? x + r : x - r, " ").concat(y, " Z\n    ");
  }

  var bottom = d === 'bottom';
  y += bottom ? r * 1.5 : -(r * 1.5);
  return "\n    M ".concat(x - r, " ").concat(y, "\n    L ").concat(x + r, " ").concat(y, "\n    L ").concat(x, " ").concat(bottom ? y + r : y - r, " Z\n  ");
}
/**
 * Handle out of bound shapes
 * Does not return anything, modifies "items" property instead (should be re-considered)
 *
 * @param {object} oob - Out of bounds object from parent
 * @param {object} settings - Settings object from parent
 * @param {object[]} items - Array of all items (for collision detection)
 * @ignore
 */


function oobManager(_ref) {
  var blueprint = _ref.blueprint,
      oob = _ref.oob,
      settings = _ref.settings,
      items = _ref.items;
  var oobKeys = Object.keys(oob);
  var style = settings.style.oob || {};

  var _loop = function _loop(i, len) {
    var key = oobKeys[i];
    var value = oob[key];

    if (value.length > 0) {
      var position = key.charAt(1);
      var flipXY = key.charAt(0) === 'y';
      var xPadding = style.padding.x + style.width;
      var yPadding = style.padding.y + style.width;
      var direction = 'bottom';

      if (flipXY) {
        direction = position === '1' ? 'bottom' : 'top';
      } else {
        direction = position === '1' ? 'right' : 'left';
      }

      var indicator = blueprint.processItem({
        fn: function fn(_ref2) {
          var width = _ref2.width,
              height = _ref2.height;

          /* eslint no-loop-func: 0 */
          var x = position * width + (position === '1' ? -xPadding : xPadding);
          var y = flipXY ? yPadding : height - yPadding;

          if (style.type === 'arc') {
            return {
              type: 'path',
              d: directionMarker(flipXY ? y : x, flipXY ? x : y, style.width, direction),
              x: x,
              y: y,
              stroke: style.stroke,
              fill: style.fill,
              strokeWidth: style.strokeWidth || 0
            };
          }

          return {
            type: 'circle',
            cx: x,
            cy: y,
            r: style.width,
            stroke: style.stroke,
            fill: style.fill,
            strokeWidth: style.strokeWidth || 0,
            opacity: style.opacity,
            data: value
          };
        },
        flipXY: flipXY
      });
      var x = indicator.cx || indicator.x;
      var y = indicator.cy || indicator.y;
      var text = {
        type: 'text',
        text: value.length || '',
        x: x - style.width * 0.4,
        y: y + style.width * 0.4,
        fontFamily: style.text.fontFamily,
        fontSize: "".concat(style.width * 1.3, "px"),
        stroke: style.text.stroke,
        fill: style.text.fill,
        strokeWidth: style.text.strokeWidth || 0,
        opacity: style.text.opacity
      };
      var triangle = {
        type: 'path',
        d: directionTriangle(x, y, style.width, direction),
        x: x,
        y: y,
        stroke: style.triangle.stroke,
        fill: style.triangle.fill,
        strokeWidth: style.triangle.strokeWidth || 0,
        opacity: style.triangle.opacity
      };
      items.push(indicator, text, triangle);
    }
  };

  for (var i = 0, len = oobKeys.length; i < len; i++) {
    _loop(i, len);
  }
}

function refLabelDefaultSettings() {
  return {
    fill: '#000',
    fontFamily: 'Arial',
    fontSize: '12px',
    opacity: 1,
    maxWidth: 1,
    maxWidthPx: 9999,
    padding: 5,
    background: {
      fill: '#fff',
      stroke: 'transparent',
      strokeWidth: 0,
      opacity: 0.5
    }
  };
}
/**
 * Converts a numerical OR string value to a normalized value
 *
 * @param {string|number} align -Description how to align (Numerical from 0-1 or 'top', 'left', 'center', 'middle', 'bottom' or 'right')
 * @returns {number} - Normalized value 0...1
 * @ignore
 */

function alignmentToNumber(align) {
  if (typeof align === 'undefined') {
    return 0;
  }

  if (typeof align === 'number' && isFinite(align)) {
    return align;
  }

  if (typeof align === 'string') {
    switch (align) {
      case 'center':
      case 'middle':
        return 0.5;

      case 'bottom':
      case 'right':
        return 1;

      case 'top':
      case 'left':
      default:
        return 0;
    }
  }

  return 0;
}
/**
 * Create line and label (if applicable)
 * Does not return anything, modifies "items" property instead (should be re-considered)
 *
 * @param {object} p - Current point
 * @param {object} style - Applicable line styling
 * @param {object} settings - Settings object derived from parent
 * @param {object[]} items - Array of all items (for collision detection)
 * @ignore
 */

function createLineWithLabel(_ref) {
  var chart = _ref.chart,
      blueprint = _ref.blueprint,
      renderer = _ref.renderer,
      p = _ref.p,
      settings = _ref.settings,
      items = _ref.items;
  var doesNotCollide = true;
  var line = false;
  var rect = false;
  var label = false;
  var value = false;
  var style = extend(true, {}, settings.style.line, p.line || {}); // Use the transposer to handle actual positioning

  line = blueprint.processItem({
    type: 'line',
    x1: p.position,
    y1: 0,
    x2: p.position,
    y2: 1,
    stroke: style.stroke || 'black',
    strokeWidth: style.strokeWidth || 1,
    flipXY: p.flipXY || false // This flips individual points (Y-lines)

  });

  if (p.label) {
    var item = extend(true, refLabelDefaultSettings(), settings.style.label || {}, {
      fill: style.stroke
    }, p.label);
    var formatter;
    var measuredValue = {
      width: 0,
      height: 0
    };
    var valueString = '';

    if (typeof p.formatter === 'string') {
      formatter = chart.formatter(p.formatter);
    } else if (_typeof(p.formatter) === 'object') {
      formatter = chart.formatter(p.formatter);
    } else if (typeof p.scale !== 'undefined' && p.scale.data) {
      // TODO - Add support for array as source into formatter
      var scaleData = p.scale.data() && p.scale.data().fields;
      formatter = scaleData && scaleData[0] ? scaleData[0].formatter() : null;
    }

    if (formatter) {
      valueString = " (".concat(formatter(p.value), ")");
    } else if (p.scale) {
      valueString = " (".concat(p.value, ")");
    }

    if (valueString) {
      measuredValue = renderer.measureText({
        text: valueString,
        fontFamily: item.fontFamily,
        fontSize: item.fontSize
      });
    } // Measure the label text


    var measuredLabel = renderer.measureText({
      text: item.text || '',
      fontFamily: item.fontFamily,
      fontSize: item.fontSize
    });
    var measured = {
      width: measuredLabel.width + measuredValue.width,
      height: Math.max(measuredLabel.height, measuredValue.height)
    };
    var labelPadding = item.padding; // let anchor = item.anchor === 'end' ? 'end' : 'start';

    var align = alignmentToNumber(p.flipXY ? item.vAlign : item.align);
    var vAlign = alignmentToNumber(p.flipXY ? item.align : item.vAlign);
    var calcWidth = Math.min(1 + measured.width + labelPadding * 2, item.maxWidth * blueprint.width, item.maxWidthPx);
    var calcHeight = measured.height + labelPadding * 2;
    var rectWidth = p.flipXY ? calcHeight : calcWidth;
    var rectHeight = p.flipXY ? calcWidth : calcHeight;
    rect = blueprint.processItem({
      fn: function fn(_ref2) {
        var width = _ref2.width,
            height = _ref2.height;
        var x = p.position * width - (p.flipXY ? calcHeight : calcWidth) * (1 - align);
        x = p.flipXY ? x : Math.max(x, 0);
        var y = Math.max(Math.abs(vAlign * height - rectHeight * vAlign), 0);
        return {
          type: 'rect',
          x: x,
          y: y,
          width: p.flipXY ? rectWidth : Math.min(rectWidth, blueprint.width - x),
          height: rectHeight,
          stroke: item.background.stroke,
          strokeWidth: item.background.strokeWidth,
          fill: item.background.fill,
          opacity: item.background.opacity
        };
      },
      flipXY: p.flipXY || false // This flips individual points (Y-lines)

    });

    if (rect.x < -1 || rect.x + rect.width > blueprint.width + 1 || rect.y < -1 || rect.y + rect.height > blueprint.height + 1) {
      // do not create labels if out of bounds
      rect = undefined;
    } else {
      // Labels are just basic objects attached to a corner of a rect,
      // and this rect needs to already be processed
      // so there is no blueprint.processItem required here
      label = {
        type: 'text',
        text: item.text || '',
        fill: item.fill,
        opacity: item.opacity,
        fontFamily: item.fontFamily,
        fontSize: item.fontSize,
        x: rect.x + labelPadding,
        y: rect.y + rect.height / 2 + measured.height / 3,
        maxWidth: rect.width - labelPadding * 2 - measuredValue.width,
        anchor: 'start'
      };

      if (valueString) {
        value = {
          type: 'text',
          text: valueString || '',
          fill: item.fill,
          opacity: item.opacity,
          fontFamily: item.fontFamily,
          fontSize: item.fontSize,
          x: label.x + 3 + (rect.width - (measuredValue.width + labelPadding * 2)),
          y: label.y
        };
      } // Detect collisions with other labels/rects or lines


      for (var i = 0, len = items.length; i < len; i++) {
        var curItem = items[i];

        if (curItem.type === 'rect') {
          // We only detect rects here, since rects are always behind labels,
          // and we wouldn't want to measure text one more time
          if (testRectRect(rect, curItem)) {
            doesNotCollide = false;
          }
        } else if (curItem.type === 'line') {
          // This will only collide when flipXY are the same for both objects,
          // So it only collides on objects on the same "axis"
          if (p.flipXY === curItem.flipXY && testRectLine(rect, curItem)) {
            doesNotCollide = false;
          }
        }
      }
    }
  } // Always push the line,
  // but this is done after collision detection,
  // because otherwise it would collide with it's own line


  items.push(line); // Only push rect & label if we haven't collided and both are defined

  if (doesNotCollide && rect && label) {
    items.push(rect, label);

    if (value) {
      items.push(value);
    }
  }
}

function createOobData(line) {
  var data = {
    value: line.value
  };

  if (line.label) {
    data.label = line.label.text;
  }

  return data;
}

function filterUndefinedValue(line) {
  return typeof line.value !== 'undefined';
}
/**
 * @typedef {object} component--ref-line
 * @experimental
 * @property {refline-generic-style} [style=refline-generic-style] - x coordinate
 * @property {object} lines - X & Y Lines
 * @property {reflines-x[]} [lines.x=refline-line[]] - lines along X
 * @property {reflines-y[]} [lines.y=refline-line[]] - lines along Y
 */

/**
 * @typedef {object} component--ref-line.style
 * @property {refline-oob-style} [oob=component--ref-line.style.oob] - Style for out of bounds object (oob)
 * @property {refline-line} [line=refline-line] - Generic style for lines
 * @property {refline-line-label} [label=refline-line-label] - Generic style for labels
 */

/**
 * @typedef {object} component--ref-line.style.oob
 * @property {boolean} [show=true] - Show out of bounds items
 * @property {string} [type=undefined] - EXPERIMENTAL:  Set this to 'arc' for an experimental out of bounds shape (only works with SVG)
 * @property {number} [width=10] - Width of the out of bounds object
 * @property {string} [fill='#1A1A1A'] - Fill color of the OOB object
 * @property {string} [stroke='transparent'] - Stroke of the OOB object
 * @property {number} [strokeWidth=0] - Stroke width of the OOB object
 * @property {number} [opacity=1] - Opacity of the OOB object
 * @property {refline-generic-text} [text=refline-generic-text] - Text configuration for out of bounds
 * @property {refline-generic-object} [triangle=refline-generic-object] - The triangle in OOB
 * @property {object} [padding] - Padding on X
 * @property {number} [padding.x=28] - Padding on X
 * @property {number} [padding.y=5] - Padding on X
 */

/**
 * @typedef {object} component--ref-line.generic-text
 * @property {string} [text=''] - Text (if applicable)
 * @property {string} [fontSize='12px'] - Font size (if applicable)
 * @property {string} [fontFamily='Arial'] - Font family
 * @property {string} [fill='#fff'] - Fill color
 * @property {string} [stroke='transparent'] - Stroke
 * @property {number} [strokeWidth=0] - Stroke width
 * @property {number} [opacity=1] - Opacity
 */

/**
 * @typedef {object} component--ref-line.line
 * @property {number} value - The value of the reference line. If a scale is specified, it is applied.
 * @property {Scale} [scale=undefined] - Scale to use (if undefined will use normalized value 0-1)
 * @property {refline-generic-object} [line=refline-generic-object] - The style of the line
 * @property {refline-line-label} [label=refline-line-label] - The label style of the line
 */

/**
 * @typedef {object} component--ref-line.line-label
 * @property {number} padding=5 - Padding inside the label
 * @property {string} [text=''] - Text
 * @property {string} [fontSize='12px'] - Font size
 * @property {string} [fontFamily='Arial'] - Font family
 * @property {string} [stroke='transparent'] - Stroke
 * @property {number} [strokeWidth=0] - Stroke width
 * @property {number} [opacity=1] - Opacity
 * @property {number|string} [align=0] - Alignment property left to right (0 = left, 1 = right). Also supports string ('left', 'center', 'middle', 'right')
 * @property {number|string} [vAlign=0] - Alignment property top to bottom (0 = top, 1 = bottom). Also supports string ('top', 'center', 'middle', 'bottom')
 * @property {number} [maxWidth=1] - The maximum relative width to the width of the rendering area (see maxWidthPx below aswell)
 * @property {number} [maxWidthPx=9999] - The maximum width in pixels.
 * @property {refline-line-label-background} [background=refline-line-label-background] - The background style (rect behind text)
 */

/**
 * @example
 * // Labels will be rendered with the maximum size of the smallest value of maxWidth and maxWidthPx size, so you may specify maxWidth 0.8 but maxWidthPx 100 and will never be over 100px and never over 80% of the renderable area.
 */

/**
 * @typedef {object} component--ref-line.line-label-background
 * @property {string} [fill='#fff'] - Fill color
 * @property {string} [stroke='transparent'] - Stroke
 * @property {number} [strokeWidth=0] - Stroke width
 * @property {number} [opacity=0.5] - Opacity
 */

/**
 * @typedef {object} component--ref-line.generic-object
 * @property {string} [fill='#fff'] - Fill color
 * @property {string} [stroke='transparent'] - Stroke
 * @property {number} [strokeWidth=0] - Stroke width
 * @property {number} [opacity=1] - Opacity
 */


var refLineComponent = {
  require: ['chart', 'renderer'],
  defaultSettings: {
    layout: {
      displayOrder: 0
    },
    style: {
      oob: {
        show: true,
        width: 10,
        fill: '#1A1A1A',
        stroke: 'transparent',
        strokeWidth: 0,
        opacity: 1,
        text: {
          fontFamily: 'Arial',
          stroke: 'transparent',
          fill: '#fff',
          strokeWidth: 0,
          opacity: 1
        },
        triangle: {
          fill: '#4D4D4D',
          stroke: 'transparent',
          strokeWidth: 0,
          opacity: 1
        },
        padding: {
          x: 28,
          y: 5
        }
      },
      line: {
        stroke: '#000'
      },
      label: {
        strokeWidth: 0
      }
    }
  },
  preferredSize: function preferredSize() {
    return 30;
  },
  beforeRender: function beforeRender() {
    this.blueprint = transposer();
    this.blueprint.width = this.rect.width;
    this.blueprint.height = this.rect.height;
    this.blueprint.x = this.rect.x;
    this.blueprint.y = this.rect.y;
    this.blueprint.crisp = true;
  },
  render: function render() {
    var _this = this;

    var settings = this.settings; // Setup lines for X and Y

    this.lines = {
      x: [],
      y: []
    };
    this.lines.x = settings.lines && settings.lines.x || [];
    this.lines.y = settings.lines && settings.lines.y || [];

    if (this.lines.x.length === 0 && this.lines.y.length === 0) {
      return [];
    }

    var oob = {
      x0: [],
      x1: [],
      y0: [],
      y1: []
    }; // Convert a value to an actual position using the scale

    this.lines.x = this.lines.x.filter(filterUndefinedValue).map(function (line) {
      if (line.scale) {
        var scale = _this.chart.scale(line.scale);

        return extend(line, {
          scale: scale,
          position: scale(line.value)
        });
      }

      return extend(line, {
        position: line.value
      });
    }); // Set all Y lines to flipXY by default
    // This makes the transposer flip them individually

    this.lines.y = this.lines.y.filter(filterUndefinedValue).map(function (line) {
      if (line.scale) {
        var scale = _this.chart.scale(line.scale);

        return extend(line, {
          scale: scale,
          position: scale(line.value),
          flipXY: true
        });
      }

      return extend(line, {
        position: line.value,
        flipXY: true
      });
    }); // Move out of bounds lines (OOB) to separate rendering

    this.lines.x = this.lines.x.filter(function (line) {
      if (line.position < 0 || line.position > 1) {
        oob["x".concat(line.position > 1 ? 1 : 0)].push(createOobData(line));
        return false;
      }

      return true;
    });
    this.lines.y = this.lines.y.filter(function (line) {
      if (line.position < 0 || line.position > 1) {
        oob["y".concat(line.position > 1 ? 1 : 0)].push(createOobData(line));
        return false;
      }

      return true;
    });
    var items = []; // Loop through all X and Y lines

    [].concat(_toConsumableArray$1(this.lines.x), _toConsumableArray$1(this.lines.y)).forEach(function (p) {
      var show = p.show === true || typeof p.show === 'undefined';

      if (show) {
        // Create line with labels
        createLineWithLabel({
          chart: _this.chart,
          blueprint: _this.blueprint,
          renderer: _this.renderer,
          p: p,
          settings: settings,
          items: items
        });
      }
    }); // Handle out of bounds

    if (settings.style.oob.show) {
      oobManager({
        blueprint: this.blueprint,
        oob: oob,
        settings: settings,
        items: items
      });
    }

    return items;
  }
};

function refLine(picasso) {
  picasso.component('ref-line', refLineComponent);
}

function appendStyle(struct, buildOpts) {
  extend(struct, buildOpts.style);
  var halfWidth = struct.strokeWidth / 2;

  if (buildOpts.align === 'top') {
    struct.y1 -= halfWidth;
    struct.y2 -= halfWidth;
  } else if (buildOpts.align === 'bottom') {
    struct.y1 += halfWidth;
    struct.y2 += halfWidth;
  } else if (buildOpts.align === 'left') {
    struct.x1 -= halfWidth;
    struct.x2 -= halfWidth;
  } else if (buildOpts.align === 'right') {
    struct.x1 += halfWidth;
    struct.x2 += halfWidth;
  }
}

function buildLine(buildOpts) {
  var struct = {
    type: 'line',
    x1: 0,
    x2: 0,
    y1: 0,
    y2: 0,
    collider: {
      type: null
    }
  };

  if (buildOpts.align === 'top' || buildOpts.align === 'bottom') {
    struct.x1 = buildOpts.innerRect.x - buildOpts.outerRect.x;
    struct.x2 = buildOpts.innerRect.width + buildOpts.innerRect.x;
    struct.y1 = struct.y2 = buildOpts.align === 'top' ? buildOpts.innerRect.height - buildOpts.padding : buildOpts.padding;
  } else {
    struct.x1 = struct.x2 = buildOpts.align === 'left' ? buildOpts.innerRect.width - buildOpts.padding : buildOpts.padding;
    struct.y1 = buildOpts.innerRect.y - buildOpts.outerRect.y;
    struct.y2 = buildOpts.innerRect.height + buildOpts.innerRect.y;
  }

  appendStyle(struct, buildOpts);
  return struct;
}

function checkText(text) {
  return typeof text === 'string' || typeof text === 'number' ? text : '-';
}

function appendStyle$1(struct, buildOpts) {
  ['fill', 'fontSize', 'fontFamily'].forEach(function (style) {
    struct[style] = buildOpts.style[style];
  });
}

function clampEnds(struct, buildOpts) {
  if (buildOpts.tilted || buildOpts.stepSize) {
    return;
  }

  if (buildOpts.align === 'top' || buildOpts.align === 'bottom') {
    var leftBoundary = 0;
    var rightBoundary = buildOpts.outerRect.width;
    var textWidth = Math.min(buildOpts.maxWidth / 2, buildOpts.textRect.width / 2);
    var leftTextBoundary = struct.x - textWidth;
    var rightTextBoundary = struct.x + textWidth;

    if (leftTextBoundary < leftBoundary) {
      struct.anchor = 'start';
      struct.x = buildOpts.innerRect.x - buildOpts.outerRect.x;
    } else if (rightTextBoundary > rightBoundary) {
      struct.anchor = 'end';
      struct.x = buildOpts.innerRect.width + buildOpts.innerRect.x;
    }
  } else {
    var topBoundary = 0;
    var bottomBoundary = buildOpts.outerRect.height;
    var textHeight = buildOpts.maxHeight / 2;
    var topTextBoundary = struct.y - textHeight;
    var bottomTextBoundary = struct.y + textHeight;

    if (topTextBoundary < topBoundary) {
      struct.y = buildOpts.innerRect.y - buildOpts.outerRect.y;
      struct.baseline = 'text-before-edge';
    } else if (bottomTextBoundary > bottomBoundary) {
      struct.y = buildOpts.innerRect.height + (buildOpts.innerRect.y - buildOpts.outerRect.y);
      struct.baseline = 'text-after-edge';
    }
  }
}

function appendPadding(struct, buildOpts) {
  if (buildOpts.align === 'top') {
    struct.y -= buildOpts.padding;
  } else if (buildOpts.align === 'bottom') {
    struct.y += buildOpts.padding + buildOpts.maxHeight;
  } else if (buildOpts.align === 'left') {
    struct.x -= buildOpts.padding;
  } else if (buildOpts.align === 'right') {
    struct.x += buildOpts.padding;
  }
}

function appendTilting(struct, buildOpts) {
  if (buildOpts.tilted) {
    var r = -buildOpts.angle;
    var radians = r * (Math.PI / 180);

    if (buildOpts.align === 'bottom') {
      struct.x -= buildOpts.maxHeight * Math.sin(radians) / 2;
      struct.y -= buildOpts.maxHeight;
      struct.y += buildOpts.maxHeight * Math.cos(radians) / 2;
    } else {
      struct.x -= buildOpts.maxHeight * Math.sin(radians) / 3;
    }

    struct.transform = "rotate(".concat(r, ", ").concat(struct.x, ", ").concat(struct.y, ")");
    struct.anchor = buildOpts.align === 'bottom' === buildOpts.angle < 0 ? 'start' : 'end'; // adjustForEnds

    var textWidth = Math.cos(radians) * buildOpts.maxWidth;

    if (buildOpts.align === 'bottom' === buildOpts.angle < 0) {
      // right
      var rightBoundary = buildOpts.outerRect.width - buildOpts.paddingEnd;
      var rightTextBoundary = struct.x + textWidth;

      if (rightTextBoundary > rightBoundary) {
        struct.maxWidth = (rightBoundary - struct.x - 10) / Math.cos(radians);
      }
    } else {
      // left
      var leftBoundary = buildOpts.paddingEnd;
      var leftTextBoundary = struct.x - textWidth;

      if (leftTextBoundary < leftBoundary) {
        struct.maxWidth = (struct.x - leftBoundary - 10) / Math.cos(radians);
      }
    }
  }
}

function bandwidthCollider(tick, struct, buildOpts) {
  if (buildOpts.align === 'bottom' || buildOpts.align === 'top') {
    var tickCenter = tick.position * buildOpts.innerRect.width;
    var leftBoundary = tickCenter + (buildOpts.innerRect.x - buildOpts.outerRect.x - buildOpts.stepSize / 2);
    struct.collider = {
      type: 'rect',
      x: leftBoundary,
      y: 0,
      width: leftBoundary < 0 ? buildOpts.stepSize + leftBoundary : buildOpts.stepSize,
      // Adjust collider so that it doesnt extend onto neighbor collider
      height: buildOpts.innerRect.height
    };
  } else {
    var _tickCenter = tick.position * buildOpts.innerRect.height;

    var topBoundary = _tickCenter + (buildOpts.innerRect.y - buildOpts.outerRect.y - buildOpts.stepSize / 2);
    struct.collider = {
      type: 'rect',
      x: 0,
      y: topBoundary,
      width: buildOpts.innerRect.width,
      height: topBoundary < 0 ? buildOpts.stepSize + topBoundary : buildOpts.stepSize // Adjust collider so that it doesnt extend onto neighbor collider

    };
  } // Clip edges of the collider, should not extend beyoned the outerRect


  var collider = struct.collider;
  collider.x = Math.max(collider.x, 0);
  collider.y = Math.max(collider.y, 0);
  var widthClip = collider.x + collider.width - (buildOpts.outerRect.x + buildOpts.outerRect.width);
  collider.width = widthClip > 0 ? collider.width - widthClip : collider.width;
  var heightClip = collider.y + collider.height - (buildOpts.outerRect.y + buildOpts.outerRect.height);
  collider.height = heightClip > 0 ? collider.height - heightClip : collider.height;
}

function boundsCollider(tick, struct) {
  struct.collider = {
    type: 'polygon',
    vertices: [{
      x: struct.boundingRect.x,
      y: struct.boundingRect.y
    }, {
      x: struct.boundingRect.x + struct.boundingRect.width,
      y: struct.boundingRect.y
    }, {
      x: struct.boundingRect.x + struct.boundingRect.width,
      y: struct.boundingRect.y + struct.boundingRect.height
    }, {
      x: struct.boundingRect.x,
      y: struct.boundingRect.y + struct.boundingRect.height
    }]
  };
}

function tiltedCollider(tick, struct, buildOpts) {
  var radians = buildOpts.angle * (Math.PI / 180);
  var halfWidth = Math.max(buildOpts.stepSize / 2, struct.boundingRect.height / 2); // Handle if bandwidth is zero

  var startAnchor = struct.anchor === 'start';
  var em = struct.anchor === 'end' && radians < 0;
  var sp = struct.anchor === 'start' && radians >= 0;
  var y = struct.boundingRect.y + (sp || em ? struct.boundingRect.height : 0); // Generate starting points at bandwidth boundaries

  var points = [{
    x: struct.x - halfWidth,
    y: y
  }, {
    x: struct.x + halfWidth,
    y: y
  }].map(function (p) {
    return rotate(p, radians, {
      x: struct.x,
      y: struct.y
    });
  }); // Rotate around center point to counteract labels rotation
  // Append points to wrap polygon around label

  var margin = 10; // extend slightly to handle single char labels better

  var leftPoint = {
    x: startAnchor ? struct.boundingRect.x + struct.boundingRect.width + margin : struct.boundingRect.x - margin,
    y: struct.boundingRect.y + struct.boundingRect.height
  };
  var rightPoint = {
    x: startAnchor ? struct.boundingRect.x + struct.boundingRect.width + margin : struct.boundingRect.x - margin,
    y: struct.boundingRect.y
  };
  var orderedPoints = radians >= 0 ? [leftPoint, rightPoint] : [rightPoint, leftPoint];
  points.push.apply(points, orderedPoints);
  struct.collider = {
    type: 'polygon',
    vertices: points
  };
}

function appendCollider(tick, struct, buildOpts) {
  if (buildOpts.layered || !buildOpts.stepSize) {
    boundsCollider(tick, struct);
  } else if (buildOpts.tilted) {
    tiltedCollider(tick, struct, buildOpts);
  } else {
    bandwidthCollider(tick, struct, buildOpts);
  }
}

function appendBounds(struct, buildOpts) {
  struct.boundingRect = buildOpts.textBounds(struct);
}

function wiggle(buildOpts, isVertical) {
  var a = isNaN(buildOpts.style.align) ? 0.5 : Math.min(Math.max(buildOpts.style.align, 0), 1);
  var w = 0;

  if (buildOpts.tilted) {
    w = buildOpts.stepSize * a;
  } else {
    var size = isVertical ? buildOpts.textRect.height : buildOpts.textRect.width;
    w = Math.max(0, buildOpts.stepSize - size) * a;
  }

  return w;
}

function buildNode(tick, buildOpts) {
  var struct = {
    type: 'text',
    text: checkText(tick.label),
    x: 0,
    y: 0,
    maxWidth: buildOpts.maxWidth,
    maxHeight: buildOpts.maxHeight
  };

  if (buildOpts.align === 'top' || buildOpts.align === 'bottom') {
    struct.x = tick.start * buildOpts.innerRect.width + (buildOpts.innerRect.x - buildOpts.outerRect.x) + wiggle(buildOpts, false);
    struct.y = buildOpts.align === 'top' ? buildOpts.innerRect.height : 0;
    struct.anchor = buildOpts.stepSize ? 'start' : 'middle';
    struct.x += isNaN(buildOpts.style.offset) ? 0 : +buildOpts.style.offset;
  } else {
    struct.y = tick.start * buildOpts.innerRect.height + (buildOpts.innerRect.y - buildOpts.outerRect.y) + wiggle(buildOpts, true);
    struct.x = buildOpts.align === 'left' ? buildOpts.innerRect.width : 0;
    struct.anchor = buildOpts.align === 'left' ? 'end' : 'start';
    struct.baseline = buildOpts.stepSize ? 'text-before-edge' : 'central';
    struct.y += isNaN(buildOpts.style.offset) ? 0 : +buildOpts.style.offset;
  }

  appendStyle$1(struct, buildOpts);
  clampEnds(struct, buildOpts);
  appendPadding(struct, buildOpts);
  appendTilting(struct, buildOpts);
  appendBounds(struct, buildOpts);
  appendCollider(tick, struct, buildOpts);
  return struct;
}

function appendStyle$2(struct, buildOpts) {
  extend(struct, buildOpts.style);
}

function appendPadding$1(struct, buildOpts) {
  if (buildOpts.align === 'top') {
    struct.y1 -= buildOpts.padding;
    struct.y2 -= buildOpts.padding;
  } else if (buildOpts.align === 'bottom') {
    struct.y1 += buildOpts.padding;
    struct.y2 += buildOpts.padding;
  } else if (buildOpts.align === 'left') {
    struct.x1 -= buildOpts.padding;
    struct.x2 -= buildOpts.padding;
  } else if (buildOpts.align === 'right') {
    struct.x1 += buildOpts.padding;
    struct.x2 += buildOpts.padding;
  }
}

function adjustForEnds(struct, buildOpts) {
  var halfWidth = struct.strokeWidth / 2;

  if (struct.x1 === buildOpts.innerRect.width) {
    // outer end tick
    struct.x1 -= halfWidth;
    struct.x2 -= halfWidth;
  } else if (struct.x1 === 0) {
    // outer start tick
    struct.x1 += halfWidth;
    struct.x2 += halfWidth;
  } else if (struct.y1 === buildOpts.innerRect.height) {
    struct.y1 -= halfWidth;
    struct.y2 -= halfWidth;
  } else if (struct.y1 === 0) {
    struct.y1 += halfWidth;
    struct.y2 += halfWidth;
  }
}

function buildNode$1(tick, buildOpts) {
  var struct = {
    type: 'line',
    x1: 0,
    x2: 0,
    y1: 0,
    y2: 0,
    collider: {
      type: null
    }
  };

  if (buildOpts.align === 'top' || buildOpts.align === 'bottom') {
    struct.x1 = struct.x2 = tick.position * buildOpts.innerRect.width + (buildOpts.innerRect.x - buildOpts.outerRect.x);
    struct.y1 = buildOpts.align === 'top' ? buildOpts.innerRect.height : 0;
    struct.y2 = buildOpts.align === 'top' ? struct.y1 - buildOpts.tickSize : struct.y1 + buildOpts.tickSize;
  } else {
    struct.y1 = struct.y2 = tick.position * buildOpts.innerRect.height + (buildOpts.innerRect.y - buildOpts.outerRect.y);
    struct.x1 = buildOpts.align === 'left' ? buildOpts.innerRect.width : 0;
    struct.x2 = buildOpts.align === 'left' ? struct.x1 - buildOpts.tickSize : struct.x1 + buildOpts.tickSize;
  }

  appendStyle$2(struct, buildOpts);
  appendPadding$1(struct, buildOpts);
  adjustForEnds(struct, buildOpts);
  return struct;
}

function isMajorTick(tick) {
  return !tick.isMinor && tick.position >= 0 && tick.position <= 1;
}

function isVerticalLabelOverlapping(_ref) {
  var majorTicks = _ref.majorTicks,
      measureText = _ref.measureText,
      rect = _ref.rect;
  var size = rect.height;
  var textHeight = measureText('M').height;

  if (majorTicks.length < 2) {
    return false;
  }

  var d = size * Math.abs(majorTicks[0].position - majorTicks[1].position);

  if (d < textHeight) {
    return true;
  }

  return false;
}

function isHorizontalLabelOverlapping(_ref2) {
  var majorTicks = _ref2.majorTicks,
      measureText = _ref2.measureText,
      rect = _ref2.rect,
      state = _ref2.state;

  /*
   * Currently isn't any good way of doing a accurate measurement on size available (bandWidth * width) for labels.
   * It's a lifecycle limitation as components docked either left or right can affect the width available after the calculation is done.
   * <number of components docked left/right> * <width of components> => Less accurate ===> Can result in only ellips char rendered as labels.
   */
  var m = state.labels.activeMode === 'layered' ? 2 : 1;
  var size = rect.width;
  var tickSize = majorTicks.map(function (tick) {
    return tick.label;
  }).map(function (l) {
    return "".concat(l.slice(0, 1)).concat(l.length > 1 ? '…' : '');
  }) // Measure the size of 1 chars + the ellips char.
  .map(measureText).map(function (r) {
    return r.width;
  });

  for (var i = 0; i < majorTicks.length; ++i) {
    var tick = majorTicks[i];
    var d1 = m * size * Math.abs(tick.start - tick.end);
    var d2 = tickSize[i];

    if (d1 < d2) {
      return true;
    }
  }

  return false;
}

function shouldAutoTilt(_ref3) {
  var majorTicks = _ref3.majorTicks,
      measure = _ref3.measure,
      rect = _ref3.rect,
      state = _ref3.state,
      settings = _ref3.settings;
  var glyphCount = settings.labels.maxGlyphCount;
  var m = state.labels.activeMode === 'layered' ? 2 : 1;
  var magicSizeRatioMultipler = settings.labels.tiltThreshold ? settings.labels.tiltThreshold : 0.7; // So that if less the 70% of labels are visible, toggle on tilt or use variable tiltThreshold

  var ellipsCharSize = measure('…').width; // include ellipsed char in calc as it's generally large then the char it replaces

  var size = rect.width;
  var maxLabelWidth = 0;
  var d1 = 0;

  if (!isNaN(glyphCount)) {
    var minBandwidth = majorTicks.reduce(function (prev, curr) {
      return Math.min(Math.abs(curr.start - curr.end), prev);
    }, Infinity);
    d1 = m * size * minBandwidth;
    maxLabelWidth = measure('M').width * magicSizeRatioMultipler * glyphCount;

    if (maxLabelWidth + ellipsCharSize > d1) {
      return true;
    }
  } else {
    for (var i = 0; i < majorTicks.length; i++) {
      var tick = majorTicks[i];
      var label = tick.label;
      var width = measure(label).width * (label.length > 1 ? magicSizeRatioMultipler : 1);
      d1 = m * size * Math.abs(tick.start - tick.end);

      if (width + ellipsCharSize > d1) {
        return true;
      }
    }
  }

  return false;
}

function isTiltedLabelOverlapping(_ref4) {
  var majorTicks = _ref4.majorTicks,
      measureText = _ref4.measureText,
      rect = _ref4.rect,
      bleedSize = _ref4.bleedSize,
      angle = _ref4.angle;

  if (majorTicks.length < 2) {
    return false;
  }

  if (angle === 0) {
    return true; // TODO 0 angle should be considered non-tilted
  }

  var absAngle = Math.abs(angle);
  var size = rect.width - bleedSize;
  var stepSize = size * Math.abs(majorTicks[0].position - majorTicks[1].position);
  var textHeight = measureText('M').height;
  var reciprocal = 1 / stepSize; // 1 === Math.sin(90 * (Math.PI / 180))

  var distanceBetweenLabels = Math.sin(absAngle * (Math.PI / 180)) / reciprocal;
  return textHeight > distanceBetweenLabels;
}

function isToLarge(_ref5) {
  var rect = _ref5.rect,
      state = _ref5.state,
      majorTicks = _ref5.majorTicks,
      measure = _ref5.measure,
      horizontal = _ref5.horizontal;

  if (horizontal) {
    return isHorizontalLabelOverlapping({
      majorTicks: majorTicks,
      measureText: measure,
      rect: rect,
      state: state
    });
  }

  return isVerticalLabelOverlapping({
    majorTicks: majorTicks,
    measureText: measure,
    rect: rect,
    state: state
  });
}

function getClampedValue(_ref6) {
  var value = _ref6.value,
      maxValue = _ref6.maxValue,
      minValue = _ref6.minValue,
      range = _ref6.range,
      modifier = _ref6.modifier;

  if (!isNaN(range) && !isNaN(modifier)) {
    value = range * modifier;
  }

  if (value > maxValue) {
    value = maxValue;
  }

  if (value < minValue) {
    value = minValue;
  }

  return value;
}
function getSize(_ref7) {
  var isDiscrete = _ref7.isDiscrete,
      rect = _ref7.rect,
      formatter = _ref7.formatter,
      measureText = _ref7.measureText,
      scale = _ref7.scale,
      settings = _ref7.settings,
      state = _ref7.state;
  var size = 0;
  var edgeBleed = {
    left: 0,
    top: 0,
    right: 0,
    bottom: 0
  };
  var _settings$labels = settings.labels,
      maxValue = _settings$labels.maxLengthPx,
      minValue = _settings$labels.minLengthPx;

  if (settings.labels.show) {
    var align = settings.align;
    var horizontal = align === 'top' || align === 'bottom';
    var distance = horizontal ? rect.width : rect.height;
    var majorTicks = scale.ticks({
      settings: settings,
      distance: distance,
      formatter: formatter
    }).filter(isMajorTick);

    var measure = function measure(text) {
      var m = measureText({
        text: text,
        fontSize: settings.labels.fontSize,
        fontFamily: settings.labels.fontFamily
      });
      m.width = getClampedValue({
        value: m.width,
        maxValue: maxValue,
        minValue: minValue
      });
      return m;
    };

    if (isDiscrete && horizontal && settings.labels.mode === 'auto') {
      if (shouldAutoTilt({
        majorTicks: majorTicks,
        measure: measure,
        rect: rect,
        state: state,
        settings: settings
      })) {
        state.labels.activeMode = 'tilted';
      } else {
        state.labels.activeMode = 'horizontal';
      }
    }

    if (!settings.labels.filterOverlapping && state.labels.activeMode !== 'tilted' && isToLarge({
      rect: rect,
      state: state,
      majorTicks: majorTicks,
      measure: measure,
      horizontal: horizontal
    })) {
      var toLargeSize = Math.max(rect.width, rect.height); // used to hide the axis

      return {
        size: toLargeSize,
        isToLarge: true
      };
    }

    var sizeFromTextRect;

    if (state.labels.activeMode === 'tilted') {
      var radians = Math.abs(settings.labels.tiltAngle) * (Math.PI / 180); // angle in radians

      sizeFromTextRect = function sizeFromTextRect(r) {
        return getClampedValue({
          value: r.width,
          maxValue: maxValue,
          minValue: minValue
        }) * Math.sin(radians) + r.height * Math.cos(radians);
      };
    } else if (horizontal) {
      sizeFromTextRect = function sizeFromTextRect(r) {
        return r.height;
      };
    } else {
      sizeFromTextRect = function sizeFromTextRect(r) {
        return getClampedValue({
          value: r.width,
          maxValue: maxValue,
          minValue: minValue
        });
      };
    }

    var labels;

    if (horizontal && state.labels.activeMode !== 'tilted') {
      labels = ['M'];
    } else if (!isNaN(settings.labels.maxGlyphCount)) {
      var label = '';

      for (var i = 0; i < settings.labels.maxGlyphCount; i++) {
        label += 'M';
      }

      labels = [label];
    } else {
      labels = majorTicks.map(function (tick) {
        return tick.label;
      });
    }

    var tickMeasures = labels.map(measure);
    var labelSizes = tickMeasures.map(sizeFromTextRect);
    var textSize = Math.max.apply(Math, _toConsumableArray$1(labelSizes).concat([0]));
    size += textSize;
    size += settings.labels.margin;

    if (state.labels.activeMode === 'layered') {
      size *= 2;
    }

    if (state.labels.activeMode === 'tilted') {
      var extendLeft = settings.align === 'bottom' === settings.labels.tiltAngle >= 0;

      var _radians = Math.abs(settings.labels.tiltAngle) * (Math.PI / 180); // angle in radians


      var h = measureText('M').height;
      var maxWidth = (textSize - h * Math.cos(_radians)) / Math.sin(_radians);

      var labelWidth = function labelWidth(r) {
        return Math.min(maxWidth, r.width) * Math.cos(_radians) + r.height;
      };

      var adjustByPosition = function adjustByPosition(s, i) {
        var pos = majorTicks[i] ? majorTicks[i].position : 0;

        if (extendLeft) {
          return s - pos * rect.width;
        }

        return s - (1 - pos) * rect.width;
      };

      var bleedSize = Math.min(settings.labels.maxEdgeBleed, Math.max.apply(Math, _toConsumableArray$1(tickMeasures.map(labelWidth).map(adjustByPosition)).concat([0]))) + settings.paddingEnd;
      var bleedDir = extendLeft ? 'left' : 'right';
      edgeBleed[bleedDir] = bleedSize;

      if (!settings.labels.filterOverlapping && isTiltedLabelOverlapping({
        majorTicks: majorTicks,
        measureText: measureText,
        rect: rect,
        bleedSize: bleedSize,
        angle: settings.labels.tiltAngle
      })) {
        return {
          size: Math.max(rect.width, rect.height),
          isToLarge: true
        };
      }
    }
  }

  return {
    size: size,
    edgeBleed: edgeBleed
  };
}

var PADDING = 2;

var tickDistance = function tickDistance(rect, start, end) {
  return rect.width * Math.abs(start.position - end.position);
};

var getLeftEdgeWidth = function getLeftEdgeWidth(_ref) {
  var innerRect = _ref.innerRect,
      outerRect = _ref.outerRect,
      tick = _ref.tick,
      nextWidth = _ref.nextWidth;
  var leftEdgeBleed = innerRect.x - outerRect.x;
  var left = innerRect.width * tick.position + leftEdgeBleed;
  var minDubble = Math.min(nextWidth, left) * 2;
  var minWidth = tick.position === 0 ? innerRect.width / 2 - PADDING : 0;
  return Math.max(nextWidth, minDubble, minWidth);
};

var getRightEdgeWidth = function getRightEdgeWidth(_ref2) {
  var innerRect = _ref2.innerRect,
      outerRect = _ref2.outerRect,
      tick = _ref2.tick,
      prevWidth = _ref2.prevWidth;
  var leftEdgeBleed = innerRect.x - outerRect.x;
  var rightEdgeBleed = outerRect.width - innerRect.width - leftEdgeBleed;
  var right = innerRect.width - innerRect.width * tick.position + rightEdgeBleed;
  var minDubble = Math.min(prevWidth, right) * 2;
  var minWidth = tick.position === 1 ? innerRect.width / 2 - PADDING : 0;
  return Math.max(prevWidth, minDubble, minWidth);
};

function getHorizontalWidth(_ref3) {
  var layered = _ref3.layered,
      major = _ref3.major,
      innerRect = _ref3.innerRect,
      outerRect = _ref3.outerRect,
      tick = _ref3.tick,
      index = _ref3.index;
  var step = layered ? 2 : 1;
  var prev = major[index - step];
  var next = major[index + step];
  var prevWidth = prev ? tickDistance(innerRect, tick, prev) / 2 - PADDING : Infinity;
  var nextWidth = next ? tickDistance(innerRect, tick, next) / 2 - PADDING : Infinity;

  if (major.length < 2) {
    return innerRect.width;
  }

  if (!prev) {
    return getLeftEdgeWidth({
      innerRect: innerRect,
      outerRect: outerRect,
      tick: tick,
      nextWidth: nextWidth
    });
  }

  if (!next) {
    return getRightEdgeWidth({
      innerRect: innerRect,
      outerRect: outerRect,
      tick: tick,
      prevWidth: prevWidth
    });
  }

  return Math.min(prevWidth, nextWidth) * 2;
}

function tickSpacing(settings) {
  var spacing = 0;
  spacing += settings.paddingStart;
  spacing += settings.line.show ? settings.line.strokeWidth : 0;
  spacing += settings.ticks.show ? settings.ticks.margin : 0;
  return spacing;
}

function tickMinorSpacing(settings) {
  return settings.line.strokeWidth + settings.minorTicks.margin;
}

function labelsSpacing(settings) {
  var spacing = 0;
  spacing += settings.ticks.show ? settings.ticks.tickSize : 0;
  spacing += tickSpacing(settings) + settings.labels.margin;
  return spacing;
}

function calcActualTextRect(_ref) {
  var style = _ref.style,
      measureText = _ref.measureText,
      tick = _ref.tick;
  return measureText({
    text: tick.label,
    fontSize: style.fontSize,
    fontFamily: style.fontFamily
  });
}

function majorTicks(ticks) {
  return ticks.filter(function (t) {
    return !t.isMinor;
  });
}

function minorTicks(ticks) {
  return ticks.filter(function (t) {
    return t.isMinor;
  });
}

function tickBuilder(ticks, buildOpts) {
  return ticks.map(function (tick) {
    return buildNode$1(tick, buildOpts);
  });
}

function tickBandwidth(scale, tick) {
  return tick ? Math.abs(tick.end - tick.start) : scale.bandwidth();
}

function labelBuilder(ticks, buildOpts, resolveTickOpts) {
  return ticks.map(function (tick, idx) {
    resolveTickOpts(tick, idx);
    var label = buildNode(tick, buildOpts);
    label.data = tick.data;
    return label;
  });
}

function layeredLabelBuilder(ticks, buildOpts, settings, resolveTickOpts) {
  var padding = buildOpts.padding;
  var spacing = labelsSpacing(settings);
  return ticks.map(function (tick, idx) {
    resolveTickOpts(tick, idx);
    var padding2 = spacing + buildOpts.maxHeight + settings.labels.margin;
    buildOpts.layer = idx % 2;
    buildOpts.padding = idx % 2 === 0 ? padding : padding2;
    var label = buildNode(tick, buildOpts);
    label.data = tick.data;
    return label;
  });
}

function filterOverlappingLabels(labels, ticks, buildOpts) {
  var isOverlapping = function isOverlapping(i, k) {
    var rect1 = expandRect(1, labels[i].boundingRect);
    var rect2 = expandRect(1, labels[k].boundingRect);
    return testRectRect(rect1, rect2);
  };

  if (buildOpts && buildOpts.tilted) {
    var absAngle = Math.abs(buildOpts.angle);

    isOverlapping = function isOverlapping(i, k) {
      var stepSize = Math.abs(labels[i].x - labels[k].x);
      var reciprocal = 1 / stepSize;
      var distanceBetweenLabels = Math.sin(absAngle * (Math.PI / 180)) / reciprocal;
      return labels[i].boundingRect.height > distanceBetweenLabels;
    };
  }

  for (var i = 0; i <= labels.length - 1; i++) {
    for (var k = i + 1; k <= Math.min(i + 5, i + (labels.length - 1)); k++) {
      // TODO Find a better way to handle exteme/layered labels then to iterare over ~5 next labels
      if (labels[i] && labels[k] && isOverlapping(i, k)) {
        if (k === labels.length - 1) {
          // On collition with last label, remove current label instead
          labels.splice(i, 1);

          if (ticks) {
            ticks.splice(i, 1);
          }
        } else {
          labels.splice(k, 1);

          if (ticks) {
            ticks.splice(k, 1);
          }
        }

        k--;
        i--;
      }
    }
  }
}

function discreteCalcMaxTextRect(_ref2) {
  var textMetrics = _ref2.textMetrics,
      settings = _ref2.settings,
      innerRect = _ref2.innerRect,
      scale = _ref2.scale,
      tilted = _ref2.tilted,
      layered = _ref2.layered,
      tick = _ref2.tick;
  var h = textMetrics.height;
  var bandwidth = tickBandwidth(scale, tick);
  var textRect = {
    width: 0,
    height: h
  };

  if (settings.align === 'left' || settings.align === 'right') {
    textRect.width = innerRect.width - labelsSpacing(settings) - settings.paddingEnd;
  } else if (layered) {
    textRect.width = bandwidth * innerRect.width * 2;
  } else if (tilted) {
    var radians = Math.abs(settings.labels.tiltAngle) * (Math.PI / 180);
    textRect.width = (innerRect.height - labelsSpacing(settings) - settings.paddingEnd - h * Math.cos(radians)) / Math.sin(radians);
  } else {
    textRect.width = bandwidth * innerRect.width;
  }

  textRect.width = getClampedValue({
    value: textRect.width,
    maxValue: settings.labels.maxLengthPx,
    minValue: settings.labels.minLengthPx
  });
  return textRect;
}

function continuousCalcMaxTextRect(_ref3) {
  var textMetrics = _ref3.textMetrics,
      settings = _ref3.settings,
      innerRect = _ref3.innerRect,
      outerRect = _ref3.outerRect,
      tilted = _ref3.tilted,
      layered = _ref3.layered,
      tick = _ref3.tick,
      index = _ref3.index,
      major = _ref3.major;
  var h = textMetrics.height;
  var textRect = {
    width: 0,
    height: h
  };

  if (settings.align === 'left' || settings.align === 'right') {
    textRect.width = innerRect.width - labelsSpacing(settings) - settings.paddingEnd;
  } else if (tilted) {
    var radians = Math.abs(settings.labels.tiltAngle) * (Math.PI / 180);
    textRect.width = (innerRect.height - labelsSpacing(settings) - settings.paddingEnd - h * Math.cos(radians)) / Math.sin(radians);
  } else {
    textRect.width = getHorizontalWidth({
      layered: layered,
      major: major,
      innerRect: innerRect,
      outerRect: outerRect,
      tick: tick,
      index: index
    });
  }

  textRect.width = getClampedValue({
    value: textRect.width,
    maxValue: settings.labels.maxLengthPx,
    minValue: settings.labels.minLengthPx
  });
  return textRect;
}

function getStepSizeFn(_ref4) {
  var innerRect = _ref4.innerRect,
      scale = _ref4.scale,
      settings = _ref4.settings,
      tick = _ref4.tick;
  var size = settings.align === 'top' || settings.align === 'bottom' ? innerRect.width : innerRect.height;
  var bandwidth = tickBandwidth(scale, tick);
  return size * bandwidth;
}

function nodeBuilder(isDiscrete) {
  var resolveLabelRect;

  function continuous() {
    resolveLabelRect = continuousCalcMaxTextRect;
    return continuous;
  }

  function discrete() {
    resolveLabelRect = discreteCalcMaxTextRect;
    return discrete;
  }

  function build(_ref5) {
    var settings = _ref5.settings,
        scale = _ref5.scale,
        innerRect = _ref5.innerRect,
        outerRect = _ref5.outerRect,
        measureText = _ref5.measureText,
        ticks = _ref5.ticks,
        state = _ref5.state,
        textBounds = _ref5.textBounds;
    var nodes = [];
    var major = majorTicks(ticks);
    var minor = minorTicks(ticks);
    var buildOpts = {
      innerRect: innerRect,
      align: settings.align,
      outerRect: outerRect
    };
    var tilted = state.labels.activeMode === 'tilted';
    var layered = state.labels.activeMode === 'layered';
    var majorTickNodes;

    if (settings.line.show) {
      buildOpts.style = settings.line;
      buildOpts.padding = settings.paddingStart;
      nodes.push(buildLine(buildOpts));
    }

    if (settings.ticks.show) {
      buildOpts.style = settings.ticks;
      buildOpts.tickSize = settings.ticks.tickSize;
      buildOpts.padding = tickSpacing(settings);
      majorTickNodes = tickBuilder(major, buildOpts);
    }

    if (settings.labels.show) {
      var padding = labelsSpacing(settings);
      buildOpts.style = settings.labels;
      buildOpts.padding = padding;
      buildOpts.tilted = tilted;
      buildOpts.layered = layered;
      buildOpts.angle = settings.labels.tiltAngle;
      buildOpts.paddingEnd = settings.paddingEnd;
      buildOpts.textBounds = textBounds;

      var resolveTickOpts = function resolveTickOpts(tick, index) {
        buildOpts.textRect = calcActualTextRect({
          tick: tick,
          measureText: measureText,
          style: buildOpts.style
        });
        var maxSize = resolveLabelRect({
          textMetrics: buildOpts.textRect,
          settings: settings,
          innerRect: innerRect,
          outerRect: outerRect,
          scale: scale,
          tilted: tilted,
          layered: layered,
          tick: tick,
          major: major,
          index: index
        });
        buildOpts.maxWidth = maxSize.width;
        buildOpts.maxHeight = maxSize.height;
        buildOpts.stepSize = getStepSizeFn({
          innerRect: innerRect,
          scale: scale,
          ticks: ticks,
          settings: settings,
          tick: tick
        });
      };

      var labelNodes = [];

      if (layered && (settings.align === 'top' || settings.align === 'bottom')) {
        labelNodes = layeredLabelBuilder(major, buildOpts, settings, resolveTickOpts);
      } else {
        labelNodes = labelBuilder(major, buildOpts, resolveTickOpts);
      } // Remove labels (and paired tick) that are overlapping


      if (settings.labels.filterOverlapping) {
        filterOverlappingLabels(labelNodes, majorTickNodes, buildOpts);
      }

      nodes.push.apply(nodes, _toConsumableArray$1(labelNodes));
    }

    if (settings.minorTicks && settings.minorTicks.show && minor.length > 0) {
      buildOpts.style = settings.minorTicks;
      buildOpts.tickSize = settings.minorTicks.tickSize;
      buildOpts.padding = tickMinorSpacing(settings);
      nodes.push.apply(nodes, _toConsumableArray$1(tickBuilder(minor, buildOpts)));
    }

    if (majorTickNodes) {
      nodes.push.apply(nodes, _toConsumableArray$1(majorTickNodes));
    }

    return nodes;
  }

  continuous.build = build;
  discrete.build = build;
  return isDiscrete ? discrete() : continuous();
}

// const DEFAULT_LAYOUT_SETTINGS = { // TODO create dis and con specific settings
//   anchor: 'auto', // TODO re-name from align..
//   // orientation: 'auto', // TODO impl. v/h/auto
//   // direction: 'auto', // TODO impl. left/right/top/bottom/auto
//   padding: { // TODO use dock layout margin instead..
//     start: 0,
//     end: 10
//   },
//   maxGlyphCount: NaN,
//   maxEdgeBleed: Infinity
//   // labelMode: 'auto' // TODO move here? auto, horizontal, layered
// };

/**
 * Discrete axis settings
 * @typedef {object}
 * @alias component--axis-discrete
 */
var DEFAULT_DISCRETE_SETTINGS = {
  /**
   * @typedef {object}
   */
  labels: {
    /** Toggle labels on/off
    * @type {boolean=} */
    show: true,

    /** Tilting angle in degrees. Capped between -90 and 90. Only applicable when labels are in `tilted` mode.
    * @type {number=} */
    tiltAngle: 40,

    /** Threshold for toggle of tilted labels. Capped between 0 and 1. For example, if it is set to 0.7, then tilted labels will be toggled if less than 70% of the labels are visible.
    * @type {number=}
    * @experimental */
    tiltThreshold: 0.7,

    /** Control the amount of space (in pixels) that labes can occupy outside their docking area. Only applicable when labels are in `tilted` mode.
    * @type {number=} */
    maxEdgeBleed: Infinity,

    /** Space in pixels between the tick and label.
    * @type {number=} */
    margin: 4,

    /** Max length of labels in pixels
    * @type {number=} */
    maxLengthPx: 150,

    /** Min length of labels in pixels. Labels will always at least require this much space
    * @type {number=} */
    minLengthPx: 0,

    /** Control how labels arrange themself. Availabe modes are `auto`, `horizontal`, `layered` and `tilted`. When set to `auto` the axis determines the best possible layout in the current context.
    * @type {string=} */
    mode: 'auto',

    /** When only a sub-set of data is available, ex. when paging. This property can be used to let the axis estimate how much space the labels will consume, allowing it to give a consistent space estimate over the entire dataset when paging.
    * @type {number=} */
    maxGlyphCount: NaN,

    /** Align act as a slider for the text bounding rect over the item bandwidth, given that the item have a bandwidth. Except when labels are tilted, then the align is a pure align that shifts the position of the label anchoring point.
    * @type {number=} */
    align: 0.5,

    /** Offset in pixels along the axis direction.
    * @type {number=} */
    offset: 0,

    /**
     * Toggle whether labels should be filtered if they are overlapping. Filtering may be applied in a non-sequential order.
     * If labels are overlapping and this setting is toggled off, the axis will automatically hide.
     * @type {boolean=}
     */
    filterOverlapping: false
  },

  /**
   * @typedef {object}
   */
  ticks: {
    /** Toggle ticks on/off
    * @type {boolean=} */
    show: false,

    /** Space in pixels between the ticks and the line.
    * @type {number=} */
    margin: 0,

    /** Size of the ticks in pixels.
    * @type {number=} */
    tickSize: 4
  },

  /**
   * @typedef {object}
   */
  line: {
    /** Toggle line on/off
    * @type {boolean=} */
    show: false
  },

  /** Padding in direction perpendicular to the axis
    * @type {number=} */
  paddingStart: 0,

  /** Padding in direction perpendicular to the axis
    * @type {number=} */
  paddingEnd: 10,

  /** Set the anchoring point of the axis. Avaialable options are `auto/left/right/bottom/top`. In `auto` the axis determines the best option. The options are restricted based on the axis orientation, a vertical axis may only anchor on `left` or `right`
    * @type {string=} */
  align: 'auto'
};
/**
 * Continuous axis settings
 * @typedef {object}
 * @alias component--axis-continuous
 */

var DEFAULT_CONTINUOUS_SETTINGS = {
  /**
   * @typedef {object}
   */
  labels: {
    /** Toggle labels on/off
    * @type {boolean=} */
    show: true,

    /** Space in pixels between the tick and label.
    * @type {number=} */
    margin: 4,

    /** Max length of labels in pixels
    * @type {number=} */
    maxLengthPx: 150,

    /** Min length of labels in pixels. Labels will always at least require this much space
    * @type {number=} */
    minLengthPx: 0,

    /** Align act as a slider for the text bounding rect over the item bandwidth, given that the item have a bandwidth.
    * @type {number=} */
    align: 0.5,

    /** Offset in pixels along the axis direction.
    * @type {number=} */
    offset: 0,

    /**
     * Toggle whether labels should be filtered if they are overlapping. Filtering may be applied in a non-sequential order.
     * If labels are overlapping and this setting is toggled off, the axis will automatically hide.
     * @type {boolean=}
     */
    filterOverlapping: true
  },

  /**
   * @typedef {object}
   */
  ticks: {
    /** Toggle ticks on/off
    * @type {boolean=} */
    show: true,

    /** Space in pixels between the ticks and the line.
    * @type {number=} */
    margin: 0,

    /** Size of the ticks in pixels.
    * @type {number=} */
    tickSize: 8
  },

  /**
   * @typedef {object}
   */
  minorTicks: {
    /** Toggle minor-ticks on/off
    * @type {boolean=} */
    show: false,

    /** Size of the ticks in pixels.
    * @type {number=} */
    tickSize: 3,

    /** Space in pixels between the ticks and the line.
    * @type {number=} */
    margin: 0
  },

  /**
   * @typedef {object}
   */
  line: {
    /** Toggle line on/off
    * @type {boolean=} */
    show: true
  },

  /** Padding in direction perpendicular to the axis
    * @type {number=} */
  paddingStart: 0,

  /** Padding in direction perpendicular to the axis
    * @type {number=} */
  paddingEnd: 10,

  /** Set the anchoring point of the axis. Avaialable options are `auto/left/right/bottom/top`. In `auto` the axis determines the best option. The options are restricted based on the axis orientation, a vertical axis may only anchor on `left` or `right`
    * @type {string=} */
  align: 'auto'
};

function calcRequiredSize(_ref) {
  var isDiscrete = _ref.isDiscrete,
      rect = _ref.rect,
      formatter = _ref.formatter,
      measureText = _ref.measureText,
      scale = _ref.scale,
      settings = _ref.settings,
      state = _ref.state;
  var size = 0;

  var _getLabelSize = getSize({
    isDiscrete: isDiscrete,
    rect: rect,
    formatter: formatter,
    measureText: measureText,
    scale: scale,
    settings: settings,
    state: state
  }),
      labelSize = _getLabelSize.size,
      edgeBleed = _getLabelSize.edgeBleed,
      isToLarge = _getLabelSize.isToLarge;

  size += labelSize;

  if (isToLarge) {
    return {
      size: size
    };
  }

  if (settings.ticks.show) {
    size += settings.ticks.margin;
    size += settings.ticks.tickSize;
  }

  if (settings.minorTicks && settings.minorTicks.show) {
    var minorTicksSize = settings.minorTicks.margin + settings.minorTicks.tickSize;

    if (minorTicksSize > size) {
      size = minorTicksSize;
    }
  }

  if (settings.line.show) {
    size += settings.line.strokeWidth;
  }

  size += settings.paddingStart;
  size += settings.paddingEnd;
  return {
    size: size,
    edgeBleed: edgeBleed
  };
}

function alignTransform(_ref) {
  var align = _ref.align,
      inner = _ref.inner;

  if (align === 'left') {
    return {
      x: inner.width + inner.x
    };
  }

  if (align === 'right' || align === 'bottom') {
    return inner;
  }

  return {
    y: inner.y + inner.height
  };
}

function resolveAlign(align, dock) {
  var horizontal = ['top', 'bottom'];
  var vertical = ['left', 'right'];

  if (horizontal.indexOf(align) !== -1 && vertical.indexOf(dock) === -1) {
    return align;
  }

  if (vertical.indexOf(align) !== -1 && horizontal.indexOf(dock) === -1) {
    return align;
  }

  return dock; // Invalid align, return current dock as default
}
/**
 * @ignore
 * @param {object} context - The component context
 */


function resolveLocalSettings(_ref2) {
  var state = _ref2.state,
      style = _ref2.style,
      settings = _ref2.settings;
  var defaultStgns = extend(true, {}, state.isDiscrete ? DEFAULT_DISCRETE_SETTINGS : DEFAULT_CONTINUOUS_SETTINGS, style);
  var localStgns = extend(true, {}, defaultStgns, settings.settings);
  var dock = settings.layout.dock || state.defaultDock;
  localStgns.dock = dock;
  localStgns.align = resolveAlign(settings.settings.align, dock);
  localStgns.labels.tiltAngle = Math.max(-90, Math.min(localStgns.labels.tiltAngle, 90));
  return localStgns;
}

function updateActiveMode(state, settings, isDiscrete) {
  var mode = settings.labels.mode;

  if (!isDiscrete || !state.isHorizontal) {
    return 'horizontal';
  }

  if (mode === 'auto') {
    return state.labels.activeMode;
  }

  if (['layered', 'tilted'].indexOf(settings.labels.mode) !== -1 && ['top', 'bottom'].indexOf(settings.dock) !== -1) {
    return mode;
  }

  return 'horizontal';
}

var axisComponent = {
  require: ['chart', 'renderer', 'dockConfig'],
  defaultSettings: {
    layout: {
      displayOrder: 0,
      prioOrder: 0
    },
    settings: {},
    style: {
      labels: '$label',
      ticks: '$guide-line',
      minorTicks: '$guide-line--minor',
      line: '$guide-line'
    }
  },
  created: function created() {
    // State is a representation of properties that are private to this component defintion and may be modified by only in this context.
    this.state = {
      isDiscrete: !!this.scale.bandwidth,
      isHorizontal: false,
      labels: {
        activeMode: 'horizontal'
      },
      ticks: [],
      innerRect: {
        width: 0,
        height: 0,
        x: 0,
        y: 0
      },
      outerRect: {
        width: 0,
        height: 0,
        x: 0,
        y: 0
      },
      defaultDock: undefined,
      concreteNodeBuilder: undefined,
      settings: undefined
    };

    if (this.state.isDiscrete) {
      this.state.defaultDock = 'bottom';
    } else {
      this.state.defaultDock = 'left';
    }

    this.setState(this.settings);
  },
  setState: function setState() {
    this.state.isDiscrete = !!this.scale.bandwidth;
    this.state.settings = resolveLocalSettings(this);
    this.state.concreteNodeBuilder = nodeBuilder(this.state.isDiscrete);
    this.dockConfig.dock(this.state.settings.dock); // Override the dock setting (TODO should be removed)

    this.state.isHorizontal = this.state.settings.align === 'top' || this.state.settings.align === 'bottom';
    this.state.labels.activeMode = updateActiveMode(this.state, this.state.settings, this.state.isDiscrete);
  },
  preferredSize: function preferredSize(opts) {
    var formatter = this.formatter,
        state = this.state,
        scale = this.scale;
    var distance = this.state.isHorizontal ? opts.inner.width : opts.inner.height;
    this.state.pxScale = scaleWithSize(scale, distance);
    var reqSize = calcRequiredSize({
      isDiscrete: this.state.isDiscrete,
      rect: opts.inner,
      formatter: formatter,
      measureText: this.renderer.measureText,
      scale: this.state.pxScale,
      settings: this.state.settings,
      state: state
    });
    return reqSize;
  },
  beforeUpdate: function beforeUpdate() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var settings = opts.settings;
    this.setState(settings);
  },
  resize: function resize(opts) {
    var inner = opts.inner,
        outer = opts.outer;
    var extendedInner = extend({}, inner, alignTransform({
      align: this.state.settings.align,
      inner: inner
    }));
    var finalOuter = outer || extendedInner;
    extend(this.state.innerRect, extendedInner);
    extend(this.state.outerRect, finalOuter);
    return outer;
  },
  beforeRender: function beforeRender() {
    var scale = this.scale,
        formatter = this.formatter;
    var distance = this.state.isHorizontal ? this.state.innerRect.width : this.state.innerRect.height;
    this.state.pxScale = scaleWithSize(scale, distance);
    this.state.ticks = this.state.pxScale.ticks({
      distance: distance,
      formatter: formatter
    }).filter(function (t) {
      return t.position >= 0 && t.position <= 1;
    });
  },
  render: function render() {
    var state = this.state;
    var nodes = [];
    nodes.push.apply(nodes, _toConsumableArray$1(this.state.concreteNodeBuilder.build({
      settings: this.state.settings,
      scale: this.state.pxScale,
      innerRect: this.state.innerRect,
      outerRect: this.state.outerRect,
      measureText: this.renderer.measureText,
      textBounds: this.renderer.textBounds,
      ticks: this.state.ticks,
      state: state
    })));
    crispifier.multiple(nodes);
    return nodes;
  }
};

/**
 * @typedef {object} component--axis
 */

/**
 * @type {string}
 * @memberof component--axis
 */

var type$1 = 'axis';
function axis(picasso) {
  picasso.component(type$1, axisComponent);
}

function parseTitle(text, join, scale) {
  var title = '';

  if (typeof text === 'function') {
    title = text();
  } else if (typeof text === 'string') {
    title = text;
  } else if (scale) {
    var data = scale.data();
    var titles = (data.fields || []).map(function (field) {
      return field.title();
    });
    title = titles.join(join);
  }

  return title;
}

function getTextAnchor(dock, anchor) {
  var val = 'middle';

  if (dock === 'left') {
    if (anchor === 'top') {
      val = 'end';
    } else if (anchor === 'bottom') {
      val = 'start';
    }
  } else if (dock === 'right') {
    if (anchor === 'top') {
      val = 'start';
    } else if (anchor === 'bottom') {
      val = 'end';
    }
  } else if (anchor === 'left') {
    val = 'start';
  } else if (anchor === 'right') {
    val = 'end';
  }

  return val;
}

function generateTitle(_ref) {
  var title = _ref.title,
      definitionSettings = _ref.definitionSettings,
      dock = _ref.dock,
      rect = _ref.rect,
      measureText = _ref.measureText,
      style = _ref.style;
  var struct = {
    type: 'text',
    text: title,
    x: 0,
    y: 0,
    dx: 0,
    dy: 0,
    anchor: getTextAnchor(dock, definitionSettings.anchor),
    baseline: 'alphabetical'
  };
  extend(struct, style.text);
  var textRect = measureText(struct);

  if (dock === 'top' || dock === 'bottom') {
    var x = rect.width / 2;

    if (definitionSettings.anchor === 'left') {
      x = definitionSettings.paddingLeft || 0;
    } else if (definitionSettings.anchor === 'right') {
      x = rect.width - (definitionSettings.paddingRight || 0);
    }

    struct.x = x;
    struct.y = dock === 'top' ? rect.height - definitionSettings.paddingStart : definitionSettings.paddingStart + textRect.height;
    struct.dy = dock === 'top' ? -(textRect.height / 6) : -(textRect.height / 3);
    struct.maxWidth = rect.width * 0.8;
  } else {
    var y = rect.height / 2;

    if (definitionSettings.anchor === 'top') {
      y = definitionSettings.paddingStart;
    } else if (definitionSettings.anchor === 'bottom') {
      y = rect.height - definitionSettings.paddingStart;
    }

    struct.y = y;
    struct.x = dock === 'left' ? rect.width - definitionSettings.paddingStart : definitionSettings.paddingStart;
    struct.dx = dock === 'left' ? -(textRect.height / 3) : textRect.height / 3;
    var rotation = dock === 'left' ? 270 : 90;
    struct.transform = "rotate(".concat(rotation, ", ").concat(struct.x + struct.dx, ", ").concat(struct.y + struct.dy, ")");
    struct.maxWidth = rect.height * 0.8;
  }

  if (!isNaN(definitionSettings.maxLengthPx)) {
    struct.maxWidth = Math.min(struct.maxWidth, definitionSettings.maxLengthPx);
  }

  return struct;
}
/**
 * @typedef {object} component--text
 * @property {string} [type='text']
 * @property {string|function} text
 * @property {component--text-settings} settings - Text settings
 * @example
 * {
 *  type: 'text',
 *  text: 'my title',
 *  dock: 'left',
 *  settings: {
 *    anchor: 'left',
 *    style: {
 *      fill: 'red'
 *    }
 *  }
 * }
 */

/**
 * @typedef {object} component--text-settings
 * @property {number} [paddingStart=5]
 * @property {number} [paddingEnd=5]
 * @property {number} [paddingLeft=0]
 * @property {number} [paddingRight=0]
 * @property {string} [anchor='center'] - Where to v- or h-align the text. Supports `left`, `right`, `top`, `bottom` and `center`
 * @property {string} [join=', '] - String to add when joining titles from multiple sources
 * @property {number} [maxLengthPx] - Limit the text length to this value in pixels
 */


var textComponent = {
  require: ['renderer', 'chart'],
  defaultSettings: {
    layout: {
      dock: 'bottom',
      displayOrder: 0,
      prioOrder: 0
    },
    settings: {
      paddingStart: 5,
      paddingEnd: 5,
      paddingLeft: 0,
      paddingRight: 0,
      anchor: 'center',
      join: ', ',
      maxLengthPx: NaN
    },
    style: {
      text: '$title'
    }
  },
  created: function created() {
    this.definitionSettings = this.settings.settings;
    var text = this.settings.text;
    var join = this.definitionSettings.join;
    this.title = parseTitle(text, join, this.scale);
  },
  preferredSize: function preferredSize() {
    var height = this.renderer.measureText({
      text: this.title,
      fontSize: this.style.text.fontSize,
      fontFamily: this.style.text.fontFamily
    }).height;
    return height + this.definitionSettings.paddingStart + this.definitionSettings.paddingEnd;
  },
  render: function render() {
    var title = this.title,
        definitionSettings = this.definitionSettings,
        rect = this.rect;
    var nodes = [];
    nodes.push(generateTitle({
      title: title,
      dock: this.settings.layout.dock,
      definitionSettings: definitionSettings,
      rect: rect,
      measureText: this.renderer.measureText,
      style: this.style
    }));
    return nodes;
  },
  beforeUpdate: function beforeUpdate(opts) {
    if (opts.settings) {
      extend(this.settings, opts.settings);
      this.definitionSettings = opts.settings.settings;
    }

    var text = this.settings.text;
    var join = this.definitionSettings.join;
    this.title = parseTitle(text, join, this.scale);
  }
};

function text(picasso) {
  picasso.component('text', textComponent);
}

/**
 * @typedef {object} component--scrollbar
 * @private
 */

/**
 * @typedef {object} component--scrollbar.settings
 * @property {boolean} [backgroundColor = '#eee']
 * @property {boolean} [thumbColor = '#ccc']
 * @property {boolean} [width = 16]
 */
function start(_scrollbar, pos) {
  var dock = _scrollbar.settings.layout.dock;
  var invert = _scrollbar.settings.settings.invert;
  var horizontal = dock === 'top' || dock === 'bottom';
  var lengthAttr = horizontal ? 'width' : 'height';
  var length = _scrollbar.rect[lengthAttr];

  var scroll = _scrollbar.chart.scroll(_scrollbar.settings.scroll);

  var currentMove;
  {
    // local scope to allow reuse of variable names later
    var offset = pos[horizontal ? 'x' : 'y'];

    if (invert) {
      offset = length - offset;
    }

    var scrollState = scroll.getState();
    currentMove = {
      startOffset: offset,
      startScroll: scrollState.start,
      swipe: false
    }; // Detect swipe start outsize the thumb & change startScroll to jump the scroll there.

    var scrollPoint = offset / length * (scrollState.max - scrollState.min) + scrollState.min;

    if (scrollPoint < scrollState.start) {
      currentMove.startScroll = scrollPoint;
    } else if (scrollPoint > scrollState.start + scrollState.viewSize) {
      currentMove.startScroll = scrollPoint - scrollState.viewSize;
    }
  }

  var update = function update(p) {
    var offset = p[horizontal ? 'x' : 'y'];

    if (invert) {
      offset = length - offset;
    }

    if (!currentMove.swipe) {
      if (Math.abs(currentMove.startOffset - offset) <= 1) {
        return;
      }

      currentMove.swipe = true;
    }

    var scrollState = scroll.getState();
    var scrollMove = (offset - currentMove.startOffset) / length * (scrollState.max - scrollState.min);
    var scrollStart = currentMove.startScroll + scrollMove;
    scroll.moveTo(scrollStart);
  };

  var end = function end(p) {
    var offset = p[horizontal ? 'x' : 'y'];

    if (invert) {
      offset = length - offset;
    }

    var scrollState = scroll.getState();

    if (currentMove.swipe) {
      var scrollMove = (offset - currentMove.startOffset) / length * (scrollState.max - scrollState.min);
      var scrollStart = currentMove.startScroll + scrollMove;
      scroll.moveTo(scrollStart);
    } else {
      var scrollCenter = offset / length * (scrollState.max - scrollState.min) + scrollState.min;

      var _scrollStart = scrollCenter - scrollState.viewSize / 2;

      scroll.moveTo(_scrollStart);
    }
  };

  return {
    update: update,
    end: end
  };
}

function getLocalPos(event, renderer) {
  var containerRect = renderer.element().getBoundingClientRect();
  return {
    x: event.center.x - containerRect.left,
    y: event.center.y - containerRect.top
  };
}

var scrollbarComponent = {
  require: ['chart', 'renderer'],
  on: {
    panStart: function panStart(event) {
      var pos = getLocalPos(event, this.renderer);
      var startPos = {
        x: pos.x - event.deltaX,
        y: pos.y - event.deltaY
      };
      this.currentMove = start(this, startPos);
      this.currentMove.update(pos);
    },
    panMove: function panMove(event) {
      if (!this.currentMove) {
        return;
      }

      var pos = getLocalPos(event, this.renderer);
      this.currentMove.update(pos);
    },
    panEnd: function panEnd(event) {
      if (!this.currentMove) {
        return;
      }

      var pos = getLocalPos(event, this.renderer);
      this.currentMove.end(pos);
      this.currentMove = null;
    },
    panCancel: function panCancel() {
      this.currentMove = null;
    },
    tap: function tap(event) {
      var pos = getLocalPos(event, this.renderer);
      var move = start(this, pos);
      move.end(pos);
    }
  },
  defaultSettings: {
    settings: {
      backgroundColor: '#eee',
      thumbColor: '#ccc',
      width: 16 // 32 for touch

    }
  },
  preferredSize: function preferredSize(rect) {
    var scrollState = this.chart.scroll(this.settings.scroll).getState(); // hide the scrollbar if it is not possible to scroll

    if (scrollState.viewSize >= scrollState.max - scrollState.min) {
      var toLargeSize = Math.max(rect.width, rect.height);
      return toLargeSize;
    }

    return this.settings.settings.width;
  },
  render: function render(h) {
    var _style;

    var dock = this.settings.layout.dock;
    var invert = this.settings.settings.invert;
    var horizontal = dock === 'top' || dock === 'bottom';
    var lengthAttr = horizontal ? 'width' : 'height';
    var _rect = this.rect;
    var length = _rect[lengthAttr];
    var scrollState = this.chart.scroll(this.settings.scroll).getState();
    var thumbStart = length * (scrollState.start - scrollState.min) / (scrollState.max - scrollState.min);
    var thumbRange = length * scrollState.viewSize / (scrollState.max - scrollState.min);

    if (invert) {
      thumbStart = length - thumbStart - thumbRange;
    }

    return h('div', {
      style: {
        position: 'relative',
        width: '100%',
        height: '100%',
        background: this.settings.settings.backgroundColor,
        pointerEvents: 'auto'
      }
    }, [].concat(h('div', {
      class: 'scroller',
      style: (_style = {
        position: 'absolute'
      }, _defineProperty(_style, horizontal ? 'left' : 'top', "".concat(thumbStart, "px")), _defineProperty(_style, horizontal ? 'top' : 'left', '25%'), _defineProperty(_style, horizontal ? 'height' : 'width', '50%'), _defineProperty(_style, lengthAttr, "".concat(Math.max(1, thumbRange), "px")), _defineProperty(_style, "background", this.settings.settings.thumbColor), _style)
    })));
  },
  renderer: 'dom'
};
function scrollbar(picasso) {
  picasso.component('scrollbar', scrollbarComponent);
}

var TARGET_SIZE = 5;
var VERTICAL = 0;
var HORIZONTAL = 1;

function buildLine$1(_ref) {
  var h = _ref.h,
      isVertical = _ref.isVertical,
      value = _ref.value,
      pos = _ref.pos,
      align = _ref.align,
      borderHit = _ref.borderHit,
      state = _ref.state,
      idx = _ref.idx;
  var isAlignStart = align !== 'end';
  var alignStart = {
    left: '0',
    top: '0'
  };
  var alignEnd = {
    right: '0',
    bottom: '0'
  };
  var alignStyle = isAlignStart ? alignStart : alignEnd;
  var start = 0;
  var width = '100%';
  var height = '100%';

  if (state.targetRect && state.settings.bubbles.align === 'start') {
    width = "".concat(state.targetRect.x + state.targetRect.width, "px");
    height = "".concat(state.targetRect.y + state.targetRect.height, "px");
  } else if (state.targetRect && state.settings.bubbles.align === 'end') {
    start = isVertical ? state.targetRect.x : state.targetRect.y;
    width = "".concat(state.rect.width - start, "px");
    height = "".concat(state.rect.height - start, "px");
  }

  if (!isAlignStart) {
    pos -= borderHit;
  } // edge


  return h('div', {
    onmouseover: function onmouseover(e) {
      e.srcElement.children[0].style.backgroundColor = '#000';
      e.srcElement.children[0].style[isVertical ? 'height' : 'width'] = '2px';
    },
    onmouseout: function onmouseout(e) {
      e.srcElement.children[0].style.backgroundColor = state.style.line.stroke;
      e.srcElement.children[0].style[isVertical ? 'height' : 'width'] = '1px';
    },
    'data-value': value,
    'data-key': [state.key, 'edge', idx].join('-'),
    style: {
      cursor: isVertical ? 'ns-resize' : 'ew-resize',
      position: 'absolute',
      left: isVertical ? "".concat(start, "px") : "".concat(pos, "px"),
      top: isVertical ? "".concat(pos, "px") : "".concat(start, "px"),
      height: isVertical ? "".concat(borderHit, "px") : height,
      width: isVertical ? width : "".concat(borderHit, "px"),
      pointerEvents: 'auto'
    }
  }, [// line
  h('div', {
    style: extend({
      backgroundColor: state.style.line.stroke,
      position: 'absolute',
      height: isVertical ? "".concat(1, "px") : '100%',
      width: isVertical ? '100%' : "".concat(1, "px"),
      pointerEvents: 'none'
    }, alignStyle)
  })]);
}

function buildBubble(_ref2) {
  var _style;

  var h = _ref2.h,
      isVertical = _ref2.isVertical,
      label = _ref2.label,
      otherValue = _ref2.otherValue,
      rangeIdx = _ref2.rangeIdx,
      idx = _ref2.idx,
      pos = _ref2.pos,
      align = _ref2.align,
      state = _ref2.state,
      value = _ref2.value;
  var isAlignStart = align !== 'end';
  var isOutside = state.settings.bubbles.placement === 'outside';
  var outside = 'none';
  var bubbleDock;

  if (isVertical) {
    bubbleDock = isAlignStart ? 'left' : 'right';

    if (isOutside) {
      outside = isAlignStart ? 'translate(-100%,  0px)' : 'translate(100%,  0px)';
    }
  } else {
    bubbleDock = isAlignStart ? 'top' : 'bottom';

    if (isOutside) {
      outside = isAlignStart ? 'translate(0px, -100%)' : 'translate(0px,  100%)';
    }
  }

  var inEdit = state.edit && state.edit.rangeIdx === rangeIdx && state.edit.bubbleIdx === idx;
  var bubbleStyle = {
    position: 'relative',
    borderRadius: "".concat(state.style.bubble.borderRadius, "px"),
    border: "".concat(state.style.bubble.strokeWidth, "px solid ").concat(state.style.bubble.stroke),
    backgroundColor: state.style.bubble.fill,
    color: state.style.bubble.color,
    fontFamily: state.style.bubble.fontFamily,
    fontSize: state.style.bubble.fontSize,
    padding: '4px 8px',
    textAlign: 'center',
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    whiteSpace: 'nowrap',
    maxWidth: '150px',
    minWidth: '50px',
    minHeight: '1em',
    pointerEvents: 'auto',
    transform: isVertical ? 'translate(0,-50%)' : 'translate(-50%,0)',
    cursor: isVertical ? 'ns-resize' : 'ew-resize'
  };
  var currentBorderColor = state.style.bubble.stroke;
  var bubble = inEdit ? h('input', {
    type: 'text',
    value: value,
    style: _objectSpread({}, bubbleStyle, {
      textAlign: 'start',
      textOverflow: '',
      fontSize: '13px' // TODO - make it styleable

    }),
    onkeyup: function onkeyup(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        e.stopPropagation();
        var newValue = parseFloat(e.target.value);

        if (isNaN(newValue)) {
          currentBorderColor = 'rgba(230, 78, 78, 0.6)';
          e.target.style.border = "".concat(state.style.bubble.strokeWidth, "px solid ").concat(currentBorderColor);
        } else {
          state.onEditConfirmed(rangeIdx, newValue, otherValue);
        }
      } else if (e.key === 'Escape') {
        e.preventDefault();
        e.stopPropagation();
        state.onEditCanceled();
      }
    }
  }) : h('div', {
    'data-key': [state.key, 'bubble', rangeIdx].join('-'),
    'data-other-value': otherValue,
    'data-idx': rangeIdx,
    'data-bidx': idx,
    style: bubbleStyle
  }, [label]); // bubble wrapper

  return h('div', {
    style: (_style = {
      position: 'absolute'
    }, _defineProperty(_style, bubbleDock, '0'), _defineProperty(_style, isVertical ? 'top' : 'left', "".concat(pos, "px")), _defineProperty(_style, "transform", outside), _style)
  }, [// bubble
  bubble]);
}

function buildArea(_ref3) {
  var h = _ref3.h,
      isVertical = _ref3.isVertical,
      top = _ref3.top,
      height = _ref3.height,
      color = _ref3.color,
      on = _ref3.on,
      opacity = _ref3.opacity;
  return h('div', extend({
    style: {
      backgroundColor: color,
      opacity: opacity,
      position: 'absolute',
      left: isVertical ? 0 : "".concat(top, "px"),
      top: isVertical ? "".concat(top, "px") : 0,
      height: isVertical ? "".concat(height, "px") : '100%',
      width: isVertical ? '100%' : "".concat(height, "px"),
      pointerEvents: 'auto'
    }
  }, on), []);
}

function buildRange(_ref4) {
  var borderHit = _ref4.borderHit,
      els = _ref4.els,
      isVertical = _ref4.isVertical,
      state = _ref4.state,
      vStart = _ref4.vStart,
      vEnd = _ref4.vEnd,
      idx = _ref4.idx;
  var targetOffset = 0;

  if (state.targetRect) {
    targetOffset = isVertical ? state.targetRect.y : state.targetRect.x;
  }

  var hasScale = !!state.scale;
  var start = hasScale ? state.scale.norm(vStart) * state.size : vStart;
  var end = hasScale ? state.scale.norm(vEnd) * state.size : vEnd;
  var height = Math.abs(start - end);
  var top = Math.min(start, end) + targetOffset;
  var bottom = top + height;

  if (state.targetRect) {
    var target = state.targetFillRect || state.targetRect;
    var targetSize = isVertical ? target.height : target.width;
    var targetStart = hasScale ? state.scale.norm(vStart) * targetSize : vStart;
    var targetEnd = hasScale ? state.scale.norm(vEnd) * targetSize : vEnd;
    var targetHeight = Math.abs(targetStart - targetEnd);
    var targetTop = Math.min(targetStart, targetEnd);
    var targetArea = {
      h: state.h,
      isVertical: isVertical,
      top: targetTop,
      height: targetHeight,
      color: state.style.target.fill,
      opacity: state.style.target.opacity
    };

    if (state.style.target.opacity < 0.8) {
      targetArea.on = {
        onmouseover: function onmouseover(e) {
          e.srcElement.style.opacity = state.style.target.opacity + 0.1;
        },
        onmouseout: function onmouseout(e) {
          e.srcElement.style.opacity = state.style.target.opacity;
        }
      };
    }

    els.push(state.h('div', {
      style: {
        position: 'absolute',
        left: "".concat(target.x, "px"),
        top: "".concat(target.y, "px"),
        height: "".concat(target.height, "px"),
        width: "".concat(target.width, "px")
      }
    }, [buildArea(targetArea)]));
  } // active range area
  // els.push(buildArea({
  //   h: state.h,
  //   isVertical,
  //   top,
  //   height,
  //   color: state.settings.fill
  // }));


  var valStart = start < end ? vStart : vEnd;
  var valEnd = start < end ? vEnd : vStart;

  var _ref5 = hasScale ? state.scale.domain() : [Math.min(vStart, vEnd), Math.max(vStart, vEnd)],
      _ref6 = _slicedToArray(_ref5, 2),
      min = _ref6[0],
      max = _ref6[1];

  var isStartVisible = valStart + 1e-5 >= min && valStart - 1e-5 <= max; // accept minor floating point difference

  var isEndVisible = valEnd - 1e-5 <= max && valEnd + 1e-5 >= min;

  if (isStartVisible) {
    els.push(buildLine$1({
      h: state.h,
      isVertical: isVertical,
      borderHit: borderHit,
      value: valStart,
      pos: top,
      align: 'start',
      state: state,
      idx: idx
    }));
  }

  if (isEndVisible) {
    els.push(buildLine$1({
      h: state.h,
      isVertical: isVertical,
      borderHit: borderHit,
      value: valEnd,
      pos: bottom,
      align: 'end',
      state: state,
      idx: idx
    }));
  }

  var bubbles = state.settings.bubbles;

  if (bubbles && bubbles.show) {
    var fontSize = bubbles.fontSize;
    var fontFamily = bubbles.fontFamily;
    var fill = bubbles.fill;
    var style = {
      fontSize: fontSize,
      fontFamily: fontFamily,
      color: fill
    };
    var range = [vStart, vEnd];

    if (isStartVisible) {
      els.push(buildBubble({
        h: state.h,
        isVertical: isVertical,
        align: bubbles.align,
        style: style,
        rangeIdx: idx,
        idx: 0,
        otherValue: valEnd,
        value: valStart,
        label: "".concat(state.format(valStart, range)),
        pos: top,
        state: state
      }));
    }

    if (isEndVisible) {
      els.push(buildBubble({
        h: state.h,
        isVertical: isVertical,
        align: bubbles.align,
        style: style,
        rangeIdx: idx,
        idx: 1,
        otherValue: valStart,
        value: valEnd,
        label: "".concat(state.format(valEnd, range)),
        pos: bottom,
        state: state
      }));
    }
  }
}
function getMoveDelta(state) {
  var posDelta = state.active.limitHigh - state.active.end;
  var negDelta = state.active.limitLow - state.active.start;
  var delta = state.current - state.start;

  if (delta < 0) {
    delta = Math.max(delta, negDelta);
  } else {
    delta = Math.min(delta, posDelta);
  }

  return delta;
}
function nodes(state) {
  var els = [];
  var isVertical = state.direction === VERTICAL;

  if (Array.isArray(state.ranges)) {
    // add all other ranges
    state.ranges.forEach(function (r, i) {
      if (!state.active || i !== state.active.idx) {
        buildRange({
          borderHit: TARGET_SIZE,
          els: els,
          isVertical: isVertical,
          state: state,
          vStart: Math.min(r.min, r.max),
          vEnd: Math.max(r.min, r.max),
          idx: i
        });
      }
    });
  }

  if (state.active) {
    // add active range
    var vStart = state.start;
    var vEnd = state.current;

    if (state.active.idx !== -1) {
      if (state.active.mode === 'foo') {
        vStart = Math.min(state.active.start, state.active.end);
        vEnd = Math.max(state.active.start, state.active.end);
      } else if (state.active.mode === 'modify') {
        vStart = Math.min(state.start, state.current);
        vEnd = Math.max(state.start, state.current);
      } else {
        var delta = getMoveDelta(state);
        vStart = state.active.start + delta;
        vEnd = state.active.end + delta;
      }
    }

    buildRange({
      borderHit: TARGET_SIZE,
      els: els,
      isVertical: isVertical,
      state: state,
      vStart: vStart,
      vEnd: vEnd,
      idx: state.active.idx
    });
  }

  return els;
}

function rangelimits(state) {
  return {
    min: state.scale.min(),
    max: state.scale.max()
  };
}

function areaLimits(state) {
  return {
    min: 0,
    max: state.direction ? state.rect.width : state.rect.height
  };
}

function findActive(state, value, limits) {
  var rs = state.ranges;
  var i;
  var activeIdx = -1;

  for (i = 0; i < rs.length; i++) {
    if (rs[i].min <= value && value <= rs[i].max) {
      activeIdx = i;
      limits.min = i ? rs[i - 1].max : limits.min;
      limits.max = i + 1 < rs.length ? rs[i + 1].min : limits.max;
      break;
    } else if (value < rs[i].min) {
      limits.max = rs[i].min;
      limits.min = i ? rs[i - 1].max : limits.min;
      break;
    }
  }

  if (activeIdx === -1 && rs.length && i >= rs.length) {
    limits.min = rs[rs.length - 1].max;
  }

  var activeRange;

  if (activeIdx !== -1) {
    activeRange = {
      idx: activeIdx,
      start: rs[activeIdx].min,
      end: rs[activeIdx].max,
      limitLow: limits.min,
      limitHigh: limits.max,
      mode: 'foo'
    };
  }

  state.active = activeRange;
}

function startArea(_ref) {
  var state = _ref.state,
      e = _ref.e,
      renderer = _ref.renderer,
      ranges = _ref.ranges,
      targetSize = _ref.targetSize;

  if (state.started) {
    return;
  }

  var x = e.center.x - e.deltaX;
  var y = e.center.y - e.deltaY;
  var target = document.elementFromPoint(x, y);

  if (!renderer.element().contains(target)) {
    target = null;
  }

  var tempState = {
    started: true
  };
  state.offset = renderer.element().getBoundingClientRect();
  state.ranges = ranges(state);
  var relX = x - state.offset.left; // coordinate relative renderer

  var relY = y - state.offset.top;
  var startPoint = e.center[state.cssCoord.coord] - e[state.cssCoord.pos] - state.offset[state.cssCoord.offset];
  var relStart = e.center[state.cssCoord.coord] - state.offset[state.cssCoord.offset];
  var v = relStart;
  var vStart = startPoint;
  tempState.start = startPoint;
  tempState.current = relStart;
  var rs = state.ranges;
  var limits = areaLimits(state);
  var i;
  var activeIdx = -1;

  if (target && target.hasAttribute('data-idx')) {
    activeIdx = parseInt(target.getAttribute('data-idx'), 10);
    limits.min = activeIdx > 0 ? rs[activeIdx - 1].max : limits.min;
    limits.max = activeIdx + 1 < rs.length ? rs[activeIdx + 1].min : limits.max;
  } else {
    for (i = 0; i < rs.length; i++) {
      if (rs[i].min <= vStart && vStart <= rs[i].max) {
        activeIdx = i;
        limits.min = i ? rs[i - 1].max : limits.min;
        limits.max = i + 1 < rs.length ? rs[i + 1].min : limits.max;
        break;
      } else if (vStart < rs[i].min) {
        limits.max = rs[i].min;
        limits.min = i ? rs[i - 1].max : limits.min;
        break;
      }
    }

    if (activeIdx === -1 && rs.length && i >= rs.length) {
      limits.min = rs[rs.length - 1].max;
    }
  }

  if (activeIdx === -1 && !state.multi) {
    tempState.ranges = [];
    limits.min = 0;
    limits.max = state.direction ? state.rect.width : state.rect.height;
  }

  var activeRange;

  if (activeIdx !== -1) {
    activeRange = {
      idx: activeIdx,
      start: rs[activeIdx].min,
      end: rs[activeIdx].max,
      limitLow: limits.min,
      limitHigh: limits.max,
      mode: 'move'
    };

    if (target && target.hasAttribute('data-other-value')) {
      tempState.start = parseFloat(target.getAttribute('data-other-value'));
      activeRange.mode = 'modify';
    } else {
      var pxStart = activeRange.start;
      var pxEnd = activeRange.end;

      if (Math.abs(startPoint - pxStart) <= targetSize) {
        tempState.start = activeRange.end;
        activeRange.mode = 'modify';
      } else if (Math.abs(startPoint - pxEnd) <= targetSize) {
        tempState.start = activeRange.start;
        activeRange.mode = 'modify';
      }
    }
  } else {
    activeRange = {
      idx: -1,
      start: vStart,
      end: v,
      limitLow: limits.min,
      limitHigh: limits.max,
      mode: 'current'
    };
  }

  tempState.active = activeRange;

  if (activeRange.mode !== 'modify' && state.targetRect && !testRectPoint(state.targetRect, {
    x: relX,
    y: relY
  })) ; else {
    Object.keys(tempState).forEach(function (key) {
      return state[key] = tempState[key];
    });
  }
}
function start$1(_ref2) {
  var state = _ref2.state,
      e = _ref2.e,
      renderer = _ref2.renderer,
      ranges = _ref2.ranges,
      targetSize = _ref2.targetSize;

  if (state.started) {
    return;
  }

  state.edit = null;
  var x = e.center.x - e.deltaX;
  var y = e.center.y - e.deltaY;
  var target = document.elementFromPoint(x, y);

  if (!renderer.element().contains(target)) {
    target = null;
  }

  var tempState = {
    started: true
  };
  state.offset = extend({}, renderer.element().getBoundingClientRect());
  var relX = x - state.offset.left; // coordinate relative renderer

  var relY = y - state.offset.top;
  state.offset.left += state.targetRect ? state.targetRect.x : 0; // make offset relative to targetRect

  state.offset.top += state.targetRect ? state.targetRect.y : 0;
  state.ranges = ranges(state, state.fauxBrushInstance || state.brushInstance);
  var startPoint = e.center[state.cssCoord.coord] - e[state.cssCoord.pos] - state.offset[state.cssCoord.offset];
  var relStart = e.center[state.cssCoord.coord] - state.offset[state.cssCoord.offset];
  tempState.current = state.scale.normInvert(relStart / state.size);
  tempState.start = state.scale.normInvert(startPoint / state.size);
  var rs = state.ranges;
  var limits = rangelimits(state);
  var i;
  var activeIdx = -1;

  if (target && target.hasAttribute('data-idx')) {
    activeIdx = parseInt(target.getAttribute('data-idx'), 10);
    limits.min = activeIdx > 0 ? rs[activeIdx - 1].max : limits.min;
    limits.max = activeIdx + 1 < rs.length ? rs[activeIdx + 1].min : limits.max;
  } else {
    for (i = 0; i < rs.length; i++) {
      if (rs[i].min <= tempState.start && tempState.start <= rs[i].max) {
        activeIdx = i;
        limits.min = i ? rs[i - 1].max : limits.min;
        limits.max = i + 1 < rs.length ? rs[i + 1].min : limits.max;
        break;
      } else if (tempState.start < rs[i].min) {
        limits.max = rs[i].min;
        limits.min = i ? rs[i - 1].max : limits.min;
        break;
      }
    }

    if (activeIdx === -1 && rs.length && i >= rs.length) {
      limits.min = rs[rs.length - 1].max;
    }
  }

  if (activeIdx === -1 && !state.multi) {
    tempState.ranges = [];
    limits.min = state.scale.min();
    limits.max = state.scale.max();
  }

  var activeRange;

  if (activeIdx !== -1) {
    activeRange = {
      idx: activeIdx,
      start: rs[activeIdx].min,
      end: rs[activeIdx].max,
      limitLow: limits.min,
      limitHigh: limits.max,
      mode: 'move'
    };

    if (target && target.hasAttribute('data-other-value')) {
      tempState.start = parseFloat(target.getAttribute('data-other-value'));
      activeRange.mode = 'modify';
    } else {
      var pxStart = state.scale.norm(activeRange.start) * state.size;
      var pxEnd = state.scale.norm(activeRange.end) * state.size;

      if (Math.abs(startPoint - pxStart) <= targetSize) {
        tempState.start = activeRange.end;
        activeRange.mode = 'modify';
      } else if (Math.abs(startPoint - pxEnd) <= targetSize) {
        tempState.start = activeRange.start;
        activeRange.mode = 'modify';
      }
    }
  } else {
    activeRange = {
      idx: -1,
      start: tempState.start,
      end: tempState.current,
      limitLow: limits.min,
      limitHigh: limits.max,
      mode: 'current'
    };
  }

  tempState.active = activeRange;

  if (activeRange.mode !== 'modify' && state.targetRect && !testRectPoint(state.targetRect, {
    x: relX,
    y: relY
  })) ; else {
    Object.keys(tempState).forEach(function (key) {
      return state[key] = tempState[key];
    });
  }
}
function end(state, ranges) {
  state.started = false;
  state.ranges = ranges(state, state.fauxBrushInstance || state.brushInstance);
  var limits = rangelimits(state);
  findActive(state, state.current, limits);
}
function endArea(state, ranges) {
  state.started = false;
  state.ranges = ranges(state);
  var limits = areaLimits(state);
  findActive(state, state.current, limits);
}
function move(state, e) {
  var relY = e.center[state.cssCoord.coord] - state.offset[state.cssCoord.offset];
  var rel = relY / state.size;
  var v = state.scale.normInvert(rel);
  state.current = Math.max(Math.min(v, state.active.limitHigh), state.active.limitLow);
}
function moveArea(state, e) {
  var rel = e.center[state.cssCoord.coord] - state.offset[state.cssCoord.offset];
  state.current = Math.max(Math.min(rel, state.active.limitHigh), state.active.limitLow);
}

function _render(state) {
  state.renderer.render(nodes(state));
}

function ranges(state, brush) {
  if (!brush || !brush.isActive()) {
    return [];
  }

  var sourceData = state.scale.data();
  var sourceFields = sourceData ? sourceData.fields || [] : [];
  var sources = sourceFields.map(function (field) {
    return field.id();
  });
  var rangeBrush = brush.brushes().filter(function (f) {
    return f.type === 'range' && sources.indexOf(f.id) !== -1;
  })[0];

  if (!rangeBrush) {
    return [];
  }

  return rangeBrush.brush.ranges();
}

function setRanges(state) {
  var rs = state.ranges.map(function (r) {
    return {
      min: r.min,
      max: r.max
    };
  });

  if (state.active.idx !== -1) {
    if (state.active.mode === 'modify') {
      rs[state.active.idx].min = Math.min(state.start, state.current);
      rs[state.active.idx].max = Math.max(state.start, state.current);
    } else {
      var delta = getMoveDelta(state);
      rs[state.active.idx].min += delta;
      rs[state.active.idx].max += delta;
    }
  } else {
    rs.push({
      min: Math.min(state.start, state.current),
      max: Math.max(state.start, state.current)
    });
  }

  var scaleData = state.scale.data();

  if (scaleData && scaleData.fields) {
    scaleData.fields.forEach(function (field) {
      if (state.fauxBrushInstance) {
        var ordRS = ranges(state, state.fauxBrushInstance);
        var oldValues = state.findValues(ordRS);
        var values = state.findValues(rs);
        var addedValues = values.filter(function (v) {
          return oldValues.indexOf(v) === -1;
        });
        var removedValues = oldValues.filter(function (v) {
          return values.indexOf(v) === -1;
        });
        var addItems = addedValues.map(function (v) {
          return {
            key: field.id(),
            value: v
          };
        });
        var removeItems = removedValues.map(function (v) {
          return {
            key: field.id(),
            value: v
          };
        });
        state.brushInstance.addAndRemoveValues(addItems, removeItems);
        state.fauxBrushInstance.setRange(field.id(), rs);
      } else {
        state.brushInstance.setRange(field.id(), rs);
      }
    });
  }
}

function setEditedRanges(state, idx, startValue, endValue) {
  var rs = state.ranges.map(function (r) {
    return {
      min: r.min,
      max: r.max
    };
  });
  var limitMin = state.scale.min();
  var limitMax = state.scale.max();
  rs[idx] = {
    min: Math.max(limitMin, Math.min(startValue, endValue)),
    max: Math.min(limitMax, Math.max(startValue, endValue))
  };
  state.ranges[idx] = _objectSpread({}, rs[idx]);
  var scaleData = state.scale.data();

  if (scaleData && scaleData.fields) {
    scaleData.fields.forEach(function (field) {
      if (!state.fauxBrushInstance) {
        state.brushInstance.setRange(field.id(), rs);
      }
    });
  }
}

function findClosest(value, scale) {
  var name;
  var minDist = Infinity;
  var domain = scale.domain();
  var halfBandwidth = scale.bandwidth() / 2;

  for (var i = 0; i < domain.length; ++i) {
    var d = Math.abs(value - halfBandwidth - scale(domain[i]));

    if (d < minDist) {
      minDist = d;
      name = domain[i];
    }
  }

  return name;
}

function findClosestLabel(value, scale) {
  var ticks = scale.ticks();
  var idx = scale.domain().indexOf(findClosest(value, scale));
  return idx !== -1 ? ticks[idx].label : '-';
}

function rangesOverlap(r1, r2) {
  return Math.min.apply(Math, _toConsumableArray$1(r1)) <= Math.max.apply(Math, _toConsumableArray$1(r2)) && Math.max.apply(Math, _toConsumableArray$1(r1)) >= Math.min.apply(Math, _toConsumableArray$1(r2));
}

function findValues(rangesValues, scale) {
  var domain = scale.domain();
  var scaleRange = scale.range();
  var values = [];
  rangesValues.forEach(function (range) {
    if (!rangesOverlap(scaleRange, [range.min, range.max])) {
      return;
    }

    var startIdx = domain.indexOf(findClosest(range.min, scale));
    var endIdx = domain.indexOf(findClosest(range.max, scale));
    values.push.apply(values, domain.slice(Math.min(startIdx, endIdx), Math.max(startIdx, endIdx) + 1));
    /* eslint prefer-spread:0 */
  });
  return values;
}

function resolveNodeBounds(targetNodes) {
  var points = targetNodes.reduce(function (ary, node) {
    ary.push.apply(ary, _toConsumableArray$1(rectToPoints(node.bounds)));
    return ary;
  }, []);
  return pointsToRect(points);
}

function resolveTarget(ctx) {
  var resolved = {
    targetRect: null,
    targetFillRect: null,
    scale: null,
    size: null
  };
  var stngs = ctx.settings.settings;
  var targets = stngs.target && (stngs.target.components || (stngs.target.component ? [stngs.target.component] : [])).map(function (c) {
    return ctx.chart.component(c);
  }).filter(function (c) {
    return !!c && !!c.rect;
  });
  var targetNodes = stngs.target && stngs.target.selector ? ctx.chart.findShapes(stngs.target.selector) : [];
  var targetFillNodes = stngs.target && stngs.target.fillSelector ? ctx.chart.findShapes(stngs.target.fillSelector) : [];

  if (targetNodes.length > 0) {
    var bounds = resolveNodeBounds(targetNodes);
    resolved.size = bounds[ctx.state.direction === VERTICAL ? 'height' : 'width'];
    resolved.scale = scaleWithSize(ctx.chart.scale(stngs.scale), resolved.size);
    resolved.targetRect = bounds;

    if (targetFillNodes.length > 0) {
      var fillBounds = resolveNodeBounds(targetFillNodes);
      resolved.targetFillRect = fillBounds;
    }
  } else if (targets && targets.length > 0) {
    var targetRect = targets.slice(1).reduce(function (prev, curr) {
      return {
        x0: Math.min(prev.x0, curr.rect.computedInner.x),
        y0: Math.min(prev.y0, curr.rect.computedInner.y),
        x1: Math.max(prev.x1, curr.rect.computedInner.x + curr.rect.computedInner.width),
        y1: Math.max(prev.y1, curr.rect.computedInner.y + curr.rect.computedInner.height)
      };
    }, {
      x0: targets[0].rect.computedInner.x,
      y0: targets[0].rect.computedInner.y,
      x1: targets[0].rect.computedInner.x + targets[0].rect.computedInner.width,
      y1: targets[0].rect.computedInner.y + targets[0].rect.computedInner.height
    });
    resolved.targetRect = {
      x: targetRect.x0 - ctx.state.rect.x,
      y: targetRect.y0 - ctx.state.rect.y,
      width: targetRect.x1 - targetRect.x0,
      height: targetRect.y1 - targetRect.y0
    };
  }

  return resolved;
}
/**
 * @typedef {object} component--brush-range-settings
 * @property {string|object} brush - Brush context to apply changes to
 * @property {string} scale - Scale to extract data from
 * @property {string} [direction=vertical] - Rendering direction [horizontal|vertical]
 * @property {object} [bubbles]
 * @property {boolean} [bubbles.show=true] - True to show label bubble, false otherwise
 * @property {string} [bubbles.align=start] - Where to anchor bubble [start|end]
 * @property {function} [bubbles.label] - Callback function for the labels
 * @property {object} [target]
 * @property {string} [target.component] - Render matching overlay on target component. @deprecated Use `components` instead
 * @property {string[]} [target.components] - Render matching overlay on target components
 * @property {string} [target.selector] - Instead of targeting a component, target one or more shapes
 * @property {string} [target.fillSelector] - Target a subset of the selector as fill area. Only applicable if `selector` property is set
 */

/**
 * @typedef {object} component--brush-range-style
 * @property {object} [bubble]
 * @property {string} [bubble.fontSize]
 * @property {string} [bubble.fontFamily]
 * @property {string} [bubble.fill]
 * @property {string} [bubble.color]
 * @property {string} [bubble.stroke]
 * @property {number} [bubble.strokeWidth]
 * @property {number} [bubble.borderRadius]
 * @property {object} [line]
 * @property {string} [line.stroke]
 * @property {number} [line.strokeWidth]
 * @property {object} [target]
 * @property {string} [target.fill]
 * @property {number} [target.strokeWidth]
 * @property {number} [target.opacity]
 */


var brushRangeComponent = {
  require: ['chart', 'settings', 'renderer'],
  defaultSettings: {
    settings: {
      bubbles: {
        show: true,
        align: 'start'
      }
    },
    style: {
      bubble: '$label-overlay',
      line: '$shape-guide--inverted',
      target: '$selection-area-target'
    }
  },
  renderer: 'dom',
  on: {
    rangeStart: function rangeStart(e) {
      this.start(e);
    },
    rangeMove: function rangeMove(e) {
      this.move(e);
    },
    rangeEnd: function rangeEnd(e) {
      this.end(e);
    },
    rangeClear: function rangeClear(e) {
      this.clear(e);
    },
    bubbleStart: function bubbleStart(e) {
      this.bubbleStart(e);
    }
  },
  created: function created() {
    this.state = {
      key: this.settings.key || 'brush-range'
    };
  },
  beforeRender: function beforeRender(opts) {
    this.state.rect = opts.size.computedInner;
  },
  renderRanges: function renderRanges() {
    if (!this.state.started) {
      this.state.ranges = ranges(this.state, this.state.brushInstance);
      this.state.active = null;

      _render(this.state);
    }
  },
  render: function render(h) {
    var _this = this;

    var stngs = this.settings.settings;
    this.state.direction = stngs.direction === 'vertical' ? VERTICAL : HORIZONTAL;
    var offset = this.renderer.element().getBoundingClientRect();
    var size = this.state.rect[this.state.direction === VERTICAL ? 'height' : 'width'];
    var scale = scaleWithSize(this.chart.scale(stngs.scale), size);
    var target = resolveTarget(this);
    scale = target.scale ? target.scale : scale;
    this.state.targetRect = target.targetRect;
    this.state.targetFillRect = target.targetFillRect;
    this.state.size = target.size === null ? size : target.size;
    this.state.settings = stngs;
    this.state.style = this.style;
    this.state.offset = offset;
    this.state.brush = _typeof(stngs.brush) === 'object' ? stngs.brush.context : stngs.brush;
    this.state.brushInstance = this.chart.brush(this.state.brush);
    this.state.renderer = this.renderer;
    this.state.multi = !!stngs.multiple;
    this.state.h = h;

    this.state.onEditConfirmed = function (rangeIdx, value, otherValue) {
      _this.state.edit = null;
      setEditedRanges(_this.state, rangeIdx, value, otherValue);

      _this.emit('bubbleEnd');

      _render(_this.state);
    };

    this.state.onEditCanceled = function () {
      _this.state.edit = null;

      _render(_this.state);
    };

    this.state.cssCoord = {
      offset: this.state.direction === VERTICAL ? 'top' : 'left',
      coord: this.state.direction === VERTICAL ? 'y' : 'x',
      pos: this.state.direction === VERTICAL ? 'deltaY' : 'deltaX'
    };
    this.state.format = typeof stngs.bubbles.label === 'function' ? function (v, r) {
      return stngs.bubbles.label.call(undefined, {
        datum: v,
        data: r,
        scale: scale,
        resources: {
          scale: _this.chart.scale,
          formatter: _this.chart.formatter
        }
      });
    } : false;

    if (!{}.hasOwnProperty.call(scale, 'norm')) {
      // Non-linear scale if norm method is unavailable
      this.state.editable = false;
      this.state.scale = scaleLinear();
      this.state.scale.data = scale.data;

      if (!this.state.format) {
        this.state.format = function (v, r) {
          if (!rangesOverlap(scale.range(), r)) {
            return '-';
          }

          return findClosestLabel(v, scale);
        };
      }

      this.state.fauxBrushInstance = brush();

      this.state.findValues = function (valueRanges) {
        return findValues(valueRanges, scale);
      };
    } else {
      this.state.editable = true;
      this.state.observeBrush = _typeof(stngs.brush) === 'object' ? stngs.brush.observe : false;
      this.state.fauxBrushInstance = null;
      this.state.findValues = null;
      this.state.scale = scale;
      var scaleData = this.state.scale.data();

      if (!this.state.format && scaleData && scaleData.fields && scaleData.fields[0]) {
        this.state.format = scaleData.fields[0].formatter();
      }
    }

    this.state.ranges = ranges(this.state, this.state.brushInstance);
    return this.state.observeBrush || this.state.sourcedFromThisComponent ? [nodes(this.state)] : [];
  },
  mounted: function mounted() {
    if (this.state.observeBrush && this.state.brushInstance) {
      this.state.brushInstance.on('update', this.renderRanges);
    }
  },
  beforeDestroy: function beforeDestroy() {
    if (this.state.observeBrush && this.state.brushInstance) {
      this.state.brushInstance.removeListener('update', this.renderRanges);
    }
  },
  start: function start(e) {
    start$1({
      e: e,
      state: this.state,
      renderer: this.renderer,
      ranges: ranges,
      targetSize: TARGET_SIZE
    });
  },
  end: function end$1() {
    if (!this.state.started) {
      return;
    }

    end(this.state, ranges);

    _render(this.state);

    this.state.sourcedFromThisComponent = true;
    this.state.active = null;
  },
  move: function move$1(e) {
    if (!this.state.started) {
      return;
    }

    move(this.state, e);

    setRanges(this.state);

    _render(this.state);
  },
  clear: function clear() {
    if (this.state.fauxBrushInstance) {
      this.state.fauxBrushInstance.clear();
    }

    this.state.renderer.render([]);
    this.state.started = false;
    this.state.active = null;
    this.state.sourcedFromThisComponent = false;
  },
  bubbleStart: function bubbleStart(e) {
    if (!this.state.editable) {
      return;
    }

    var ee = e.srcEvent || e;
    var target = ee.target;
    var ed = {
      rangeIdx: parseInt(target.getAttribute('data-idx'), 10),
      bubbleIdx: parseInt(target.getAttribute('data-bidx'), 10)
    };

    if (isNaN(ed.rangeIdx) || JSON.stringify(ed) === JSON.stringify(this.state.edit)) {
      return;
    }

    this.state.edit = ed;
    ee.stopPropagation();
    ee.stopImmediatePropagation();
    ee.preventDefault();
    var wrapper = target.parentNode;

    _render(this.state);

    var inputEl = wrapper.querySelector('input');
    inputEl.focus();
    inputEl.select();
  }
};

function render(state) {
  state.renderer.render(nodes(state));
}

function ranges$1(state) {
  return state.rc.ranges();
}

function shapesFromRange(state, brushRange) {
  var shapeAt = {
    x: state.direction ? brushRange.min + state.rect.x : state.rect.x,
    y: state.direction ? state.rect.y : brushRange.min + state.rect.y,
    width: state.direction ? brushRange.max - brushRange.min : state.rect.width + state.rect.x,
    height: state.direction ? state.rect.height + state.rect.y : brushRange.max - brushRange.min
  };
  return state.chart.shapesAt(shapeAt, state.settings.brush);
}

function brushFromShape(state, newShapes) {
  state.chart.brushFromShapes(newShapes, state.settings.brush);
}

function setRanges$1(state) {
  var rs = state.ranges.map(function (r) {
    return {
      min: r.min,
      max: r.max
    };
  });

  if (state.active.idx !== -1) {
    if (state.active.mode === 'modify') {
      rs[state.active.idx].min = Math.min(state.start, state.current);
      rs[state.active.idx].max = Math.max(state.start, state.current);
    } else {
      var delta = getMoveDelta(state);
      rs[state.active.idx].min = state.active.start + delta;
      rs[state.active.idx].max = state.active.end + delta;
    }
  } else {
    rs.push({
      min: Math.min(state.start, state.current),
      max: Math.max(state.start, state.current)
    });
  }

  state.rc.set(rs);
  var shapes = [];
  rs.forEach(function (range) {
    shapes.push.apply(shapes, _toConsumableArray$1(shapesFromRange(state, range)));
  });
  brushFromShape(state, shapes);
}

function getBubbleLabel(state, value, range) {
  var min = Math.min.apply(Math, _toConsumableArray$1(range));
  var max = Math.max.apply(Math, _toConsumableArray$1(range));
  var shapeAt = {
    x: state.direction ? min + state.rect.x : state.rect.x,
    y: state.direction ? state.rect.y : min + state.rect.y,
    width: state.direction ? max - min : state.rect.width + state.rect.x,
    height: state.direction ? state.rect.height + state.rect.y : max - min
  };
  var shapes = state.chart.shapesAt(shapeAt, state.settings.brush);

  if (shapes.length === 0) {
    return '-';
  }

  var labelShape = shapes.reduce(function (s0, s1) {
    // Min value
    var bounds0 = s0.bounds;
    var bounds1 = s1.bounds;

    if (value === min) {
      if (bounds0[state.cssCoord.coord] <= bounds1[state.cssCoord.coord]) {
        return s0;
      }

      return s1;
    } // Max value


    if (bounds0[state.cssCoord.coord] + bounds0[state.cssCoord.area] >= bounds1[state.cssCoord.coord] + bounds1[state.cssCoord.area]) {
      return s0;
    }

    return s1;
  });
  var compConfig = state.settings.brush.components.reduce(function (c0, c1) {
    return c0.key === labelShape.key ? c0 : c1;
  });

  if (typeof state.settings.bubbles.label === 'function') {
    return state.settings.bubbles.label(labelShape.data);
  }

  if (Array.isArray(compConfig.data) && compConfig.data.length) {
    return labelShape.data[compConfig.data[0]].label;
  }

  return labelShape.data && labelShape.data.label ? labelShape.data.label : '-';
}
/**
 * @typedef {object} component--brush-area-dir-settings
 * @property {object} brush
 * @property {array} brush.components
 * @property {object} brush.components[].key - Component key
 * @property {object} brush.components[].contexts[] - Brush context to apply changes to
 * @property {object} [brush.components[].data] - Data reference
 * @property {object} [brush.components[].action] - Type of brush action
 * @property {string} [direction=vertical] - Rendering direction [horizontal|vertical]
 * @property {object} [bubbles]
 * @property {boolean} [bubbles.show=true] - True to show label bubble, false otherwise
 * @property {string} [bubbles.align=start] - Where to anchor bubble [start|end]
 * @property {function} [bubbles.label] - Callback function for the labels
 * @property {object} [target]
 * @property {string} [target.component] - Render matching overlay on target component. @deprecated Use `components` instead
 * @property {string[]} [target.components] - Render matching overlay on target components
 */

/**
 * @typedef {object} component--brush-area-dir-style
 * @property {object} [bubble]
 * @property {string} [bubble.fontSize]
 * @property {string} [bubble.fontFamily]
 * @property {string} [bubble.fill]
 * @property {string} [bubble.color]
 * @property {string} [bubble.stroke]
 * @property {number} [bubble.strokeWidth]
 * @property {number} [bubble.borderRadius]
 * @property {object} [line]
 * @property {string} [line.stroke]
 * @property {number} [line.strokeWidth]
 * @property {object} [target]
 * @property {string} [target.fill]
 * @property {number} [target.strokeWidth]
 * @property {number} [target.opacity]
 */


var brushAreaDirectionalComponent = {
  require: ['chart', 'settings', 'renderer'],
  defaultSettings: {
    settings: {
      bubbles: {
        show: true,
        align: 'start'
      }
    },
    style: {
      bubble: '$label-overlay',
      line: '$shape-guide--inverted',
      target: '$selection-area-target'
    }
  },
  renderer: 'dom',
  on: {
    areaStart: function areaStart(e) {
      this.start(e);
    },
    areaMove: function areaMove(e) {
      this.move(e);
    },
    areaEnd: function areaEnd(e) {
      this.end(e);
    },
    areaClear: function areaClear(e) {
      this.clear(e);
    }
  },
  created: function created() {
    this.state = {
      key: this.settings.key || 'brush-area-dir'
    };
  },
  render: function render(h) {
    var _this = this;

    this.state.rect = this.rect;
    var stngs = this.settings.settings;
    var direction = stngs.direction === 'vertical' ? VERTICAL : HORIZONTAL;
    var size = this.state.rect[direction === VERTICAL ? 'height' : 'width'];
    var offset = this.renderer.element().getBoundingClientRect();
    var targets = (stngs.target ? stngs.target.components || [stngs.target.component] : []).map(function (c) {
      return _this.chart.component(c);
    }).filter(function (c) {
      return !!c && !!c.rect;
    });
    var targetRect = targets[0] ? targets.slice(1).reduce(function (prev, curr) {
      return {
        x0: Math.min(prev.x0, curr.rect.x),
        y0: Math.min(prev.y0, curr.rect.y),
        x1: Math.max(prev.x1, curr.rect.x + curr.rect.width),
        y1: Math.max(prev.y1, curr.rect.y + curr.rect.height)
      };
    }, {
      x0: targets[0].rect.x,
      y0: targets[0].rect.y,
      x1: targets[0].rect.x + targets[0].rect.width,
      y1: targets[0].rect.y + targets[0].rect.height
    }) : null;
    this.state.targetRect = targetRect ? {
      x: targetRect.x0 - this.rect.x,
      y: targetRect.y0 - this.rect.y,
      width: targetRect.x1 - targetRect.x0,
      height: targetRect.y1 - targetRect.y0
    } : null;
    this.state.style = this.style;
    this.state.chart = this.chart;
    this.state.direction = direction;
    this.state.settings = stngs;
    this.state.offset = offset;
    this.state.rc = rangeCollection();
    this.state.renderer = this.renderer;
    this.state.multi = !!stngs.multiple;
    this.state.h = h;
    this.state.size = size;
    this.state.cssCoord = {
      offset: this.state.direction === VERTICAL ? 'top' : 'left',
      coord: this.state.direction === VERTICAL ? 'y' : 'x',
      pos: this.state.direction === VERTICAL ? 'deltaY' : 'deltaX',
      area: this.state.direction === VERTICAL ? 'height' : 'width'
    };

    this.state.format = function getFormat(v, r) {
      return getBubbleLabel(this, v, r);
    };

    return [];
  },
  start: function start(e) {
    startArea({
      e: e,
      state: this.state,
      renderer: this.renderer,
      ranges: ranges$1,
      targetSize: TARGET_SIZE
    });
  },
  end: function end() {
    if (!this.state.started) {
      return;
    }

    endArea(this.state, ranges$1);
    render(this.state);
  },
  move: function move(e) {
    if (!this.state.started) {
      return;
    }

    moveArea(this.state, e);
    setRanges$1(this.state);
    render(this.state);
  },
  clear: function clear() {
    if (this.state.rc) {
      this.state.rc.clear();
    }

    this.state.renderer.render([]);
  }
};

function rangeBrush(picasso) {
  picasso.component('brush-range', brushRangeComponent);
  picasso.component('brush-area-dir', brushAreaDirectionalComponent);
}

var FILL = '#ccc';
var OPACITY = 1;

function ranges$2(state) {
  var brush = state.brush;

  if (!brush || !brush.isActive()) {
    return [];
  }

  var sourceData = state.scale.data();
  var sourceFields = sourceData ? sourceData.fields || [] : [];
  var sources = sourceFields.map(function (field) {
    return field.id();
  });
  var rangeBrush = brush.brushes().filter(function (f) {
    return f.type === 'range' && sources.indexOf(f.id) !== -1;
  })[0];

  if (!rangeBrush) {
    return [];
  }

  return rangeBrush.brush.ranges();
}

function shapes(state) {
  var isVertical = state.direction === 'vertical';
  var size = state.rect[isVertical ? 'height' : 'width'];
  var otherSize = state.rect[isVertical ? 'width' : 'height'];
  return ranges$2(state).map(function (range) {
    var start = state.scale(range.min) * size;
    var end = state.scale(range.max) * size;
    var low = Math.min(start, end);
    var s = Math.abs(start - end);
    return {
      type: 'rect',
      fill: state.fill,
      opacity: state.opacity,
      x: isVertical ? 0 : low,
      width: isVertical ? otherSize : s,
      y: isVertical ? low : 0,
      height: isVertical ? s : otherSize
    };
  });
}

function onStart(state) {
  state.renderer.render(shapes(state));
}

function onUpdate(state) {
  state.renderer.render(shapes(state));
}

function onEnd(state) {
  state.renderer.render(shapes(state));
}

function setup(state, brush, scale, renderer) {
  state.brush = brush;

  if (!brush) {
    return;
  }

  function start() {
    onStart(state);
  }

  function update() {
    onUpdate(state);
  }

  function end() {
    onEnd(state);
  }

  brush.on('start', start);
  brush.on('update', update);
  brush.on('end', end);
  state.start = start;
  state.update = update;
  state.end = end;
  state.brush = brush;
  state.scale = scale;
  state.renderer = renderer;
}

function teardown(state) {
  if (state.brush) {
    state.brush.removeListener('start', state.start);
    state.brush.removeListener('update', state.update);
    state.brush.removeListener('end', state.end);
  }

  state.start = undefined;
  state.update = undefined;
  state.end = undefined;
  state.brush = undefined;
  state.scale = undefined;
  state.renderer = undefined;
}
/**
 * @typedef {object} component--range
 */

/**
 * @typedef {object} component--range.settings
 * @property {string} brush - Name of brush instance
 * @property {string} scale - Name of a scale
 * @property {string} [direction='horizontal'] - Direction of the brush
 * @property {string} [fill='#ccc'] - Fill color
 * @property {number} [opacity=1] - Layer opacity
 */


var rangeComponent = {
  require: ['chart', 'settings', 'renderer'],
  defaultSettings: {
    settings: {}
  },
  preferredSize: function preferredSize() {
    return 50;
  },
  created: function created() {
    this.state = {};
  },
  render: function render() {
    var stngs = this.settings.settings;
    var brush = this.chart.brush(stngs.brush);
    var direction = stngs.direction || 'horizontal';
    var distance = direction === 'horizontal' ? this.rect.width : this.rect.height;
    var scale = scaleWithSize(this.chart.scale(stngs.scale), distance);
    teardown(this.state);
    setup(this.state, brush, scale, this.renderer);
    this.state.rect = this.rect;
    this.state.fill = stngs.fill || FILL;
    this.state.opacity = typeof stngs.opacity !== 'undefined' ? stngs.opacity : OPACITY;
    this.state.direction = direction;
    return shapes(this.state);
  },
  beforeDestroy: function beforeDestroy() {
    teardown(this.state);
  }
};

function rangeBrush$1(picasso) {
  picasso.component('range', rangeComponent);
}

function getPoint(rendererBounds, event) {
  var eventOffsetX = event.center.x;
  var eventOffsetY = event.center.y;
  return {
    x: eventOffsetX - rendererBounds.left,
    y: eventOffsetY - rendererBounds.top
  }; // return {
  //   x: Math.min(Math.max(eventOffsetX - rendererBounds.left, 0), rendererBounds.width),
  //   y: Math.min(Math.max(eventOffsetY - rendererBounds.top, 0), rendererBounds.height)
  // };
}

function withinThreshold(p, state, settings) {
  var startPoint = state.points[0];
  var sqrDist = sqrDistance(p, startPoint);
  return sqrDist < Math.pow(settings.settings.snapIndicator.threshold, 2);
}

function appendToPath(state, p) {
  if (state.path.d == null) {
    state.path.d = "M".concat(p.x, " ").concat(p.y, " ");
  } else {
    state.path.d += "L".concat(p.x, " ").concat(p.y, " ");
  }

  state.points.push(p);
}

function render$1(state, renderer) {
  var nodes = [state.startPoint, state.path, state.snapIndicator].filter(function (node) {
    return node.visible;
  });
  renderer.render(nodes);
}

function setSnapIndictor(_ref) {
  var state = _ref.state,
      _ref$start = _ref.start,
      start = _ref$start === void 0 ? null : _ref$start,
      _ref$end = _ref.end,
      end = _ref$end === void 0 ? null : _ref$end;

  if (start !== null) {
    state.snapIndicator.x1 = start.x;
    state.snapIndicator.y1 = start.y;
  }

  if (end !== null) {
    state.snapIndicator.x2 = end.x;
    state.snapIndicator.y2 = end.y;
  }
}

function showSnapIndicator(state, show) {
  state.snapIndicator.visible = show;
}

function setStartPoint(state, p) {
  state.startPoint.cx = p.x;
  state.startPoint.cy = p.y;
}

function getComponentDelta(chart, rendererBounds) {
  var chartBounds = chart.element.getBoundingClientRect();
  return {
    x: rendererBounds.left - chartBounds.left,
    y: rendererBounds.top - chartBounds.top
  };
}

function doLineBrush(state, chart) {
  if (state.active) {
    var p1 = state.points[state.points.length - 2];
    var p2 = state.points[state.points.length - 1];
    state.lineBrushShape.x1 = p1.x + state.componentDelta.x;
    state.lineBrushShape.y1 = p1.y + state.componentDelta.y;
    state.lineBrushShape.x2 = p2.x + state.componentDelta.x;
    state.lineBrushShape.y2 = p2.y + state.componentDelta.y;
    var shapes = chart.shapesAt(state.lineBrushShape, {
      components: state.brushConfig
    });
    chart.brushFromShapes(shapes, {
      components: state.brushConfig
    });
  }
}

function doPolygonBrush(state, chart) {
  if (state.active) {
    var dx = state.componentDelta.x;
    var dy = state.componentDelta.y;
    var vertices = state.points.map(function (p) {
      return {
        x: p.x + dx,
        y: p.y + dy
      };
    });
    var shapes = chart.shapesAt({
      vertices: vertices
    }, {
      components: state.brushConfig
    });
    chart.brushFromShapes(shapes, {
      components: state.brushConfig
    });
  }
}

function initPath(stgns) {
  return {
    visible: true,
    type: 'path',
    d: null,
    fill: stgns.fill,
    stroke: stgns.stroke,
    strokeWidth: stgns.strokeWidth,
    opacity: stgns.opacity,
    strokeDasharray: stgns.strokeDasharray,
    collider: {
      type: null
    }
  };
}

function initSnapIndicator(stgns) {
  return {
    visible: false,
    type: 'line',
    x1: 0,
    y1: 0,
    x2: 0,
    y2: 0,
    strokeDasharray: stgns.strokeDasharray,
    stroke: stgns.stroke,
    strokeWidth: stgns.strokeWidth,
    opacity: stgns.opacity,
    collider: {
      type: null
    }
  };
}

function initStartPoint(stgns) {
  return {
    visible: true,
    type: 'circle',
    cx: 0,
    cy: 0,
    r: stgns.r,
    fill: stgns.fill,
    opacity: stgns.opacity,
    stroke: stgns.stroke,
    strokeWidth: stgns.strokeWidth,
    collider: {
      type: null
    }
  };
}

function getBrushConfig(settings) {
  return settings.settings.brush.components.map(function (b) {
    return {
      key: b.key,
      contexts: b.contexts || ['lassoBrush'],
      data: b.data || [''],
      action: b.action || 'add'
    };
  });
}

function endBrush(state, chart) {
  state.brushConfig.forEach(function (config) {
    config.contexts.forEach(function (context) {
      chart.brush(context).end();
    });
  });
}

function resetState() {
  return {
    points: [],
    active: false,
    path: null,
    snapIndicator: null,
    startPoint: null,
    rendererBounds: null,
    componentDelta: null,
    brushConfig: null,
    lineBrushShape: {
      x1: 0,
      y1: 0,
      x2: 0,
      y2: 0 // Keep a single shape instance to avoid instantiating a new object on each lookup

    }
  };
}
/**
 * @typedef {object} component--brush-lasso
 */

/**
 * @typedef {object} component--brush-lasso-settings
 * @property {object} [lasso] - Lasso style settings
 * @property {string} [lasso.fill='transparent']
 * @property {string} [lasso.stroke='black']
 * @property {number} [lasso.strokeWidth=2]
 * @property {number} [lasso.opacity=0.7]
 * @property {number} [lasso.strokeDasharray]
 * @property {object} [snapIndicator] - Snap indicator settings
 * @property {number} [snapIndicator.threshold=75] - The distance in pixel to show the snap indicator, if less then threshold the indicator is dispalyed
 * @property {string} [snapIndicator.strokeDasharray='5, 5']
 * @property {string} [snapIndicator.stroke='black']
 * @property {number} [snapIndicator.strokeWidth=2]
 * @property {number} [snapIndicator.opacity=0.5]
 * @property {object} [startPoint] - Start point style settings
 * @property {number} [startPoint.r=10] - Circle radius
 * @property {string} [startPoint.stroke='green']
 * @property {number} [startPoint.strokeWidth=1]
 * @property {number} [startPoint.opacity=1]
 * @property {object} [brush]
 * @property {object[]} brush.components - Array of components to brush on.
 * @property {string} [brush.components[].component.key] - Component key
 * @property {string[]} [brush.components[].component.contexts=['brushLasso']] - Name of the brushing contexts to affect
 * @property {string[]} [brush.components[].component.data=['']] - The mapped data properties to add to the brush
 * @property {string} [brush.components[].component.action='add'] - Type of action to respond with
 */


var brushLassoComponent = {
  require: ['chart', 'renderer', 'settings'],
  defaultSettings: {
    layout: {
      displayOrder: 0
    },
    settings: {
      brush: {
        components: []
      },
      snapIndicator: {
        threshold: 75,
        strokeDasharray: '5, 5',
        stroke: 'black',
        strokeWidth: 2,
        opacity: 0.5
      },
      lasso: {
        fill: 'transparent',
        stroke: 'black',
        strokeWidth: 2,
        opacity: 0.7,
        strokeDasharray: '20, 10'
      },
      startPoint: {
        r: 10,
        fill: 'green',
        stroke: 'black',
        strokeWidth: 1,
        opacity: 1
      }
    }
  },
  on: {
    lassoStart: function lassoStart(e) {
      this.start(e);
    },
    lassoEnd: function lassoEnd(e) {
      this.end(e);
    },
    lassoMove: function lassoMove(e) {
      this.move(e);
    },
    lassoCancel: function lassoCancel() {
      this.cancel();
    }
  },
  created: function created() {
    this.state = resetState();
  },
  start: function start(e) {
    this.state.active = true;
    this.state.path = initPath(this.settings.settings.lasso);
    this.state.snapIndicator = initSnapIndicator(this.settings.settings.snapIndicator);
    this.state.startPoint = initStartPoint(this.settings.settings.startPoint);
    this.state.rendererBounds = this.renderer.element().getBoundingClientRect();
    this.state.componentDelta = getComponentDelta(this.chart, this.state.rendererBounds);
    this.state.brushConfig = getBrushConfig(this.settings);
    var p = getPoint(this.state.rendererBounds, e);
    appendToPath(this.state, p);
    setSnapIndictor({
      state: this.state,
      start: p
    });
    setStartPoint(this.state, p);
  },
  move: function move(e) {
    if (!this.state.active) {
      return;
    }

    var p = getPoint(this.state.rendererBounds, e);

    if (withinThreshold(p, this.state, this.settings)) {
      showSnapIndicator(this.state, true);
    } else {
      showSnapIndicator(this.state, false);
    }

    appendToPath(this.state, p);
    setSnapIndictor({
      state: this.state,
      end: p
    });
    render$1(this.state, this.renderer);
    doLineBrush(this.state, this.chart);
  },
  end: function end(e) {
    if (!this.state.active) {
      return;
    }

    showSnapIndicator(this.state, false);
    var p = getPoint(this.state.rendererBounds, e);
    var shouldSnap = withinThreshold(p, this.state, this.settings);

    if (shouldSnap) {
      doPolygonBrush(this.state, this.chart);
    }

    this.state = resetState();
    this.renderer.render([]);
  },
  cancel: function cancel() {
    if (!this.state.active) {
      return;
    }

    endBrush(this.state, this.chart);
    this.state = resetState();
    this.renderer.render([]);
  },
  render: function render() {// Do nothing
  }
};

function lassoBrush(picasso) {
  picasso.component('brush-lasso', brushLassoComponent);
}

/**
 * Using the basic example found here: https://en.wikipedia.org/wiki/Binary_search_algorithm
 *
 * Finds the first node that may intersect the label.
 * @private
 */

function binaryLeftSearch(labelBounds, ary, coord, side, extractBounds) {
  var left = 0;
  var right = ary.length - 1;
  var bounds;

  while (left < right) {
    var m = Math.floor((left + right) / 2);
    bounds = extractBounds(ary[m]);

    if (bounds[coord] + bounds[side] < labelBounds[coord]) {
      // label is on right side
      left = m + 1;
    } else {
      // label is on the left side
      right = m;
    }
  }

  return left;
}
/**
 * The purpose of this module is to act as a filtering function to remove any labels
 * that meets one of the following criterias:
 * -- The label is not fully inside the container, such that it would be fully or partially clipped if rendered
 * -- The label overlaps another label
 * -- The label overlaps another bar which is not the bar the label is originating from
 *
 * Assumes that the nodes are sorted from left/top to right/down, as that allows
 * some optimizations to be performed.
 * @private
 * @returns {function} Filter function, returns false if label be removed and true otherwise
 */

function filterOverlappingLabels$1(_ref) {
  var orientation = _ref.orientation,
      targetNodes = _ref.targetNodes,
      labels = _ref.labels,
      container = _ref.container;
  var findLeft = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : binaryLeftSearch;
  var renderLabels = [];
  var coord = orientation === 'v' ? 'x' : 'y';
  var side = orientation === 'v' ? 'width' : 'height';

  var getTextBounds = function getTextBounds(item) {
    return item.textBounds;
  };

  var getNodeBounds = function getNodeBounds(item) {
    return item.node.localBounds;
  };

  return function (doNotUse, labelIndex) {
    var _labels$labelIndex = labels[labelIndex],
        labelBounds = _labels$labelIndex.textBounds,
        labelNode = _labels$labelIndex.node; // ### Test if label is not fully inside container based on the orientation ###

    if (labelBounds[coord] < container[coord] || labelBounds[coord] + labelBounds[side] > container[coord] + container[side]) {
      return false;
    } // ### Test label to label collision ###


    var leftStartLabel = findLeft(labelBounds, renderLabels, coord, side, getTextBounds);

    for (var i = leftStartLabel; i < renderLabels.length; i++) {
      if (testRectRect(labelBounds, renderLabels[i].textBounds)) {
        return false;
      }
    } // ### Test label to node collision ###


    var leftStartNode = findLeft(labelBounds, targetNodes, coord, side, getNodeBounds);
    var labelRightBoundary = labelBounds[coord] + labelBounds[side];

    for (var _i = leftStartNode; _i < targetNodes.length; _i++) {
      var node = targetNodes[_i].node; // Do not test beyond this node, as they are assumed to not collide with the label

      if (labelRightBoundary < node.localBounds[coord]) {
        break;
      }

      if (testRectRect(labelBounds, node.localBounds) && labelNode !== node) {
        return false;
      }
    } // No collision occured, allow the label to be rendered


    renderLabels.push(labels[labelIndex]);
    return true;
  };
}

var PADDING$1 = 4; // const DOUBLE_PADDING = PADDING * 2;

function cbContext(node, chart) {
  return {
    node: node,
    data: node.data,
    scale: chart.scale,
    formatter: chart.formatter,
    dataset: chart.dataset
  };
}

function isValidText(text) {
  var type = _typeof(text);

  return (type === 'string' || type === 'number') && text !== '';
}

function toBackground(label) {
  return _objectSpread({
    type: 'rect',
    rx: 2,
    ry: 2,
    fill: label.backgroundColor
  }, label.backgroundBounds);
}

function isTextInRect(rect, textMetrics, opts) {
  return opts.rotate ? !(rect.width < textMetrics.height || rect.height < textMetrics.width) : !(rect.width < textMetrics.width || rect.height < textMetrics.height);
}
function placeSegmentInSegment(majorSegmentPosition, majorSegmentSize, minorSegmentSize, align) {
  var majorSegmentCenter = majorSegmentPosition + majorSegmentSize * 0.5;
  var offset = (align - 0.5) * (majorSegmentSize - minorSegmentSize);
  var minorSegmentCenter = majorSegmentCenter + offset;
  var minorSegmentPosition = minorSegmentCenter - minorSegmentSize * 0.5;
  return minorSegmentPosition;
}
function placeTextInRect(rect, text, opts) {
  var label = {
    type: 'text',
    text: text,
    maxWidth: opts.rotate ? rect.height : rect.width,
    x: 0,
    y: rect.y,
    dx: 0,
    dy: 0,
    fill: opts.fill,
    anchor: opts.rotate ? 'end' : 'start',
    baseline: 'central',
    fontSize: "".concat(opts.fontSize, "px"),
    fontFamily: opts.fontFamily
  };
  var textMetrics = opts.textMetrics;

  if (!opts.overflow && !isTextInRect(rect, textMetrics, opts)) {
    return false;
  }

  var baseLineOffset = textMetrics.height * 0.5;

  if (opts.rotate) {
    label.x = placeSegmentInSegment(rect.x, rect.width, textMetrics.height, opts.align) + baseLineOffset;
    label.y = placeSegmentInSegment(rect.y, rect.height, textMetrics.width, opts.justify);
    label.transform = "rotate(-90, ".concat(label.x + label.dx, ", ").concat(label.y + label.dy, ")");
  } else {
    label.x = placeSegmentInSegment(rect.x, rect.width, textMetrics.width, opts.align);
    label.y = placeSegmentInSegment(rect.y, rect.height, textMetrics.height, opts.justify) + baseLineOffset;
  }

  return label;
}

function limitBounds(bounds, view) {
  var minY = Math.max(0, Math.min(bounds.y, view.height));
  var maxY = Math.max(0, Math.min(bounds.y + bounds.height, view.height));
  var minX = Math.max(0, Math.min(bounds.x, view.width));
  var maxX = Math.max(0, Math.min(bounds.x + bounds.width, view.width));
  bounds.x = minX;
  bounds.width = maxX - minX;
  bounds.y = minY;
  bounds.height = maxY - minY;
}

function pad$1(bounds) {
  var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _padding$top = padding.top,
      top = _padding$top === void 0 ? PADDING$1 : _padding$top,
      _padding$bottom = padding.bottom,
      bottom = _padding$bottom === void 0 ? PADDING$1 : _padding$bottom,
      _padding$left = padding.left,
      left = _padding$left === void 0 ? PADDING$1 : _padding$left,
      _padding$right = padding.right,
      right = _padding$right === void 0 ? PADDING$1 : _padding$right;
  bounds.x += left;
  bounds.width -= left + right;
  bounds.y += top;
  bounds.height -= top + bottom;
}

function getBarRect(_ref) {
  var bar = _ref.bar,
      view = _ref.view,
      direction = _ref.direction,
      position = _ref.position,
      _ref$padding = _ref.padding,
      padding = _ref$padding === void 0 ? PADDING$1 : _ref$padding;
  var bounds = {};
  extend(bounds, bar);

  if (!position || position === 'inside') ; else if (direction === 'up' || direction === 'down') {
    var start = Math.max(0, Math.min(bar.y, view.height));
    var end = Math.max(0, Math.min(bar.y + bar.height, view.height));

    if (position === 'outside' && direction === 'up' || position === 'opposite' && direction === 'down') {
      bounds.y = 0;
      bounds.height = start;
    } else if (position === 'outside' && direction === 'down' || position === 'opposite' && direction === 'up') {
      bounds.y = end;
      bounds.height = view.height - end;
    }
  } else {
    var _start = Math.max(0, Math.min(bar.x, view.width));

    var _end = Math.max(0, Math.min(bar.x + bar.width, view.width));

    if (position === 'outside' && direction === 'left' || position === 'opposite' && direction === 'right') {
      bounds.x = 0;
      bounds.width = _start;
    } else if (position === 'outside' && direction === 'right' || position === 'opposite' && direction === 'left') {
      bounds.x = _end;
      bounds.width = view.width - _end;
    }
  }

  limitBounds(bounds, view);
  pad$1(bounds, padding);
  return bounds;
}
function findBestPlacement(_ref2) {
  var direction = _ref2.direction,
      fitsHorizontally = _ref2.fitsHorizontally,
      measured = _ref2.measured,
      node = _ref2.node,
      orientation = _ref2.orientation,
      placementSettings = _ref2.placementSettings,
      rect = _ref2.rect;
  var barRect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getBarRect;
  var largest;
  var bounds;
  var placement;
  var testBounds;
  var p;
  var boundaries = [];

  for (p = 0; p < placementSettings.length; p++) {
    placement = placementSettings[p];
    testBounds = barRect({
      bar: node.localBounds,
      view: rect,
      direction: direction,
      position: placement.position,
      padding: placement.padding
    });
    boundaries.push(testBounds);
    largest = !p || testBounds.height > largest.height ? testBounds : largest;

    if (orientation === 'v' && (fitsHorizontally && testBounds.height >= measured.height || !fitsHorizontally && testBounds.height >= measured.width && testBounds.width >= measured.height)) {
      bounds = testBounds;
      break;
    } else if (orientation === 'h' && testBounds.height >= measured.height && testBounds.width >= measured.width) {
      bounds = testBounds;
      break;
    }
  } // fallback strategy - place the text in the largest rectangle


  if (!bounds) {
    bounds = largest;
    p = boundaries.indexOf(bounds);
  }

  placement = placementSettings[p];
  return {
    bounds: bounds,
    placement: placement
  };
}

function approxTextBounds(label, textMetrics, rotated, rect) {
  var padding = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
  var _padding$top2 = padding.top,
      top = _padding$top2 === void 0 ? PADDING$1 : _padding$top2,
      _padding$bottom2 = padding.bottom,
      bottom = _padding$bottom2 === void 0 ? PADDING$1 : _padding$bottom2,
      _padding$left2 = padding.left,
      left = _padding$left2 === void 0 ? PADDING$1 : _padding$left2,
      _padding$right2 = padding.right,
      right = _padding$right2 === void 0 ? PADDING$1 : _padding$right2;
  var x0 = label.x + label.dx;
  var y0 = label.y + label.dy;
  var height = rotated ? Math.min(textMetrics.width, rect.height) : Math.min(textMetrics.height, rect.width);
  var width = rotated ? Math.min(textMetrics.height, rect.height) : Math.min(textMetrics.width, rect.width);
  var offset = textMetrics.height * 0.5;
  var PADDING_OFFSET = 1e-9; // Needed to support a case when multiple bars are on the same location

  var x = rotated ? x0 - offset : x0;
  var y = rotated ? y0 : y0 - offset;
  var bounds = {
    x: x - left - PADDING_OFFSET,
    y: y - top - PADDING_OFFSET,
    width: width + (left + right) - PADDING_OFFSET,
    height: height + (top + bottom) - PADDING_OFFSET
  };
  return bounds;
}

function placeInBars(_ref3) {
  var chart = _ref3.chart,
      targetNodes = _ref3.targetNodes,
      rect = _ref3.rect,
      fitsHorizontally = _ref3.fitsHorizontally,
      collectiveOrientation = _ref3.collectiveOrientation;
  var findPlacement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : findBestPlacement;
  var placer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : placeTextInRect;
  var postFilter = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : filterOverlappingLabels$1;
  var labels = [];
  var postFilterContext = {
    container: rect,
    targetNodes: targetNodes,
    labels: [],
    orientation: collectiveOrientation
  };
  var label;
  var target;
  var node;
  var text;
  var justify;
  var bounds;
  var fill;
  var measured;
  var direction;
  var lblStngs;
  var placement;
  var placements;
  var arg;
  var orientation;

  for (var i = 0, len = targetNodes.length; i < len; i++) {
    bounds = null;
    target = targetNodes[i];
    node = target.node;
    arg = cbContext(node, chart);
    direction = target.direction;
    orientation = direction === 'left' || direction === 'right' ? 'h' : 'v';

    for (var j = 0; j < target.texts.length; j++) {
      text = target.texts[j];

      if (!isValidText(text)) {
        continue;
      }

      lblStngs = target.labelSettings[j];
      measured = target.measurements[j];
      placements = lblStngs.placements;
      var bestPlacement = findPlacement({
        direction: direction,
        fitsHorizontally: fitsHorizontally,
        lblStngs: lblStngs,
        measured: measured,
        node: node,
        orientation: orientation,
        placements: placements,
        placementSettings: target.placementSettings[j],
        rect: rect
      });
      bounds = bestPlacement.bounds;
      placement = bestPlacement.placement;

      if (bounds && placement) {
        justify = placement.justify;
        fill = typeof placement.fill === 'function' ? placement.fill(arg, i) : placement.fill;
        var linkData = typeof lblStngs.linkData === 'function' ? lblStngs.linkData(arg, i) : undefined;
        var overflow = typeof placement.overflow === 'function' ? placement.overflow(arg, i) : placement.overflow;

        if (direction === 'up') {
          justify = 1 - justify;
        }

        if (placement.position === 'opposite') {
          justify = 1 - justify;
        }

        if (direction === 'left') {
          justify = 1 - justify;
        }

        var isRotated = !(collectiveOrientation === 'h' || fitsHorizontally);
        label = placer(bounds, text, {
          fill: fill,
          justify: orientation === 'h' ? placement.align : justify,
          align: orientation === 'h' ? justify : placement.align,
          fontSize: lblStngs.fontSize,
          fontFamily: lblStngs.fontFamily,
          textMetrics: measured,
          rotate: isRotated,
          overflow: !!overflow
        });

        if (label) {
          if (typeof linkData !== 'undefined') {
            label.data = linkData;
          }

          if (_typeof(placement.background) === 'object') {
            label.backgroundColor = typeof placement.background.fill === 'function' ? placement.background.fill(arg, i) : placement.background.fill;

            if (typeof label.backgroundColor !== 'undefined') {
              label.backgroundBounds = approxTextBounds(label, measured, isRotated, bounds, placement.background.padding);
            }
          }

          labels.push(label);
          postFilterContext.labels.push({
            node: node,
            textBounds: approxTextBounds(label, measured, isRotated, bounds, placement.padding)
          });
        }
      }
    }
  }

  var filteredLabels = labels.filter(postFilter(postFilterContext));
  var backgrounds = filteredLabels.filter(function (lb) {
    return typeof lb.backgroundBounds !== 'undefined';
  }).map(toBackground);
  return [].concat(_toConsumableArray$1(backgrounds), _toConsumableArray$1(filteredLabels));
}
function precalculate(_ref4) {
  var nodes = _ref4.nodes,
      rect = _ref4.rect,
      chart = _ref4.chart,
      labelSettings = _ref4.labelSettings,
      placementSettings = _ref4.placementSettings,
      settings = _ref4.settings,
      renderer = _ref4.renderer;
  var labelStruct = {};
  var targetNodes = [];
  var target;
  var fitsHorizontally = true;
  var hasHorizontalDirection = false;
  var node;
  var text;
  var bounds;
  var measured;
  var lblStng;
  var direction;

  for (var i = 0; i < nodes.length; i++) {
    node = nodes[i];
    bounds = node.localBounds;

    if (!testRectRect(bounds, rect)) {
      continue;
    }

    var arg = cbContext(node, chart);
    target = {
      node: node,
      texts: [],
      measurements: [],
      labelSettings: [],
      placementSettings: [] // direction: 'up'

    };

    for (var j = 0; j < labelSettings.length; j++) {
      lblStng = labelSettings[j];
      text = typeof lblStng.label === 'function' ? lblStng.label(arg, i) : undefined;

      if (!isValidText(text)) {
        continue; // eslint-ignore-line
      }

      direction = typeof settings.direction === 'function' ? settings.direction(arg, i) : settings.direction || 'up';
      hasHorizontalDirection = hasHorizontalDirection || direction === 'left' || direction === 'right';
      labelStruct.fontFamily = lblStng.fontFamily;
      labelStruct.fontSize = "".concat(lblStng.fontSize, "px");
      labelStruct.text = text;
      measured = renderer.measureText(labelStruct);
      target.measurements.push(measured);
      target.texts.push(text);
      target.labelSettings.push(lblStng);
      target.placementSettings.push(placementSettings[j]);
      target.direction = direction;
      fitsHorizontally = fitsHorizontally && measured.width <= bounds.width - PADDING$1 * 2;
    }

    targetNodes.push(target);
  }

  return {
    targetNodes: targetNodes,
    fitsHorizontally: fitsHorizontally,
    hasHorizontalDirection: hasHorizontalDirection
  };
}
/**
 * @typedef {object} component--labels~label-strategy
 *
 */

/**
 * @typedef {object} component--labels~label-strategy.settings
 * @property {string|function} [direction='up'] - The direction in which the bars are growing: 'up', 'down', 'right' or 'left'.
 * @property {string} [fontFamily='Arial']
 * @property {number} [fontSize=12]
 * @property {Array<object>} labels
 * @property {string|function} labels[].label - The text value
 * @property {function} labels[].linkData - Link data to the label
 * @property {Array<object>} labels[].placements
 * @property {string} labels[].placements[].position - 'inside' | 'outside' | 'opposite'
 * @property {number} [labels[].placements[].justify=0] - Placement of the label along the direction of the bar
 * @property {number} [labels[].placements[].align=0.5] - Placement of the label along the perpendicular direction of the bar
 * @property {string} [labels[].placements[].fill='#333'] - Color of the label
 * @property {boolean} [labels[].placements[].overflow=false] - True if the label is allowed to overflow the bar
 * @property {object} labels[].placements[].padding - Padding between the label and the bar
 * @property {number} [labels[].placements[].padding.top=4] - Padding-top between the label and the bar
 * @property {number} [labels[].placements[].padding.bottom=4] - Padding-bottom between the label and the bar
 * @property {number} [labels[].placements[].padding.left=4] - Padding-left between the label and the bar
 * @property {number} [labels[].placements[].padding.right=4] - Padding-right between the label and the bar
 * @property {object} labels[].placements[].background - Background of the label
 * @property {string|function} labels[].placements[].background.fill - Background color of the label
 * @property {object} labels[].placements[].background.padding - Padding between the label and the background
 * @property {number} [labels[].placements[].background.padding.top=4] - Padding-top between the label and the background
 * @property {number} [labels[].placements[].background.padding.bottom=4] - Padding-bottom between the label and the background
 * @property {number} [labels[].placements[].background.padding.left=4] - Padding-left between the label and the background
 * @property {number} [labels[].placements[].background.padding.right=4] - Padding-right between the label and the background
 */

function bars(_ref5) {
  var settings = _ref5.settings,
      chart = _ref5.chart,
      nodes = _ref5.nodes,
      rect = _ref5.rect,
      renderer = _ref5.renderer,
      style = _ref5.style;
  var placer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : placeInBars;
  var defaults = extend({
    fontSize: 12,
    fontFamily: 'Arial',
    align: 0.5,
    justify: 0,
    fill: '#333'
  }, style.label);
  defaults.fontSize = parseInt(defaults.fontSize, 10);
  var labelSettings = settings.labels.map(function (labelSetting) {
    return extend({}, defaults, settings, labelSetting);
  });
  var placementSettings = settings.labels.map(function (labelSetting) {
    return labelSetting.placements.map(function (placement) {
      return extend({}, defaults, settings, labelSetting, placement);
    });
  });

  var _precalculate = precalculate({
    nodes: nodes,
    chart: chart,
    renderer: renderer,
    settings: settings,
    rect: rect,
    labelSettings: labelSettings,
    placementSettings: placementSettings
  }),
      fitsHorizontally = _precalculate.fitsHorizontally,
      hasHorizontalDirection = _precalculate.hasHorizontalDirection,
      targetNodes = _precalculate.targetNodes;

  var coord = hasHorizontalDirection ? 'y' : 'x';
  var side = hasHorizontalDirection ? 'height' : 'width';
  targetNodes.sort(function (a, b) {
    return a.node.localBounds[coord] + a.node.localBounds[side] - (b.node.localBounds[coord] + b.node.localBounds[side]);
  });
  return placer({
    chart: chart,
    targetNodes: targetNodes,
    stngs: settings,
    rect: rect,
    fitsHorizontally: fitsHorizontally,
    collectiveOrientation: hasHorizontalDirection ? 'h' : 'v'
  });
}

function normalize$1(angle) {
  var PI2 = Math.PI * 2;
  return (angle % PI2 + PI2) % PI2; // normalize
}

function pad$2(bounds, padding) {
  bounds.x += padding;
  bounds.width -= padding * 2;
  bounds.y += padding;
  bounds.height -= padding * 2;
}

function getTopLeftBounds(bounds) {
  var x = bounds.x;
  var y = bounds.y - bounds.height / 2;
  return {
    x: x,
    y: y,
    width: bounds.width,
    height: bounds.height
  };
} // assume 0 <= angle < (PI / 2)


function getLineCircleIntersection(radius, offset, angle) {
  var x = offset.x,
      y = offset.y;

  if (x * x + y * y > radius * radius) {
    return null;
  }

  var dx = Math.sin(angle);
  var dy = Math.cos(angle);
  var D = x * dy - y * dx;
  var d = radius * radius - D * D;

  if (d < 0) {
    return null;
  }

  var sqrtD = Math.sqrt(d);
  return {
    x: D * dy + dx * sqrtD,
    y: -(D * dx) + dy * sqrtD
  };
} // assume 0 <= angle < (PI * 2)


function getRectFromCircleIntersection(_ref) {
  var radius = _ref.radius,
      size = _ref.size,
      angle = _ref.angle;
  var width = size.width,
      height = size.height;
  var lineOffset = {
    x: width / 2,
    y: height / 2
  };
  var section = Math.floor(angle / (Math.PI / 2));
  var intersection;
  var offset;

  switch (section) {
    case 0:
      intersection = getLineCircleIntersection(radius, lineOffset, angle);

      if (!intersection) {
        return null;
      }

      intersection.y *= -1;
      offset = {
        x: -width,
        y: 0
      };
      break;

    case 1:
      intersection = getLineCircleIntersection(radius, lineOffset, Math.PI - angle);

      if (!intersection) {
        return null;
      }

      offset = {
        x: -width,
        y: -height
      };
      break;

    case 2:
      intersection = getLineCircleIntersection(radius, lineOffset, angle - Math.PI);

      if (!intersection) {
        return null;
      }

      intersection.x *= -1;
      offset = {
        x: 0,
        y: -height
      };
      break;

    case 3:
      intersection = getLineCircleIntersection(radius, lineOffset, 2 * Math.PI - angle);

      if (!intersection) {
        return null;
      }

      intersection.x *= -1;
      intersection.y *= -1;
      offset = {
        x: 0,
        y: 0
      };
      break;

    default:
      throw new Error('invalid angle');
  }

  var bounds = {
    x: intersection.x + offset.x,
    y: intersection.y + offset.y,
    width: width,
    height: height
  };
  return bounds;
}

function getHorizontalInsideSliceRect(_ref2) {
  var slice = _ref2.slice,
      padding = _ref2.padding,
      measured = _ref2.measured;
  var start = slice.start,
      end = slice.end,
      innerRadius = slice.innerRadius,
      outerRadius = slice.outerRadius;
  var middle = normalize$1((start + end) / 2);
  var size = {
    width: measured.width + padding * 2,
    height: measured.height + padding * 2
  };
  var bounds = getRectFromCircleIntersection({
    radius: outerRadius,
    size: size,
    angle: middle
  });

  if (!bounds) {
    return null;
  }

  bounds.baseline = 'top';
  var startLine = {
    x1: 0,
    y1: 0,
    x2: Math.sin(start) * outerRadius,
    y2: -Math.cos(start) * outerRadius
  };

  if (testRectLine(bounds, startLine)) {
    return null;
  }

  var endLine = {
    x1: 0,
    y1: 0,
    x2: Math.sin(end) * outerRadius,
    y2: -Math.cos(end) * outerRadius
  };

  if (testRectLine(bounds, endLine)) {
    return null;
  }

  var circle = {
    cx: 0,
    cy: 0,
    r: innerRadius
  };

  if (testCircleRect(circle, bounds)) {
    return null;
  }

  pad$2(bounds, padding);
  return bounds;
} // TODO: this case can support a justify setting


function getRotatedInsideSliceRect(_ref3) {
  var slice = _ref3.slice,
      measured = _ref3.measured,
      padding = _ref3.padding;
  var start = slice.start,
      end = slice.end,
      innerRadius = slice.innerRadius,
      outerRadius = slice.outerRadius;
  var maxWidth = outerRadius - innerRadius - padding * 2;
  var size = end - start;

  if (size < Math.PI) {
    var x = (measured.height / 2 + padding) / Math.tan(size / 2);

    if (x > innerRadius) {
      maxWidth = outerRadius - x - padding * 2;
    }
  }

  if (maxWidth < 0) {
    return null;
  }

  var middle = normalize$1((start + end) / 2);
  var r = outerRadius - padding;
  var bounds = {
    x: Math.sin(middle) * r,
    y: -Math.cos(middle) * r,
    width: maxWidth,
    height: measured.height
  };

  if (middle < Math.PI) {
    bounds.angle = middle - Math.PI / 2;
    bounds.anchor = 'end';
  } else {
    bounds.angle = middle + Math.PI / 2;
    bounds.anchor = 'start';
  }

  return bounds;
}

function getRotatedOusideSliceRect(_ref4) {
  var slice = _ref4.slice,
      measured = _ref4.measured,
      padding = _ref4.padding,
      view = _ref4.view;
  var start = slice.start,
      end = slice.end,
      outerRadius = slice.outerRadius,
      offset = slice.offset;
  var r = outerRadius + padding;
  var size = end - start;

  if (size < Math.PI) {
    var minR = (measured.height / 2 + padding) / Math.tan(size / 2);

    if (minR > r) {
      return null;
    }
  }

  var middle = normalize$1((start + end) / 2);
  var x = Math.sin(middle) * r;
  var y = -Math.cos(middle) * r;
  var maxWidth = measured.width;
  var v = middle % Math.PI;

  if (v > Math.PI / 2) {
    v = Math.PI - v;
  }

  if (Math.cos(v) > 0.001) {
    var edge = y < 0 ? view.y : view.y + view.height;
    var d = Math.abs(edge - offset.y);
    var w = d / Math.cos(v) - Math.tan(v) * (measured.height / 2) - padding * 2 - outerRadius;

    if (w < maxWidth) {
      maxWidth = w;
    }
  }

  if (Math.sin(v) > 0.001) {
    var _edge = x < 0 ? view.x : view.x + view.width;

    var _d = Math.abs(_edge - offset.x);

    var _w = _d / Math.sin(v) - measured.height / 2 / Math.tan(v) - padding * 2 - outerRadius;

    if (_w < maxWidth) {
      maxWidth = _w;
    }
  }

  if (maxWidth <= 0) {
    return 0;
  }

  var bounds = {
    x: x,
    y: y,
    width: maxWidth,
    height: measured.height
  };

  if (middle < Math.PI) {
    bounds.angle = middle - Math.PI / 2;
    bounds.anchor = 'start';
  } else {
    bounds.angle = middle + Math.PI / 2;
    bounds.anchor = 'end';
  }

  return bounds;
}

function outOfSpace(context, section, view) {
  switch (section) {
    case 0:
      return context.q1maxY < 0;

    case 1:
      return context.q2minY > view.height;

    case 2:
      return context.q3minY > view.height;

    case 3:
      return context.q4maxY < 0;

    default:
      return true;
  }
}

function adjustBounds(bounds, context, slice) {
  var LINE_PADDING = 2;
  var LIMIT = 1;
  var start = slice.start,
      end = slice.end,
      offset = slice.offset,
      outerRadius = slice.outerRadius;
  var middle = normalize$1((start + end) / 2);
  var section = Math.floor(middle / (Math.PI / 2));

  switch (section) {
    case 0:
      if (context.q1maxY !== undefined) {
        var y = Math.min(bounds.y, context.q1maxY - bounds.height);
        var dy = bounds.y - y;
        bounds.y = y;

        if (dy > LIMIT) {
          var r = outerRadius + LINE_PADDING;
          bounds.line = {
            type: 'line',
            x1: bounds.x - LINE_PADDING,
            y1: bounds.y + LINE_PADDING,
            x2: offset.x + Math.sin(middle) * r,
            y2: offset.y - Math.cos(middle) * r,
            strokeWidth: 1
          };
        }
      }

      break;

    case 1:
      if (context.q2minY !== undefined) {
        var _y = Math.max(bounds.y, context.q2minY);

        var _dy = _y - bounds.y;

        bounds.y = _y;

        if (_dy > LIMIT) {
          var _r = outerRadius + LINE_PADDING;

          bounds.line = {
            type: 'line',
            x1: bounds.x - LINE_PADDING,
            y1: bounds.y - LINE_PADDING,
            x2: offset.x + Math.sin(middle) * _r,
            y2: offset.y - Math.cos(middle) * _r,
            strokeWidth: 1
          };
        }
      }

      break;

    case 2:
      if (context.q3minY !== undefined) {
        var _y2 = Math.max(bounds.y, context.q3minY);

        var _dy2 = _y2 - bounds.y;

        bounds.y = _y2;

        if (_dy2 > LIMIT) {
          var _r2 = outerRadius + LINE_PADDING;

          bounds.line = {
            type: 'line',
            x1: bounds.x + LINE_PADDING,
            y1: bounds.y - LINE_PADDING,
            x2: offset.x + Math.sin(middle) * _r2,
            y2: offset.y - Math.cos(middle) * _r2,
            strokeWidth: 1
          };
        }
      }

      break;

    case 3:
      if (context.q4maxY !== undefined) {
        var _y3 = Math.min(bounds.y, context.q4maxY - bounds.height);

        var _dy3 = bounds.y - _y3;

        bounds.y = _y3;

        if (_dy3 > LIMIT) {
          var _r3 = outerRadius + LINE_PADDING;

          bounds.line = {
            type: 'line',
            x1: bounds.x + LINE_PADDING,
            y1: bounds.y + LINE_PADDING,
            x2: offset.x + Math.sin(middle) * _r3,
            y2: offset.y - Math.cos(middle) * _r3,
            strokeWidth: 1
          };
        }
      }

      break;

    default:
      break;
  }
}

function updateContext(_ref5) {
  var context = _ref5.context,
      node = _ref5.node,
      bounds = _ref5.bounds;
  var PADDING = 2;
  var _node$desc$slice = node.desc.slice,
      start = _node$desc$slice.start,
      end = _node$desc$slice.end;
  var middle = normalize$1((start + end) / 2);
  var section = Math.floor(middle / (Math.PI / 2));

  switch (section) {
    case 0:
      context.q1maxY = bounds.y - PADDING;

      if (context.q2minY === undefined) {
        context.q2minY = bounds.y + bounds.height + PADDING;
      }

      break;

    case 1:
      context.q2minY = bounds.y + bounds.height + PADDING;
      break;

    case 2:
      context.q3minY = bounds.y + bounds.height + PADDING;
      break;

    case 3:
      context.q4maxY = bounds.y - PADDING;

      if (context.q3minY === undefined) {
        context.q3minY = bounds.y + bounds.height + PADDING;
      }

      break;

    default:
      break;
  }
}

function getHorizontalOusideSliceRect(_ref6) {
  var slice = _ref6.slice,
      measured = _ref6.measured,
      padding = _ref6.padding,
      view = _ref6.view,
      context = _ref6.context;
  var start = slice.start,
      end = slice.end,
      outerRadius = slice.outerRadius,
      offset = slice.offset;
  var middle = normalize$1((start + end) / 2);
  var section = Math.floor(middle / (Math.PI / 2));

  if (outOfSpace(context, section, view)) {
    return null;
  }

  var r = outerRadius + padding + measured.height / 2;
  var x = Math.sin(middle) * r;
  var y = -Math.cos(middle) * r;
  var maxWidth = measured.width;

  if (middle < Math.PI) {
    var w = Math.abs(view.x + view.width - (x + offset.x));

    if (w < maxWidth) {
      maxWidth = w;
    }
  } else {
    var _w2 = Math.abs(view.x - (x + offset.x));

    if (_w2 < maxWidth) {
      maxWidth = _w2;
    }
  }

  var bounds = {
    x: x,
    y: y,
    width: maxWidth,
    height: measured.height
  };

  if (middle < Math.PI) {
    bounds.anchor = 'start';
  } else {
    bounds.anchor = 'end';
  }

  return bounds;
}

function cbContext$1(node, chart) {
  return {
    node: node,
    data: node.data,
    scale: chart.scale,
    formatter: chart.formatter,
    dataset: chart.dataset
  };
}

function placeTextOnPoint(rect, text, opts) {
  var label = {
    type: 'text',
    text: text,
    maxWidth: rect.width,
    x: rect.x,
    y: rect.y + (rect.baseline === 'top' ? rect.height / 2 : 0),
    fill: opts.fill,
    anchor: rect.anchor || 'start',
    baseline: 'middle',
    fontSize: "".concat(opts.fontSize, "px"),
    fontFamily: opts.fontFamily
  };

  if (!isNaN(rect.angle)) {
    var angle = rect.angle * (360 / (Math.PI * 2));
    label.transform = "rotate(".concat(angle, ", ").concat(label.x, ", ").concat(label.y, ")");
  }

  return label;
}

function getSliceRect(_ref7) {
  var slice = _ref7.slice,
      direction = _ref7.direction,
      position = _ref7.position,
      padding = _ref7.padding,
      measured = _ref7.measured,
      view = _ref7.view,
      context = _ref7.context;
  var start = slice.start,
      end = slice.end,
      innerRadius = slice.innerRadius,
      offset = slice.offset;
  var bounds;
  var s;

  switch (position) {
    case 'into':
      if (direction === 'rotate') {
        bounds = getRotatedInsideSliceRect({
          slice: slice,
          measured: measured,
          padding: padding
        });
      } else {
        bounds = getHorizontalInsideSliceRect({
          slice: slice,
          measured: measured,
          padding: padding
        });
      }

      break;

    case 'inside':
      s = {
        start: start,
        end: end,
        innerRadius: 0,
        outerRadius: innerRadius
      };

      if (direction === 'rotate') {
        bounds = getRotatedInsideSliceRect({
          slice: s,
          measured: measured,
          padding: padding
        });
      } else {
        bounds = getHorizontalInsideSliceRect({
          slice: s,
          measured: measured,
          padding: padding
        });
      }

      break;

    case 'outside':
      if (direction === 'rotate') {
        bounds = getRotatedOusideSliceRect({
          slice: slice,
          measured: measured,
          padding: padding,
          view: view
        });
      } else {
        bounds = getHorizontalOusideSliceRect({
          slice: slice,
          measured: measured,
          padding: padding,
          view: view,
          context: context
        });
      }

      break;

    default:
      throw new Error('not implemented');
  }

  if (bounds) {
    bounds.x += offset.x;
    bounds.y += offset.y;

    if (position === 'outside' && direction !== 'rotate') {
      adjustBounds(bounds, context, slice);
    }
  }

  return bounds;
}

function findBestPlacement$1(_ref8) {
  var context = _ref8.context,
      direction = _ref8.direction,
      measured = _ref8.measured,
      node = _ref8.node,
      placementSettings = _ref8.placementSettings,
      rect = _ref8.rect;
  var sliceRect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getSliceRect;

  for (var p = 0; p < placementSettings.length; p++) {
    var placement = placementSettings[p];
    var bounds = sliceRect({
      context: context,
      slice: node.desc.slice,
      view: rect,
      direction: direction,
      position: placement.position,
      measured: measured,
      padding: placement.padding
    });

    if (!bounds) {
      continue;
    }

    return {
      bounds: bounds,
      placement: placement
    };
  }

  return {
    bounds: null,
    placement: null
  };
}
/*
 * Sorts the nodes so that
 *   in each quarter sort nodes from the center (in y) outwards
 *   first quarter before the second
 *   forth quarter before the third
 */


function sortNodes(nodes) {
  var q1 = [];
  var q2 = [];
  var q3 = [];
  var q4 = [];

  for (var i = 0; i < nodes.length; ++i) {
    var _nodes$i$desc$slice = nodes[i].desc.slice,
        start = _nodes$i$desc$slice.start,
        end = _nodes$i$desc$slice.end;
    var middle = normalize$1((start + end) / 2);
    var section = Math.floor(middle / (Math.PI / 2));

    switch (section) {
      case 0:
        q1.push(nodes[i]);
        break;

      case 1:
        q2.push(nodes[i]);
        break;

      case 2:
        q3.push(nodes[i]);
        break;

      case 3:
        q4.push(nodes[i]);
        break;

      default:
        break;
    }
  }

  var sortFn = function sortFn(a, b) {
    var middleA = normalize$1((a.desc.slice.start + a.desc.slice.end) / 2);
    var middleB = normalize$1((b.desc.slice.start + b.desc.slice.end) / 2);
    return middleA - middleB;
  };

  var reverseSortFn = function reverseSortFn(a, b) {
    return sortFn(b, a);
  };

  q1.sort(reverseSortFn);
  q2.sort(sortFn);
  q3.sort(reverseSortFn);
  q4.sort(sortFn);
  return q1.concat(q2, q4, q3);
}
/**
 * @typedef {object} component--labels~slices-label-strategy
 *
 */

/**
 * @typedef {object} component--labels~slices-label-strategy.settings
 * @property {string|function} [direction='horizontal'] - The direction of the text: 'horizontal' or 'rotate'.
 * @property {string} [fontFamily='Arial']
 * @property {number} [fontSize=12]
 * @property {Array<object>} labels
 * @property {string|function} labels[].label - The text value
 * @property {function} labels[].linkData - Link data to the label
 * @property {Array<object>} labels[].placements
 * @property {string} [labels[].placements[].position='into'] - 'inside' | 'into' | 'outside' (outside is not implmented yet)
 * @property {string} [labels[].placements[].fill='#333'] - Color of the label
 */


function slices(_ref9) {
  var settings = _ref9.settings,
      chart = _ref9.chart,
      nodes = _ref9.nodes,
      rect = _ref9.rect,
      renderer = _ref9.renderer,
      style = _ref9.style;
  var findPlacement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : findBestPlacement$1;
  var placer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : placeTextOnPoint;
  var defaults = extend({
    fontSize: 12,
    fontFamily: 'Arial',
    fill: '#333',
    padding: 4,
    position: 'into'
  }, style.label);
  defaults.fontSize = parseInt(defaults.fontSize, 10);
  var labelSettings = settings.labels.map(function (labelSetting) {
    return extend({}, defaults, settings, labelSetting);
  });
  var placementSettings = settings.labels.map(function (labelSetting) {
    return labelSetting.placements.map(function (placement) {
      return extend({}, defaults, settings, labelSetting, placement);
    });
  });
  var labelStruct = {};
  var labels = [];
  nodes = sortNodes(nodes);
  var context = {};

  for (var i = 0, len = nodes.length; i < len; i++) {
    var node = nodes[i];
    var arg = cbContext$1(node, chart);

    for (var j = 0; j < labelSettings.length; j++) {
      var lblStngs = labelSettings[j];
      var text = typeof lblStngs.label === 'function' ? lblStngs.label(arg, i) : '';

      if (!text) {
        continue;
      }

      var direction = typeof lblStngs.direction === 'function' ? lblStngs.direction(arg, i) : lblStngs.direction || 'horizontal';
      var linkData = typeof lblStngs.linkData === 'function' ? lblStngs.linkData(arg, i) : undefined;
      labelStruct.fontFamily = lblStngs.fontFamily;
      labelStruct.fontSize = "".concat(lblStngs.fontSize, "px");
      labelStruct.text = text;
      var measured = renderer.measureText(labelStruct);
      var bestPlacement = findPlacement({
        context: context,
        direction: direction,
        lblStngs: lblStngs,
        measured: measured,
        node: node,
        placementSettings: placementSettings[j],
        rect: rect
      });
      var bounds = bestPlacement.bounds;
      var placement = bestPlacement.placement;

      if (bounds && placement) {
        if (placement.position === 'outside' && direction !== 'rotate') {
          updateContext({
            context: context,
            node: node,
            bounds: bounds
          });
          var topLeftBounds = getTopLeftBounds(bounds);

          if (!rectContainsRect(topLeftBounds, rect)) {
            continue;
          }
        }

        var fill = typeof placement.fill === 'function' ? placement.fill(arg, i) : placement.fill;
        var label = placer(bounds, text, {
          fill: fill,
          fontSize: lblStngs.fontSize,
          fontFamily: lblStngs.fontFamily,
          textMetrics: measured
        });

        if (label) {
          if (typeof linkData !== 'undefined') {
            label.data = linkData;
          }

          labels.push(label);

          if (bounds.line) {
            bounds.line.stroke = fill;
            labels.push(bounds.line);
          }
        }
      }
    }
  }

  return labels;
}

var LINE_HEIGHT = 1.2;
var CIRCLE_FACTOR = 0.9;

function cbContext$2(node, chart) {
  return {
    node: node,
    data: node.data,
    scale: chart.scale,
    formatter: chart.formatter,
    dataset: chart.dataset
  };
}

function placeTextInRect$1(rect, text, opts) {
  var label = {
    type: 'text',
    text: text,
    maxWidth: rect.width,
    x: 0,
    y: rect.y,
    dx: 0,
    dy: 0,
    fill: opts.fill,
    anchor: 'start',
    baseline: 'alphabetical',
    fontSize: "".concat(opts.fontSize, "px"),
    fontFamily: opts.fontFamily
  };
  var textMetrics = opts.textMetrics;

  if (rect.width < opts.fontSize) {
    return false;
  }

  var wiggleWidth = Math.max(0, rect.width - textMetrics.width);
  label.x = rect.x + opts.align * wiggleWidth;
  label.y = rect.y + textMetrics.height / LINE_HEIGHT;
  return label;
}

function getRectFromCircle(_ref) {
  var cx = _ref.cx,
      cy = _ref.cy,
      r = _ref.r;
  return {
    type: 'circle',
    bounds: {
      cx: cx,
      cy: cy,
      r: r
    }
  };
}

function getSliceBounds(slice) {
  var EPSILON = 1e-12;
  var start = slice.start,
      end = slice.end,
      innerRadius = slice.innerRadius,
      outerRadius = slice.outerRadius,
      offset = slice.offset;

  if (Math.abs(start + 2 * Math.PI - end) > EPSILON) {
    return {
      type: null,
      bounds: null
    };
  }

  var r = innerRadius !== 0 ? innerRadius : outerRadius;
  return getRectFromCircle({
    cx: offset.x,
    cy: offset.y,
    r: r
  });
}

function getBounds(node) {
  if (node.desc && node.desc.slice) {
    return getSliceBounds(node.desc.slice);
  }

  if (node.type === 'circle') {
    return getRectFromCircle(node.attrs);
  }

  if (node.type === 'rect') {
    return {
      type: 'rect',
      bounds: node.bounds
    };
  } // defualt to node.bounds ?


  return {
    type: null,
    bounds: null
  };
}
/**
 * @typedef {object} component--labels~rows-label-strategy
 *
 */

/**
 * @typedef {object} component--labels~rows-label-strategy.settings
 * @property {string} [fontFamily='Arial']
 * @property {number} [fontSize=12]
 * @property {number} [justify=0.5]
 * @property {number} [padding=4]
 * @property {Array<object>} labels
 * @property {string|function} labels[].label - The text value
 * @property {function} labels[].linkData - Link data to the label
 * @property {number} [labels[].align=0.5]
 * @property {string|function} [labels[].fill='#333']
 */


function rows(_ref2) {
  var settings = _ref2.settings,
      chart = _ref2.chart,
      nodes = _ref2.nodes,
      renderer = _ref2.renderer,
      style = _ref2.style;
  var placer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : placeTextInRect$1;
  var defaults = extend({
    fontSize: 12,
    fontFamily: 'Arial',
    fill: '#333',
    padding: 4,
    align: 0.5,
    justify: 0.5
  }, style.label);
  defaults.fontSize = parseInt(defaults.fontSize, 10);
  var rowSettings = extend({}, defaults, settings);
  var labelSettings = settings.labels.map(function (labelSetting) {
    return extend({}, rowSettings, labelSetting);
  });
  var labelStruct = {};
  var labels = [];

  for (var i = 0, len = nodes.length; i < len; i++) {
    var node = nodes[i];
    var arg = cbContext$2(node, chart);

    var _getBounds = getBounds(node),
        type = _getBounds.type,
        bounds = _getBounds.bounds;

    if (!bounds) {
      continue;
    }

    var totalHeight = 0;
    var measurements = [];
    var texts = [];
    var maxHeight = type === 'circle' ? 2 * bounds.r * CIRCLE_FACTOR : bounds.height;
    totalHeight += rowSettings.padding;
    var j = void 0;

    for (j = 0; j < labelSettings.length; j++) {
      var lblStngs = labelSettings[j];
      var text = typeof lblStngs.label === 'function' ? lblStngs.label(arg, i) : '';
      labelStruct.fontFamily = lblStngs.fontFamily;
      labelStruct.fontSize = "".concat(lblStngs.fontSize, "px");
      labelStruct.text = text;
      var measured = renderer.measureText(labelStruct);
      totalHeight += measured.height + lblStngs.padding;

      if (totalHeight > maxHeight) {
        break;
      }

      texts.push(text);
      measurements.push(measured);
    }

    var labelCount = j;
    var wiggleHeight = Math.max(0, maxHeight - totalHeight);
    var currentY = void 0;

    if (type === 'circle') {
      currentY = bounds.cy - bounds.r * CIRCLE_FACTOR;
    } else {
      currentY = bounds.y;
    }

    currentY += rowSettings.justify * wiggleHeight + rowSettings.padding;

    for (j = 0; j < labelCount; j++) {
      var _lblStngs = labelSettings[j];
      var rect = void 0;

      if (type === 'circle') {
        var maxYDistToCenter = Math.max(Math.abs(currentY - bounds.cy), Math.abs(currentY + measurements[j].height - bounds.cy));
        var halfWidth = Math.sqrt(bounds.r * bounds.r - maxYDistToCenter * maxYDistToCenter);
        rect = {
          x: bounds.cx - halfWidth + rowSettings.padding,
          y: currentY,
          width: 2 * halfWidth - 2 * rowSettings.padding,
          height: measurements[j].height
        };
      } else {
        rect = {
          x: bounds.x + rowSettings.padding,
          y: currentY,
          width: bounds.width - 2 * rowSettings.padding,
          height: measurements[j].height
        };
      }

      currentY += measurements[j].height + rowSettings.padding;
      var fill = typeof _lblStngs.fill === 'function' ? _lblStngs.fill(arg, i) : _lblStngs.fill;
      var linkData = typeof _lblStngs.linkData === 'function' ? _lblStngs.linkData(arg, i) : undefined;
      var label = placer(rect, texts[j], {
        fill: fill,
        align: _lblStngs.align,
        fontSize: _lblStngs.fontSize,
        fontFamily: _lblStngs.fontFamily,
        textMetrics: measurements[j]
      });

      if (label) {
        if (typeof linkData !== 'undefined') {
          label.data = linkData;
        }

        labels.push(label);
      }
    }
  }

  return labels;
}

var strategies = {
  bar: bars,
  slice: slices,
  rows: rows
};

/**
 * @typedef {object} component--labels
 * @property {string} [type='labels']
 */

/**
 * @typedef {object} component--labels.settings
 * @property {Array<object>} sources
 * @property {string} sources[].component
 * @property {string} sources[].selector
 * @property {component--labels~label-strategy} sources[].strategy
 */

function strategy(_ref, fn) {
  var chart = _ref.chart,
      source = _ref.source,
      rect = _ref.rect,
      renderer = _ref.renderer,
      style = _ref.style;
  var component = chart.component(source.component);

  if (!component) {
    return [];
  }

  var nodes = chart.findShapes(source.selector).filter(function (n) {
    return n.key === source.component;
  });
  return fn({
    chart: chart,
    settings: source.strategy.settings,
    nodes: nodes,
    rect: {
      x: 0,
      y: 0,
      width: rect.width,
      height: rect.height
    },
    renderer: renderer,
    style: style
  });
}
var labelsComponent = {
  require: ['chart', 'renderer', 'settings'],
  defaultSettings: {
    settings: {},
    style: {
      label: '$label'
    }
  },
  render: function render() {
    var _this = this;

    var stngs = this.settings.settings;
    var labels = [];
    (stngs.sources || []).forEach(function (source) {
      if (source.strategy && strategies[source.strategy.type] && source.component) {
        labels.push.apply(labels, _toConsumableArray$1(strategy({
          chart: _this.chart,
          rect: _this.rect,
          renderer: _this.renderer,
          source: source,
          style: _this.style
        }, strategies[source.strategy.type])));
      }
    });
    return labels;
  }
};

function labels(picasso) {
  picasso.component('labels', labelsComponent);
}

/**
 * @typedef {object}
 * @alias component--legend-cat.settings
 */

var DEFAULT_SETTINGS$6 = {
  /**
   * @typedef {object=}
   */
  layout: {
    /**
     * Maximum number of columns (vertical) or rows (horizontal)
     * @type {number=}
     */
    size: 1,

    /**
     * Layout direction. Either `'ltr'` or `'rtl'`
     * @type {string=}
     */
    direction: 'ltr',

    /** Initial scroll offset
     * @type {number=} */
    scrollOffset: 0
  },

  /**
   * Settings applied per item
   * @typedef {object=}
   */
  item: {
    /** Whether to show the current item
     * @type {boolean=} */
    show: true,
    justify: 0.5,
    align: 0.5,

    /**
     * @typedef {object=} */
    label: {
      fontSize: '12px',
      fontFamily: 'Arial',
      fill: '#595959',

      /** Word break rule, how to apply line break if label text overflows its maxWidth property. Either `'break-word'` or `'break-all'`
       * @type {string=} */
      wordBreak: 'none',

      /** Max number of lines allowed if label is broken into multiple lines (only applicable with wordBreak)
       * @type {number=} */
      maxLines: 2,

      /** Maximum width of label, in px
       * @type {number=} */
      maxWidth: 136,
      lineHeight: 1.2
    },

    /**
     * @typedef {object=} */
    shape: {
      /**
       * @type {string=} */
      type: 'square',

      /**
       * @type {number=} */
      size: 12
    }
  },

  /**
   * @typedef {object=} */
  title: {
    /** Whether to show the title
     * @type {boolean=} */
    show: true,

    /** Title text. Defaults to the title of the provided data field
     * @type {string=} */
    text: undefined,

    /** Horizontal alignment of the text. Allowed values are `'start'`, `'middle'` and `'end'`
     * @type {string}
     */
    anchor: 'start',
    fontSize: '16px',
    fontFamily: 'Arial',
    fill: '#595959',

    /** Word break rule, how to apply line break if label text overflows its maxWidth property. Either `'break-word'` or `'break-all'`
     * @type {string=} */
    wordBreak: 'none',

    /** Max number of lines allowed if label is broken into multiple lines, is only appled when `wordBreak` is not set to `'none'`
     * @type {number=} */
    maxLines: 2,

    /** Maximum width of title, in px
     * @type {number=} */
    maxWidth: 156,
    lineHeight: 1.25
  },

  /**
   * @typedef {object=} */
  navigation: {
    /**
     * @typedef {object=} */
    button: {
      /**
       * @type {object<string, boolean>=} */
      class: undefined,

      /**
       * @type {function} */
      content: undefined
    },

    /** Whether the button should be disabled or not
     * @type {boolean=} */
    disabled: false
  }
};
/**
 * Resolve settings based on input, defaults, and data
 *
 * @ignore
 * @param {legendComponent} comp - The component instance
 */

function resolveSettings$2(comp) {
  var domain = comp.scale.domain();
  var data = {
    items: []
  };
  var dock = comp.settings.layout.dock;

  if (comp.scale.type === 'threshold-color') {
    var fields = comp.scale.data().fields;
    var sourceField = fields[0];

    var formatter = function formatter(v) {
      return String(v);
    };

    if (comp.settings.formatter) {
      formatter = comp.chart.formatter(comp.settings.formatter);
    } else if (sourceField) {
      formatter = sourceField.formatter();
    }

    for (var i = 0; i < domain.length - 1; i++) {
      var it = {
        value: domain[i],
        label: "".concat(formatter(domain[i]), " - < ").concat(formatter(domain[i + 1]))
      };

      if (sourceField) {
        it.source = {
          field: sourceField.id()
        };
      }

      data.items.push(it);
    }

    var orientation = dock === 'top' || dock === 'bottom' ? 'horizontal' : 'vertical';

    if (orientation === 'vertical') {
      data.items.reverse();
    }
  } else {
    var _labels = comp.scale.labels ? comp.scale.labels() : null;

    data.items = domain.map(function (d, idx) {
      var datum = comp.scale.datum ? extend({}, comp.scale.datum(d)) : {
        value: d
      };
      datum.value = d;

      if (comp.scale.label) {
        datum.label = comp.scale.label(d);
      } else if (_labels) {
        datum.label = _labels[idx];
      }

      return datum;
    });
  }

  var title = comp.resolver.resolve({
    data: {
      fields: comp.scale.data().fields
    },
    defaults: extend(true, {}, DEFAULT_SETTINGS$6.title, comp.style.title),
    settings: comp.settings.settings.title
  });
  var layout = comp.resolver.resolve({
    data: {
      fields: comp.scale.data().fields
    },
    defaults: DEFAULT_SETTINGS$6.layout,
    settings: comp.settings.settings.layout
  });
  var labels = comp.resolver.resolve({
    data: data,
    defaults: extend(true, {}, DEFAULT_SETTINGS$6.item.label, comp.style.item.label),
    settings: (comp.settings.settings.item || {}).label
  });
  var shapeSettings = extend(true, {}, (comp.settings.settings.item || {}).shape);

  if (typeof shapeSettings.fill === 'undefined' && comp.settings.scale) {
    shapeSettings.fill = {
      scale: comp.settings.scale
    };
  }

  var symbols = comp.resolver.resolve({
    data: data,
    defaults: extend(true, {}, DEFAULT_SETTINGS$6.item.shape, comp.style.item.shape),
    settings: shapeSettings
  });
  var items = comp.resolver.resolve({
    data: data,
    defaults: extend(true, {}, {
      show: DEFAULT_SETTINGS$6.item.show
    }),
    settings: {
      show: (comp.settings.settings.item || {}).show
    }
  });

  function range(item, i) {
    var v = item.data.value;
    var next = domain[i + 1];
    item.data.value = [v, next];
  }

  if (comp.scale.type === 'threshold-color') {
    var _orientation = dock === 'top' || dock === 'bottom' ? 'horizontal' : 'vertical';

    if (_orientation === 'vertical') {
      items.items.reverse().forEach(range);
      items.items.reverse();
    } else {
      items.items.forEach(range);
    }
  }

  return {
    title: title,
    labels: labels,
    symbols: symbols,
    items: items,
    layout: layout
  };
}

/* eslint no-mixed-operators:0 */

function placeTextInRect$2(rect, label, opts) {
  var textMetrics = opts.textMetrics;

  if (rect.height < textMetrics.height) {
    return false;
  }

  var wiggleWidth = Math.max(0, rect.width - textMetrics.width);
  label.baseline = 'text-before-edge';
  var wiggleHeight = Math.max(0, rect.height - textMetrics.height);
  label.x = rect.x + opts.align * wiggleWidth;
  label.y = rect.y + opts.justify * wiggleHeight + parseInt(label.fontSize, 10) * 0.175; // 0.175 - basline offset

  return label;
}

function wiggleSymbol(container, size, opts) {
  var wiggleWidth = Math.max(0, container.width - size);
  var wiggleHeight = Math.max(0, container.height - size);
  return {
    x: container.x + size / 2 + opts.align * wiggleWidth,
    y: container.y + size / 2 + opts.justify * wiggleHeight
  };
}

function createRenderItem(_ref) {
  var _ref$x = _ref.x,
      x = _ref$x === void 0 ? 0 : _ref$x,
      y = _ref.y,
      item = _ref.item,
      globalMetrics = _ref.globalMetrics,
      _ref$symbolFn = _ref.symbolFn,
      symbolFn = _ref$symbolFn === void 0 ? create$3 : _ref$symbolFn,
      _ref$direction = _ref.direction,
      direction = _ref$direction === void 0 ? 'ltr' : _ref$direction;
  var label = item.label.displayObject;
  var labelBounds = item.label.bounds;
  var symbolItem = item.symbol.meta;
  var rtl = direction === 'rtl';
  var labelRect = {
    x: rtl ? x + globalMetrics.maxLabelBounds.width : x + globalMetrics.maxSymbolSize + globalMetrics.spacing,
    y: y,
    width: globalMetrics.maxLabelBounds.width,
    height: Math.max(globalMetrics.maxSymbolSize, globalMetrics.maxLabelBounds.height)
  };
  var wiggled = wiggleSymbol({
    x: rtl ? x + globalMetrics.maxLabelBounds.width + globalMetrics.spacing : x,
    y: y,
    width: globalMetrics.maxSymbolSize,
    height: labelRect.height
  }, symbolItem.size, {
    align: typeof symbolItem.align === 'undefined' ? 0.5 : symbolItem.align,
    justify: typeof symbolItem.justify === 'undefined' ? 0.5 : symbolItem.justify
  });
  var symbol = symbolFn(extend({}, symbolItem, wiggled));
  delete symbol.collider;
  label.anchor = rtl ? 'end' : 'start';
  placeTextInRect$2(labelRect, label, {
    textMetrics: labelBounds,
    fontSize: parseInt(label.fontSize, 10),
    align: 0.0,
    justify: 0.5
  });
  var container = {
    type: 'container',
    data: item.label.displayObject.data,
    children: [symbol, label],
    collider: {
      type: 'rect',
      x: x,
      y: y,
      width: globalMetrics.maxItemBounds.width,
      height: globalMetrics.maxItemBounds.height
    }
  };
  return {
    item: container,
    metrics: labelRect
  };
}

function _getItemsToRender(_ref2, rect, _ref3) {
  var viewRect = _ref2.viewRect;
  var itemized = _ref3.itemized,
      _ref3$create = _ref3.create,
      create = _ref3$create === void 0 ? createRenderItem : _ref3$create,
      parallels = _ref3.parallels;
  var direction = itemized.layout.direction;
  var globalMetrics = itemized.globalMetrics;
  var legendItems = itemized.items;
  var isHorizontal = itemized.layout.orientation === 'horizontal';
  var s = 0;
  var renderItems = [];
  var fixedHeight = globalMetrics.maxItemBounds.height;
  var fixedWidth = globalMetrics.maxItemBounds.width;
  var rowHeight = itemized.layout.margin.vertical + fixedHeight;
  var columnWidth = itemized.layout.margin.horizontal + fixedWidth;
  var x = rect.x;
  var y = rect.y;
  var shift = viewRect.x - rect.x;

  for (var i = 0; i < legendItems.length; i++) {
    var renderItem = create({
      y: y,
      x: direction === 'rtl' ? viewRect.x + shift + viewRect.width - fixedWidth - (x - rect.x) : x,
      item: legendItems[i],
      globalMetrics: globalMetrics,
      direction: direction
    });

    if (isHorizontal && x >= viewRect.x - fixedWidth || !isHorizontal && y >= viewRect.y - fixedHeight) {
      renderItems.push(renderItem.item);
    }

    s++;

    if (s >= parallels) {
      s = 0;

      if (isHorizontal) {
        x += columnWidth; // next column

        y = rect.y; // reset y to first row
      } else {
        y += rowHeight; // next row

        x = rect.x; // reset x to first column
      }
    } else if (isHorizontal) {
      y += rowHeight; // next row
    } else {
      x += columnWidth; // next column
    }

    if (!isHorizontal && y > viewRect.y + viewRect.height) {
      break;
    } else if (isHorizontal && x > viewRect.x + viewRect.width) {
      break;
    }
  }

  return renderItems;
}

function _itemize(_ref4, renderer) {
  var resolved = _ref4.resolved,
      dock = _ref4.dock;
  var label;
  var items = [];
  var item;
  var sourceItems = resolved.items.items;
  var sourceSymbols = resolved.symbols.items;
  var sourceLabels = resolved.labels.items;
  var maxSymbolSize = 0;
  var maxLabelWidth = 0;
  var maxLabelHeight = 0;

  for (var i = 0; i < sourceItems.length; i++) {
    if (sourceItems[i].show === false) {
      continue;
    }

    var text = typeof sourceLabels[i].text !== 'undefined' ? sourceLabels[i].text : sourceLabels[i].data.label || '';
    label = extend({}, sourceLabels[i], {
      // create the displayObject here in order to measure it
      type: 'text',
      fontSize: "".concat(parseInt(sourceLabels[i].fontSize, 10), "px"),
      text: text,
      title: text
    });
    item = {
      symbol: {
        // can't create a displayObject here due to need to wiggle the center position of the symbol later on,
        // just store the object needed later on
        meta: sourceSymbols[i]
      },
      label: {
        displayObject: label,
        bounds: renderer.textBounds(label)
      }
    };
    items.push(item);
    maxSymbolSize = Math.max(sourceSymbols[i].size, maxSymbolSize);
    maxLabelWidth = Math.max(item.label.bounds.width, maxLabelWidth);
    maxLabelHeight = Math.max(item.label.bounds.height, maxLabelHeight);
  }

  return {
    items: items,
    globalMetrics: {
      spacing: 8,
      maxSymbolSize: maxSymbolSize,
      maxItemBounds: {
        height: Math.max(maxSymbolSize, maxLabelHeight),
        width: maxSymbolSize + 8 + maxLabelWidth
      },
      maxLabelBounds: {
        width: maxLabelWidth,
        height: maxLabelHeight
      }
    },
    layout: {
      margin: {
        vertical: typeof resolved.layout.item.vertical !== 'undefined' ? resolved.layout.item.vertical : 4,
        horizontal: typeof resolved.layout.item.horizontal !== 'undefined' ? resolved.layout.item.horizontal : 4
      },
      mode: resolved.layout.item.mode,
      size: resolved.layout.item.size,
      orientation: dock === 'top' || dock === 'bottom' ? 'horizontal' : 'vertical',
      direction: resolved.layout.item.direction,
      scrollOffset: resolved.layout.item.scrollOffset
    }
  };
}

function _extent(itemized, parallels) {
  var count = itemized.items.length;
  var size = Math.ceil(count / parallels);
  var property = itemized.layout.orientation === 'horizontal' ? 'width' : 'height';
  var margin = property === 'width' ? 'horizontal' : 'vertical';
  return itemized.globalMetrics.maxItemBounds[property] * size + (size - 1) * itemized.layout.margin[margin];
}

function _spread(itemized, parallels) {
  var size = parallels;
  var property = itemized.layout.orientation === 'horizontal' ? 'height' : 'width';
  var margin = property === 'width' ? 'horizontal' : 'vertical';
  return itemized.globalMetrics.maxItemBounds[property] * size + // expected vertical size of items
  (size - 1) * itemized.layout.margin[margin]; // expected spacing between items
}

function _parallelize(availableExtent, availableSpread, itemized) {
  var count = itemized.items.length;
  var extentProperty = itemized.layout.orientation === 'horizontal' ? 'width' : 'height';
  var margin = extentProperty === 'width' ? 'horizontal' : 'vertical';
  var extentInPx = itemized.globalMetrics.maxItemBounds[extentProperty] * count + (count - 1) * itemized.layout.margin[margin];
  var numNeeded = Math.ceil(extentInPx / availableExtent);

  if (availableSpread != null) {
    var spreadProperty = itemized.layout.orientation === 'horizontal' ? 'height' : 'width';
    var numAllowed = Math.floor(availableSpread / (4 + itemized.globalMetrics.maxItemBounds[spreadProperty]));
    numNeeded = Math.min(numNeeded, numAllowed);
  }

  var numInput = isNaN(itemized.layout.size) ? 1 : itemized.layout.size;
  return Math.max(1, Math.min(numNeeded, numInput));
}
function itemRendererFactory (legend, _ref5) {
  var _ref5$onScroll = _ref5.onScroll,
      onScroll = _ref5$onScroll === void 0 ? function () {} : _ref5$onScroll;
  var itemized;
  var parallels;
  var viewRect;
  var containerRect;
  var _offset = null;
  var overflow = 0;
  var api = {
    itemize: function itemize(obj) {
      itemized = _itemize(obj, legend.renderer);
      _offset = !isNaN(itemized.layout.scrollOffset) ? itemized.layout.scrollOffset : _offset; // Set the initial offset
    },
    getItemsToRender: function getItemsToRender(obj) {
      viewRect = obj.viewRect;
      overflow = api.getContentOverflow(viewRect);
      var ext = api.extent();
      _offset = Math.max(0, Math.min(_offset, overflow));
      containerRect = extend({}, viewRect);
      var offsetProperty = api.orientation() === 'horizontal' ? 'x' : 'y';
      containerRect[offsetProperty] -= _offset;
      containerRect[offsetProperty === 'x' ? 'width' : 'height'] = ext;
      return _getItemsToRender(obj, containerRect, {
        itemized: itemized,
        parallels: parallels
      });
    },
    parallelize: function parallelize(availableExtent, availableSpread) {
      parallels = _parallelize(availableExtent, availableSpread, itemized);
      return parallels;
    },
    hasContentOverflow: function hasContentOverflow() {
      var property = itemized.layout.orientation === 'horizontal' ? 'width' : 'height';
      return _extent(itemized, parallels) > viewRect[property];
    },
    getContentOverflow: function getContentOverflow() {
      var rect = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : viewRect;
      var property = itemized.layout.orientation === 'horizontal' ? 'width' : 'height';
      return Math.max(0, _extent(itemized, parallels) - rect[property]);
    },
    getNextSize: function getNextSize() {
      // TODO - calculate the actual size to next item to ensure alignment
      var property = itemized.layout.orientation === 'horizontal' ? 'width' : 'height';
      var margin = property === 'width' ? 'horizontal' : 'vertical';
      return itemized.globalMetrics.maxItemBounds[property] + itemized.layout.margin[margin];
    },
    getPrevSize: function getPrevSize() {
      // TODO - calculate the actual size to next item to ensure alignment
      var property = itemized.layout.orientation === 'horizontal' ? 'width' : 'height';
      var margin = property === 'width' ? 'horizontal' : 'vertical';
      return itemized.globalMetrics.maxItemBounds[property] + itemized.layout.margin[margin];
    },
    hasNext: function hasNext() {
      if (api.orientation() === 'horizontal') {
        return viewRect.x + viewRect.width < containerRect.x + containerRect.width;
      }

      return viewRect.y + viewRect.height < containerRect.y + containerRect.height;
    },
    hasPrev: function hasPrev() {
      if (api.orientation() === 'horizontal') {
        return containerRect.x < viewRect.x;
      }

      return containerRect.y < viewRect.y;
    },
    next: function next() {
      api.scroll(-api.getNextSize());
    },
    prev: function prev() {
      api.scroll(api.getPrevSize());
    },
    scroll: function scroll(delta) {
      var current = Math.max(0, Math.min(overflow, _offset - delta));

      if (current === _offset) {
        return;
      }

      _offset = current;
      onScroll();
    },
    offset: function offset() {
      return _offset;
    },
    orientation: function orientation() {
      return itemized.layout.orientation;
    },
    direction: function direction() {
      return itemized.layout.direction;
    },
    extent: function extent() {
      return _extent(itemized, parallels);
    },
    // total amount of space along orientation
    spread: function spread() {
      return _spread(itemized, parallels);
    } // total amount of space perpendicular to orientation

  };
  return api;
}

/**
 * Concatenate object keys into a space separated string. Use for transforming a 'class name map' into a class string
 * @private
 * @param  {Object} classMap Object with class names as keys and true or false values depending on if they should be in the returned class string or not
 * @return {String} Space separated string with class names
 */
function classString(classMap) {
  return Object.keys(classMap).filter(function (className) {
    return classMap[className];
  }).join(' ');
}

var DIR = {
  up: "\u25B2",
  right: "\u25B6",
  down: "\u25BC",
  left: "\u25C0"
};

function _itemize$1(_ref) {
  var dock = _ref.dock,
      navigation = _ref.navigation;
  return {
    layout: {
      orientation: dock === 'top' || dock === 'bottom' ? 'vertical' : 'horizontal'
    },
    navigation: navigation
  };
}

function btn(h, _ref2) {
  var size = _ref2.size,
      isActive = _ref2.isActive,
      direction = _ref2.direction,
      nav = _ref2.nav,
      attrs = _ref2.attrs;
  var c = {};
  var content = '';

  if (nav && nav.button) {
    if (typeof nav.button.class === 'function') {
      c = nav.button.class({
        direction: direction
      });
    } else if (nav.button.class) {
      c = nav.button.class;
    }

    if (typeof nav.button.content === 'function') {
      content = nav.button.content(h, {
        direction: direction
      });
    }
  }

  var style = {
    width: "".concat(size, "px"),
    minWidth: "".concat(size, "px"),
    height: "".concat(size, "px")
  };

  if (!Object.keys(c).length) {
    // if no classes are set, add some basic styling
    style.border = '0';
    style.background = 'none';
  }

  var attrsMerged = attrs;

  if (!isActive || nav && nav.disabled) {
    attrsMerged.disabled = 'disabled';
  }

  return h('button', extend({
    class: classString(c),
    style: style
  }, attrsMerged), [content || h('span', {
    style: {
      pointerEvents: 'none'
    }
  }, [DIR[direction]])]);
}

function _render$1(renderer, _ref3, itemized, legend) {
  var rect = _ref3.rect,
      itemRenderer = _ref3.itemRenderer;

  if (!renderer || !renderer.renderArgs) {
    return;
  }

  renderer.size(rect);
  var h = renderer.renderArgs[0];
  var isVertical = itemized.layout.orientation === 'vertical'; // orientation of the navigation (not the legend)

  var isRtl = itemRenderer.direction() === 'rtl';
  var hasNext = itemRenderer.hasNext();
  var hasPrev = itemRenderer.hasPrev();

  if (!hasPrev && !hasNext) {
    renderer.render([]);
    return;
  }

  var buttonSize = 32;
  var order = isVertical ? ['right', 'left'] : ['down', 'up'];

  if (isRtl && isVertical) {
    order.reverse();
  }

  var nodes = [h('div', {
    style: {
      position: 'relative',
      display: 'flex',
      'flex-direction': isVertical ? 'column' : 'row',
      'justify-content': 'center',
      height: '100%',
      pointerEvents: 'auto'
    },
    dir: isRtl && !isVertical ? 'rtl' : 'ltr'
  }, [btn(h, {
    size: buttonSize,
    isActive: hasNext,
    direction: order[0],
    attrs: {
      'data-action': 'next',
      'data-component-key': legend.settings.key
    },
    nav: itemized.navigation
  }), btn(h, {
    size: buttonSize,
    isActive: hasPrev,
    direction: order[1],
    attrs: {
      'data-action': 'prev',
      'data-component-key': legend.settings.key
    },
    nav: itemized.navigation
  })])];
  renderer.render(nodes);
}

function navigationRendererFactory (legend) {
  var itemized;
  var nav = {
    itemize: function itemize(obj) {
      itemized = _itemize$1(obj);
    },
    render: function render(obj) {
      return _render$1(nav.renderer, obj, itemized, legend);
    },
    extent: function extent() {
      return 32;
    },
    spread: function spread() {
      return 64;
    }
  };
  return nav;
}

function _itemize$2(_ref, legend) {
  var resolved = _ref.resolved;

  if (resolved.title.item.show === false) {
    return null;
  }

  var t = extend({}, resolved.title.item, {
    type: 'text'
  });

  if (resolved.layout.item.direction === 'rtl') {
    if (!t.anchor || t.anchor === 'start') {
      t.anchor = 'end';
    } else if (t.anchor === 'end') {
      t.anchor = 'start';
    }
  }

  if (typeof resolved.title.settings.text === 'undefined') {
    var fields = legend.scale.data().fields;
    t.text = fields && fields[0] ? fields[0].title() : '';
  }

  return {
    displayObject: t,
    bounds: legend.renderer.textBounds(t)
  };
}

function _render$2(_ref2, renderer, itemized) {
  var rect = _ref2.rect;

  if (!renderer) {
    return;
  }

  var nodes = [];
  renderer.size(rect);

  if (itemized) {
    var align = {
      start: 0,
      end: rect.width,
      middle: rect.width / 2
    };
    nodes.push(extend({}, itemized.displayObject, {
      x: align[itemized.displayObject.anchor] || 0,
      y: 0,
      baseline: 'text-before-edge',
      title: itemized.displayObject.text
    }));
  }

  renderer.render(nodes);
}

function titleRendererFactory (legend) {
  var itemized;
  var api = {
    itemize: function itemize(obj) {
      itemized = _itemize$2(obj, legend);
    },
    render: function render(obj) {
      _render$2(obj, api.renderer, itemized);
    },
    spread: function spread() {
      return itemized ? itemized.bounds.height : 0;
    },
    extent: function extent() {
      return itemized ? itemized.bounds.width : 0;
    }
  };
  return api;
}

/* eslint no-mixed-operators:0 */

function layout(rect, display, orientation, _ref) {
  var itemRenderer = _ref.itemRenderer,
      navigationRenderer = _ref.navigationRenderer,
      titleRenderer = _ref.titleRenderer,
      _ref$isPreliminary = _ref.isPreliminary,
      isPreliminary = _ref$isPreliminary === void 0 ? false : _ref$isPreliminary;
  var title;
  var content;
  var navigation;
  var preferredSize = 0;
  var paddedRect = {
    x: display.spacing,
    y: display.spacing,
    width: rect.width - 2 * display.spacing,
    height: rect.height - 2 * display.spacing
  };
  title = {
    x: paddedRect.x,
    y: paddedRect.y,
    width: paddedRect.width,
    height: titleRenderer.spread()
  };

  if (orientation === 'horizontal') {
    // const titleAtTop = false;
    // if (titleAtTop) { // this might be a nicer layout sometimes
    //   // |------------------|
    //   // |title             |
    //   // |------------|-----|
    //   // |content     | nav |
    //   // |------------|-----|
    //   // available space for items without navigation UI
    //   const availableExtentForItems = paddedRect.width;
    //   const availableSpreadForItems = paddedRect.height - (title.y + title.height) + 8;
    //   const isRtl = itemRenderer.direction() === 'rtl';
    //   itemRenderer.parallelize(availableExtentForItems, isPreliminary ? undefined : availableSpreadForItems);
    //   const navigationSize = itemRenderer.extent() > availableExtentForItems ? navigationRenderer.extent() : 0;
    //   content = {
    //     x: paddedRect.x,
    //     y: title.y + title.height,
    //     width: paddedRect.width - navigationSize,
    //     height: availableSpreadForItems
    //   };
    //   navigation = {
    //     x: content.x + content.width,
    //     y: title.y + title.height,
    //     width: navigationSize,
    //     height: paddedRect.height - (title.y + title.height) + 8
    //   };
    //   if (isRtl) { // switch navigation and content
    //     navigation.x = content.x;
    //     content.x = navigation.x + navigation.width;
    //     // totalContent.x = navigation.x;
    //   }
    //   preferredSize = title.height + Math.max(navigationRenderer.spread(), itemRenderer.spread());
    // } else {
    // |-----|------------|-----|
    // |title|content     | nav |
    // |-----|------------|-----|
    title = {
      x: paddedRect.x,
      y: paddedRect.y,
      width: titleRenderer.extent(),
      height: titleRenderer.spread()
    }; // available space for items without navigation UI

    var availableExtentForItems = paddedRect.width - title.width - (title.width ? display.spacing : 0);
    var availableSpreadForItems = paddedRect.height;
    itemRenderer.parallelize(availableExtentForItems, isPreliminary ? undefined : availableSpreadForItems);
    var navigationSize = itemRenderer.extent() > availableExtentForItems ? navigationRenderer.extent() : 0;
    var spread = itemRenderer.spread();
    var navigationSpread = navigationSize ? navigationRenderer.spread() : 0;
    content = {
      x: title.x + title.width + (title.width ? display.spacing : 0),
      y: paddedRect.y + Math.max(0, (navigationSpread - spread) / 2),
      width: paddedRect.width - navigationSize - title.width - (navigationSize ? display.spacing : 0) - (title.width ? display.spacing : 0),
      height: availableSpreadForItems
    };
    navigation = {
      x: content.x + content.width + (navigationSize ? display.spacing : 0),
      y: paddedRect.y,
      width: navigationSize,
      height: paddedRect.height
    };
    title.y = content.y;
    var isRtl = itemRenderer.direction() === 'rtl';

    if (isRtl) {
      // switch title, content and navigation
      navigation.x = paddedRect.x;
      content.x = navigation.x + navigation.width + (navigation.width ? display.spacing : 0);
      title.x = content.x + content.width + (title.width ? display.spacing : 0);
    }

    preferredSize = Math.max(title.height, navigationSpread, itemRenderer.spread()); // }
  } else {
    // |------------|
    // |title       |
    // |------------|
    // |content     |
    // |------------|
    // |navigation  |
    // |------------|
    var _availableExtentForItems = paddedRect.height - title.height - (title.height ? display.spacing : 0);

    var _availableSpreadForItems = paddedRect.width;
    itemRenderer.parallelize(_availableExtentForItems, isPreliminary ? undefined : _availableSpreadForItems);

    var _navigationSize = itemRenderer.extent() > _availableExtentForItems ? navigationRenderer.extent() : 0;

    navigation = {
      x: paddedRect.x,
      y: paddedRect.y + paddedRect.height - _navigationSize,
      width: paddedRect.width,
      height: _navigationSize
    };
    content = {
      x: paddedRect.x,
      y: title.y + title.height + (title.height ? display.spacing : 0),
      width: paddedRect.width,
      height: paddedRect.height - title.height - (title.height ? display.spacing : 0) - navigation.height - (navigation.height ? display.spacing : 0)
    };
    preferredSize = Math.max(titleRenderer.extent(), _navigationSize ? navigationRenderer.spread() : 0, itemRenderer.spread());
  }

  content = extend({}, rect, {
    x: rect.x + content.x,
    y: rect.y + content.y,
    width: content.width,
    height: content.height
  });
  navigation.x += rect.x;
  navigation.y += rect.y;
  title.x += rect.x;
  title.y += rect.y;
  return {
    title: extend({}, rect, title),
    content: extend({}, rect, content),
    navigation: extend({}, rect, navigation),
    orientation: orientation,
    preferredSize: preferredSize
  };
}

function update(comp) {
  comp.state.resolved = resolveSettings$2(comp);
  comp.titleRenderer.itemize({
    resolved: comp.state.resolved,
    dock: comp.settings.layout.dock || 'center'
  });
  comp.itemRenderer.itemize({
    resolved: comp.state.resolved,
    dock: comp.settings.layout.dock || 'center'
  });
  comp.navigationRenderer.itemize({
    resolved: comp.state.resolved,
    dock: comp.settings.layout.dock || 'center',
    navigation: comp.settings.settings.navigation
  });
  comp.state.display = {
    spacing: 8
  };
}

function _preferredSize(comp, size) {
  var s = 0;
  var dock = comp.settings.layout.dock || 'center';
  var orientation = dock === 'top' || dock === 'bottom' ? 'horizontal' : 'vertical';
  var d = comp.state.display;
  var tempLayout = layout(size.inner, d, orientation, {
    itemRenderer: comp.itemRenderer,
    navigationRenderer: comp.navigationRenderer,
    titleRenderer: comp.titleRenderer,
    isPreliminary: true
  });
  s += d.spacing; // start padding in both vertical and horizontal mode

  s += tempLayout.preferredSize;
  s += d.spacing; // end padding in both vertical and horizontal mode

  return s;
}

function _render$3(legend) {
  var rect = legend.rect,
      settings = legend.settings,
      state = legend.state,
      itemRenderer = legend.itemRenderer,
      navigationRenderer = legend.navigationRenderer,
      titleRenderer = legend.titleRenderer;
  var dock = settings.layout.dock;
  var orientation = dock === 'top' || dock === 'bottom' ? 'horizontal' : 'vertical';
  var l = layout(rect, state.display, orientation, {
    itemRenderer: itemRenderer,
    navigationRenderer: navigationRenderer,
    titleRenderer: titleRenderer
  });
  legend.renderer.size(l.content); // l.content.x = 0;
  // l.content.y = 0;
  // l.navigation.x += rect.x;
  // l.navigation.y += rect.y;
  // l.title.x += rect.x;
  // l.title.y += rect.y;

  var contentItems = itemRenderer.getItemsToRender({
    viewRect: extend({}, l.content, {
      x: 0,
      y: 0
    })
  });
  navigationRenderer.render({
    rect: l.navigation,
    itemRenderer: itemRenderer
  });
  titleRenderer.render({
    rect: l.title
  });
  legend.state.views = {
    layout: l
  };
  return contentItems;
}

var component$2 = {
  require: ['chart', 'settings', 'renderer', 'update', 'resolver', 'registries'],
  defaultSettings: {
    settings: {},
    style: {
      item: {
        label: '$label',
        shape: '$shape'
      },
      title: '$title'
    }
  },
  mounted: function mounted(renderElement) {
    if (renderElement && renderElement.parentNode) {
      this.navigationRenderer.renderer.appendTo(renderElement.parentNode);
      this.titleRenderer.renderer.appendTo(renderElement.parentNode);
      renderElement.parentNode.insertBefore(this.navigationRenderer.renderer.element(), renderElement);
      renderElement.parentNode.insertBefore(this.titleRenderer.renderer.element(), renderElement);
    }

    this.navigationRenderer.render({
      rect: this.state.views.layout.navigation,
      itemRenderer: this.itemRenderer
    });
    this.titleRenderer.render({
      rect: this.state.views.layout.title
    });
  },
  beforeUnmount: function beforeUnmount() {
    this.navigationRenderer.renderer.clear();
    this.titleRenderer.renderer.clear();
  },
  on: {
    panstart: function panstart() {
      if (this.state.interaction.started) {
        return;
      }

      var contentOverflow = this.itemRenderer.getContentOverflow();

      if (!contentOverflow) {
        return;
      }

      this.state.interaction.started = true;
      this.state.interaction.delta = 0;
    },
    panmove: function panmove(e) {
      if (!this.state.interaction.started) {
        return;
      }

      var delta = this.itemRenderer.orientation() === 'horizontal' ? (this.itemRenderer.direction() === 'rtl' ? -1 : 1) * e.deltaX : e.deltaY;
      this.itemRenderer.scroll(delta - this.state.interaction.delta);
      this.state.interaction.delta = delta;
    },
    panend: function panend() {
      this.state.interaction.started = false;
    },
    scroll: function scroll(delta) {
      this.itemRenderer.scroll(-delta);
    },
    next: function next() {
      this.itemRenderer.next();
    },
    prev: function prev() {
      this.itemRenderer.prev();
    }
  },
  created: function created() {
    var _this = this;

    this.state = {
      interaction: {}
    };

    this.onScroll = function () {
      var items = _render$3(_this);

      _this.update(items);
    };

    this.itemRenderer = itemRendererFactory(this, {
      onScroll: this.onScroll
    });
    this.navigationRenderer = navigationRendererFactory(this);
    this.titleRenderer = titleRendererFactory(this);
    this.navigationRenderer.renderer = this.registries.renderer('dom')();
    this.titleRenderer.renderer = this.registries.renderer(this.settings.renderer)();
    update(this);
  },
  preferredSize: function preferredSize(obj) {
    return _preferredSize(this, obj);
  },
  beforeUpdate: function beforeUpdate() {
    update(this);
  },
  render: function render() {
    return _render$3(this);
  },
  beforeDestroy: function beforeDestroy() {
    this.navigationRenderer.renderer.destroy();
    this.titleRenderer.renderer.destroy();
  },
  additionalElements: function additionalElements() {
    return [this.titleRenderer.renderer.element(), this.navigationRenderer.renderer.element()];
  },
  _DO_NOT_USE_getInfo: function _DO_NOT_USE_getInfo() {
    return {
      offset: this.itemRenderer.offset()
    };
  }
};

/**
 * @typedef {object} component--legend-cat
 * @property {string} scale
 */

/**
 * @type {string}
 * @memberof component--legend-cat
 */

var type$2 = 'legend-cat';
function categoricalLegend(picasso) {
  picasso.component(type$2, component$2);
}

function applyAlignJustify(ctx, node) {
  var wiggle = 0;
  var cmd = {
    type: ctx.state.isVertical ? 'justify' : 'align',
    coord: ctx.state.isVertical ? 'y' : 'x',
    pos: ctx.state.isVertical ? 'height' : 'width',
    fn: ctx.state.isVertical ? 'requiredHeight' : 'requiredWidth'
  };
  wiggle = ctx.state.rect[cmd.pos] - ctx.state.legend.length() - ctx.state.title[cmd.fn]();
  wiggle *= Math.min(1, Math.max(ctx.stgns[cmd.type], 0));
  node[cmd.coord] += wiggle;
}

function generateStopNodes(ctx) {
  var fillScale = ctx.state.legend.fillScale;
  var majorScale = ctx.state.legend.majorScale;
  var stops = fillScale.domain().map(function (d) {
    return {
      type: 'stop',
      color: fillScale(d),
      offset: Math.min(1, Math.max(0, majorScale.norm(d)))
    };
  });
  return stops.sort(function (a, b) {
    return a.offset - b.offset;
  });
}
function createTitleNode(ctx) {
  var state = ctx.state;
  var settings = ctx.stgns;
  var isTickLeft = state.ticks.anchor === 'left';
  var isTickTop = state.ticks.anchor === 'top';
  var x = state.rect.x;
  var y = state.rect.y;
  var textAnchor = 'start';

  if (state.title.anchor === 'left') {
    x += state.title.requiredWidth() - settings.title.padding;
    y += state.title.textMetrics.height;
    y += isTickTop ? state.rect.height - state.title.textBounds.height : 0;
    textAnchor = 'end';
  } else if (state.title.anchor === 'right') {
    x += state.legend.length();
    x += settings.title.padding;
    y += state.title.textMetrics.height;
    y += isTickTop ? state.rect.height - state.title.textBounds.height : 0;
  } else if (state.title.anchor === 'top') {
    x += isTickLeft ? state.rect.width : 0;
    y += state.title.textMetrics.height;
    textAnchor = isTickLeft ? 'end' : 'start';
  }

  var node = {
    tag: 'legend-title',
    type: 'text',
    x: x,
    y: Math.min(y, state.rect.y + state.rect.height),
    text: settings.title.text,
    fill: settings.title.fill,
    fontSize: settings.title.fontSize,
    fontFamily: settings.title.fontFamily,
    maxWidth: settings.title.maxLengthPx,
    maxLines: settings.title.maxLines,
    wordBreak: settings.title.wordBreak,
    hyphens: settings.title.hyphens,
    lineHeight: settings.title.lineHeight,
    anchor: textAnchor,
    title: settings.title.text
  };
  applyAlignJustify(ctx, node);
  return node;
}
function createLegendRectNode(ctx, stops) {
  var state = ctx.state;
  var settings = ctx.stgns;
  var container = state.rect;
  var x = container.x;
  var y = container.y;
  var width = state.isVertical ? settings.size : state.legend.length();
  var height = state.isVertical ? state.legend.length() : settings.size;

  if (state.ticks.anchor === 'left') {
    x += state.rect.width - settings.size;
  } else if (state.ticks.anchor === 'top') {
    y += state.rect.height - settings.size;
  }

  if (state.title.anchor === 'top') {
    y += state.title.requiredHeight();
  } else if (state.title.anchor === 'left') {
    x += state.title.requiredWidth();
  }

  var node = {
    type: 'rect',
    x: x,
    y: y,
    width: width,
    height: height,
    fill: {
      type: 'gradient',
      stops: stops,
      degree: state.isVertical ? 90 : 180
    }
  };
  applyAlignJustify(ctx, node);
  return node;
}
function createTickNodes(ctx, legendNode) {
  var state = ctx.state;
  var settings = ctx.stgns;
  var anchor = 'start';
  var rangeSelectorRect = {
    type: 'rect',
    x: legendNode.x,
    y: legendNode.y,
    width: state.isVertical ? 0 : legendNode.width,
    height: state.isVertical ? legendNode.height : 0,
    fill: 'transparent'
  };
  var nodes = state.ticks.values.map(function (tick) {
    var x = 0;
    var y = 0;
    var dx = 0;
    var dy = 0;
    var baseline = 'alphabetical';

    if (state.isVertical) {
      y = legendNode.y + legendNode.height * tick.pos;
      baseline = tick.pos === 0 ? 'text-before-edge' : 'text-after-edge';
    } else {
      x = legendNode.x + legendNode.width * tick.pos;
    }

    if (state.ticks.anchor === 'right') {
      x = legendNode.x + settings.size + settings.tick.padding;
      rangeSelectorRect.x = legendNode.x + legendNode.width;
    } else if (state.ticks.anchor === 'left') {
      x = legendNode.x - settings.tick.padding;
      anchor = 'end';
    } else if (state.ticks.anchor === 'top') {
      y = legendNode.y - settings.tick.padding;
      dy -= tick.textMetrics.height * 0.25;
      anchor = tick.pos === 0 ? 'start' : 'end';
    } else if (state.ticks.anchor === 'bottom') {
      y = legendNode.y + legendNode.height + settings.tick.padding;
      dy = tick.textMetrics.height * 0.8;
      anchor = tick.pos === 0 ? 'start' : 'end';
      rangeSelectorRect.y = legendNode.y + legendNode.height;
    }

    var node = {
      type: 'text',
      x: x,
      y: y,
      dx: dx,
      dy: dy,
      text: tick.label,
      fontSize: settings.tick.fontSize,
      fontFamily: settings.tick.fontFamily,
      fill: settings.tick.fill,
      maxWidth: state.isVertical ? settings.tick.maxLengthPx : Math.min(settings.tick.maxLengthPx, state.legend.length() / 2),
      anchor: anchor,
      textBoundsFn: ctx.renderer.textBounds,
      title: tick.label,
      baseline: baseline
    };
    return node;
  });
  return {
    type: 'container',
    id: 'legend-seq-ticks',
    children: [].concat(_toConsumableArray$1(nodes), [rangeSelectorRect])
  };
}

function resolveAnchor(dock, anchor, map) {
  var mapped = map[dock];

  if (_typeof(mapped) === 'object') {
    if (mapped.valid.indexOf(anchor) !== -1) {
      return anchor;
    }

    return mapped.default;
  }

  return map.default;
}

function resolveTickAnchor(settings) {
  var dock = settings.layout.dock;
  var anchor = settings.settings.tick.anchor;
  var dockAnchorMap = {
    left: {
      valid: ['left', 'right'],
      default: 'left'
    },
    right: {
      valid: ['left', 'right'],
      default: 'right'
    },
    top: {
      valid: ['top', 'bottom'],
      default: 'top'
    },
    bottom: {
      valid: ['top', 'bottom'],
      default: 'bottom'
    },
    default: 'right'
  };
  return resolveAnchor(dock, anchor, dockAnchorMap);
}

function resolveTitleAnchor(settings) {
  var dockAnchorMap = {
    left: {
      valid: ['top'],
      default: 'top'
    },
    right: {
      valid: ['top'],
      default: 'top'
    },
    top: {
      valid: ['left', 'right'],
      default: 'left'
    },
    bottom: {
      valid: ['left', 'right'],
      default: 'left'
    },
    default: 'top'
  };
  var dock = settings.layout.dock;
  var anchor = settings.settings.title.anchor;
  return resolveAnchor(dock, anchor, dockAnchorMap);
}

function initRect(ctx, size) {
  var rect = {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  };
  var padding = ctx.stgns.padding;
  rect.x = padding.left;
  rect.y = padding.top;
  rect.width = size.width - padding.left - padding.right;
  rect.height = size.height - padding.top - padding.bottom;
  return rect;
}

function getTicks(ctx, majorScale) {
  var values = majorScale.domain();
  var labels = values;
  var labelFn = ctx.stgns.tick.label;

  if (!labelFn && ctx.formatter) {
    labelFn = ctx.formatter;
  } else if (!labelFn && majorScale.data().fields) {
    labelFn = majorScale.data().fields[0].formatter();
  }

  if (typeof labelFn === 'function') {
    labels = values.map(labelFn).map(String);
  }

  var ticks = values.map(function (value, i) {
    var label = labels[i];
    return {
      value: value,
      label: label,
      pos: majorScale.norm(parseFloat(value, 10)),
      textMetrics: ctx.renderer.measureText({
        text: label,
        fontSize: ctx.stgns.tick.fontSize,
        fontFamily: ctx.stgns.tick.fontFamily
      })
    };
  });
  return ticks;
}

function initState(ctx) {
  var isVertical = ctx.settings.layout.dock !== 'top' && ctx.settings.layout.dock !== 'bottom';
  var titleStgns = ctx.stgns.title;
  var fillScale = ctx.chart.scale(ctx.stgns.fill);
  var majorScale = ctx.chart.scale(ctx.stgns.major);
  var tickValues = getTicks(ctx, majorScale);
  var tickAnchor = resolveTickAnchor(ctx.settings);

  if (typeof titleStgns.text === 'undefined') {
    var fields = majorScale.data().fields;
    titleStgns.text = fields && fields[0] ? fields[0].title() : '';
  }

  var titleTextMetrics = ctx.renderer.measureText({
    text: titleStgns.text,
    fontSize: titleStgns.fontSize,
    fontFamily: titleStgns.fontFamily
  });
  var titleTextBounds = ctx.renderer.textBounds({
    text: titleStgns.text,
    fontSize: titleStgns.fontSize,
    fontFamily: titleStgns.fontFamily,
    maxLines: titleStgns.maxLines,
    maxWidth: titleStgns.maxLengthPx,
    wordBreak: titleStgns.wordBreak,
    hyphens: titleStgns.hyphens,
    lineHeight: titleStgns.lineHeight
  });
  var state = {
    isVertical: isVertical,
    nodes: [],
    title: {
      anchor: resolveTitleAnchor(ctx.settings),
      textMetrics: titleTextMetrics,
      textBounds: titleTextBounds,
      requiredWidth: function requiredWidth() {
        if (!titleStgns.show) {
          return 0;
        }

        var w = titleTextBounds.width;
        var mw = titleStgns.maxLengthPx;

        if (!isVertical) {
          w += titleStgns.padding;
          mw += titleStgns.padding;
        }

        return Math.min(w, mw, state.rect.width);
      },
      requiredHeight: function requiredHeight() {
        if (!titleStgns.show) {
          return 0;
        }

        var h = titleTextBounds.height;

        if (isVertical) {
          h += titleStgns.padding;
        }

        return Math.min(h, state.rect.height);
      }
    },
    ticks: {
      values: tickValues,
      anchor: tickAnchor,
      length: Math.min(Math.max.apply(Math, _toConsumableArray$1(tickValues.map(function (t) {
        return t.textMetrics.width;
      }))), ctx.stgns.tick.maxLengthPx),
      requiredHeight: function requiredHeight() {
        return tickAnchor === 'top' ? Math.max.apply(Math, _toConsumableArray$1(state.ticks.values.map(function (t) {
          return t.textMetrics.height;
        }))) + ctx.stgns.tick.padding : 0;
      },
      height: Math.max.apply(Math, _toConsumableArray$1(tickValues.map(function (t) {
        return t.textMetrics.height;
      })))
    },
    legend: {
      fillScale: fillScale,
      majorScale: majorScale,
      length: function length() {
        var pos = isVertical ? 'height' : 'width';
        var fnPos = isVertical ? 'requiredHeight' : 'requiredWidth';
        var len = Math.min(state.rect[pos], state.rect[pos] * ctx.stgns.length) - state.title[fnPos]();
        return Math.max(0, Math.min(len, ctx.stgns.maxLengthPx));
      }
    }
  };
  return state;
}
/**
 * @typedef {object} component--legend-seq
 * @property {string} fill - Reference to definition of sequential color scale
 * @property {string} major - Reference to definition of linear scale
 * @property {number} [size=15] - Size in pixels of the legend, if vertical is the width and height otherwise
 * @property {number} [length=1] - A value in the range 0-1 indicating the length of the legend node
 * @property {number} [maxLengthPx=250] - Max length in pixels
 * @property {number} [align=0.5] - A value in the range 0-1 indicating horizontal alignment of the legend's content. 0 aligns to the left, 1 to the right.
 * @property {number} [justify=0] - A value in the range 0-1 indicating vertical alignment of the legend's content. 0 aligns to the top, 1 to the bottom.
 * @property {object} [padding]
 * @property {number} [padding.left=5]
 * @property {number} [padding.right=5]
 * @property {number} [padding.top=5]
 * @property {number} [padding.bottom=5]
 * @property {object} [tick]
 * @property {function} [tick.label] - Function applied to all tick values, returned values are used as labels
 * @property {string} [tick.fill='#595959']
 * @property {string} [tick.fontSize='12px']
 * @property {string} [tick.fontFamily='Arial']
 * @property {number} [tick.maxLengthPx=150] - Max length in pixels
 * @property {string} [tick.anchor='right'] - Where to anchor the tick in relation to the legend node, supported values are [top, bottom, left and right]
 * @property {number} [tick.padding=5] - padding in pixels to the legend node
 * @property {object} [title] - Title settings
 * @property {boolean} [title.show=true] - Toggle title on/off
 * @property {string} [title.text=''] - Title text. Defaults to the title of the provided data field
 * @property {string} [title.fill='#595959']
 * @property {string} [title.fontSize='12px']
 * @property {string} [title.fontFamily='Arial']
 * @property {number} [title.maxLengthPx=100] - Max length in pixels
 * @property {number} [title.padding=5] - padding in pixels to the legend node
 * @property {string} [title.anchor='top'] - Where to anchor the title in relation to the legend node, supported values are [top, left and right]
 * @property {string} [title.wordBreak='none'] - How overflowing title is handled, if it should insert line breaks at word boundries (break-word) or character boundries (break-all)
 * @property {string} [title.hyphens='auto'] - How words should be hyphenated when text wraps across multiple lines (only applicable with wordBreak)
 * @property {number} [title.maxLines=2] - Number of allowed lines if title contains line breaks (only applicable with wordBreak)
 * @property {number} [title.lineHeight=1.2] - A multiplier defining the distance between lines (only applicable with wordBreak)
 */


var legendDef = {
  require: ['chart', 'settings', 'renderer'],
  defaultSettings: {
    layout: {
      displayOrder: 0,
      dock: 'right'
    },
    settings: {
      size: 15,
      length: 0.5,
      maxLengthPx: 250,
      align: 0.5,
      justify: 0,
      padding: {
        left: 5,
        right: 5,
        top: 5,
        bottom: 5
      },
      tick: {
        label: null,
        fill: '#595959',
        fontSize: '12px',
        fontFamily: 'Arial',
        maxLengthPx: 100,
        anchor: null,
        // Use default based on dock
        padding: 5
      },
      title: {
        show: true,
        text: undefined,
        fill: '#595959',
        fontSize: '12px',
        fontFamily: 'Arial',
        maxLengthPx: 100,
        padding: 5,
        maxLines: 2,
        wordBreak: 'none',
        lineHeight: 1.2,
        hyphens: 'auto',
        anchor: null // Use default based on dock

      }
    }
  },
  preferredSize: function preferredSize(opts) {
    var state = this.state;
    state.rect = initRect(this, opts.inner); // Init with size of legend

    var prefSize = this.stgns.size; // Append paddings

    var paddings = state.isVertical ? this.stgns.padding.left + this.stgns.padding.right : this.stgns.padding.top + this.stgns.padding.bottom;
    prefSize += paddings; // Append tick size

    var maxSize = Math.max(opts.inner.width, opts.inner.height);

    if (state.ticks.anchor === 'left' || state.ticks.anchor === 'right') {
      var tHeight = state.ticks.values.reduce(function (sum, t) {
        return sum + t.textMetrics.height;
      }, 0);

      if (tHeight > this.state.legend.length()) {
        return maxSize;
      }

      prefSize += state.ticks.length;
    } else {
      var tWidth = state.ticks.length;

      if (tWidth > this.state.legend.length()) {
        return maxSize;
      }

      prefSize += Math.max.apply(Math, _toConsumableArray$1(state.ticks.values.map(function (t) {
        return t.textMetrics.height;
      })));
    }

    prefSize += this.stgns.tick.padding; // Append or use title size

    if (this.stgns.title.show) {
      if (state.title.anchor === 'left' || state.title.anchor === 'right') {
        prefSize = Math.max(state.title.textBounds.height + paddings, prefSize);
      } else {
        prefSize = Math.max(prefSize, state.title.requiredWidth() + paddings);
      }
    }

    this.state.preferredSize = prefSize;
    return prefSize;
  },
  created: function created() {
    this.stgns = this.settings.settings;
    this.state = initState(this);
  },
  beforeUpdate: function beforeUpdate(opts) {
    this.stgns = opts.settings.settings;
    this.state = initState(this);
  },
  beforeRender: function beforeRender(opts) {
    this.state.nodes = [];
    this.state.rect = initRect(this, opts.size);

    if (this.stgns.title.show) {
      var titleNode = createTitleNode(this);
      this.state.nodes.push(titleNode);
    }

    var stopNodes = generateStopNodes(this);
    var rectNode = createLegendRectNode(this, stopNodes);
    var tickNodes = createTickNodes(this, rectNode);
    var targetNode = {
      // The target node enables range selection component to limit its range to a specific area
      id: 'legend-seq-target',
      type: 'container',
      children: [rectNode, tickNodes]
    };
    this.state.nodes.push(targetNode);
  },
  render: function render() {
    return this.state.nodes;
  }
};

function sequentialLegend(picasso) {
  picasso.component('legend-seq', legendDef);
}

var CURVES = {
  step: curveStep,
  stepAfter: stepAfter,
  stepBefore: stepBefore,
  linear: curveLinear,
  basis: curveBasis,
  cardinal: curveCardinal.tension(0),
  catmullRom: curveCatmullRom,
  monotonex: monotoneX,
  monotoney: monotoneY,
  natural: curveNatural
};
/**
 * @callback component--line~layerSort
 * @param {object} a
 * @param {string} a.id
 * @param {Array<datum-extract>} a.data
 * @param {object} b
 * @param {string} b.id
 * @param {Array<datum-extract>} b.data
 */

/**
 * @typedef {object}
 * @alias component--line-settings
 */

var SETTINGS = {
  /**
   * @typedef {object}
   */
  coordinates: {
    /**
     * @type {number} */
    minor: 0.5,

    /**
     * @type {number} */
    major: 0.5,

    /**
     * @type {number=} */
    layerId: 0
  },

  /**
   * @type {string=} */
  orientation: 'horizontal',

  /**
   * @typedef {object} */
  layers: {
    /**
     * @type {string=} */
    curve: 'linear',

    /**
     * @type {boolean=} */
    show: true,

    /**
     * @type {component--line~layerSort=} */
    sort: undefined,

    /**
     * @typedef {object} */
    line: {
      /**
       * @type {string=} */
      stroke: '#ccc',

      /**
       * @type {number=} */
      strokeWidth: 1,

      /**
       * @type {string=} */
      strokeLinejoin: 'miter',

      /**
       * @type {string=} */
      strokeDasharray: undefined,

      /**
       * @type {number=} */
      opacity: 1,

      /**
       * @type {boolean=} */
      show: true
    },

    /**
     * @typedef {object} */
    area: {
      /**
       * @type {string=} */
      fill: '#ccc',

      /**
       * @type {number=} */
      opacity: 0.8,

      /**
       * @type {boolean=} */
      show: true
    }
  }
};

function createDisplayLayer(points, _ref) {
  var generator = _ref.generator,
      item = _ref.item,
      data = _ref.data;
  var fill = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  var path = generator(points);
  var d = {
    type: 'path',
    d: path,
    opacity: item.opacity,
    stroke: item.stroke,
    strokeWidth: item.strokeWidth,
    strokeLinejoin: item.strokeLinejoin,
    fill: fill || item.fill,
    data: data
  };

  if (item.strokeDasharray) {
    d.strokeDasharray = item.strokeDasharray;
  }

  return d;
}

function createDisplayLayers(layers, _ref2) {
  var width = _ref2.width,
      height = _ref2.height,
      missingMinor0 = _ref2.missingMinor0,
      stngs = _ref2.stngs;
  var nodes = [];
  var layerStngs = stngs.layers || {};
  layers.forEach(function (layer) {
    var lineObj = layer.lineObj,
        layerObj = layer.layerObj,
        areaObj = layer.areaObj,
        points = layer.points;
    var areaGenerator = area();
    var lineGenerator;
    var secondaryLineGenerator;
    var minor = {
      size: height,
      p: 'y'
    };
    var major = {
      size: width,
      p: 'x'
    };

    if (stngs.orientation === 'vertical') {
      var temp = extend(true, {}, major);
      major = extend(true, {}, minor);
      minor = extend(true, {}, temp);
    }

    areaGenerator[major.p](function (d) {
      return d.major * major.size;
    }) // eslint-disable-line no-unexpected-multiline
    ["".concat(minor.p, "1")](function (d) {
      return d.minor * minor.size;
    }) // eslint-disable-line no-unexpected-multiline
    ["".concat(minor.p, "0")](function (d) {
      return d.minor0 * minor.size;
    }) // eslint-disable-line no-unexpected-multiline
    .defined(function (d) {
      return typeof d.minor === 'number' && !isNaN(d.minor);
    }).curve(CURVES[layerObj.curve === 'monotone' ? "monotone".concat(major.p) : layerObj.curve]);
    lineGenerator = areaGenerator["line".concat(minor.p.toUpperCase(), "1")]();
    secondaryLineGenerator = areaGenerator["line".concat(minor.p.toUpperCase(), "0")](); // area layer

    if (layerStngs.area && areaObj.show !== false) {
      nodes.push(createDisplayLayer(points, {
        data: layer.firstPoint,
        item: areaObj,
        generator: areaGenerator
      }));
    } // main line layer


    if (lineObj && lineObj.show !== false) {
      nodes.push(createDisplayLayer(points, {
        data: layer.firstPoint,
        item: lineObj,
        generator: lineGenerator
      }, 'none')); // secondary line layer, used only when rendering area

      if (!missingMinor0 && layerStngs.area && areaObj.show !== false) {
        nodes.push(createDisplayLayer(points, {
          data: layer.firstPoint,
          item: lineObj,
          generator: secondaryLineGenerator
        }, 'none'));
      }
    }
  });
  return nodes;
}

function resolve$1(_ref3) {
  var data = _ref3.data,
      stngs = _ref3.stngs,
      rect = _ref3.rect,
      resolver = _ref3.resolver,
      style = _ref3.style;
  var width = rect.width,
      height = rect.height;
  var coordinates = resolver.resolve({
    data: data,
    defaults: SETTINGS.coordinates,
    settings: stngs.coordinates || {},
    scaled: {
      major: stngs.orientation === 'vertical' ? height : width,
      minor: stngs.orientation === 'vertical' ? width : height
    }
  }); // collect points into layers

  var layerIds = {};
  var numLines = 0;

  for (var i = 0; i < coordinates.items.length; i++) {
    var p = coordinates.items[i];
    var lid = p.layerId;
    layerIds[lid] = layerIds[lid] || {
      order: numLines++,
      id: lid,
      items: [],
      firstPoint: p.data
    };
    layerIds[lid].items.push(p);
  }

  var metaLayers = Object.keys(layerIds).map(function (lid) {
    return layerIds[lid];
  });
  var layersData = {
    items: metaLayers.map(function (layer) {
      return layer.firstPoint;
    })
  };
  var layerStngs = stngs.layers || {};
  var layersResolved = resolver.resolve({
    data: layersData,
    defaults: {
      curve: SETTINGS.layers.curve,
      show: SETTINGS.layers.show
    },
    settings: {
      curve: layerStngs.curve,
      show: layerStngs.show
    }
  });
  var linesResolved = resolver.resolve({
    data: layersData,
    defaults: extend({}, SETTINGS.layers.line, style.line),
    settings: layerStngs.line
  });
  var areasResolved = resolver.resolve({
    data: layersData,
    defaults: extend({}, SETTINGS.layers.area, style.area),
    settings: layerStngs.area
  });
  return {
    coordinates: coordinates,
    metaLayers: metaLayers,
    layers: layersResolved,
    lines: linesResolved,
    areas: areasResolved
  };
}

function calculateVisibleLayers(opts) {
  var _resolve = resolve$1(opts),
      metaLayers = _resolve.metaLayers,
      coordinates = _resolve.coordinates,
      layers = _resolve.layers,
      lines = _resolve.lines,
      areas = _resolve.areas;

  var visibleLayers = [];
  metaLayers.forEach(function (layer, ix) {
    var layerObj = layers.items[ix];

    if (layerObj.show === false) {
      return;
    } // layerObj.points = [];


    layerObj.datum = layerObj.data;
    layerObj.data = [];
    layerObj.id = layer.id;
    var values = [];
    var points = [];
    var point;
    var pData;

    for (var i = 0; i < layer.items.length; i++) {
      point = layer.items[i];
      pData = point.data;

      if (isNaN(point.major)) {
        continue;
      }

      if (opts.missingMinor0) {
        point.minor0 = coordinates.settings.minor.scale ? coordinates.settings.minor.scale(pData.minor0 ? pData.minor0.value : 0) : 0;
      }

      if (!isNaN(point.minor)) {
        values.push(point.minor);
      }

      points.push(point);
      layerObj.data.push(point.data);
    }

    var median = values.sort(function (a, b) {
      return a - b;
    })[Math.floor((values.length - 1) / 2)];
    visibleLayers.push({
      layerObj: layerObj,
      lineObj: lines.items[ix],
      areaObj: areas.items[ix],
      median: median,
      points: points,
      firstPoint: layer.firstPoint
    });
  });
  return visibleLayers;
}

var lineMarkerComponent = {
  require: ['chart', 'resolver'],
  defaultSettings: {
    style: {
      area: '$shape',
      line: '$shape-outline'
    }
  },
  created: function created() {},
  render: function render(_ref4) {
    var data = _ref4.data;
    var _this$rect = this.rect,
        width = _this$rect.width,
        height = _this$rect.height;
    this.stngs = this.settings.settings || {};
    var missingMinor0 = !this.stngs.coordinates || typeof this.stngs.coordinates.minor0 === 'undefined';
    var visibleLayers = calculateVisibleLayers({
      data: data,
      stngs: this.stngs,
      rect: this.rect,
      resolver: this.resolver,
      style: this.style,
      missingMinor0: missingMinor0
    });

    if (this.stngs.layers && this.stngs.layers.sort) {
      var sortable = visibleLayers.map(function (v) {
        return {
          id: v.layerObj.id,
          data: v.layerObj.data
        };
      });
      sortable.sort(this.stngs.layers.sort).map(function (s) {
        return s.id;
      });
      visibleLayers.sort(function (a, b) {
        return sortable.indexOf(b.layerObj.id) - sortable.indexOf(a.layerObj.id);
      });
    } else {
      visibleLayers.sort(function (a, b) {
        return a.median - b.median;
      });
    } // generate visuals


    return createDisplayLayers(visibleLayers, {
      width: width,
      height: height,
      missingMinor0: missingMinor0,
      stngs: this.stngs
    });
  }
};

/**
 * @typedef {object} component--line
 */

/**
 * @type {string}
 * @memberof component--line
 */

var type$3 = 'line';
function line$2(picasso) {
  picasso.component(type$3, lineMarkerComponent);
}

/**
 * @typedef {object} component--brush-area-brush
 * @property {string} key - Component key
 * @property {string[]} [contexts] - Name of the brushing contexts to affect
 * @property {string[]} [data] - The mapped data properties to add to the brush
 * @property {string} [action='set'] - Type of action to respond with
 */

/**
  * @typedef {object}
  * @alias component--brush-area-settings
  */

var DEFAULT_SETTINGS$7 = {
  /**
   * @type {object}
   */
  brush: {
    /**
    * @type {Array<component--brush-area-brush>}
    */
    components: []
  }
};
/**
 * Transform the incoming event into point in the local coordinate system. That is the coordinate system of the component.
 * @private
 * @param {object} ctx - Context
 * @param {object} event - Incoming event, either native event or hammer event
 * @param {boolean} clamp - True to clamp the point inside the component bounds
 * @returns {point}
 */

function getLocalPoint(ctx, event) {
  var clamp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var x;
  var y;

  if (_typeof(event.center) === 'object') {
    x = event.center.x;
    y = event.center.y;
  } else {
    x = event.clientX;
    y = event.clientY;
  }

  var localX = x - ctx.state.boundingRect.left;
  var localY = y - ctx.state.boundingRect.top;
  return {
    x: clamp ? Math.max(0, Math.min(localX, ctx.rect.width)) : localX,
    y: clamp ? Math.max(0, Math.min(localY, ctx.rect.height)) : localY
  };
}
/**
 * Transform a local point into a point in the chart coordinate system.
 * @private
 * @param {object} ctx - Context
 * @param {object} p - Point to transform
 * @returns {point}
 */


function localToChartPoint(ctx, p) {
  return {
    x: p.x + ctx.rect.x,
    y: p.y + ctx.rect.y
  };
}
/**
 * Extract and apply default brush configuration.
 * @private
 * @param {object} settings
 * @returns {object[]} An Array of brush configurations
 */


function getBrushConfig$1(settings) {
  return settings.settings.brush.components.map(function (b) {
    return {
      key: b.key,
      contexts: b.contexts,
      data: b.data,
      action: b.action || 'set'
    };
  });
}
/**
 * End all active brush contexts.
 * @private
 * @param {oject} state
 * @param {object} chart - Chart instance
 */


function doEndBrush(state, chart) {
  state.brushConfig.forEach(function (config) {
    if (Array.isArray(config.contexts)) {
      config.contexts.forEach(function (context) {
        chart.brush(context).end();
      });
    }
  });
}
/**
 * Convert two points into a rectangle.
 * @private
 * @param {point} p0
 * @param {point} p1
 * @returns {rect}
 */


function toRect(p0, p1) {
  var xMin = Math.min(p0.x, p1.x);
  var yMin = Math.min(p0.y, p1.y);
  var xMax = Math.max(p0.x, p1.x);
  var yMax = Math.max(p0.y, p1.y);
  return {
    x: xMin,
    y: yMin,
    width: xMax - xMin,
    height: yMax - yMin
  };
}
/**
 * Perform a brush on the given area.
 * @private
 * @param {object} ctx
 */


function doAreaBrush(ctx) {
  if (ctx.state.active) {
    var start = localToChartPoint(ctx, ctx.state.start);
    var end = localToChartPoint(ctx, ctx.state.end);
    var shapes = ctx.chart.shapesAt(toRect(start, end), {
      components: ctx.state.brushConfig
    });
    ctx.chart.brushFromShapes(shapes, {
      components: ctx.state.brushConfig
    });
  }
}

function render$2(ctx) {
  ctx.renderer.render([extend({
    type: 'rect'
  }, toRect(ctx.state.start, ctx.state.end), ctx.style.area)]);
}

function resetState$1() {
  return {
    start: {
      x: 0,
      y: 0
    },
    end: {
      x: 0,
      y: 0
    },
    active: false
  };
}

var definition = {
  require: ['chart', 'renderer'],
  defaultSettings: {
    layout: {
      displayOrder: 99
    },
    settings: DEFAULT_SETTINGS$7,
    style: {
      area: '$selection-area-target'
    }
  },
  on: {
    areaStart: function areaStart(e) {
      this.start(e);
    },
    areaMove: function areaMove(e) {
      this.move(e);
    },
    areaEnd: function areaEnd(e) {
      this.end(e);
    },
    areaCancel: function areaCancel() {
      this.cancel();
    }
  },
  created: function created() {
    this.state = resetState$1();
  },
  preferredSize: function preferredSize() {
    return 0;
  },
  render: function render() {},
  start: function start(e) {
    this.state.boundingRect = this.renderer.element().getBoundingClientRect();
    var p = getLocalPoint(this, e, false); // Require event to be inside the component bounds

    if (!testRectPoint({
      x: 0,
      y: 0,
      width: this.rect.width,
      height: this.rect.height
    }, p)) {
      return;
    }

    this.state.brushConfig = getBrushConfig$1(this.settings);
    this.state.start = getLocalPoint(this, e);
    this.state.active = true;
  },
  move: function move(e) {
    if (!this.state.active) {
      return;
    }

    this.state.end = getLocalPoint(this, e);
    doAreaBrush(this);
    render$2(this);
  },
  end: function end() {
    if (!this.state.active) {
      return;
    }

    this.state = resetState$1();
    this.renderer.render([]);
  },
  cancel: function cancel() {
    if (!this.state.active) {
      return;
    }

    doEndBrush(this.state, this.chart);
    this.state = resetState$1();
    this.renderer.render([]);
  }
};

function areaBrush(picasso) {
  picasso.component('brush-area', definition);
}

function extractor(nodes, _ref) {
  var chart = _ref.chart,
      scale = _ref.scale,
      props = _ref.props,
      h = _ref.h;
  var dataCtx = {
    resources: {
      dataset: chart.dataset,
      scale: chart.scale,
      formatter: chart.formatter
    },
    scale: scale,
    h: h
  };
  var data = [];
  nodes.forEach(function (node) {
    if (typeof props.extract === 'function') {
      var ctx = extend({
        node: node
      }, dataCtx);
      data.push(props.extract(ctx));
    }
  });
  return data;
}

function resolveClasses(props, opts) {
  return {
    tooltip: typeof props.tooltipClass === 'function' ? props.tooltipClass({
      dock: opts.dock
    }) : props.tooltipClass,
    content: typeof props.contentClass === 'function' ? props.contentClass({
      dock: opts.dock
    }) : props.contentClass,
    arrow: typeof props.arrowClass === 'function' ? props.arrowClass({
      dock: opts.dock
    }) : props.arrowClass
  };
}

function resolveContent(h, data, style, props) {
  return props.content({
    h: h,
    style: style,
    data: data
  });
}

function render$3(data, placement, _ref) {
  var renderer = _ref.renderer,
      style = _ref.style,
      props = _ref.props,
      h = _ref.h;
  var classes = resolveClasses(props, placement);
  var content = resolveContent(h, data, style, props);
  var tooltipDefaultStyle = {
    position: 'relative',
    display: 'inline-block'
  };
  var tooltipNode = h("div", {
    dir: props.direction,
    class: classString(extend({
      'pic-tooltip': true
    }, classes.tooltip)),
    style: extend(tooltipDefaultStyle, placement.computedTooltipStyle)
  }, h("div", {
    style: style.content,
    class: classString(extend({
      'pic-tooltip-content': true
    }, classes.content))
  }, content), h("div", {
    class: classString(extend({
      'pic-tooltip-arrow': true
    }, classes.arrow)),
    style: extend({}, style.arrow, style["arrow-".concat(placement.dock)], placement.computedArrowStyle)
  }));
  renderer.render(tooltipNode);
  return renderer.element().children[0];
}

// Successfull flow: pending -> active -> fulfilled (only with duration)
// Cancelled flow: pending -> active -> cancelled
// Rejected flow: pending -> rejected
// Debounced flow: pending -> debounced -> pending -> [rejected|fulfilled]
function dispatcherState() {
  var fn = function fn() {};

  var on = {
    pending: [],
    debounced: [],
    active: [],
    cancelled: [],
    rejected: [],
    fulfilled: []
  };
  var state;

  fn.set = function (s) {
    state = s;
    on[state].forEach(function (event) {
      return event(s);
    });
  };

  fn.on = function (key, event) {
    if (Array.isArray(key)) {
      key.forEach(function (k) {
        return on[k].push(event);
      });
    } else {
      on[key].push(event);
    }
  };

  fn.destroy = function () {
    Object.keys(on).forEach(function (key) {
      on[key].length = 0;
    });
  }; // fn.on(['pending', 'debounced', 'active', 'cancelled', 'rejected', 'fulfilled'], (e) => {
  //   console.log(e);
  // });


  return fn;
}

function timeSpanDispatcher(_ref) {
  var defaultDuration = _ref.defaultDuration,
      defaultDelay = _ref.defaultDelay;
  var actionId = null;
  var fulfilledId = null;
  var isActive = false;
  var state = dispatcherState();

  var fn = function fn() {};

  var fulfilled = function fulfilled() {
    actionId = null;
    fulfilledId = null;
    isActive = false;
    state.set('fulfilled');
  };

  fn.invoke = function (action) {
    var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultDuration;
    var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultDelay;

    if (actionId) {
      clearTimeout(actionId);
      state.set('debounced');
    }

    state.set('pending');
    actionId = setTimeout(function () {
      action();
      isActive = true;
      actionId = null;
      state.set('active');
    }, delay);

    if (duration > 0) {
      if (fulfilledId) {
        clearTimeout(fulfilledId);
      }

      fulfilledId = setTimeout(fulfilled, duration + Math.max(delay, 0));
    }
  };

  fn.clear = function () {
    if (isActive) {
      state.set('cancelled');
    } else if (actionId) {
      clearTimeout(actionId);
      state.set('rejected');
    }

    if (fulfilledId) {
      clearTimeout(fulfilledId);
    }

    actionId = null;
    fulfilledId = null;
    isActive = false;
  };

  fn.on = function (key, event) {
    state.on(key, event);
  };

  fn.destroy = function () {
    fn.clear();
    state.destroy();
  };

  return fn;
}

function getDockTransform() {
  var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  return {
    left: "translate(-100%,-50%) translateX(".concat(-offset, "px)"),
    right: "translate(".concat(offset, "px, -50%)"),
    top: "translate(-50%, -100%) translateY(".concat(-offset, "px)"),
    bottom: "translate(-50%, ".concat(offset, "px)")
  };
}

function getDockOffset(width, height) {
  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  return {
    left: {
      x: -width - offset,
      y: -height / 2
    },
    right: {
      x: offset,
      y: -height / 2
    },
    top: {
      x: -width / 2,
      y: -height - offset
    },
    bottom: {
      x: -width / 2,
      y: offset
    }
  };
}

function getComputedArrowStyle(offset) {
  return {
    left: {
      left: '100%',
      top: "calc(50% - ".concat(offset, "px)"),
      borderWidth: "".concat(offset, "px")
    },
    right: {
      left: "".concat(-offset * 2, "px"),
      top: "calc(50% - ".concat(offset, "px)"),
      borderWidth: "".concat(offset, "px")
    },
    top: {
      left: "calc(50% - ".concat(offset, "px)"),
      top: '100%',
      borderWidth: "".concat(offset, "px")
    },
    bottom: {
      left: "calc(50% - ".concat(offset, "px)"),
      top: "".concat(-offset * 2, "px"),
      borderWidth: "".concat(offset, "px")
    }
  };
}

function isInsideArea(area, vx, vy, width, height, offset) {
  var rect = {
    x: vx + offset.x,
    y: vy + offset.y,
    width: width,
    height: height
  };

  if (rect.x < 0 || rect.y < 0) {
    return false;
  }

  if (rect.x + rect.width > area.width || rect.y + rect.height > area.height) {
    return false;
  }

  return true;
}
/**
 * @param {vx} vx X-coordinate realative to the area
 * @param {vy} vy Y-coordinate realative to the area
 */


function calcOffset(_ref) {
  var area = _ref.area,
      vx = _ref.vx,
      vy = _ref.vy,
      width = _ref.width,
      height = _ref.height,
      offset = _ref.offset;
  var rect = {
    x: vx + offset.x,
    y: vy + offset.y,
    width: width,
    height: height
  };
  var offsetX = rect.x < 0 ? -rect.x : 0;
  var offsetY = rect.y < 0 ? -rect.y : 0;
  offsetX += rect.x + rect.width > area.width ? -(rect.x + rect.width - area.width) : 0;
  offsetY += rect.y + rect.height > area.height ? -(rect.y + rect.height - area.height) : 0;
  return {
    x: offsetX,
    y: offsetY
  };
}

function alignToBounds(_ref2) {
  var resources = _ref2.resources,
      nodes = _ref2.nodes,
      pointer = _ref2.pointer,
      elmWidth = _ref2.width,
      elmHeight = _ref2.height,
      options = _ref2.options;
  var targetBounds = pointer.targetBounds;

  var _resources$getNodeBou = resources.getNodeBoundsRelativeToTarget(nodes[0]),
      x = _resources$getNodeBou.x,
      y = _resources$getNodeBou.y,
      width = _resources$getNodeBou.width,
      height = _resources$getNodeBou.height;

  var docks = {
    left: {
      x: x,
      y: y + height / 2
    },
    right: {
      x: x + width,
      y: y + height / 2
    },
    top: {
      x: x + width / 2,
      y: y
    },
    bottom: {
      x: x + width / 2,
      y: y + height
    }
  }; // Check if explicit dock

  var dockTransforms = getDockTransform(options.offset);
  var transform = dockTransforms[options.dock];

  if (transform) {
    return {
      computedTooltipStyle: {
        left: "".concat(docks[options.dock].x, "px"),
        top: "".concat(docks[options.dock].y, "px"),
        transform: transform
      },
      computedArrowStyle: getComputedArrowStyle(options.offset)[options.dock],
      dock: options.dock
    };
  }

  var area = {
    width: options.area === 'target' ? targetBounds.width : window.innerWidth,
    height: options.area === 'target' ? targetBounds.height : window.innerHeight
  };
  var dockOffsets = getDockOffset(elmWidth, elmHeight, options.offset);
  var dockOrder = ['top', 'left', 'right', 'bottom'];

  for (var i = 0; i < dockOrder.length; i += 1) {
    var dock = dockOrder[i];
    var vx = options.area === 'target' ? docks[dock].x : targetBounds.left + docks[dock].x;
    var vy = options.area === 'target' ? docks[dock].y : targetBounds.top + docks[dock].y;

    if (isInsideArea(area, vx, vy, elmWidth, elmHeight, dockOffsets[dock])) {
      return {
        computedTooltipStyle: {
          left: "".concat(docks[dock].x, "px"),
          top: "".concat(docks[dock].y, "px"),
          transform: dockTransforms[dock]
        },
        computedArrowStyle: getComputedArrowStyle(options.offset)[dock],
        dock: dock
      };
    }
  }

  return {
    computedTooltipStyle: {
      left: "".concat(docks.top.x, "px"),
      top: "".concat(docks.top.y, "px"),
      transform: dockTransforms.top
    },
    computedArrowStyle: getComputedArrowStyle(options.offset).top,
    dock: 'top'
  };
}

function alignToPoint(_ref3) {
  var options = _ref3.options,
      pointer = _ref3.pointer,
      width = _ref3.width,
      height = _ref3.height,
      dockOrder = _ref3.dockOrder,
      x = _ref3.x,
      y = _ref3.y;
  var targetBounds = pointer.targetBounds; // Check if explicit dock

  var dockTransforms = getDockTransform(options.offset);
  var transform = dockTransforms[options.dock];

  if (transform) {
    return {
      computedTooltipStyle: {
        left: "".concat(x, "px"),
        top: "".concat(y, "px"),
        transform: transform
      },
      computedArrowStyle: getComputedArrowStyle(options.offset)[options.dock],
      dock: options.dock
    };
  }

  var area = {
    width: options.area === 'target' ? targetBounds.width : window.innerWidth,
    height: options.area === 'target' ? targetBounds.height : window.innerHeight
  };
  var dockOffsets = getDockOffset(width, height, options.offset);
  var results = [];
  var edgeMargin = 20;
  var vx = options.area === 'target' ? x : targetBounds.left + x;
  var vy = options.area === 'target' ? y : targetBounds.top + y;

  for (var i = 0; i < dockOrder.length; i += 1) {
    var dock = dockOrder[i];
    var offset = calcOffset({
      area: area,
      vx: vx,
      vy: vy,
      width: width,
      height: height,
      offset: dockOffsets[dock]
    });
    var computedTooltipStyle = {
      left: "".concat(x, "px"),
      top: "".concat(y, "px"),
      transform: dockTransforms[dock]
    };
    var computedArrowStyle = getComputedArrowStyle(options.offset)[dock];

    if (offset.x !== 0) {
      computedTooltipStyle.width = "".concat(width - edgeMargin - Math.abs(offset.x), "px");

      if (dock === 'top' || dock === 'bottom') {
        computedTooltipStyle.left = "".concat(x + offset.x, "px");
        computedArrowStyle.left = "calc(50% ".concat(offset.x > 0 ? '-' : '+', " ").concat(Math.abs(offset.x), "px)");
      }
    }

    var result = {
      computedTooltipStyle: computedTooltipStyle,
      computedArrowStyle: computedArrowStyle,
      dock: dock,
      rect: {
        width: width,
        height: height
      }
    };

    if (offset.x === 0 && offset.y === 0) {
      return result;
    }

    result.offset = offset;
    results.push(result);
  }

  results.sort(function (a, b) {
    return Math.abs(a.offset.x) - Math.abs(b.offset.x);
  });
  return results[0];
}

function alignToPointer(_ref4) {
  var options = _ref4.options,
      pointer = _ref4.pointer,
      width = _ref4.width,
      height = _ref4.height;
  var x = pointer.x,
      y = pointer.y;
  return alignToPoint({
    x: x,
    y: y,
    pointer: pointer,
    width: width,
    height: height,
    options: options,
    dockOrder: ['top', 'left', 'right', 'bottom']
  });
}

function alignToSlice(_ref5) {
  var options = _ref5.options,
      pointer = _ref5.pointer,
      width = _ref5.width,
      height = _ref5.height,
      nodes = _ref5.nodes,
      resources = _ref5.resources;
  var node = nodes[0];
  var dx = pointer.dx,
      dy = pointer.dy;
  var componentBounds = resources.getComponentBoundsFromNode(node); // cx and cy relative to targetBounds

  var center = {
    x: dx + componentBounds.x + componentBounds.width / 2,
    y: dy + componentBounds.y + componentBounds.height / 2
  };
  var _node$desc$slice = node.desc.slice,
      start = _node$desc$slice.start,
      end = _node$desc$slice.end,
      outerRadius = _node$desc$slice.outerRadius; // Node origin is at 12 o clock, clockwise, but Math uses 3 a clock, so it's transformed to origin at 3 a clock

  var middle = (start + end) / 2 - Math.PI / 2;
  var PI2 = Math.PI * 2;
  var radians = (middle % PI2 + PI2) % PI2;
  var dockOrder = ['top', 'left', 'right', 'bottom'];

  if (options.dock === 'auto') {
    if (radians <= Math.PI / 4 || radians >= Math.PI * 7 / 4) {
      dockOrder = ['right', 'top', 'bottom', 'left'];
    } else if (radians <= Math.PI * 3 / 4) {
      dockOrder = ['bottom', 'left', 'right', 'top'];
    } else if (radians <= Math.PI * 5 / 4) {
      dockOrder = ['left', 'top', 'bottom', 'right'];
    } else {
      dockOrder = ['top', 'left', 'right', 'bottom'];
    }
  }

  return alignToPoint({
    x: center.x + outerRadius * componentBounds.scaleRatio.x * Math.cos(radians),
    y: center.y + outerRadius * componentBounds.scaleRatio.y * Math.sin(radians),
    pointer: pointer,
    width: width,
    height: height,
    options: options,
    dockOrder: dockOrder
  });
}

function _getComponentBoundsFromNode(node, pointer, chart) {
  var comp = node.key ? chart.component(node.key) : chart.componentsFromPoint({
    x: pointer.clientX,
    y: pointer.clientY
  })[0];

  if (!comp) {
    return {
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      scaleRatio: {
        x: 1,
        y: 1
      }
    };
  }

  var componentSize = comp.rect;
  return extend({
    scaleRatio: componentSize.scaleRatio
  }, componentSize.computedInner);
}

function _getNodeBoundsRelativeToTarget(node, pointer, chart) {
  var componentBounds = _getComponentBoundsFromNode(node, pointer, chart);

  var bounds = node.bounds;
  return {
    x: componentBounds.x + pointer.dx + bounds.x,
    y: componentBounds.y + pointer.dy + bounds.y,
    width: bounds.width,
    height: bounds.height
  };
}

var STRATEGIES = {
  bounds: alignToBounds,
  pointer: alignToPointer,
  slice: alignToSlice
};
function placement(_ref6, _ref7) {
  var width = _ref6.width,
      height = _ref6.height;
  var chart = _ref7.chart,
      state = _ref7.state,
      props = _ref7.props;
  var propCtx = {
    resources: {
      formatter: chart.formatter,
      scale: chart.scale,
      component: chart.component,
      getComponentBoundsFromNode: function getComponentBoundsFromNode(node) {
        return _getComponentBoundsFromNode(node, state.pointer, chart);
      },
      getNodeBoundsRelativeToTarget: function getNodeBoundsRelativeToTarget(node) {
        return _getNodeBoundsRelativeToTarget(node, state.pointer, chart);
      }
    },
    nodes: state.activeNodes,
    pointer: state.pointer,
    width: width,
    height: height
  };

  var type = _typeof(props.placement);

  if (type === 'object' && typeof props.placement.fn === 'function') {
    // Custom placement strategy function
    return props.placement.fn(propCtx);
  }

  var opts = {
    type: 'pointer',
    offset: 8,
    dock: 'auto',
    area: 'viewport'
  };

  if (type === 'function') {
    // Custom placement function
    opts = extend(opts, props.placement(propCtx));
  }

  if (type === 'object' && STRATEGIES[props.placement.type]) {
    // Predefined placement function with options
    opts = extend(opts, props.placement);
  } else if (type === 'string' && STRATEGIES[props.placement]) {
    // Predefined placement function without options
    opts = extend(opts, {
      type: props.placement
    });
  }

  propCtx.options = opts;
  var plcm = STRATEGIES[opts.type](propCtx);

  var _propCtx$resources$ge = propCtx.resources.getComponentBoundsFromNode(propCtx.nodes[0]),
      minX = _propCtx$resources$ge.x,
      minY = _propCtx$resources$ge.y,
      maxX = _propCtx$resources$ge.width,
      maxY = _propCtx$resources$ge.height;

  minX += propCtx.pointer.dx;
  maxX += minX;
  minY += propCtx.pointer.dy;
  maxY += minY; // Clamp tooltip position

  plcm.computedTooltipStyle.left = "".concat(Math.min(Math.max(0, minX, parseFloat(plcm.computedTooltipStyle.left)), maxX), "px");
  plcm.computedTooltipStyle.top = "".concat(Math.min(Math.max(0, minY, parseFloat(plcm.computedTooltipStyle.top)), maxY), "px");
  return plcm;
}

var instance;
function setActive(action) {
  instance = action;
}
function removeActive(action) {
  if (instance === action) {
    instance = null;
    return true;
  }

  return false;
}
function cancelActive(a) {
  if (instance && instance !== a) {
    instance();
  }
}
function remove$1() {
  instance = null;
}

/**
 * @typedef {object}
 * @alias component--tooltip.settings
 */

var DEFAULT_SETTINGS$8 = {
  /**
   * How long the tooltip is visible, in milliseconds
   * @type {number=}
   */
  duration: 8000,

  /**
   * Delay before the tooltip is rendered, in milliseconds
   * @type {number=}
   */
  delay: 500,

  /**
   * Reduce incoming nodes to only a set of applicable nodes. Is called as a part of the `show` event.
   * @type {function=}
   * @returns {array} An array of nodes
   */
  filter: function filter(nodes) {
    return nodes.filter(function (node) {
      return node.data && typeof node.data.value !== 'undefined';
    });
  },

  /**
   * Extract data from a node.
   * @type {function=}
   * @returns {object} An array of data
   */
  extract: function extract(ctx) {
    return ctx.node.data.value;
  },

  /**
   * Content generator. Extracted data is available in the `data` property, where each value in the area is the extracted datum from a node.
   * @type {function=}
   * @returns {object[]} Array of h objects
   */
  content: function content(_ref) {
    var h = _ref.h,
        data = _ref.data;
    return data.map(function (datum) {
      return h('div', {}, datum);
    });
  },

  /**
   * Comparison function. If evaluted to true, the incoming nodes in the `show` event are ignored. If evaluated to false, any active tooltip is cleared and a new tooltip is queued.
   *
   * The function gets two parameters, the first is the currently active set of nodes, if any, and the second is the incoming set of nodes. By default the two set of nodes are considered equal if their data attributes are the same.
   * @type {function=}
   * @returns {boolean}
   */
  isEqual: function isEqual(prev, curr) {
    return prev.length && prev.length === curr.length && prev.every(function (p, i) {
      return curr[i] && JSON.stringify(p.data) === JSON.stringify(curr[i].data);
    });
  },

  /**
   * @typedef {object=}
   */
  placement: {
    /**
     * Available types: [pointer | bounds | slice]
     * @type {string=}
     */
    type: 'pointer',

    /**
     * Docking position of the tooltip. Available positions: [left | right | top | bottom | auto]
     * @type {string=}
     */
    dock: 'auto',

    /**
     * Distance from the content area to the tooltip position, in px.
     * @type {number=}
     */
    offset: 8,

    /**
     * Specify the limiting area, where target is the component area unless the appendTo property is set, in which case it referes to the appendTo element. Viewport is the browser viewport.
     *
     * Available options are: [viewport | target]
     * @type {number=}
     */
    area: 'viewport'
  },

  /**
   * Set tooltip class.
  * @type {object<string, boolean>=}
  */
  tooltipClass: {},

  /**
   * Set content class.
  * @type {object<string, boolean>=}
  */
  contentClass: {},

  /**
   * Set arrow class.
  * @type {object<string, boolean>=}
  */
  arrowClass: {},

  /**
   * Content direction [ltr | rtl]
   * @type {string=}
   */
  direction: 'ltr',

  /**
   * Explicitly set a target element. This allows the tooltip to attach itself outside the picasso container.
   * @type {HTMLElement=}
   */
  appendTo: undefined,

  /**
   * Component lifecycle hook. Called before the tooltip is displayed.
   * @type {function=}
   */
  beforeShow: undefined,

  /**
   * Component lifecycle hook. Called after the tooltip have been displayed.
   * @type {function=}
   */
  afterShow: undefined,

  /**
   * Component lifecycle hook. Called before the tooltip is hidden.
   * @type {function=}
   */
  beforeHide: undefined,

  /**
   * Component lifecycle hook. Called when the toolip is hidden. By default this deletes the tooltip element.
   * @type {function=}
   */
  onHide: undefined,

  /**
   * Component lifecycle hook. Called after the tooltip is hidden.
   * @type {function=}
   */
  afterHide: undefined
};
var DEFAULT_STYLE = {
  tooltip: {},
  content: {
    backgroundColor: '$gray-25',
    color: '$font-color--inverted',
    fontFamily: '$font-family',
    fontSize: '$font-size',
    lineHeight: '$line-height',
    borderRadius: '4px',
    padding: '8px',
    opacity: 0.9
  },
  arrow: {
    position: 'absolute',
    width: '0px',
    height: '0px',
    borderStyle: 'solid',
    color: '$gray-25',
    opacity: 0.9
  },
  'arrow-bottom': {
    borderTopColor: 'transparent',
    borderLeftColor: 'transparent',
    borderRightColor: 'transparent'
  },
  'arrow-top': {
    borderBottomColor: 'transparent',
    borderLeftColor: 'transparent',
    borderRightColor: 'transparent'
  },
  'arrow-right': {
    borderTopColor: 'transparent',
    borderLeftColor: 'transparent',
    borderBottomColor: 'transparent'
  },
  'arrow-left': {
    borderTopColor: 'transparent',
    borderBottomColor: 'transparent',
    borderRightColor: 'transparent'
  }
};

function toPoint(event, _ref2) {
  var chart = _ref2.chart,
      state = _ref2.state;
  var x = 0;
  var y = 0;

  if (event.center) {
    x += event.center.x;
    y += event.center.y;
  } else {
    x += event.clientX;
    y += event.clientY;
  } // TODO Don't do getBoundingClientRect lookup here. It's performance heavy.


  var chartBounds = chart.element.getBoundingClientRect();
  var targetBounds = state.targetElement.getBoundingClientRect();
  var clientX = x;
  var clientY = y;
  var dx = chartBounds.left - targetBounds.left;
  var dy = chartBounds.top - targetBounds.top;
  var cx = x - chartBounds.left;
  var cy = y - chartBounds.top;
  x -= targetBounds.left;
  y -= targetBounds.top;
  return {
    x: x,
    // Target point relative to the target bounds
    y: y,
    dx: dx,
    // Delta from target bounds to the chart bounds
    dy: dy,
    cx: cx,
    // Target point relative to the chart bounds
    cy: cy,
    clientX: clientX,
    clientY: clientY,
    targetBounds: targetBounds,
    // Target bounding rect
    chartBounds: chartBounds // Chart bounding rect

  };
}

var component$3 = {
  require: ['chart', 'renderer'],
  defaultSettings: {
    settings: DEFAULT_SETTINGS$8,
    style: DEFAULT_STYLE
  },
  renderer: 'dom',
  on: {
    hide: function hide() {
      this.hide();
    },
    show: function show(event) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.show(event, opts);
    },
    prevent: function prevent(p) {
      this.prevent(p);
    }
  },
  hide: function hide() {
    this.dispatcher.clear();
    this.state.activeNodes = [];
    this.state.pointer = {};
  },
  show: function show(event) {
    var _this = this;

    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        nodes = _ref3.nodes,
        duration = _ref3.duration,
        delay = _ref3.delay;

    if (this.state.prevent) {
      return;
    } // Set pointer here to always expose latest pointer to invokeRenderer


    this.state.pointer = toPoint(event, this);
    var fNodes;

    if (Array.isArray(nodes)) {
      fNodes = this.props.filter(nodes);
    } else {
      fNodes = this.props.filter(this.chart.shapesAt({
        x: this.state.pointer.cx,
        y: this.state.pointer.cy
      }));
    }

    if (this.props.isEqual(this.state.activeNodes, fNodes)) {
      return;
    }

    this.dispatcher.clear();
    this.state.activeNodes = fNodes;

    if (this.state.activeNodes.length) {
      this.dispatcher.invoke(function () {
        return _this.invokeRenderer(_this.state.activeNodes);
      }, duration, delay);
    }
  },
  prevent: function prevent(p) {
    this.state.prevent = !!p;
  },
  init: function init(settings) {
    var _this2 = this;

    this.state = {
      activeNodes: [],
      pointer: {},
      targetElement: null,
      prevent: false
    };
    this.props = settings.settings;
    this.dispatcher = timeSpanDispatcher({
      defaultDuration: this.props.duration,
      defaultDelay: this.props.delay
    });
    var instanceId = this.dispatcher.clear;
    this.dispatcher.on('pending', function () {
      // Cancel only if the active is another instance
      cancelActive(instanceId);
      setActive(instanceId);

      if (typeof _this2.props.beforeShow === 'function') {
        _this2.props.beforeShow.call(undefined, {
          resources: {
            formatter: _this2.chart.formatter,
            scale: _this2.chart.scale
          }
        });
      }
    });
    this.dispatcher.on(['cancelled', 'fulfilled'], function () {
      var listenerCtx = {
        resources: {
          formatter: _this2.chart.formatter,
          scale: _this2.chart.scale
        }
      };

      if (typeof _this2.props.beforeHide === 'function') {
        _this2.props.beforeHide.call(undefined, extend({
          element: _this2.state.tooltipElm
        }, listenerCtx));
      }

      if (typeof _this2.props.onHide === 'function') {
        _this2.props.onHide.call(undefined, extend({
          element: _this2.state.tooltipElm
        }, listenerCtx));
      } else {
        _this2.renderer.clear([]); // Hide tooltip

      }

      if (typeof _this2.props.afterHide === 'function') {
        _this2.props.afterHide.call(undefined, listenerCtx);
      }

      removeActive(instanceId);
      _this2.state.tooltipElm = undefined;
    });
    this.dispatcher.on('active', function () {
      if (typeof _this2.props.afterShow === 'function') {
        _this2.props.afterShow.call(undefined, {
          element: _this2.state.tooltipElm,
          resources: {
            formatter: _this2.chart.formatter,
            scale: _this2.chart.scale
          }
        });
      }
    });
  },
  created: function created() {
    this.init(this.settings);
  },
  beforeUpdate: function beforeUpdate(_ref4) {
    var settings = _ref4.settings;

    if (this.dispatcher) {
      this.dispatcher.destroy();
      remove$1();
    }

    this.init(settings);
  },
  render: function render(h) {
    this.h = h;
    return []; // Nothing to render initially.
  },
  beforeDestroy: function beforeDestroy() {
    this.dispatcher.destroy();
    remove$1();
  },
  appendTo: function appendTo() {
    if (this.props.appendTo) {
      this.state.targetElement = typeof this.props.appendTo === 'function' ? this.props.appendTo({
        resources: {
          formatter: this.chart.formatter,
          scale: this.chart.scale
        }
      }) : this.props.appendTo;

      var _this$state$targetEle = this.state.targetElement.getBoundingClientRect(),
          width = _this$state$targetEle.width,
          height = _this$state$targetEle.height;

      this.renderer.destroy();
      this.renderer.size({
        width: width,
        height: height
      });
      this.renderer.appendTo(this.state.targetElement);
    } else {
      this.state.targetElement = this.renderer.element();
    }
  },
  mounted: function mounted() {
    this.appendTo();
  },
  updated: function updated() {
    // Append here to, otherwise the picasso displayOrder logic screw things up
    this.appendTo();
  },
  invokeRenderer: function invokeRenderer(nodes) {
    var items = extractor(nodes, this);
    var pseudoElement = render$3(items, {
      style: {
        left: '0px',
        top: '0px',
        visibility: 'hidden'
      }
    }, this);
    var pos = placement(pseudoElement.getBoundingClientRect(), this);
    this.state.tooltipElm = render$3(items, pos, this);
  }
};

/**
 * @typedef {object} component--tooltip
 */

/**
 * @type {string}
 * @memberof component--tooltip
 */

var type$4 = 'tooltip';
function addTooltip(picasso) {
  picasso.component(type$4, component$3);
}

var debugColliderDef = {
  require: ['renderer', 'chart'],
  defaultSettings: {
    settings: {
      target: '',
      selector: '*',
      fill: 'rgba(0, 255, 0, 0.1)',
      stroke: 'lime',
      opacity: 1,
      useOuterRect: false
    }
  },
  on: {
    update: function update() {
      this.draw();
    }
  },
  draw: function draw() {
    var _this = this;

    var shapes = this.chart.findShapes(this.props.selector).filter(function (s) {
      return s.key === _this.props.target;
    }); // Find all shapes

    var colliders = shapes.filter(function (s) {
      return s.collider;
    }).map(function (s) {
      return s.collider;
    });
    colliders.forEach(function (c) {
      c.fill = _this.props.fill;
      c.stroke = _this.props.stroke;
      c.opacity = _this.props.opacity;
      c.collider = {
        type: null
      };
    });
    this.renderer.render(colliders);
  },
  created: function created() {
    this.props = this.settings.settings;
  },
  resize: function resize(_ref) {
    var outer = _ref.outer,
        inner = _ref.inner;

    if (this.props.useOuterRect) {
      return outer;
    }

    return inner;
  },
  render: function render() {},
  mounted: function mounted() {
    this.draw();
  },
  updated: function updated() {
    this.props = this.settings.settings;
    this.draw();
  }
};

var PI_X2 = Math.PI * 2;
/**
 * Implementation of F.6.5 https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes
 * @ignore
 * @param {number} rx - Arc x-radius
 * @param {number} ry - Arc y-radius
 * @param {number} rotation - Arc rotation in degrees (0-360)
 * @param {boolean} largeArcFlag
 * @param {boolean} sweepFlag
 * @param {number} endX - X-coordinate for end of arc
 * @param {number} endY - Y-coordinate for end of arc
 * @param {number} startX - X-coordinate for start of arc
 * @param {number} startY - Y-coordinate for start of arc
 * @returns {object}
 */

function arcToCenter(rx, ry, rotation, largeArcFlag, sweepFlag, endX, endY, startX, startY) {
  var startAngle;
  var endAngle;
  var sweepAngle;
  var cx;
  var cy;
  var radiusRatio;
  var rad = toRadians(rotation % 360); // F.6.5.1

  var cos = Math.cos(rad);
  var sin = Math.sin(rad);
  var hdx = (startX - endX) / 2;
  var hdy = (startY - endY) / 2;
  var x1d = cos * hdx + sin * hdy;
  var y1d = cos * hdy - sin * hdx; // F.6.6

  rx = Math.abs(rx);
  ry = Math.abs(ry);
  radiusRatio = Math.pow(x1d, 2) / Math.pow(rx, 2) + Math.pow(y1d, 2) / Math.pow(ry, 2);

  if (radiusRatio > 1) {
    radiusRatio = Math.sqrt(radiusRatio);
    rx *= radiusRatio;
    ry *= radiusRatio;
  } // F.6.5.2


  var rxry = rx * ry;
  var rxy1d = rx * y1d;
  var ryx1d = ry * x1d;
  var den = Math.pow(rxy1d, 2) + Math.pow(ryx1d, 2);
  var num = Math.pow(rxry, 2) - den;
  var frac = Math.sqrt(Math.max(num / den, 0));

  if (largeArcFlag === sweepFlag) {
    frac = -frac;
  }

  var cxd = frac * (rxy1d / ry);
  var cyd = frac * -(ryx1d / rx); // F.6.5.3

  var mx = (startX + endX) / 2;
  var my = (startY + endY) / 2;
  cx = cos * cxd - sin * cyd + mx;
  cy = sin * cxd + cos * cyd + my; // F.6.5.6 clockwise angle

  var ux = (x1d - cxd) / rx;
  var uy = (y1d - cyd) / ry;
  var vx = (-x1d - cxd) / rx;
  var vy = (-y1d - cyd) / ry;
  startAngle = Math.atan2(uy, ux);
  startAngle += startAngle < 0 ? PI_X2 : 0;
  endAngle = Math.atan2(vy, vx);
  endAngle += endAngle < 0 ? PI_X2 : 0;
  sweepAngle = endAngle - startAngle;

  if (!sweepFlag && startAngle < endAngle) {
    sweepAngle -= PI_X2;
  } else if (sweepFlag && endAngle < startAngle) {
    sweepAngle += PI_X2;
  }

  sweepAngle %= PI_X2;
  return {
    startAngle: startAngle,
    sweepAngle: sweepAngle,
    cx: cx,
    cy: cy,
    rx: rx,
    ry: ry
  };
}

/**
 * Measure the flatnass of a cubic bezier curve
 * @ignore
 * @param {point} s - Start point
 * @param {point} cp1 - First control point
 * @param {point} cp2 - Second control point
 * @param {point} e - End point
 */
function flatness(s, cp1, cp2, e) {
  var ux = Math.abs(s.x + cp2.x - (cp1.x + cp1.x));
  var uy = Math.abs(s.y + cp2.y - (cp1.y + cp1.y));
  var vx = Math.abs(cp1.x + e.x - (cp2.x + cp2.x));
  var vy = Math.abs(cp1.y + e.y - (cp2.y + cp2.y));
  return ux + uy + vx + vy;
}

function mid(p0, p1) {
  return {
    x: (p0.x + p1.x) / 2,
    y: (p0.y + p1.y) / 2
  };
}

function interpolate(t, s, cp1, cp2, e) {
  var td = 1 - t;
  var t0 = Math.pow(td, 3) * s;
  var t1 = 3 * Math.pow(td, 2) * t * cp1;
  var t2 = 3 * td * Math.pow(t, 2) * cp2;
  var t3 = Math.pow(t, 3) * e;
  return t0 + t1 + t2 + t3;
}
/**
 * Recursive subdivision of a curve using de Casteljau algorithm.
 * Splits the curve into multiple line segments where each segments is choosen based on a level of flatness.
 * @ignore
 * @param {point} s - Start point
 * @param {point} cp1 - First control point
 * @param {point} cp2 - Second control point
 * @param {point} e - End point
 * @param {array} points - Initial set of points
 * @returns {point[]} Array of points
 */


function toPoints(s, cp1, cp2, e) {
  var points = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];

  if (flatness(s, cp1, cp2, e) <= 10) {
    // Poor man's Set
    if (points.indexOf(s) === -1) {
      points.push(s);
    }

    if (points.indexOf(e) === -1) {
      points.push(e);
    }

    return points;
  }

  var t = 0.5;
  var m0 = mid(s, cp1);
  var m1 = mid(cp1, cp2);
  var m2 = mid(cp2, e);
  var b = {
    // Split curve at point
    x: interpolate(t, s.x, cp1.x, cp2.x, e.x),
    y: interpolate(t, s.y, cp1.y, cp2.y, e.y)
  };
  var q0 = mid(m0, m1); // New cp2 for left curve

  var q1 = mid(m1, m2); // New cp1 for right curve

  toPoints(s, m0, q0, b, points); // left curve

  toPoints(b, q1, m2, e, points); // Right curve

  return points;
}

function toCubic(s, cp, e) {
  var cp1x = s.x + 2 / 3 * (cp.x - s.x);
  var cp1y = s.y + 2 / 3 * (cp.y - s.y);
  var cp2x = e.x + 2 / 3 * (cp.x - e.x);
  var cp2y = e.y + 2 / 3 * (cp.y - e.y);
  var cp1 = {
    x: cp1x,
    y: cp1y
  };
  var cp2 = {
    x: cp2x,
    y: cp2y
  };
  return {
    cp1: cp1,
    cp2: cp2
  };
}
/**
 * Recursive subdivision of a curve using de Casteljau algorithm.
 * Splits the curve into multiple line segments where each segments is choosen based on a level of flatness.
 * @ignore
 * @param {point} s - Start point
 * @param {point} cp - Control point
 * @param {point} e - End point
 * @returns {point[]} Array of points
 */


function toPoints$1(s, cp, e) {
  var _toCubic = toCubic(s, cp, e),
      cp1 = _toCubic.cp1,
      cp2 = _toCubic.cp2;

  return toPoints(s, cp1, cp2, e);
}

var EPSILON$1 = 1e-12;

function removeDuplicates(points) {
  for (var i = 0; i < points.length - 1; i++) {
    var p0 = points[i];
    var p1 = points[i + 1];

    if (Math.abs(p0.x - p1.x) < EPSILON$1 && Math.abs(p0.y - p1.y) < EPSILON$1) {
      points.splice(i, 1);
      i--;
    }
  }
}
/**
 * Transform an arc to a set of points a long the arc.
 * Specifiction F.6 (https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes)
 * @ignore
 * @param {array} s - Segments
 * @param {number} startX - X-coordinate for start of arc
 * @param {number} startY - Y-coordinate for start of arc
 */


function arcToPoints(s, startX, startY) {
  var points = [];
  var largeArcFlag = !!s[4]; // F.6.3

  var sweepFlag = !!s[5]; // F.6.3

  var rotation = s[3];
  var endX = s[6];
  var endY = s[7];
  var rx = s[1];
  var ry = s[2];
  var cx;
  var cy;
  var sweepAngle;
  var startAngle;

  if (s[0] === 'a') {
    endX += startX;
    endY += startY;
  } // F.6.2


  if (startX === endY && startY === endY) {
    return points;
  } // Given no radius, threat as lineTo command


  if (!rx || !ry) {
    points.push({
      x: endX,
      y: endY
    });
    return points;
  }

  var _arcToCenter = arcToCenter(rx, ry, rotation, largeArcFlag, sweepFlag, endX, endY, startX, startY);

  cx = _arcToCenter.cx;
  cy = _arcToCenter.cy;
  rx = _arcToCenter.rx;
  ry = _arcToCenter.ry;
  sweepAngle = _arcToCenter.sweepAngle;
  startAngle = _arcToCenter.startAngle;
  // Approximation of perimeter
  var p = Math.abs(sweepAngle * Math.sqrt((Math.pow(rx, 2) + Math.pow(ry, 2)) / 2)); // Generate a point every 10th pixel. Scaling of the node should probably be included in this calculation

  var res = Math.ceil(p / 10);
  var resAngle = sweepAngle / res;

  for (var k = 1; k <= res; k++) {
    var deltaAngle = resAngle * k;
    var radians = (startAngle + deltaAngle) % PI_X2;
    var cos = Math.cos(radians);
    var sin = Math.sin(radians); // F.6.3 https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes

    points.push({
      x: cx + cos * rx + -sin * cos,
      y: cy + sin * ry + cos * sin
    });
  } // points.push({ x: cx, y: cy });


  return points;
}
/**
 * Converts a SVG path data string into a set of points.
 * @ignore
 * @param {string} path
 * @returns {Array<point[]>} Array of points
 */


function pathToPoints(path) {
  var commands = parsePath_1(path);
  var segments = [];
  var points = [];
  var x = 0; // Current point

  var y = 0;
  var cpx = null; // Last control point on a cubic curve

  var cpy = null;
  var qcpx = null; // Last control point on a quad curve

  var qcpy = null;

  for (var i = 0; i < commands.length; ++i) {
    var cmd = commands[i];
    var pathType = cmd[0]; // Reset control point if command is not cubic

    if (pathType !== 'S' && pathType !== 's' && pathType !== 'C' && pathType !== 'c') {
      cpx = null;
      cpy = null;
    }

    if (pathType !== 'T' && pathType !== 't' && pathType !== 'Q' && pathType !== 'q') {
      qcpx = null;
      qcpy = null;
    }

    switch (pathType) {
      case 'm':
        if (points.length) {
          segments.push(points.splice(0));
        }

      // Fall through

      case 'l':
        // eslint-disable-line no-fallthrough
        x += cmd[1];
        y += cmd[2];
        points.push({
          x: x,
          y: y
        });
        break;

      case 'M':
        if (points.length) {
          segments.push(points.splice(0));
        }

      // Fall through

      case 'L':
        // eslint-disable-line no-fallthrough
        x = cmd[1];
        y = cmd[2];
        points.push({
          x: x,
          y: y
        });
        break;

      case 'H':
        x = cmd[1];
        points.push({
          x: x,
          y: y
        });
        break;

      case 'h':
        x += cmd[1];
        points.push({
          x: x,
          y: y
        });
        break;

      case 'V':
        y = cmd[1];
        points.push({
          x: x,
          y: y
        });
        break;

      case 'v':
        y += cmd[1];
        points.push({
          x: x,
          y: y
        });
        break;

      case 'a':
        points.push.apply(points, _toConsumableArray$1(arcToPoints(cmd, x, y)));
        x += cmd[6];
        y += cmd[7];
        break;

      case 'A':
        points.push.apply(points, _toConsumableArray$1(arcToPoints(cmd, x, y)));
        x = cmd[6];
        y = cmd[7];
        break;

      case 'c':
        points.push.apply(points, _toConsumableArray$1(toPoints({
          x: x,
          y: y
        }, {
          x: cmd[1] + x,
          y: cmd[2] + y
        }, {
          x: cmd[3] + x,
          y: cmd[4] + y
        }, {
          x: cmd[5] + x,
          y: cmd[6] + y
        })));
        cpx = cmd[3] + x; // Last control point

        cpy = cmd[4] + y;
        x += cmd[5];
        y += cmd[6];
        break;

      case 'C':
        points.push.apply(points, _toConsumableArray$1(toPoints({
          x: x,
          y: y
        }, {
          x: cmd[1],
          y: cmd[2]
        }, {
          x: cmd[3],
          y: cmd[4]
        }, {
          x: cmd[5],
          y: cmd[6]
        })));
        cpx = cmd[3]; // Last control point

        cpy = cmd[4];
        x = cmd[5];
        y = cmd[6];
        break;

      case 's':
        if (cpx === null || cpx === null) {
          cpx = x;
          cpy = y;
        }

        points.push.apply(points, _toConsumableArray$1(toPoints({
          x: x,
          y: y
        }, {
          x: 2 * x - cpx,
          y: 2 * y - cpy
        }, {
          x: cmd[1] + x,
          y: cmd[2] + y
        }, {
          x: cmd[3] + x,
          y: cmd[4] + y
        })));
        cpx = cmd[1] + x; // last control point

        cpy = cmd[2] + y;
        x += cmd[3];
        y += cmd[4];
        break;

      case 'S':
        if (cpx === null || cpx === null) {
          cpx = x;
          cpy = y;
        }

        points.push.apply(points, _toConsumableArray$1(toPoints({
          x: x,
          y: y
        }, {
          x: 2 * x - cpx,
          y: 2 * y - cpy
        }, {
          x: cmd[1],
          y: cmd[2]
        }, {
          x: cmd[3],
          y: cmd[4]
        })));
        cpx = cmd[1]; // last control point

        cpy = cmd[2];
        x = cmd[3];
        y = cmd[4];
        break;

      case 'Q':
        points.push.apply(points, _toConsumableArray$1(toPoints$1({
          x: x,
          y: y
        }, {
          x: cmd[1],
          y: cmd[2]
        }, {
          x: cmd[3],
          y: cmd[4]
        })));
        qcpx = cmd[1]; // last control point

        qcpy = cmd[2];
        x = cmd[3];
        y = cmd[4];
        break;

      case 'q':
        points.push.apply(points, _toConsumableArray$1(toPoints$1({
          x: x,
          y: y
        }, {
          x: cmd[1] + x,
          y: cmd[2] + y
        }, {
          x: cmd[3] + x,
          y: cmd[4] + y
        })));
        qcpx = cmd[1] + x; // last control point

        qcpy = cmd[2] + y;
        x += cmd[3];
        y += cmd[4];
        break;

      case 'T':
        if (qcpx === null || qcpx === null) {
          qcpx = x;
          qcpy = y;
        }

        qcpx = 2 * x - qcpx; // last control point

        qcpy = 2 * y - qcpy;
        points.push.apply(points, _toConsumableArray$1(toPoints$1({
          x: x,
          y: y
        }, {
          x: qcpx,
          y: qcpy
        }, {
          x: cmd[1],
          y: cmd[2]
        })));
        x = cmd[1];
        y = cmd[2];
        break;

      case 't':
        if (qcpx === null || qcpx === null) {
          qcpx = x;
          qcpy = y;
        }

        qcpx = 2 * x - qcpx; // last control point

        qcpy = 2 * y - qcpy;
        points.push.apply(points, _toConsumableArray$1(toPoints$1({
          x: x,
          y: y
        }, {
          x: qcpx,
          y: qcpy
        }, {
          x: cmd[1] + x,
          y: cmd[2] + y
        })));
        x += cmd[1];
        y += cmd[2];
        break;

      case 'z':
      case 'Z':
        if (points.length) {
          points.push({
            x: points[0].x,
            y: points[0].y
          });
        }

        break;

      default: // Do nothing

    }
  }

  removeDuplicates(points);
  segments.push(points.splice(0));
  return segments;
}

var debugPathToPointsDef = {
  require: ['renderer', 'chart'],
  defaultSettings: {
    settings: {
      target: '',
      fill: 'transparent',
      stroke: 'lime',
      opacity: 1,
      radius: 2,
      useOuterRect: false
    }
  },
  on: {
    update: function update() {
      this.draw();
    }
  },
  draw: function draw() {
    var _this = this;

    var shapes = this.chart.findShapes('path').filter(function (s) {
      return s.key === _this.props.target;
    }); // Find all shapes

    var circles = [];
    shapes.forEach(function (s) {
      pathToPoints(s.attrs.d).forEach(function (segment) {
        segment.forEach(function (p) {
          circles.push({
            type: 'circle',
            cx: p.x,
            cy: p.y,
            r: _this.props.radius,
            fill: _this.props.fill,
            stroke: _this.props.stroke,
            opacity: _this.props.opacity,
            collider: {
              type: null
            }
          });
        });
      });
    });
    this.renderer.render(circles);
  },
  created: function created() {
    this.props = this.settings.settings;
  },
  resize: function resize(_ref) {
    var outer = _ref.outer,
        inner = _ref.inner;

    if (this.props.useOuterRect) {
      return outer;
    }

    return inner;
  },
  render: function render() {},
  mounted: function mounted() {
    this.draw();
  },
  updated: function updated() {
    this.props = this.settings.settings;
    this.draw();
  }
};

function debugCollider(picasso) {
  picasso.component('debug-collider', debugColliderDef);
}
function debugPathToPoints(picasso) {
  picasso.component('debug-path-to-points', debugPathToPointsDef);
}

var components = [box$1, pointMarker, pie$1, gridLine, refLine, axis, text, scrollbar, rangeBrush, rangeBrush$1, lassoBrush, labels, categoricalLegend, sequentialLegend, line$2, areaBrush, addTooltip, debugCollider, debugPathToPoints];

var Node =
/*#__PURE__*/
function () {
  /**
   * @private
   */
  function Node(type) {
    _classCallCheck$1(this, Node);

    this._parent = null;
    this._children = [];
    this._ancestors = null;
    this.type = type;
    this.data = null;
  }
  /**
   * Detaches this node from its parent, if such exists.
   * @returns {Node}
   */


  _createClass$1(Node, [{
    key: "detach",
    value: function detach() {
      if (this._parent) {
        this._parent.removeChild(this);
      }

      return this;
    }
    /**
     * Parent of this node.
     * @readonly
     * @type {Node}
     */

  }, {
    key: "equals",

    /**
     *
     * @returns {Boolean}
     */
    value: function equals(n) {
      var children = this.children;
      var nChildren = n.children;

      if (children.length !== nChildren.length) {
        return false;
      } // Requires deterministic child order


      for (var i = 0; i < children.length; i++) {
        if (!children[i].equals(nChildren[i])) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        type: this.type,
        children: this.children.map(function (ch) {
          return ch.toJSON();
        })
      };
    }
  }, {
    key: "parent",
    get: function get() {
      return this._parent;
    }
    /**
     * Checks whether this node is a branch.
     *
     * True if this node has children, false otherwise.
     * @readonly
     * @type {Boolean}
     */

  }, {
    key: "isBranch",
    get: function get() {
      return this._children && this._children.length;
    }
    /**
     * Children of this node.
     * @readonly
     * @type {Node[]}
     */

  }, {
    key: "children",
    get: function get() {
      return this._children;
    }
    /**
     * Ancestors of this node, including parent.
     * @readonly
     * @type {Node[]}
     */

  }, {
    key: "ancestors",
    get: function get() {
      if (!this._ancestors) {
        this._ancestors = [];

        if (this.parent) {
          var _this$_ancestors;

          (_this$_ancestors = this._ancestors).push.apply(_this$_ancestors, [this.parent].concat(_toConsumableArray$1(this.parent.ancestors)));
        }
      }

      return this._ancestors;
    }
    /**
     * Descendants of this node.
     * @readonly
     * @type {Node[]}
     */

  }, {
    key: "descendants",
    get: function get() {
      var r = [];
      var len = this.children.length;
      var i;
      var c;

      for (i = 0, len; i < len; i++) {
        c = this.children[i];
        r.push(c);

        if (c.children.length) {
          r.push.apply(r, _toConsumableArray$1(c.descendants));
        }
      }

      return r;
    }
  }]);

  return Node;
}();

/**
 * Construct a new GeoRect instance
 * @private
 */

var GeoRect =
/*#__PURE__*/
function () {
  function GeoRect() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$x = _ref.x,
        x = _ref$x === void 0 ? 0 : _ref$x,
        _ref$y = _ref.y,
        y = _ref$y === void 0 ? 0 : _ref$y,
        _ref$width = _ref.width,
        width = _ref$width === void 0 ? 0 : _ref$width,
        _ref$height = _ref.height,
        height = _ref$height === void 0 ? 0 : _ref$height,
        _ref$minWidth = _ref.minWidth,
        minWidth = _ref$minWidth === void 0 ? 0 : _ref$minWidth,
        _ref$minHeight = _ref.minHeight,
        minHeight = _ref$minHeight === void 0 ? 0 : _ref$minHeight;

    _classCallCheck$1(this, GeoRect);

    this.set({
      x: x,
      y: y,
      width: width,
      height: height,
      minWidth: minWidth,
      minHeight: minHeight
    });
  }

  _createClass$1(GeoRect, [{
    key: "set",
    value: function set() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$x = _ref2.x,
          x = _ref2$x === void 0 ? 0 : _ref2$x,
          _ref2$y = _ref2.y,
          y = _ref2$y === void 0 ? 0 : _ref2$y,
          _ref2$width = _ref2.width,
          width = _ref2$width === void 0 ? 0 : _ref2$width,
          _ref2$height = _ref2.height,
          height = _ref2$height === void 0 ? 0 : _ref2$height,
          _ref2$minWidth = _ref2.minWidth,
          minWidth = _ref2$minWidth === void 0 ? 0 : _ref2$minWidth,
          _ref2$minHeight = _ref2.minHeight,
          minHeight = _ref2$minHeight === void 0 ? 0 : _ref2$minHeight;

      this.type = 'rect';

      if (width >= 0) {
        this.x = x;
        this.width = Math.max(width, minWidth);
      } else {
        this.x = x + Math.min(width, -minWidth);
        this.width = -Math.min(width, -minWidth);
      }

      if (height >= 0) {
        this.y = y;
        this.height = Math.max(height, minHeight);
      } else {
        this.y = y + Math.min(height, -minHeight);
        this.height = -Math.min(height, -minHeight);
      }
    }
    /**
     * @param {point} p
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "containsPoint",
    value: function containsPoint(p) {
      return testRectPoint(this, p);
    }
    /**
     * @param {point[]} points - Line start and end point as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsLine",
    value: function intersectsLine(points) {
      var line = pointsToLine(points);
      return testRectLine(this, line);
    }
    /**
     * @param {point[]} points - Rect vertices as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsRect",
    value: function intersectsRect(points) {
      var rect = pointsToRect(points);
      return testRectRect(this, rect);
    }
    /**
     * @param {circle} c
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsCircle",
    value: function intersectsCircle(c) {
      return testCircleRect(c, this);
    }
    /**
     * @param {GeoPolygon} polygon
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsPolygon",
    value: function intersectsPolygon(polygon) {
      return testPolygonRect(polygon, this);
    }
    /**
     * Get the points
     * @returns {point[]}
     */

  }, {
    key: "points",
    value: function points() {
      return [{
        x: this.x,
        y: this.y
      }, {
        x: this.x + this.width,
        y: this.y
      }, {
        x: this.x + this.width,
        y: this.y + this.height
      }, {
        x: this.x,
        y: this.y + this.height
      }];
    }
  }]);

  return GeoRect;
}();

function create$4() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return _construct(GeoRect, args);
}

/**
 * Construct a new GeoCircle instance
 * @private
 */

var GeoCircle =
/*#__PURE__*/
function () {
  function GeoCircle() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$cx = _ref.cx,
        cx = _ref$cx === void 0 ? 0 : _ref$cx,
        _ref$cy = _ref.cy,
        cy = _ref$cy === void 0 ? 0 : _ref$cy,
        _ref$r = _ref.r,
        r = _ref$r === void 0 ? 0 : _ref$r,
        _ref$minRadius = _ref.minRadius,
        minRadius = _ref$minRadius === void 0 ? 0 : _ref$minRadius;

    _classCallCheck$1(this, GeoCircle);

    this.set({
      cx: cx,
      cy: cy,
      r: r,
      minRadius: minRadius
    });
  }

  _createClass$1(GeoCircle, [{
    key: "set",
    value: function set() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$cx = _ref2.cx,
          cx = _ref2$cx === void 0 ? 0 : _ref2$cx,
          _ref2$cy = _ref2.cy,
          cy = _ref2$cy === void 0 ? 0 : _ref2$cy,
          _ref2$r = _ref2.r,
          r = _ref2$r === void 0 ? 0 : _ref2$r,
          _ref2$minRadius = _ref2.minRadius,
          minRadius = _ref2$minRadius === void 0 ? 0 : _ref2$minRadius;

      this.type = 'circle';
      this.cx = cx;
      this.cy = cy;
      this.r = Math.max(r, minRadius);
      this.vector = {
        x: this.cx,
        y: this.cy
      };
    }
    /**
     * @param {point} p
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "containsPoint",
    value: function containsPoint(p) {
      return testCirclePoint(this, p);
    }
    /**
     * @param {point[]} points - Line start and end point as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsLine",
    value: function intersectsLine(points) {
      var line = pointsToLine(points);
      return testCircleLine(this, line);
    }
    /**
     * @param {point[]} points - Rect vertices as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsRect",
    value: function intersectsRect(points) {
      var rect = pointsToRect(points);
      return testCircleRect(this, rect);
    }
    /**
     * @param {circle} c
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsCircle",
    value: function intersectsCircle(c) {
      return testCircleCircle(this, c);
    }
    /**
     * @param {GeoPolygon} polygon
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsPolygon",
    value: function intersectsPolygon(polygon) {
      return testCirclePolygon(this, polygon);
    }
    /**
     * Get the points
     * @returns {point[]}
     */

  }, {
    key: "points",
    value: function points() {
      return [{
        x: this.cx,
        y: this.cy
      }];
    }
  }]);

  return GeoCircle;
}();

function create$5() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return _construct(GeoCircle, args);
}

/**
 * Construct a new GeoLine instance
 * @private
 */

var GeoLine =
/*#__PURE__*/
function () {
  function GeoLine() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$x = _ref.x1,
        x1 = _ref$x === void 0 ? 0 : _ref$x,
        _ref$y = _ref.y1,
        y1 = _ref$y === void 0 ? 0 : _ref$y,
        _ref$x2 = _ref.x2,
        x2 = _ref$x2 === void 0 ? 0 : _ref$x2,
        _ref$y2 = _ref.y2,
        y2 = _ref$y2 === void 0 ? 0 : _ref$y2,
        _ref$tolerance = _ref.tolerance,
        tolerance = _ref$tolerance === void 0 ? 0 : _ref$tolerance;

    _classCallCheck$1(this, GeoLine);

    this.set({
      x1: x1,
      y1: y1,
      x2: x2,
      y2: y2,
      tolerance: tolerance
    });
  }

  _createClass$1(GeoLine, [{
    key: "set",
    value: function set() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$x = _ref2.x1,
          x1 = _ref2$x === void 0 ? 0 : _ref2$x,
          _ref2$y = _ref2.y1,
          y1 = _ref2$y === void 0 ? 0 : _ref2$y,
          _ref2$x2 = _ref2.x2,
          x2 = _ref2$x2 === void 0 ? 0 : _ref2$x2,
          _ref2$y2 = _ref2.y2,
          y2 = _ref2$y2 === void 0 ? 0 : _ref2$y2,
          _ref2$tolerance = _ref2.tolerance,
          tolerance = _ref2$tolerance === void 0 ? 0 : _ref2$tolerance;

      this.type = 'line';
      this.x1 = x1;
      this.y1 = y1;
      this.x2 = x2;
      this.y2 = y2;
      this.tolerance = Math.max(0, Math.round(tolerance));
      this.vectors = this.points();
      this.zeroSize = x1 === x2 && y1 === y2;
    }
    /**
     * @param {point} p
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "containsPoint",
    value: function containsPoint(p) {
      if (this.tolerance > 0) {
        var c = {
          cx: p.x,
          cy: p.y,
          r: this.tolerance
        };
        return testCircleLine(c, this);
      }

      return testLinePoint(this, p);
    }
    /**
     * @param {point[]} points - Line start and end point as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsLine",
    value: function intersectsLine(points) {
      var line = pointsToLine(points);
      return testLineLine(this, line);
    }
    /**
     * @param {point[]} points - Rect vertices as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsRect",
    value: function intersectsRect(points) {
      var rect = pointsToRect(points);
      return testRectLine(rect, this);
    }
    /**
     * @param {circle} c
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsCircle",
    value: function intersectsCircle(c) {
      return testCircleLine(c, this);
    }
    /**
     * @param {GeoPolygon} polygon
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsPolygon",
    value: function intersectsPolygon(polygon) {
      return testPolygonLine(polygon, this);
    }
    /**
     * Get the points
     * @returns {point[]}
     */

  }, {
    key: "points",
    value: function points() {
      return [{
        x: this.x1,
        y: this.y1
      }, {
        x: this.x2,
        y: this.y2
      }];
    }
  }]);

  return GeoLine;
}();

function create$6() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return _construct(GeoLine, args);
}

function close(vertices) {
  var first = vertices[0];
  var last = vertices[vertices.length - 1];

  if (first.x !== last.x || first.y !== last.y) {
    vertices.push(first);
  }
}

function removeDuplicates$1(vertices) {
  for (var i = 0; i < vertices.length - 1; i++) {
    var v0 = vertices[i];
    var v1 = vertices[i + 1];

    if (v0.x === v1.x && v0.y === v1.y) {
      vertices.splice(i, 1);
      i--;
    }
  }
}
/**
 * Construct a new GeoPolygon instance
 * @private
 */


var GeoPolygon =
/*#__PURE__*/
function () {
  function GeoPolygon() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$vertices = _ref.vertices,
        vertices = _ref$vertices === void 0 ? [] : _ref$vertices;

    _classCallCheck$1(this, GeoPolygon);

    this.set({
      vertices: vertices
    });
  }
  /**
   * Set the vertices.
   * If vertices doesn't close the polygon, a closing vertice is appended.
   * @param {object} input An object with a vertices property
   * @param {point[]} [input.vertices=[]] Vertices are represented as an array of points.
   */


  _createClass$1(GeoPolygon, [{
    key: "set",
    value: function set() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$vertices = _ref2.vertices,
          vertices = _ref2$vertices === void 0 ? [] : _ref2$vertices;

      this.type = 'polygon';
      this.vertices = vertices.slice();
      this.edges = [];
      removeDuplicates$1(this.vertices);

      if (this.vertices.length <= 2) {
        return;
      }

      close(this.vertices);
      this.xMin = NaN;
      this.yMin = NaN;
      this.xMax = NaN;
      this.yMax = NaN;

      for (var i = 0; i < this.vertices.length; i++) {
        if (i < this.vertices.length - 1) {
          this.edges.push([this.vertices[i], this.vertices[i + 1]]);
        }

        this.xMin = isNaN(this.xMin) ? this.vertices[i].x : Math.min(this.xMin, this.vertices[i].x);
        this.xMax = isNaN(this.xMax) ? this.vertices[i].x : Math.max(this.xMax, this.vertices[i].x);
        this.yMin = isNaN(this.yMin) ? this.vertices[i].y : Math.min(this.yMin, this.vertices[i].y);
        this.yMax = isNaN(this.yMax) ? this.vertices[i].y : Math.max(this.yMax, this.vertices[i].y);
      }

      this._bounds = null;
      this._boundingRect = null;
    }
    /**
     * Check if a point is inside the area of the polygon.
     * Supports convex, concave and self-intersecting polygons (filled area).
     * @param {point} point
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "containsPoint",
    value: function containsPoint(point) {
      return testPolygonPoint(this, point);
    }
    /**
     * Check if circle is inside the area of the polygon.
     * Supports convex, concave and self-intersecting polygons (filled area).
     * @param {circle} circle
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsCircle",
    value: function intersectsCircle(circle) {
      return testCirclePolygon(circle, this);
    }
    /**
     * @param {point[]} points - Line start and end point as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsLine",
    value: function intersectsLine(points) {
      return testPolygonLine(this, pointsToLine(points));
    }
    /**
     * @param {point[]} points - Rect vertices as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsRect",
    value: function intersectsRect(points) {
      return testPolygonRect(this, pointsToRect(points));
    }
    /**
     * Check if polygon intersects another polygon.
     * Supports convex, concave and self-intersecting polygons (filled area).
     * @param {GeoPolygon} polygon
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsPolygon",
    value: function intersectsPolygon(polygon) {
      // This is a unoptimized solution and should be replaced by a more efficient algorithm.
      if (!testRectRect(this.boundingRect(), polygon.boundingRect())) {
        return false;
      }

      var intersects = false;

      for (var i = 0, len = this.edges.length; i < len; i++) {
        intersects = testPolygonLine(polygon, pointsToLine(this.edges[i]));

        if (intersects === true) {
          break;
        }
      }

      return intersects;
    }
    /**
     * Get the points
     * @returns {point[]}
     */

  }, {
    key: "points",
    value: function points() {
      return this.vertices;
    }
    /**
     * Get the bounds of the polygon, as an array of points
     * @returns {point[]}
     */

  }, {
    key: "bounds",
    value: function bounds() {
      if (!this._bounds) {
        this._bounds = [{
          x: this.xMin,
          y: this.yMin
        }, {
          x: this.xMax,
          y: this.yMin
        }, {
          x: this.xMax,
          y: this.yMax
        }, {
          x: this.xMin,
          y: this.yMax
        }];
      }

      return this._bounds;
    }
    /**
     * Get the bounding rect of the polygon
     * @returns {rect}
     */

  }, {
    key: "boundingRect",
    value: function boundingRect() {
      if (!this._boundingRect) {
        this._boundingRect = {
          x: this.xMin,
          y: this.yMin,
          width: this.xMax - this.xMin,
          height: this.yMax - this.yMin
        };
      }

      return this._boundingRect;
    }
  }]);

  return GeoPolygon;
}();
/**
* Construct a new GeoPolygon instance
* @param {object} input An object with a vertices property
* @param {point[]} [input.vertices=[]] Vertices are represented as an array of points.
* @returns {GeoPolygon} GeoPolygon instance
* @private
*/


function create$7() {
  for (var _len = arguments.length, a = new Array(_len), _key = 0; _key < _len; _key++) {
    a[_key] = arguments[_key];
  }

  return _construct(GeoPolygon, a);
}

function pointsAreNotEqual(p0, p1) {
  return p0.x !== p1.x || p0.y !== p1.y;
}
/**
 * Construct a new GeoPolyline instance
 * @private
 */


var GeoPolyline =
/*#__PURE__*/
function () {
  function GeoPolyline() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$points = _ref.points,
        points = _ref$points === void 0 ? [] : _ref$points;

    _classCallCheck$1(this, GeoPolyline);

    this.set({
      points: points
    });
  }

  _createClass$1(GeoPolyline, [{
    key: "set",
    value: function set() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$points = _ref2.points,
          points = _ref2$points === void 0 ? [] : _ref2$points;

      this.type = 'polyline';
      this.segments = [];
      this._points = points.slice();

      if (this._points.length > 1) {
        for (var i = 0, len = this._points.length - 1; i < len; i++) {
          if (pointsAreNotEqual(this._points[i], this._points[i + 1])) {
            this.segments.push({
              x1: this._points[i].x,
              y1: this._points[i].y,
              x2: this._points[i + 1].x,
              y2: this._points[i + 1].y
            });
          }
        }
      }
    }
    /**
     * @param {point} point
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "containsPoint",
    value: function containsPoint(point) {
      return this.segments.some(function (line) {
        return testLinePoint(line, point);
      });
    }
    /**
     * @param {circle} circle
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsCircle",
    value: function intersectsCircle(circle) {
      return this.segments.some(function (line) {
        return testCircleLine(circle, line);
      });
    }
    /**
     * @param {point[]} points - Line start and end point as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsLine",
    value: function intersectsLine(points) {
      var testLine = pointsToLine(points);
      return this.segments.some(function (line) {
        return testLineLine(line, testLine);
      });
    }
    /**
     * @param {point[]} points - Rect vertices as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsRect",
    value: function intersectsRect(points) {
      var rect = pointsToRect(points);
      return this.segments.some(function (line) {
        return testRectLine(rect, line);
      });
    }
    /**
     * @param {GeoPolygon} polygon
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsPolygon",
    value: function intersectsPolygon(polygon) {
      // This is a unoptimized solution and should be replaced by a more efficient algorithm.
      return this.segments.some(function (line) {
        return testPolygonLine(polygon, line);
      });
    }
    /**
     * Get the points
     * @returns {point[]}
     */

  }, {
    key: "points",
    value: function points() {
      return this._points;
    }
  }]);

  return GeoPolyline;
}();

function create$8() {
  for (var _len = arguments.length, a = new Array(_len), _key = 0; _key < _len; _key++) {
    a[_key] = arguments[_key];
  }

  return _construct(GeoPolyline, a);
}

var reg$3 = registryFactory();
reg$3.add('rect', create$4);
reg$3.add('circle', create$5);
reg$3.add('line', create$6);
reg$3.add('polygon', create$7);
reg$3.add('polyline', create$8);
function create$9(type, input) {
  // eslint-disable-line import/prefer-default-export
  return reg$3.get(type)(input);
}
/**
 * @typedef {object} rect
 * @property {number} x - X-coordinate
 * @property {number} y - Y-coordinate
 * @property {number} width - Width
 * @property {number} height - Height
 */

/**
 * @typedef {object} line
 * @property {number} x1 - Start x-coordinate
 * @property {number} y1 - Start y-coordinate
 * @property {number} x2 - End x-coordinate
 * @property {number} y2 - End y-coordinate
 */

/**
 * @typedef {object} point
 * @property {number} x - X-coordinate
 * @property {number} y - Y-coordinate
 */

/**
 * @typedef {object} circle
 * @property {number} cx - Center x-coordinate
 * @property {number} cy - Center y-coordinate
 * @property {number} r - Circle radius
 */

/**
 * @typedef {object} polygon
 * @property {Array<point>} points - Array of connected points
 */

/**
 * @typedef {object} polyline
 * @property {Array<point>} points - Array of connected points
 */

/**
 * @typedef {object} path
 * @property {string} d - Path definition
 */

/**
 * Construct a new GeometryCollection instance
 * @private
  */

var GeometryCollection =
/*#__PURE__*/
function () {
  function GeometryCollection() {
    var collection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    _classCallCheck$1(this, GeometryCollection);

    this.set(collection);
  }

  _createClass$1(GeometryCollection, [{
    key: "set",
    value: function set() {
      var _this = this;

      var collection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      this.geometries = [];
      collection.forEach(function (geo) {
        var geoInstance = create$9(geo.type, geo);

        if (geoInstance) {
          _this.geometries.push(geoInstance);
        }
      });
    }
    /**
     * @param {point} p
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "containsPoint",
    value: function containsPoint(p) {
      return this.geometries.some(function (geo) {
        return geo.containsPoint(p);
      });
    }
    /**
     * @param {point[]} points - Line start and end point as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsLine",
    value: function intersectsLine(points) {
      return this.geometries.some(function (geo) {
        return geo.intersectsLine(points);
      });
    }
    /**
     * @param {point[]} points - Rect vertices as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsRect",
    value: function intersectsRect(points) {
      return this.geometries.some(function (geo) {
        return geo.intersectsRect(points);
      });
    }
    /**
     * @param {circle} c
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsCircle",
    value: function intersectsCircle(c) {
      return this.geometries.some(function (geo) {
        return geo.intersectsCircle(c);
      });
    }
    /**
     * @param {GeoPolygon} polygon
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsPolygon",
    value: function intersectsPolygon(polygon) {
      return this.geometries.some(function (geo) {
        return geo.intersectsPolygon(polygon);
      });
    }
  }]);

  return GeometryCollection;
}();

function create$a() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return _construct(GeometryCollection, args);
}

var Matrix =
/*#__PURE__*/
function () {
  /**
   * Creates a matrix with identity values.
   * @private
   */
  function Matrix() {
    _classCallCheck$1(this, Matrix);

    this._elements = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
    this._stack = [];
  }
  /**
   * Creates a new matrix with a copy of the current values.
   */


  _createClass$1(Matrix, [{
    key: "clone",
    value: function clone() {
      var mt = new Matrix();
      return mt.multiply(this);
    }
    /**
    * Sets the matrix values
    * @param {Number[][]} arr A 3x3 array.
    */

  }, {
    key: "set",
    value: function set(arr) {
      this._elements = arr;
      return this;
    }
    /**
    * Saves the current matrix values to a stack.
    */

  }, {
    key: "save",
    value: function save() {
      this._stack.push(this.elements);

      return this;
    }
    /**
    * Sets the current matrix values to the last ones saved on to the stack.
    */

  }, {
    key: "restore",
    value: function restore() {
      if (this._stack.length) {
        this._elements = this._stack.pop(); // TODO - use a copy instead
      }

      return this;
    }
    /**
    * Adds a scalar value to each element in the matrix.
    * @param {Number} value
    */

  }, {
    key: "add",
    value: function add(value) {
      // assume scalar
      var i, j;

      for (i = 0; i < this._elements.length; i++) {
        for (j = 0; j < this._elements[i].length; j++) {
          this._elements[i][j] += value;
        }
      }

      return this;
    }
    /**
    * Translates the current matrix along the x and y axis.
    * @param {Number} x
    * @param {Number} y
    */

  }, {
    key: "translate",
    value: function translate(x, y) {
      this.multiply([[1, 0, x], [0, 1, y], [0, 0, 1]]);
      return this;
    }
    /**
    * Rotates the current matrix.
    * @param {Number} radianAngle Angle in radians.
    */

  }, {
    key: "rotate",
    value: function rotate(radianAngle) {
      var cos = Math.cos(-radianAngle),
          sin = Math.sin(-radianAngle);
      this.multiply([[cos, sin, 0], [-sin, cos, 0], [0, 0, 1]]);
      return this;
    }
    /**
    *
    * If value is a number; multiplies each element in the matrix by the given value.
    * If value is a matrix; multiplies the two matrices.
    * @param {Number|Array|Matrix} value
    */

  }, {
    key: "multiply",
    value: function multiply(value) {
      var i, j, m, k;

      if (value instanceof Matrix) {
        value = value._elements;
      }

      if (Array.isArray(value)) {
        // matrix multiplication
        m = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];

        for (i = 0; i < this._elements.length; i++) {
          // row
          for (j = 0; j < this._elements[i].length; j++) {
            // column
            for (k = 0; k < 3; k++) {
              // row
              m[i][j] += this._elements[i][k] * value[k][j];
            }
          }
        }

        this._elements = m;
      } else {
        // scalar multiplication
        for (i = 0; i < this._elements.length; i++) {
          for (j = 0; j < this._elements[i].length; j++) {
            this._elements[i][j] *= value;
          }
        }
      }

      return this;
    }
    /**
    * Scales the matrix along x and y axis.
    * @param {Number} x The value to scale the matrix with along the x direction
    * @param {Number} [y=x] The value to scale the matrix with along the y direction.
    */

  }, {
    key: "scale",
    value: function scale(x) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;
      // if ( arguments.length < 2 || typeof y === "undefined" ) {
      //  y = x;
      // }
      this.multiply([[x, 0, 0], [0, y, 0], [0, 0, 1]]);
      return this;
    }
    /**
     * Multiples the matrix with the supplied transformation values
     * @param {Number} a Horizontal scaling
     * @param {Number} b Horizontal skewing
     * @param {Number} c Vertical skewing
     * @param {Number} d Vertical scaling
     * @param {Number} e Horizontal moving
     * @param {Number} f Vertical scaling
     */

  }, {
    key: "transform",
    value: function transform(a, b, c, d, e, f) {
      this.multiply([[a, c, e], [b, d, f], [0, 0, 1]]);
      return this;
    }
    /**
    * Gets the value of the determinant.
    * @return {Number}
    */

  }, {
    key: "determinant",
    value: function determinant() {
      var a = this._elements[0][0],
          b = this._elements[0][1],
          c = this._elements[0][2],
          d = this._elements[1][0],
          e = this._elements[1][1],
          f = this._elements[1][2],
          g = this._elements[2][0],
          h = this._elements[2][1],
          i = this._elements[2][2],
          p = 0;
      p = a * e * i + b * f * g + c * d * h - c * e * g - b * d * i - a * f * h;
      return p;
    }
    /**
    * Inverts the matrix.
    */

  }, {
    key: "invert",
    value: function invert() {
      var dt = this.determinant(),
          a = this._elements[0][0],
          b = this._elements[0][1],
          c = this._elements[0][2],
          d = this._elements[1][0],
          e = this._elements[1][1],
          f = this._elements[1][2],
          g = this._elements[2][0],
          h = this._elements[2][1],
          k = this._elements[2][2];
      this._elements = [[e * k - f * h, c * h - b * k, b * f - c * e], [f * g - d * k, a * k - c * g, c * d - a * f], [d * h - e * g, g * b - a * h, a * e - b * d]];
      this.multiply(1 / dt); // TODO - handle when dt === 0 ?

      return this;
    }
    /**
    * Transposes the elements of the matrix.
    */

  }, {
    key: "transpose",
    value: function transpose() {
      var m = Object.create(this._elements); // ?

      this._elements = [[m[0][0], m[1][0], m[2][0]], [m[0][1], m[1][1], m[2][1]], [m[0][2], m[1][2], m[2][2]]];
      return this;
    }
    /**
    * Resets the inner elements of the matrix to identity values.
    */

  }, {
    key: "identity",
    value: function identity() {
      this._elements = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
      return this;
    }
  }, {
    key: "toString",
    value: function toString() {
      return "".concat(this._elements.map(function (r) {
        return r.join('\t');
      }).join('\n'));
    }
  }, {
    key: "isIdentity",
    value: function isIdentity() {
      var m = this._elements;
      return m[0][0] === 1 && m[0][1] === 0 && m[0][2] === 0 && m[1][0] === 0 && m[1][1] === 1 && m[1][2] === 0 && m[2][0] === 0 && m[2][1] === 0 && m[2][2] === 1;
    }
    /**
     * Transforms the given point by this matrix and returns a new point
     */

  }, {
    key: "transformPoint",
    value: function transformPoint(p) {
      var vec = [p.x, p.y, 1],
          i,
          j,
          e = this._elements,
          m = [0, 0, 0];

      for (i = 0; i < this._elements.length; i++) {
        // row
        for (j = 0; j < this._elements[i].length; j++) {
          // column
          m[i] += vec[j] * e[i][j];
        }
      }

      return {
        x: m[0],
        y: m[1]
      };
    }
    /**
     * Transforms the given points by this matrix and returns the new points
     */

  }, {
    key: "transformPoints",
    value: function transformPoints(array) {
      var vec,
          i,
          j,
          k,
          m,
          e = this._elements,
          ret = [];

      for (k = 0; k < array.length; k++) {
        vec = [array[k].x, array[k].y, 1];
        m = [0, 0, 0];

        for (i = 0; i < this._elements.length; i++) {
          // row
          for (j = 0; j < this._elements[i].length; j++) {
            // column
            m[i] += vec[j] * e[i][j];
          }
        }

        ret.push({
          x: m[0],
          y: m[1]
        });
      }

      return ret;
    }
  }, {
    key: "elements",
    get: function get() {
      var m = this._elements;
      return [[m[0][0], m[0][1], m[0][2]], [m[1][0], m[1][1], m[1][2]], [m[2][0], m[2][1], m[2][2]]];
    }
  }]);

  return Matrix;
}();

var transformRegEx = /(translate|scale|rotate|matrix)\(([0-9,.eE+-\s]+)(?:,|\s?)+\)/g;

function parseTransform(transform) {
  var m,
      commands = [];

  while ((m = transformRegEx.exec(transform)) !== null) {
    // eslint-disable-line no-cond-assign
    var argsStr = m[2].trim();
    var args = argsStr.indexOf(',') === -1 ? argsStr.split(' ') : argsStr.split(',');
    commands.push({
      cmd: m[1],
      args: args.filter(function (a) {
        return a.trim().length > 0;
      }).map(function (a) {
        return Number(a);
      })
    });
  }

  return commands;
}

function resolveRotateCmd(matrix, transform) {
  var radians = transform.args[0] * (Math.PI / 180);

  if (transform.args.length > 2) {
    var x = transform.args[1];
    var y = transform.args[2];
    matrix.translate(x, y);
    matrix.rotate(radians);
    matrix.translate(-x, -y);
  } else if (transform.args.length === 1) {
    matrix.rotate(radians);
  }
}

function resolveScaleCmd(matrix, transform) {
  var x = transform.args[0];
  var y = isNaN(transform.args[1]) ? transform.args[0] : transform.args[1];
  matrix.scale(x, y);
}

function resolveTranslateCmd(matrix, transform) {
  var x = transform.args[0];
  var y = isNaN(transform.args[1]) ? 0 : transform.args[1];
  matrix.translate(x, y);
}

function resolveMatrixCmd(matrix, transform) {
  if (transform.args.length >= 6) {
    matrix.transform.apply(matrix, _toConsumableArray$1(transform.args));
  }
}

function resolveTransform(t, matrix) {
  var transforms = parseTransform(t);
  var transform;

  for (var i = 0, len = transforms.length; i < len; i++) {
    transform = transforms[i];

    if (transform.cmd === 'rotate') {
      resolveRotateCmd(matrix, transform);
    } else if (transform.cmd === 'scale') {
      resolveScaleCmd(matrix, transform);
    } else if (transform.cmd === 'matrix') {
      resolveMatrixCmd(matrix, transform);
    } else if (transform.cmd === 'translate') {
      resolveTranslateCmd(matrix, transform);
    }
  }
}

/* eslint-disable no-useless-escape */
var SELECTOR_MAPS = {
  type: /^\w[\w-]+/,
  attr: /^\[\w(?:[\w\._-]+)?(?:[!]?=['\"][\w\s*#_-]*['\"])?\]/,
  universal: /^(\*)/,
  tag: /^\.(\w+)/
};
var FILTERS = {
  type: function type(c, objects) {
    // eslint-disable-line arrow-body-style
    return objects.filter(function (o) {
      var type = o.type;

      if (type) {
        return type.toLowerCase() === c.toLowerCase();
      }

      return false;
    });
  },
  attr: function attr(_attr, operator, value, objects) {
    // eslint-disable-line arrow-body-style
    return objects.filter(function (o) {
      var v = o.attrs[_attr];

      if (!operator) {
        // TODO handle undefined differently for != operator? As display object may very well have a default rendering color
        return typeof v !== 'undefined';
      }

      if (typeof v === 'undefined') {
        return false;
      }

      switch (operator) {
        case '=':
          return value === String(v);

        case '!=':
          return value !== String(v);

        default:
          return false;
      }
    });
  },
  universal: function universal(objects) {
    return objects;
  },
  tag: function tag(selector, objects) {
    // eslint-disable-line arrow-body-style
    return objects.filter(function (o) {
      var tag = o.tag;

      if (tag) {
        return tag.trim().split(/\s+/).indexOf(selector.replace('.', '')) !== -1;
      }

      return false;
    });
  }
};
/**
* Filters out objects of given type and value
* @ignore
* @example
* filter(
*   {type:'type', value:'Circle'},
*   [new Circle(), new Rectangle()]
* )
* // [Circle]
* @param {Object} token
* @param {Array} objects
* @returns {Object[]} Objects that fulfill the type and value
*/

function filter(token, objects) {
  if (!objects || !objects.length || !token || typeof FILTERS[token.type] !== 'function') {
    return [];
  }

  switch (token.type) {
    case 'type':
      return FILTERS[token.type](token.value, objects);

    case 'attr':
      return FILTERS[token.type](token.attribute, token.operator, token.attributeValue, objects);

    case 'universal':
      return FILTERS[token.type](objects);

    case 'tag':
      return FILTERS[token.type](token.value, objects);

    default:
      return [];
  }
}
/**
* Tokenizes a string into supported selectors
* @ignore
*
* @example
* tokenize("Circle[color='red']")
*
* @param {String} s
*/

function tokenize(s) {
  var groups = [];
  var sub;
  var info;
  var match;
  var validSelector;
  s.split(/\s*,\s*/).forEach(function (group) {
    group = group.trim();
    sub = [];

    var selectorMapsIterator = function selectorMapsIterator(key) {
      match = group.match(SELECTOR_MAPS[key]);

      if (match) {
        validSelector = true;
        group = group.slice(match[0].length);
        info = {
          type: key,
          value: match[0]
        };

        if (key === 'attr') {
          // extract parts of attribute from e.g. [color='red'] => (color, =, red)
          match = match[0].match(/\[(\w[\w\._-]+)?(?:([!]?=)['\"]([\w\s#_-]*)['\"])?\]/);
          info.attribute = match[1];
          info.operator = match[2];
          info.attributeValue = match[3];
        }

        sub.push(info);
      }
    };

    while (group) {
      validSelector = false;
      match = group.match(/^\s*([>+~]|\s)\s*/);

      if (match) {
        validSelector = true;
        sub.push({
          type: ' ',
          value: match[0]
        });
        group = group.slice(match[0].length);
      }

      Object.keys(SELECTOR_MAPS).forEach(selectorMapsIterator);

      if (sub && sub.length && groups.indexOf(sub) < 0) {
        groups.push(sub);
      }

      if (!validSelector) {
        break;
      }
    }
  });
  return groups;
}

function find(s, object) {
  var result = [];
  var groupResults = [];
  var groups;
  var descendants;

  if (object.isBranch) {
    groups = tokenize(s);
    descendants = object.descendants;
    var tokens;

    var _loop = function _loop(gi, glen) {
      tokens = groups[gi];
      var levels = [];
      var filtered = descendants.slice();
      var hasRemainder = false;
      tokens.reverse().forEach(function (token) {
        if (token.type === ' ') {
          levels.push(filtered);
          filtered = descendants.slice();
          hasRemainder = false;
          return;
        }

        filtered = filter(token, filtered);
        hasRemainder = true;
      });

      if (hasRemainder) {
        levels.push(filtered);
      }

      var selected = levels[0].filter(function (node) {
        var ancestor = node.parent;
        var idx;

        for (var _i = 1; _i < levels.length; _i++) {
          idx = levels[_i].indexOf(ancestor);

          while (ancestor && idx < 0) {
            ancestor = ancestor.parent;
            idx = levels[_i].indexOf(ancestor);
          }

          if (idx < 0) {
            return false;
          }
        }

        return true;
      });
      groupResults.push(selected);
    };

    for (var gi = 0, glen = groups.length; gi < glen; gi++) {
      _loop(gi, glen);
    }

    for (var i = 0, len = groupResults.length; i < len; i++) {
      for (var ni = 0, nlen = groupResults[i].length; ni < nlen; ni++) {
        if (result.indexOf(groupResults[i][ni]) < 0) {
          result.push(groupResults[i][ni]);
        }
      }
    }
  }

  return result || [];
}

var nodeSelector = {
  find: find
};

function appendDpi(points, dpi) {
  for (var i = 0, len = points.length; i < len; i++) {
    points[i].x /= dpi;
    points[i].y /= dpi;
  }
}

function geometryToDef(geometry, dpi, mvm) {
  var type = geometry.type;
  var points = mvm ? mvm.transformPoints(geometry.points()) : geometry.points();
  appendDpi(points, dpi);
  var def = null;

  if (type === 'rect' || type === 'bounds') {
    def = pointsToRect(points);
    def.type = type;
  } else if (type === 'circle') {
    def = pointsToCircle(points, geometry.r);
    def.type = type;
  } else if (type === 'line') {
    def = pointsToLine(points);
    def.type = type;
  } else if (type === 'polygon' || type === 'polyline') {
    var path = pointsToPath(points, type === 'polygon');
    def = {
      type: 'path',
      d: path
    };
  }

  return def;
}
/**
 * @ignore
 * @returns {object} Returns a node definition of the collider
 */


function colliderToShape(node, dpi) {
  if (node.collider) {
    var mvm = node.modelViewMatrix;
    var isCollection = node.colliderType === 'collection';

    if (isCollection) {
      var children = node.collider.geometries.map(function (geometry) {
        return geometryToDef(geometry, dpi, mvm);
      });
      return {
        type: 'container',
        children: children
      };
    }

    return geometryToDef(node.collider, dpi, mvm);
  }

  return null;
}
/**
 * Read-only object representing a node on the scene.
 */


var SceneNode =
/*#__PURE__*/
function () {
  function SceneNode(node) {
    var _this = this;

    _classCallCheck$1(this, SceneNode);

    this._bounds = function () {
      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      var _ref = node.boundingRect ? node.boundingRect(includeTransform) : {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      },
          x = _ref.x,
          y = _ref.y,
          width = _ref.width,
          height = _ref.height;

      return {
        x: x,
        y: y,
        width: width,
        height: height
      };
    };

    this._attrs = node.attrs;
    this._type = node.type;
    this._data = node.data;
    this._dpi = node.stage ? node.stage.dpi : 1;

    this._collider = function () {
      return colliderToShape(node, _this._dpi);
    };

    this._desc = node.desc;
    this._tag = node.tag;

    this._children = function () {
      return node.children.map(function (n) {
        return new SceneNode(n);
      });
    };

    this._parent = function () {
      return node.parent ? new SceneNode(node.parent) : null;
    };

    this._cache = {
      elementBoundingRect: null
    };

    this._getElementBoundingRect = function () {
      if (!_this._cache.elementBoundingRect && _this.element) {
        _this._cache.elementBoundingRect = _this.element.getBoundingClientRect();
      }

      return _this._cache.elementBoundingRect || {
        left: 0,
        top: 0
      };
    };
  }
  /**
   * Get child nodes
   * @type {SceneNode[]}
   */


  _createClass$1(SceneNode, [{
    key: "boundsRelativeTo",

    /**
     * Bounding rectangle of the node, relative a target.
     *
     * If target is an HTMLElement, the bounds are relative to the HTMLElement.
     * Any other target type will return the bounds relative to the viewport of the browser.
     *
     * @param {HTMLElement|any} target
     * @param {boolean} includeTransform - Whether to include any applied transforms on the node
     * @returns {rect}
     * @example
     *
     * node.boundsRelativeTo($('div'));
     * node.boundsRelativeTo('viewport');
     */
    value: function boundsRelativeTo(target) {
      var includeTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      var type = _typeof(target);

      var bounds = includeTransform ? this.bounds : this.localBounds;

      var selfRect = this._getElementBoundingRect();

      var dx = selfRect.left;
      var dy = selfRect.top;

      if (type === 'object' && target !== null && typeof target.getBoundingClientRect === 'function') {
        var _target$getBoundingCl = target.getBoundingClientRect(),
            _target$getBoundingCl2 = _target$getBoundingCl.left,
            left = _target$getBoundingCl2 === void 0 ? 0 : _target$getBoundingCl2,
            _target$getBoundingCl3 = _target$getBoundingCl.top,
            top = _target$getBoundingCl3 === void 0 ? 0 : _target$getBoundingCl3;

        dx -= left;
        dy -= top;
      }

      bounds.x += dx;
      bounds.y += dy;
      return bounds;
    }
    /**
     * Collider of the node. Transform on the node has been applied to the collider shape, if any, but excluding scaling transform related to devicePixelRatio.
     * Origin is in the top-left corner of the scene element.
     *
     * If node has no collider, null is returned.
     * @type {line|rect|circle|path}
     */

  }, {
    key: "children",
    get: function get() {
      return this._children();
    }
    /**
     * Get parent node
     * @type {SceneNode}
     */

  }, {
    key: "parent",
    get: function get() {
      return this._parent();
    }
    /**
     * Node type
     * @type {string}
     */

  }, {
    key: "type",
    get: function get() {
      return this._type;
    }
    /**
     * Get the associated data
     * @type {any}
     */

  }, {
    key: "data",
    get: function get() {
      return this._data;
    }
    /**
     * Node attributes
     * @type {object}
     */

  }, {
    key: "attrs",
    get: function get() {
      return this._attrs;
    }
    /**
     * Element the scene is attached to
     * @type {HTMLElement}
     * @private
     */

  }, {
    key: "element",
    set: function set(e) {
      this._cache.elementBoundingRect = null;
      this._element = e;
    }
    /**
     * Element the scene is attached to
     * @type {HTMLElement}
     */
    ,
    get: function get() {
      return this._element;
    }
    /**
    * Key of the component this shape belongs to
    * @type {string}
    * @private
    */

  }, {
    key: "key",
    set: function set(k) {
      this._key = k;
    }
    /**
    * Key of the component this shape belongs to
    * @type {string}
    */
    ,
    get: function get() {
      return this._key;
    }
    /**
     * Bounding rectangle of the node. After any transform has been applied, if any, but excluding scaling transform related to devicePixelRatio.
     * Origin is in the top-left corner of the scene element.
     * @type {rect}
     */

  }, {
    key: "bounds",
    get: function get() {
      var bounds = this._bounds();

      bounds.x /= this._dpi;
      bounds.y /= this._dpi;
      bounds.width /= this._dpi;
      bounds.height /= this._dpi;
      return bounds;
    }
    /**
     * Bounding rectangle of the node withing it's local coordinate system.
     * Origin is in the top-left corner of the scene element.
     * @type {rect}
     */

  }, {
    key: "localBounds",
    get: function get() {
      var bounds = this._bounds(false);

      return bounds;
    }
  }, {
    key: "collider",
    get: function get() {
      return this._collider();
    }
    /**
     * Node description
     * @type {object}
     */

  }, {
    key: "desc",
    get: function get() {
      return this._desc;
    }
    /**
     * Node tag
     * @type {string}
     */

  }, {
    key: "tag",
    get: function get() {
      return this._tag;
    }
  }]);

  return SceneNode;
}();

function create$b() {
  for (var _len = arguments.length, a = new Array(_len), _key = 0; _key < _len; _key++) {
    a[_key] = arguments[_key];
  }

  return _construct(SceneNode, a);
}

var Collision =
/*#__PURE__*/
function () {
  function Collision(node) {
    _classCallCheck$1(this, Collision);

    this._node = create$b(node);
    this._parent = null;
    this._input = null;
  }

  _createClass$1(Collision, [{
    key: "node",
    get: function get() {
      return this._node;
    }
  }, {
    key: "parent",
    set: function set(p) {
      this._parent = p;
    },
    get: function get() {
      return this._parent;
    }
  }, {
    key: "input",
    set: function set(i) {
      this._input = i;
    },
    get: function get() {
      return this._input;
    }
  }]);

  return Collision;
}();
function create$c() {
  for (var _len = arguments.length, a = new Array(_len), _key = 0; _key < _len; _key++) {
    a[_key] = arguments[_key];
  }

  return _construct(Collision, a);
}

function appendParentNode(node, collision) {
  var p = node.parent;

  if (p && p.type !== 'stage') {
    collision.parent = create$c(p);
    var pp = p.parent;

    if (pp && pp.type !== 'stage') {
      appendParentNode(pp, collision.parent);
    }
  }
}

function appendInputShape(shape, collisions) {
  for (var i = 0, len = collisions.length; i < len; i++) {
    collisions[i].input = shape;
  }
}

function resolveFrontChildCollision(node, type, input) {
  var num = node.descendants.length;

  for (var i = num - 1; i >= 0; i--) {
    var desc = node.descendants[i];

    if (desc.collider === null) {
      continue;
    }

    if (desc.collider[type](input)) {
      var collision = create$c(desc);
      appendParentNode(desc, collision);
      return collision;
    }
  }

  return null;
}

function resolveGeometryCollision(node, type, input) {
  if (node.collider[type](input)) {
    var c = create$c(node);
    appendParentNode(node, c);
    return c;
  }

  return null;
}

function inverseTransform(node, input) {
  var transformedInput = {};

  if (node.modelViewMatrix) {
    if (Array.isArray(input)) {
      // Rect or Line
      transformedInput = node.inverseModelViewMatrix.transformPoints(input);
    } else if (!isNaN(input.r)) {
      // Circle
      var p = {
        x: input.cx,
        y: input.cy
      };

      var _node$inverseModelVie = node.inverseModelViewMatrix.transformPoint(p);

      transformedInput.cx = _node$inverseModelVie.x;
      transformedInput.cy = _node$inverseModelVie.y;
      transformedInput.r = input.r;
    } else if (Array.isArray(input.vertices)) {
      // Polygon
      transformedInput.vertices = node.inverseModelViewMatrix.transformPoints(input.vertices);
    } else {
      // Point
      transformedInput = node.inverseModelViewMatrix.transformPoint(input);
    }
  } else {
    transformedInput = input;
  }

  if (Array.isArray(transformedInput.vertices)) {
    transformedInput = create$7(transformedInput); // TODO Shouldn't have to do this here, currently its beacause a collision algorithm optimization, i.e. caching of polygon bounds
  }

  return transformedInput;
}

function resolveCollision(node, intersectionType, input) {
  if (node.colliderType === null) {
    return null;
  }

  var transformedInput = inverseTransform(node, input);

  if (node.colliderType === 'frontChild') {
    return resolveFrontChildCollision(node, intersectionType, transformedInput);
  }

  return resolveGeometryCollision(node, intersectionType, transformedInput);
}

function findAllCollisions(nodes, intersectionType, ary, input) {
  var num = nodes.length;

  for (var i = 0; i < num; i++) {
    var node = nodes[i];
    var collision = resolveCollision(node, intersectionType, input);

    if (collision) {
      ary.push(collision);
    } // Only traverse children if no match is found on parent and it doesnt have any custom collider


    if (node.children && !collision && !node.collider) {
      findAllCollisions(node.children, intersectionType, ary, input);
    }
  }
}

function hasCollision(nodes, intersectionType, input) {
  var num = nodes.length;

  for (var i = 0; i < num; i++) {
    var node = nodes[i];
    var collision = resolveCollision(node, intersectionType, input);

    if (collision !== null) {
      return true;
    }

    if (node.children && !node.collider) {
      return hasCollision(node.children, intersectionType, input);
    }
  }

  return false;
}

function resolveShape(shape) {
  var ratio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var type = getShapeType(shape);
  var _shape = {};

  switch (type) {
    case 'circle':
      _shape.cx = shape.cx * ratio;
      _shape.cy = shape.cy * ratio;
      _shape.r = shape.r;
      return ['intersectsCircle', _shape];

    case 'rect':
      _shape = rectToPoints(shape).map(function (p) {
        return scalarMultiply(p, ratio);
      });
      return ['intersectsRect', _shape];

    case 'line':
      _shape = lineToPoints(shape).map(function (p) {
        return scalarMultiply(p, ratio);
      });
      return ['intersectsLine', _shape];

    case 'point':
      _shape = scalarMultiply(shape, ratio);
      return ['containsPoint', _shape];

    case 'polygon':
      _shape.vertices = shape.vertices.map(function (vertex) {
        return scalarMultiply(vertex, ratio);
      });
      return ['intersectsPolygon', _shape];

    default:
      return [];
  }
}

function resolveCollionsOnNode(node, shape) {
  var _resolveShape = resolveShape(shape, node.dpi),
      _resolveShape2 = _slicedToArray(_resolveShape, 2),
      intersectionType = _resolveShape2[0],
      _shape = _resolveShape2[1];

  var collisions = [];

  if (intersectionType) {
    findAllCollisions([node], intersectionType, collisions, _shape);
    appendInputShape(shape, collisions);
  }

  return collisions;
}
function hasCollisionOnNode(node, shape) {
  var _resolveShape3 = resolveShape(shape, node.dpi),
      _resolveShape4 = _slicedToArray(_resolveShape3, 2),
      intersectionType = _resolveShape4[0],
      _shape = _resolveShape4[1];

  return hasCollision([node], intersectionType, _shape);
}

/**
 * @typedef {object} node-def
 * @property {string} type
 * @property {string|gradient-def|pattern-def} [fill] - {@link https://www.w3.org/TR/fill-stroke-3/#fill-shorthand}
 * @property {string|gradient-def|pattern-def} [stroke] - {@link https://www.w3.org/TR/fill-stroke-3/#propdef-stroke}
 * @property {number} [strokeWidth] - {@link https://www.w3.org/TR/fill-stroke-3/#propdef-stroke-width}
 * @property {string|number[]} [strokeDasharray] - {@link https://www.w3.org/TR/fill-stroke-3/#propdef-stroke-dasharray}
 * @property {number} [opacity] - {@link https://www.w3.org/TR/css-color-4/#propdef-opacity}
 * @property {string} [transform] - {@link https://www.w3.org/TR/SVG/coords.html#TransformAttribute}
 * @property {object} [data] - Data object, may contain any properties
 * @property {object} [desc] - Meta-data object, may contain any properties
 * @property {string} [tag] - White-space seperated list of tags
 * @property {string} [id] - Unique identifier of the node
 * @property {object} [collider]
 */

var DisplayObject =
/*#__PURE__*/
function (_Node) {
  _inherits(DisplayObject, _Node);

  function DisplayObject(type) {
    var _this;

    _classCallCheck$1(this, DisplayObject);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(DisplayObject).call(this, type));
    _this._stage = null;
    _this._collider = {
      type: null,
      definition: null,
      fn: null
    };
    _this._attrs = {};
    _this._node = null;
    return _this;
  }

  _createClass$1(DisplayObject, [{
    key: "set",
    value: function set() {
      var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.node = v;
      var data = v.data,
          desc = v.desc,
          tag = v.tag,
          strokeReference = v.strokeReference,
          fillReference = v.fillReference;
      assignMappedAttribute(this.attrs, v);

      if (typeof data !== 'undefined') {
        this.data = data;
      }

      if (_typeof(desc) === 'object') {
        this.desc = extend(true, {}, desc);
      }

      if (typeof tag === 'string') {
        this.tag = tag;
      }

      if (typeof strokeReference === 'string') {
        this.strokeReference = strokeReference;
      }

      if (typeof fillReference === 'string') {
        this.fillReference = fillReference;
      }
    }
  }, {
    key: "findShapes",
    value: function findShapes(selector) {
      return nodeSelector.find(selector, this).map(function (node) {
        return create$b(node);
      });
    }
  }, {
    key: "getItemsFrom",
    value: function getItemsFrom(shape) {
      return resolveCollionsOnNode(this, shape);
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(p) {
      return hasCollisionOnNode(this, p);
    }
  }, {
    key: "intersectsLine",
    value: function intersectsLine(line) {
      return hasCollisionOnNode(this, line);
    }
  }, {
    key: "intersectsRect",
    value: function intersectsRect(rect) {
      return hasCollisionOnNode(this, rect);
    }
  }, {
    key: "intersectsCircle",
    value: function intersectsCircle(circle) {
      return hasCollisionOnNode(this, circle);
    }
  }, {
    key: "intersectsPolygon",
    value: function intersectsPolygon(polygon) {
      return hasCollisionOnNode(this, polygon);
    }
  }, {
    key: "resolveLocalTransform",
    value: function resolveLocalTransform() {
      var m = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Matrix();

      if (typeof this.attrs.transform !== 'undefined') {
        resolveTransform(this.attrs.transform, m);
      }

      this.modelViewMatrix = m.clone();
    }
  }, {
    key: "resolveGlobalTransform",
    value: function resolveGlobalTransform() {
      var m = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Matrix();
      var a = this.ancestors;

      if (a.length > 0) {
        for (var i = a.length - 1; i >= 0; i--) {
          a[i].resolveLocalTransform(m);
          m = a[i].modelViewMatrix;
        }
      }

      this.resolveLocalTransform(m);
    }
    /**
     * Returns the value of attribute a.
     * @private
     * @param a
     * @returns {*} The value of attribute a.
     */

  }, {
    key: "attr",
    value: function attr(a) {
      return this.attrs[a];
    }
  }, {
    key: "equals",
    value: function equals(d) {
      var attrs = this.attrs;
      var attrKeys = Object.keys(attrs);
      var dAttrs = d.attrs;
      var dAttrKeys = Object.keys(dAttrs);

      if (attrKeys.length !== dAttrKeys.length) {
        return false;
      }

      for (var i = 0; i < attrKeys.length; i++) {
        var key = attrKeys[i];

        if (!Object.hasOwnProperty.call(dAttrs, key)) {
          return false;
        }

        if (attrs[key] !== dAttrs[key]) {
          return false;
        }
      }

      return _get(_getPrototypeOf(DisplayObject.prototype), "equals", this).call(this, d);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var json = _get(_getPrototypeOf(DisplayObject.prototype), "toJSON", this).call(this);

      json.attrs = this.attrs;
      return json;
    }
  }, {
    key: "attrs",
    get: function get() {
      return this._attrs;
    }
  }, {
    key: "stage",
    get: function get() {
      if (this._parent && !this._stage) {
        // lazy evaluation
        this._stage = this._parent.stage;
      } else if (!this._parent && this._stage !== this) {
        this._stage = null;
      }

      return this._stage;
    }
  }, {
    key: "modelViewMatrix",
    set: function set(m) {
      this._mvm = m;
      this._imvm = null;
    },
    get: function get() {
      return this._mvm;
    }
  }, {
    key: "inverseModelViewMatrix",
    get: function get() {
      this._imvm = this._imvm ? this._imvm : this._mvm.clone().invert();
      return this._imvm;
    }
  }, {
    key: "node",
    set: function set(n) {
      this._node = n;
    },
    get: function get() {
      return this._node;
    }
  }, {
    key: "collider",
    set: function set(definition) {
      var type = Array.isArray(definition) ? 'collection' : definition && definition.type;

      if (typeof type !== 'string') {
        // Non string type definition resets the collider
        this._collider.type = null;
        this._collider.definition = null;
        this._collider.fn = null;
        return;
      } // Check if a collider of the same type is already defined, if so, do an update


      if (this._collider !== null && this._collider.type === type && this._collider.fn !== null) {
        this._collider.fn.set(definition);

        this._collider.definition = definition;
        return;
      } // Store the definition so that it can be lazy evaluated


      this._collider.type = type;
      this._collider.definition = definition;
    },
    get: function get() {
      // Resolve geometry function from cache
      if (this._collider.fn !== null) {
        return this._collider.fn;
      } // Resolve geometry function and store it in cache


      switch (this._collider.type) {
        case 'collection':
          this._collider.fn = create$a(this._collider.definition);
          break;

        case 'frontChild':
          // TODO Deprecate
          // Front child is not resolved by a function on this node, but instead on one of its child nodes
          return true;

        case 'bounds':
          this._collider.fn = create$9('rect', this.boundingRect());
          break;

        case 'line':
        case 'rect':
        case 'circle':
        case 'polygon':
        case 'polyline':
          this._collider.fn = create$9(this._collider.type, this._collider.definition);
          break;

        default:
          return null;
      }

      return this._collider.fn;
    }
  }, {
    key: "colliderType",
    get: function get() {
      return this._collider.type;
    }
  }]);

  return DisplayObject;
}(Node);

var NodeContainer =
/*#__PURE__*/
function (_Node) {
  _inherits(NodeContainer, _Node);

  function NodeContainer() {
    _classCallCheck$1(this, NodeContainer);

    return _possibleConstructorReturn(this, _getPrototypeOf(NodeContainer).apply(this, arguments));
  }

  _createClass$1(NodeContainer, [{
    key: "addChild",
    value: function addChild(c) {
      if (!c || !(c instanceof Node)) {
        throw new TypeError("Expecting a Node as argument, but got ".concat(c));
      }

      if (c === this) {
        throw new Error('Can not add itself as child!');
      }

      if (c._children && c._children.length && this.ancestors.indexOf(c) >= 0) {
        throw new Error('Can not add an ancestor as child!');
      }

      if (c._parent && c._parent !== this) {
        c._parent.removeChild(c);
      }

      this._children.push(c);

      c._parent = this;
      c._ancestors = null;
      return this;
    }
  }, {
    key: "addChildren",
    value: function addChildren(children) {
      var i,
          num = children ? children.length : 0;

      for (i = 0; i < num; i++) {
        this.addChild(children[i]);
      }

      return this;
    }
    /**
     * Removes given child node from this node.
     * @private
     * @param {Node} c
     * @returns {Node} This object, for chaining purposes.
     */

  }, {
    key: "removeChild",
    value: function removeChild(c) {
      var indx = this._children.indexOf(c);

      if (indx >= 0) {
        this._children.splice(indx, 1);

        c._parent = null;
        c._ancestors = null;
      }

      return this;
    }
  }, {
    key: "removeChildren",
    value: function removeChildren(children) {
      var i, num;

      if (!this._children) {
        return this;
      }

      if (children) {
        num = children.length;

        for (i = 0; i < num; i++) {
          this.removeChild(children[i]);
        }
      } else {
        while (this._children.length) {
          this.removeChild(this._children[0]);
        }
      }

      return this;
    }
  }]);

  return NodeContainer;
}(Node);

/**
 * @extends node-def
 * @typedef {object} node--container-def
 * @property {node-def[]} children - Array of child nodes
 */

var NC = NodeContainer.prototype;

var Container =
/*#__PURE__*/
function (_DisplayObject) {
  _inherits(Container, _DisplayObject);

  function Container() {
    var _this;

    var s = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck$1(this, Container);

    var _s$type = s.type,
        type = _s$type === void 0 ? 'container' : _s$type;
    _this = _possibleConstructorReturn(this, _getPrototypeOf(Container).call(this, type));

    _this.set(s);

    return _this;
  }

  _createClass$1(Container, [{
    key: "set",
    value: function set() {
      var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _get(_getPrototypeOf(Container.prototype), "set", this).call(this, v);

      var collider = v.collider;
      var opts = extend({
        type: null
      }, collider);
      this.collider = opts;
      this.__boundingRect = {
        true: null,
        false: null
      };
      this.__bounds = {
        true: null,
        false: null
      };
    }
  }, {
    key: "appendChildRect",
    value: function appendChildRect(child, includeTransform) {
      if (typeof child.bounds !== 'undefined') {
        var rect = this.__boundingRect[includeTransform] || {};

        var _child$bounds = child.bounds(includeTransform),
            _child$bounds2 = _slicedToArray(_child$bounds, 3),
            p0 = _child$bounds2[0],
            p2 = _child$bounds2[2];

        var xMin = p0.x,
            yMin = p0.y;
        var xMax = p2.x,
            yMax = p2.y;

        var _xMax = isNaN(rect.width) ? xMax : Math.max(xMax, rect.width + rect.x);

        var _yMax = isNaN(rect.height) ? yMax : Math.max(yMax, rect.height + rect.y);

        rect.x = isNaN(rect.x) ? xMin : Math.min(xMin, rect.x);
        rect.y = isNaN(rect.y) ? yMin : Math.min(yMin, rect.y);
        rect.width = _xMax - rect.x;
        rect.height = _yMax - rect.y;
        this.__boundingRect[includeTransform] = rect;
      }
    }
  }, {
    key: "boundingRect",
    value: function boundingRect() {
      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.__boundingRect[includeTransform] !== null) {
        return this.__boundingRect[includeTransform];
      }

      var num = this.children.length;

      for (var i = 0; i < num; i++) {
        this.appendChildRect(this.children[i], includeTransform);
      }

      this.__boundingRect[includeTransform] = extend({
        x: 0,
        y: 0,
        width: 0,
        height: 0
      }, this.__boundingRect[includeTransform]);
      return this.__boundingRect[includeTransform];
    }
  }, {
    key: "bounds",
    value: function bounds() {
      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.__bounds[includeTransform] !== null) {
        return this.__bounds[includeTransform];
      }

      var rect = this.boundingRect(includeTransform);
      this.__bounds[includeTransform] = [{
        x: rect.x,
        y: rect.y
      }, {
        x: rect.x + rect.width,
        y: rect.y
      }, {
        x: rect.x + rect.width,
        y: rect.y + rect.height
      }, {
        x: rect.x,
        y: rect.y + rect.height
      }];
      return this.__bounds[includeTransform];
    }
  }, {
    key: "addChild",
    value: function addChild(c) {
      var r = NC.addChild.call(this, c);

      if (this._collider && this._collider.type === 'bounds') {
        this.appendChildRect(c, true);
        var opts = extend({
          type: 'bounds',
          x: 0,
          y: 0,
          width: 0,
          height: 0
        }, this.__boundingRect.true);
        this.collider = opts;
      }

      return r;
    }
  }, {
    key: "addChildren",
    value: function addChildren(children) {
      var r = NC.addChildren.call(this, children);
      var num = children.length;

      if (this._collider && this._collider.type === 'bounds' && num > 0) {
        for (var i = 0; i < num; i++) {
          this.appendChildRect(children[i], true);
        }

        var opts = extend({
          type: 'bounds',
          x: 0,
          y: 0,
          width: 0,
          height: 0
        }, this.__boundingRect.true);
        this.collider = opts;
      }

      return r;
    }
  }, {
    key: "removeChild",
    value: function removeChild(c) {
      c._stage = null;
      var desc = c.descendants,
          num = desc ? desc.length : 0,
          i; // remove reference to stage from all descendants

      for (i = 0; i < num; i++) {
        desc[i]._stage = null;
      }

      NC.removeChild.call(this, c);

      if (this._collider && this._collider.type === 'bounds') {
        this.__boundingRect = {
          true: null,
          false: null
        };
        this.__bounds = {
          true: null,
          false: null
        };
        var opts = extend(this.boundingRect(true), {
          type: 'bounds'
        });
        this.collider = opts;
      }

      return this;
    }
  }, {
    key: "removeChildren",
    value: function removeChildren(children) {
      NC.removeChildren.call(this, children);

      if (this._collider && this._collider.type === 'bounds') {
        this.__boundingRect = {
          true: null,
          false: null
        };
        this.__bounds = {
          true: null,
          false: null
        };
        var opts = extend(this.boundingRect(true), {
          type: 'bounds'
        });
        this.collider = opts;
      }

      return this;
    }
  }]);

  return Container;
}(DisplayObject);
function create$d() {
  for (var _len = arguments.length, s = new Array(_len), _key = 0; _key < _len; _key++) {
    s[_key] = arguments[_key];
  }

  return _construct(Container, s);
}

var Stage =
/*#__PURE__*/
function (_Container) {
  _inherits(Stage, _Container);

  function Stage(dpi) {
    var _this;

    _classCallCheck$1(this, Stage);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Stage).call(this, 'stage'));
    _this._stage = _assertThisInitialized(_this);
    _this._dpiRatio = dpi || 1;
    return _this;
  }

  _createClass$1(Stage, [{
    key: "dpi",
    get: function get() {
      return this._dpiRatio;
    }
  }]);

  return Stage;
}(Container);
function create$e() {
  for (var _len = arguments.length, a = new Array(_len), _key = 0; _key < _len; _key++) {
    a[_key] = arguments[_key];
  }

  return _construct(Stage, a);
}

/**
 * @typedef {object} gradient-def
 * @property {string} type
 * @property {object[]} stops
 * @property {string} [stops[].type=linearGradient] - radialGradient|linearGradient
 * @property {string} stops[].color - {@link https://www.w3.org/TR/SVG/types.html#DataTypeColor}
 * @property {string} [stops[].opacity=1] - {@link https://www.w3.org/TR/css-color-4/#propdef-opacity}
 * @property {number} stops[].offset - {@link https://www.w3.org/TR/SVG/pservers.html#StopElementOffsetAttribute}
 * @property {number} [degree] - Gradient rotation angle
 */

/**
 * @typedef {object} node--gradient-item-def
 * @property {string} id - Gradient identifier
 * @property {number} x1 - {@link https://www.w3.org/TR/SVG/pservers.html#LinearGradientElementX1Attribute}
 * @property {number} y1 - {@link https://www.w3.org/TR/SVG/pservers.html#LinearGradientElementY1Attribute}
 * @property {number} x2 - {@link https://www.w3.org/TR/SVG/pservers.html#LinearGradientElementX2Attribute}
 * @property {number} y2 - {@link https://www.w3.org/TR/SVG/pservers.html#LinearGradientElementY2Attribute}
 * @property {number} offset - {@link https://www.w3.org/TR/SVG/pservers.html#StopElementOffsetAttribute}
 * @property {object} style - {@link https://www.w3.org/TR/SVG/styling.html#StyleAttribute}
 */

var NC$1 = NodeContainer.prototype;
var allowedAttrs = ['x1', 'x2', 'y1', 'y2', 'id', 'offset', 'style'];

var GradientItem =
/*#__PURE__*/
function (_DisplayObject) {
  _inherits(GradientItem, _DisplayObject);

  function GradientItem() {
    var _this;

    var s = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck$1(this, GradientItem);

    var _s$type = s.type,
        type = _s$type === void 0 ? 'container' : _s$type;
    _this = _possibleConstructorReturn(this, _getPrototypeOf(GradientItem).call(this, type));

    _this.set(s);

    _this._boundingRect = {};
    return _this;
  }

  _createClass$1(GradientItem, [{
    key: "set",
    value: function set() {
      var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _get(_getPrototypeOf(GradientItem.prototype), "set", this).call(this, v);

      var attrs = this.attrs;
      var attrKey = '';

      for (var i = 0, len = allowedAttrs.length; i !== len; i++) {
        attrKey = allowedAttrs[i];

        if (typeof v[attrKey] !== 'undefined') {
          attrs[attrKey] = v[attrKey];
        }
      }
    }
  }, {
    key: "addChild",
    value: function addChild(c) {
      var r = NC$1.addChild.call(this, c);
      return r;
    }
  }, {
    key: "addChildren",
    value: function addChildren(children) {
      var r = NC$1.addChildren.call(this, children);
      return r;
    }
  }, {
    key: "removeChild",
    value: function removeChild(c) {
      c._stage = null;
      var desc = c.descendants,
          num = desc ? desc.length : 0,
          i; // remove reference to stage from all descendants

      for (i = 0; i < num; i++) {
        desc[i]._stage = null;
      }

      NC$1.removeChild.call(this, c);
      return this;
    }
  }, {
    key: "removeChildren",
    value: function removeChildren(children) {
      NC$1.removeChildren.call(this, children);
      return this;
    }
  }]);

  return GradientItem;
}(DisplayObject);
function create$f() {
  for (var _len = arguments.length, s = new Array(_len), _key = 0; _key < _len; _key++) {
    s[_key] = arguments[_key];
  }

  return _construct(GradientItem, s);
}

/**
 * @experimental
 * @typedef {object} pattern-def
 * @property {'pattern'} type
 * @property {string} fill
 * @property {number} width
 * @property {number} height
 * @property {object[]} shapes
 * @example
 * Stripe pattern
 * ```js
 * {
 *   type: 'pattern',
 *   fill: 'red',
 *   width: 4,
 *   height: 4,
 *   shapes: [
 *     { type: 'rect', x: 3, y: 0, width: 1, height: 1 },
 *     { type: 'rect', x: 2, y: 1, width: 1, height: 1 },
 *     { type: 'rect', x: 1, y: 2, width: 1, height: 1 },
 *     { type: 'rect', x: 0, y: 3, width: 1, height: 1 },
 *   ]
 * }
 * ```
 */

var NC$2 = NodeContainer.prototype;
var allowedAttrs$1 = ['patternUnits', 'x', 'y', 'width', 'height', 'id'];

var PatternItem =
/*#__PURE__*/
function (_DisplayObject) {
  _inherits(PatternItem, _DisplayObject);

  function PatternItem() {
    var _this;

    var s = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck$1(this, PatternItem);

    var _s$type = s.type,
        type = _s$type === void 0 ? 'container' : _s$type;
    _this = _possibleConstructorReturn(this, _getPrototypeOf(PatternItem).call(this, type));

    _this.set(s);

    _this._boundingRect = {};
    return _this;
  }

  _createClass$1(PatternItem, [{
    key: "set",
    value: function set() {
      var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _get(_getPrototypeOf(PatternItem.prototype), "set", this).call(this, v);

      var attrs = this.attrs;
      var attrKey = '';

      for (var i = 0, len = allowedAttrs$1.length; i !== len; i++) {
        attrKey = allowedAttrs$1[i];

        if (typeof v[attrKey] !== 'undefined') {
          attrs[attrKey] = v[attrKey];
        }
      }
    }
  }, {
    key: "addChild",
    value: function addChild(c) {
      var r = NC$2.addChild.call(this, c);
      return r;
    }
  }, {
    key: "addChildren",
    value: function addChildren(children) {
      var r = NC$2.addChildren.call(this, children);
      return r;
    }
  }, {
    key: "removeChild",
    value: function removeChild(c) {
      c._stage = null;
      var desc = c.descendants,
          num = desc ? desc.length : 0,
          i; // remove reference to stage from all descendants

      for (i = 0; i < num; i++) {
        desc[i]._stage = null;
      }

      NC$2.removeChild.call(this, c);
      return this;
    }
  }, {
    key: "removeChildren",
    value: function removeChildren(children) {
      NC$2.removeChildren.call(this, children);
      return this;
    }
  }]);

  return PatternItem;
}(DisplayObject);
function create$g() {
  for (var _len = arguments.length, s = new Array(_len), _key = 0; _key < _len; _key++) {
    s[_key] = arguments[_key];
  }

  return _construct(PatternItem, s);
}

/**
 * @extends node-def
 * @typedef {object} node--rect-def
 * @property {number} x - {@link https://www.w3.org/TR/SVG/shapes.html#RectElementXAttribute}
 * @property {number} y - {@link https://www.w3.org/TR/SVG/shapes.html#RectElementYAttribute}
 * @property {number} width - {@link https://www.w3.org/TR/SVG/shapes.html#RectElementWidthAttribute}
 * @property {number} height- {@link https://www.w3.org/TR/SVG/shapes.html#RectElementHeightAttribute}
 */

var Rect =
/*#__PURE__*/
function (_DisplayObject) {
  _inherits(Rect, _DisplayObject);

  function Rect() {
    var _this2;

    var _this;

    _classCallCheck$1(this, Rect);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Rect).call(this, 'rect'));

    (_this2 = _this).set.apply(_this2, arguments);

    return _this;
  }

  _createClass$1(Rect, [{
    key: "set",
    value: function set() {
      var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _v$x = v.x,
          x = _v$x === void 0 ? 0 : _v$x,
          _v$y = v.y,
          y = _v$y === void 0 ? 0 : _v$y,
          _v$width = v.width,
          width = _v$width === void 0 ? 0 : _v$width,
          _v$height = v.height,
          height = _v$height === void 0 ? 0 : _v$height,
          _v$rx = v.rx,
          rx = _v$rx === void 0 ? 0 : _v$rx,
          _v$ry = v.ry,
          ry = _v$ry === void 0 ? 0 : _v$ry,
          collider = v.collider;
      var opts = extend({
        type: 'rect',
        x: x,
        y: y,
        width: width,
        height: height
      }, collider);

      _get(_getPrototypeOf(Rect.prototype), "set", this).call(this, v);

      if (width >= 0) {
        this.attrs.x = x;
        this.attrs.width = width;
      } else {
        this.attrs.x = x + width;
        this.attrs.width = -width;
      }

      if (height >= 0) {
        this.attrs.y = y;
        this.attrs.height = height;
      } else {
        this.attrs.y = y + height;
        this.attrs.height = -height;
      }

      if (rx > 0) {
        this.attrs.rx = rx;
      }

      if (ry > 0) {
        this.attrs.ry = ry;
      }

      this.collider = opts;
      this.__boundingRect = {
        true: null,
        false: null
      };
      this.__bounds = {
        true: null,
        false: null
      };
    }
  }, {
    key: "boundingRect",
    value: function boundingRect() {
      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.__boundingRect[includeTransform] !== null) {
        return this.__boundingRect[includeTransform];
      }

      var p = rectToPoints(this.attrs);
      var pt = includeTransform && this.modelViewMatrix ? this.modelViewMatrix.transformPoints(p) : p;

      var _getMinMax = getMinMax(pt),
          _getMinMax2 = _slicedToArray(_getMinMax, 4),
          xMin = _getMinMax2[0],
          yMin = _getMinMax2[1],
          xMax = _getMinMax2[2],
          yMax = _getMinMax2[3];

      this.__boundingRect[includeTransform] = {
        x: xMin,
        y: yMin,
        width: xMax - xMin,
        height: yMax - yMin
      };
      return this.__boundingRect[includeTransform];
    }
  }, {
    key: "bounds",
    value: function bounds() {
      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.__bounds[includeTransform] !== null) {
        return this.__bounds[includeTransform];
      }

      var rect = this.boundingRect(includeTransform);
      this.__bounds[includeTransform] = [{
        x: rect.x,
        y: rect.y
      }, {
        x: rect.x + rect.width,
        y: rect.y
      }, {
        x: rect.x + rect.width,
        y: rect.y + rect.height
      }, {
        x: rect.x,
        y: rect.y + rect.height
      }];
      return this.__bounds[includeTransform];
    }
  }]);

  return Rect;
}(DisplayObject);
function create$h() {
  for (var _len = arguments.length, s = new Array(_len), _key = 0; _key < _len; _key++) {
    s[_key] = arguments[_key];
  }

  return _construct(Rect, s);
}

/**
 * @extends node-def
 * @typedef {object} node--circle-def
 * @property {number} cx - {@link https://www.w3.org/TR/SVG/shapes.html#CircleElementCXAttribute}
 * @property {number} cy - {@link https://www.w3.org/TR/SVG/shapes.html#CircleElementCYAttribute}
 * @property {number} r - {@link https://www.w3.org/TR/SVG/shapes.html#CircleElementRAttribute}
 */

var Circle =
/*#__PURE__*/
function (_DisplayObject) {
  _inherits(Circle, _DisplayObject);

  function Circle() {
    var _this2;

    var _this;

    _classCallCheck$1(this, Circle);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Circle).call(this, 'circle'));

    (_this2 = _this).set.apply(_this2, arguments);

    return _this;
  }

  _createClass$1(Circle, [{
    key: "set",
    value: function set() {
      var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _v$cx = v.cx,
          cx = _v$cx === void 0 ? 0 : _v$cx,
          _v$cy = v.cy,
          cy = _v$cy === void 0 ? 0 : _v$cy,
          _v$r = v.r,
          r = _v$r === void 0 ? 0 : _v$r,
          collider = v.collider;
      var opts = extend({
        type: 'circle',
        cx: cx,
        cy: cy,
        r: r
      }, collider);

      _get(_getPrototypeOf(Circle.prototype), "set", this).call(this, v);

      this.attrs.cx = cx;
      this.attrs.cy = cy;
      this.attrs.r = r;
      this.collider = opts;
      this.__boundingRect = {
        true: null,
        false: null
      };
      this.__bounds = {
        true: null,
        false: null
      };
    }
  }, {
    key: "boundingRect",
    value: function boundingRect() {
      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.__boundingRect[includeTransform] !== null) {
        return this.__boundingRect[includeTransform];
      } // TODO Handle Circle bounds correctly for a circle transformed to an non axis aligned ellipse/circle
      // Current solution only rotate the bounds, giving a larger boundingRect if rotated


      var p = this.bounds(includeTransform);
      this.__boundingRect[includeTransform] = {
        x: p[0].x,
        y: p[0].y,
        width: p[2].x - p[0].x,
        height: p[2].y - p[0].y
      };
      return this.__boundingRect[includeTransform];
    }
  }, {
    key: "bounds",
    value: function bounds() {
      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.__bounds[includeTransform] !== null) {
        return this.__bounds[includeTransform];
      } // TODO Handle Circle bounds correctly for a circle transformed to an non axis aligned ellipse/circle


      var _this$attrs = this.attrs,
          cx = _this$attrs.cx,
          cy = _this$attrs.cy,
          rX = _this$attrs.r,
          rY = _this$attrs.r;
      var x = cx - rX;
      var y = cy - rY;
      var w = rX * 2;
      var h = rY * 2;
      var p = [{
        x: x,
        y: y
      }, {
        x: x + w,
        y: y
      }, {
        x: x + w,
        y: y + h
      }, {
        x: x,
        y: y + h
      }];

      if (includeTransform && this.modelViewMatrix) {
        p = this.modelViewMatrix.transformPoints(p);

        var _getMinMax = getMinMax(p),
            _getMinMax2 = _slicedToArray(_getMinMax, 4),
            xMin = _getMinMax2[0],
            yMin = _getMinMax2[1],
            xMax = _getMinMax2[2],
            yMax = _getMinMax2[3];

        w = xMax - xMin;
        h = yMax - yMin;
        this.__bounds[includeTransform] = [{
          x: xMin,
          y: yMin
        }, {
          x: xMin + w,
          y: yMin
        }, {
          x: xMin + w,
          y: yMin + h
        }, {
          x: xMin,
          y: yMin + h
        }];
      } else {
        this.__bounds[includeTransform] = p;
      }

      return this.__bounds[includeTransform];
    }
  }]);

  return Circle;
}(DisplayObject);
function create$i() {
  for (var _len = arguments.length, s = new Array(_len), _key = 0; _key < _len; _key++) {
    s[_key] = arguments[_key];
  }

  return _construct(Circle, s);
}

/**
 * @extends node-def
 * @typedef {object} node--line-def
 * @property {number} x1 - {@link https://www.w3.org/TR/SVG/shapes.html#LineElementX1Attribute}
 * @property {number} y1 - {@link https://www.w3.org/TR/SVG/shapes.html#LineElementY1Attribute}
 * @property {number} x2 - {@link https://www.w3.org/TR/SVG/shapes.html#LineElementX2Attribute}
 * @property {number} y2 - {@link https://www.w3.org/TR/SVG/shapes.html#LineElementY2Attribute}
 */

var Line =
/*#__PURE__*/
function (_DisplayObject) {
  _inherits(Line, _DisplayObject);

  function Line() {
    var _this2;

    var _this;

    _classCallCheck$1(this, Line);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Line).call(this, 'line'));

    (_this2 = _this).set.apply(_this2, arguments);

    return _this;
  }

  _createClass$1(Line, [{
    key: "set",
    value: function set() {
      var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _v$x = v.x1,
          x1 = _v$x === void 0 ? 0 : _v$x,
          _v$y = v.y1,
          y1 = _v$y === void 0 ? 0 : _v$y,
          _v$x2 = v.x2,
          x2 = _v$x2 === void 0 ? 0 : _v$x2,
          _v$y2 = v.y2,
          y2 = _v$y2 === void 0 ? 0 : _v$y2,
          collider = v.collider;

      _get(_getPrototypeOf(Line.prototype), "set", this).call(this, v);

      this.attrs.x1 = x1;
      this.attrs.y1 = y1;
      this.attrs.x2 = x2;
      this.attrs.y2 = y2;
      var defaultCollider = {
        type: 'line',
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2
      };
      this.collider = extend(defaultCollider, collider);
      this.__boundingRect = {
        true: null,
        false: null
      };
      this.__bounds = {
        true: null,
        false: null
      };
    }
  }, {
    key: "boundingRect",
    value: function boundingRect() {
      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.__boundingRect[includeTransform] !== null) {
        return this.__boundingRect[includeTransform];
      }

      var p = lineToPoints(this.attrs);

      if (includeTransform && this.modelViewMatrix) {
        p = this.modelViewMatrix.transformPoints(p);
      }

      var _getMinMax = getMinMax(p),
          _getMinMax2 = _slicedToArray(_getMinMax, 4),
          xMin = _getMinMax2[0],
          yMin = _getMinMax2[1],
          xMax = _getMinMax2[2],
          yMax = _getMinMax2[3];

      var hasSize = xMin !== xMax || yMin !== yMax;
      this.__boundingRect[includeTransform] = {
        x: xMin,
        y: yMin,
        width: hasSize ? Math.max(1, xMax - xMin) : 0,
        height: hasSize ? Math.max(1, yMax - yMin) : 0
      };
      return this.__boundingRect[includeTransform];
    }
  }, {
    key: "bounds",
    value: function bounds() {
      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.__bounds[includeTransform] !== null) {
        return this.__bounds[includeTransform];
      }

      var rect = this.boundingRect(includeTransform);
      this.__bounds[includeTransform] = [{
        x: rect.x,
        y: rect.y
      }, {
        x: rect.x + rect.width,
        y: rect.y
      }, {
        x: rect.x + rect.width,
        y: rect.y + rect.height
      }, {
        x: rect.x,
        y: rect.y + rect.height
      }];
      return this.__bounds[includeTransform];
    }
  }]);

  return Line;
}(DisplayObject);
function create$j() {
  for (var _len = arguments.length, s = new Array(_len), _key = 0; _key < _len; _key++) {
    s[_key] = arguments[_key];
  }

  return _construct(Line, s);
}

var PI_2 = Math.PI / 2;

function lineAngle(p0, p1) {
  var t = Math.atan2(p1.y - p0.y, p1.x - p0.x);
  return t < 0 ? t + Math.PI * 2 : t;
} // TODO Find a more accurate method to find the open and closed points


function rotatePoint$1(p, angle, radius) {
  return {
    x: p.x + Math.cos(angle) * radius,
    y: p.y + Math.sin(angle) * radius
  };
}

function polylineToPolygonCollider(points, radius) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var open = [];
  var close = []; // TODO handle case if points.length === 2

  if (opts.forceOrientation === 'h') {
    var start = points[0].x < points[1].x ? -1 : 1;
    var end = points[points.length - 1].x > points[points.length - 2].x ? 1 : -1;
    points.unshift({
      x: points[0].x + start,
      y: points[0].y
    });
    points.push({
      x: points[points.length - 1].x + end,
      y: points[points.length - 1].y
    });
  } else if (opts.forceOrientation === 'v') {
    var _start = points[0].y < points[1].y ? -1 : 1;

    var _end = points[points.length - 1].y > points[points.length - 2].y ? 1 : -1;

    points.unshift({
      x: points[0].x,
      y: points[0].y + _start
    });
    points.push({
      x: points[points.length - 1].x,
      y: points[points.length - 1].y + _end
    });
  }

  var len = points.length - 1;

  for (var i = 1; i < len; i++) {
    var prev = points[i - 1];
    var curr = points[i];
    var next = points[i + 1];
    var currToPrev = lineAngle(curr, prev);
    var currToNext = lineAngle(curr, next);
    var openAngle = (currToPrev + currToNext) / 2;
    var closeAngle = openAngle + Math.PI;
    var maxAngle = Math.max(openAngle, closeAngle);
    var minAngle = Math.min(openAngle, closeAngle);
    var openClose = currToPrev > currToNext;

    if (i === 1) {
      var prevToCurr = lineAngle(prev, curr);
      open.push(rotatePoint$1(prev, prevToCurr - PI_2, radius));
      close.unshift(rotatePoint$1(prev, prevToCurr + PI_2, radius));
    }

    var opened = openClose ? maxAngle : minAngle;
    var closed = openClose ? minAngle : maxAngle;
    open.push(rotatePoint$1(curr, opened, radius));
    close.unshift(rotatePoint$1(curr, closed, radius));

    if (i === len - 1) {
      var nextToCurr = lineAngle(next, curr);
      open.push(rotatePoint$1(next, nextToCurr + PI_2, radius));
      close.unshift(rotatePoint$1(next, nextToCurr - PI_2, radius));
    }
  }

  return {
    type: 'polygon',
    vertices: [].concat(open, close)
  };
}

function flatten2d(ary) {
  var newAry = [];
  var a;
  var len = ary.length;

  for (var i = 0; i < len; i++) {
    a = ary[i];

    for (var k = 0; k < a.length; k++) {
      newAry.push(a[k]);
    }
  }

  return newAry;
}

var EPSILON$2 = 1e-12;
/**
 * @extends node-def
 * @typedef {object} node--path-def
 * @property {string} d - {@link https://www.w3.org/TR/SVG/paths.html#DAttribute}
 */

function isClosed(points) {
  if (points.length < 2) {
    return false;
  }

  var p0 = points[0];
  var p1 = points[points.length - 1];
  return Math.abs(p0.x - p1.x) < EPSILON$2 && Math.abs(p0.y - p1.y) < EPSILON$2;
}

var Path$1 =
/*#__PURE__*/
function (_DisplayObject) {
  _inherits(Path, _DisplayObject);

  function Path() {
    var _this2;

    var _this;

    _classCallCheck$1(this, Path);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Path).call(this, 'path'));

    (_this2 = _this).set.apply(_this2, arguments);

    return _this;
  }

  _createClass$1(Path, [{
    key: "set",
    value: function set() {
      var _this3 = this;

      var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _get(_getPrototypeOf(Path.prototype), "set", this).call(this, v);

      this.segments = [];
      this.points = [];
      this.attrs.d = v.d;

      if (Array.isArray(v.collider) || _typeof(v.collider) === 'object' && typeof v.collider.type !== 'undefined') {
        this.collider = v.collider;
      } else if (v.d) {
        this.segments = pathToPoints(v.d);
        this.segments.forEach(function (segment) {
          if (segment.length <= 1) ; else if (isClosed(segment)) {
            _this3.collider = extend({
              type: 'polygon',
              vertices: segment
            }, v.collider);
          } else if (_typeof(v.collider) === 'object' && v.collider.visual) {
            var size = _this3.attrs['stroke-width'] / 2;
            _this3.collider = polylineToPolygonCollider(segment, size, v.collider);
          } else {
            _this3.collider = extend({
              type: 'polyline',
              points: segment
            }, v.collider);
          }
        });
      }

      this.__boundingRect = {
        true: null,
        false: null
      };
      this.__bounds = {
        true: null,
        false: null
      };
    }
  }, {
    key: "boundingRect",
    value: function boundingRect() {
      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.__boundingRect[includeTransform] !== null) {
        return this.__boundingRect[includeTransform];
      }

      if (!this.points.length) {
        this.segments = this.segments.length ? this.segments : pathToPoints(this.attrs.d);
        this.points = flatten2d(this.segments);
      }

      var pt = includeTransform && this.modelViewMatrix ? this.modelViewMatrix.transformPoints(this.points) : this.points;

      var _getMinMax = getMinMax(pt),
          _getMinMax2 = _slicedToArray(_getMinMax, 4),
          xMin = _getMinMax2[0],
          yMin = _getMinMax2[1],
          xMax = _getMinMax2[2],
          yMax = _getMinMax2[3];

      this.__boundingRect[includeTransform] = {
        x: xMin || 0,
        y: yMin || 0,
        width: xMax - xMin || 0,
        height: yMax - yMin || 0
      };
      return this.__boundingRect[includeTransform];
    }
  }, {
    key: "bounds",
    value: function bounds() {
      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.__bounds[includeTransform] !== null) {
        return this.__bounds[includeTransform];
      }

      var rect = this.boundingRect(includeTransform);
      this.__bounds[includeTransform] = [{
        x: rect.x,
        y: rect.y
      }, {
        x: rect.x + rect.width,
        y: rect.y
      }, {
        x: rect.x + rect.width,
        y: rect.y + rect.height
      }, {
        x: rect.x,
        y: rect.y + rect.height
      }];
      return this.__bounds[includeTransform];
    }
  }]);

  return Path;
}(DisplayObject);
function create$k() {
  for (var _len = arguments.length, s = new Array(_len), _key = 0; _key < _len; _key++) {
    s[_key] = arguments[_key];
  }

  return _construct(Path$1, s);
}

function hasData(_ref) {
  var data = _ref.data,
      _boundingRect = _ref._boundingRect,
      _textBoundsFn = _ref._textBoundsFn;
  return typeof data !== 'undefined' && data !== null && (_boundingRect || _textBoundsFn);
}
/**
 * @extends node-def
 * @typedef {object} node--text-def
 * @property {string} text
 * @property {number} x - {@link https://www.w3.org/TR/SVG/text.html#TextElementXAttribute}
 * @property {number} y - {@link https://www.w3.org/TR/SVG/text.html#TextElementYAttribute}
 * @property {number} [dx] - {@link https://www.w3.org/TR/SVG/text.html#TextElementDXAttribute}
 * @property {number} [dy] - {@link https://www.w3.org/TR/SVG/text.html#TextElementDYAttribute}
 * @property {string} [fontSize] - {@link https://www.w3.org/TR/SVG/text.html#FontPropertiesUsedBySVG}
 * @property {string} [fontFamily] - {@link https://www.w3.org/TR/SVG/text.html#FontPropertiesUsedBySVG}
 * @property {rect} [boundingRect] - Explicitly set the bounding rectangle of the node. Has predence over textBoundsFn
 * @property {function} [textBoundsFn] - Implicitly set the bounding rectangle of the node, the function must return an object with x, y, width and height attributes
 * @property {string} [baseline] - Alias for dominantBaseline
 * @property {string} [dominantBaseline] - {@link https://www.w3.org/TR/SVG/text.html#BaselineAlignmentProperties}
 * @property {string} [anchor] - Alias for textAnchor
 * @property {string} [textAnchor] - {@link https://www.w3.org/TR/SVG/text.html#TextAnchorProperty}
 * @property {string} [wordBreak] - Word-break option
 * @property {number} [maxWidth] - Maximum allowed text width
 * @property {number} [maxHeight] - Maximum allowed text height. If both maxLines and maxHeight are set, the property that results in the fewest number of lines is used
 * @property {number} [maxLines] - Maximum number of lines allowed
 * @property {number} [lineHeight=1.2] - Line height
 */


var Text =
/*#__PURE__*/
function (_DisplayObject) {
  _inherits(Text, _DisplayObject);

  function Text() {
    var _this2;

    var _this;

    _classCallCheck$1(this, Text);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Text).call(this, 'text'));

    (_this2 = _this).set.apply(_this2, arguments);

    return _this;
  }

  _createClass$1(Text, [{
    key: "set",
    value: function set() {
      var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _v$x = v.x,
          x = _v$x === void 0 ? 0 : _v$x,
          _v$y = v.y,
          y = _v$y === void 0 ? 0 : _v$y,
          _v$dx = v.dx,
          dx = _v$dx === void 0 ? 0 : _v$dx,
          _v$dy = v.dy,
          dy = _v$dy === void 0 ? 0 : _v$dy,
          textBoundsFn = v.textBoundsFn,
          text = v.text,
          title = v.title,
          collider = v.collider,
          boundingRect = v.boundingRect;

      _get(_getPrototypeOf(Text.prototype), "set", this).call(this, v);

      this.attrs.x = x;
      this.attrs.y = y;
      this.attrs.dx = dx;
      this.attrs.dy = dy;
      this.attrs.text = text;

      if (typeof title !== 'undefined') {
        this.attrs.title = String(title);
      }

      if (_typeof(boundingRect) === 'object') {
        this._textBoundsFn = function () {
          return boundingRect;
        };
      } else if (typeof textBoundsFn === 'function') {
        this._textBoundsFn = textBoundsFn;
      }

      this.collider = extend({
        type: hasData(this) ? 'bounds' : null
      }, collider);
      this.__boundingRect = {
        true: null,
        false: null
      };
      this.__bounds = {
        true: null,
        false: null
      };
    }
  }, {
    key: "boundingRect",
    value: function boundingRect() {
      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.__boundingRect[includeTransform] !== null) {
        return this.__boundingRect[includeTransform];
      }

      var rect;

      if (typeof this._textBoundsFn === 'function') {
        rect = this._textBoundsFn(this.attrs);
      } else {
        return {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
      }

      var p = rectToPoints(rect);
      var pt = includeTransform && this.modelViewMatrix ? this.modelViewMatrix.transformPoints(p) : p;

      var _getMinMax = getMinMax(pt),
          _getMinMax2 = _slicedToArray(_getMinMax, 4),
          xMin = _getMinMax2[0],
          yMin = _getMinMax2[1],
          xMax = _getMinMax2[2],
          yMax = _getMinMax2[3];

      this.__boundingRect[includeTransform] = {
        x: xMin,
        y: yMin,
        width: xMax - xMin,
        height: yMax - yMin
      };
      return this.__boundingRect[includeTransform];
    }
  }, {
    key: "bounds",
    value: function bounds() {
      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.__bounds[includeTransform] !== null) {
        return this.__bounds[includeTransform];
      }

      var rect = this.boundingRect(includeTransform);
      this.__bounds[includeTransform] = [{
        x: rect.x,
        y: rect.y
      }, {
        x: rect.x + rect.width,
        y: rect.y
      }, {
        x: rect.x + rect.width,
        y: rect.y + rect.height
      }, {
        x: rect.x,
        y: rect.y + rect.height
      }];
      return this.__bounds[includeTransform];
    }
  }]);

  return Text;
}(DisplayObject);
function create$l() {
  for (var _len = arguments.length, s = new Array(_len), _key = 0; _key < _len; _key++) {
    s[_key] = arguments[_key];
  }

  return _construct(Text, s);
}

var reg$4 = registryFactory();
reg$4.add('rect', create$h);
reg$4.add('circle', create$i);
reg$4.add('text', create$l);
reg$4.add('line', create$j);
reg$4.add('path', create$k);
reg$4.add('stage', create$e);
reg$4.add('container', create$d);
reg$4.add('defs', create$d);
reg$4.add('linearGradient', create$f);
reg$4.add('radialGradient', create$f);
reg$4.add('stop', create$f);
reg$4.add('pattern', create$g);
function create$m(type, input) {
  // eslint-disable-line import/prefer-default-export
  return reg$4.get(type)(input);
}

/**
 * Creates a context. Input an array of strings that should be inherited by the context.
 * @private
 *
 * @param  {Array}  [whitelist=[]]  An array of whitelisted string keys to inherit
 * @return {Function}               A context function
 */

function contextFactory() {
  var whitelist = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var states = [{}];
  /**
   * Returns the current context as an object. The object is mutable.
   * @private
   *
   * @return {Object}   Current context
   */

  function context() {
    // Returns the current context, the last in the stack.
    var item = states[states.length - 1];
    return item;
  }
  /**
   * Call context.save() to save the current context and move down the stack.
   *
   * @param  {Object} [item={}]   Optional item to save.
   * @return {Object}             The current context, just as context()
   */


  context.save = function save() {
    var item = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var current = context();
    var obj = {};
    var key = ''; // Only inherit whitelisted properties

    for (var i = 0; i < whitelist.length; i++) {
      key = whitelist[i];

      if (typeof current[key] !== 'undefined') {
        obj[key] = current[key];
      }
    } // Extend the new object with the saved item


    extend(obj, item); // Push it to the stack

    states.push(obj); // Return the new current context

    return context();
  };
  /**
   * Restore the previous context. Returns the context.
   *
   * @return {Undefined}   Returns nothing
   */


  context.restore = function restore() {
    // Remove the last element from the stack
    states.splice(states.length - 1, 1);
  };

  return context;
}

var styleContext = contextFactory(['stroke', 'fill', 'strokeWidth', 'opacity', 'fontFamily', 'fontSize', 'baseline']);

function doEvent(state, listeners) {
  if (!Array.isArray(listeners)) {
    return;
  }

  for (var i = 0, len = listeners.length; i < len; i++) {
    listeners[i](state);
  }
}

function updateState(state, index, nodes) {
  state.node = nodes[index];
  state.index = index;
}

function traverse(items, parent, matrix, on) {
  var disabled = false;
  var state = {
    siblings: items,
    node: null,
    index: 0
  };

  for (var i = 0, len = items.length; i < len; i++) {
    updateState(state, i, items);
    doEvent(state, on.create);
    disabled = typeof state.node.disabled === 'function' ? state.node.disabled() : state.node.disabled;

    if (disabled) {
      continue;
    } // Save the current style context to be able to inherit styles


    state.node = styleContext.save(state.node);
    var displayNode = create$m(state.node.type, state.node);

    if (displayNode) {
      if (state.node.transform) {
        matrix.save();
        resolveTransform(state.node.transform, matrix);
      }

      if (!matrix.isIdentity()) {
        displayNode.modelViewMatrix = matrix.clone();
      }

      parent.addChild(displayNode);

      if (state.node.children) {
        traverse(state.node.children, displayNode, matrix, on);
      }

      if (state.node.transform) {
        matrix.restore();
      }
    } // Revert to previous style context


    styleContext.restore();
  }
}

function scene(_ref) {
  var items = _ref.items,
      stage = _ref.stage,
      dpi = _ref.dpi,
      _ref$on = _ref.on,
      on = _ref$on === void 0 ? {} : _ref$on;

  if (!stage) {
    stage = create$m('stage', dpi);
  }

  traverse(items, stage, new Matrix(), on);
  return stage;
}

var LINEBREAK_REGEX = /\n+|\r+|\r\n/;
var WHITESPACE_REGEX = /\s/;
var HYPHEN_REGEX = /[a-zA-Z\u00C0-\u00F6\u00F8-\u00FF\u00AD]/;
var NO_BREAK = 0;
var MANDATORY = 1;
var BREAK_ALLOWED = 2;
function includesLineBreak(c) {
  if (typeof c === 'string') {
    return c.search(LINEBREAK_REGEX) !== -1;
  }

  return String(c).search(LINEBREAK_REGEX) !== -1;
}

function includesWhiteSpace(c) {
  return c.search(WHITESPACE_REGEX) !== -1;
}

function hyphenationAllowed(c) {
  /* Latin character set. Excluding numbers, sign and symbol characters, but including soft hyphen */
  return c.search(HYPHEN_REGEX) !== -1;
}

function resolveBreakOpportunity(chunk, i, chunks, mandatory, noBreakAllowed) {
  if (mandatory.some(function (fn) {
    return fn(chunk, i, chunks);
  })) {
    return MANDATORY;
  }

  if (noBreakAllowed.some(function (fn) {
    return fn(chunk, i, chunks);
  })) {
    return NO_BREAK;
  }

  return BREAK_ALLOWED;
}

function cleanEmptyChunks(chunks) {
  if (chunks[0] === '') {
    chunks.shift();
  }

  if (chunks[chunks.length - 1] === '') {
    chunks.pop();
  }
}

function clamp$1(val, min, max) {
  return Math.max(min, Math.min(max, val));
}

function stringTokenizer() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      string = _ref.string,
      _ref$separator = _ref.separator,
      separator = _ref$separator === void 0 ? '' : _ref$separator,
      _ref$reverse = _ref.reverse,
      reverse = _ref$reverse === void 0 ? false : _ref$reverse,
      _ref$measureText = _ref.measureText,
      measureText = _ref$measureText === void 0 ? function (text) {
    return {
      width: text.length,
      height: 1
    };
  } : _ref$measureText,
      _ref$mandatoryBreakId = _ref.mandatoryBreakIdentifiers,
      mandatoryBreakIdentifiers = _ref$mandatoryBreakId === void 0 ? [includesLineBreak] : _ref$mandatoryBreakId,
      _ref$noBreakAllowedId = _ref.noBreakAllowedIdentifiers,
      noBreakAllowedIdentifiers = _ref$noBreakAllowedId === void 0 ? [] : _ref$noBreakAllowedId,
      _ref$suppressIdentifi = _ref.suppressIdentifier,
      suppressIdentifier = _ref$suppressIdentifi === void 0 ? [includesWhiteSpace, includesLineBreak, function (chunk) {
    return chunk === '';
  }] : _ref$suppressIdentifi,
      _ref$hyphenationIdent = _ref.hyphenationIdentifiers,
      hyphenationIdentifiers = _ref$hyphenationIdent === void 0 ? [hyphenationAllowed] : _ref$hyphenationIdent;

  var chunks = String(string).split(separator);
  cleanEmptyChunks(chunks);
  var length = chunks.length;
  var isNotDone = reverse ? function (p) {
    return p >= 0;
  } : function (p) {
    return p < length;
  };
  var position = reverse ? length : -1; // Set init position 1 step before or after to make first next call go to first position

  function peek(peekAt) {
    var i = clamp$1(peekAt, 0, length - 1);
    var chunk = chunks[i];
    var textMeasure = measureText(chunk);
    var opportunity = resolveBreakOpportunity(chunk, i, chunks, mandatoryBreakIdentifiers, noBreakAllowedIdentifiers);
    return {
      index: i,
      value: chunk,
      breakOpportunity: opportunity,
      suppress: suppressIdentifier.some(function (fn) {
        return fn(chunk, i, chunks);
      }),
      hyphenation: hyphenationIdentifiers.some(function (fn) {
        return fn(chunk, i, chunks);
      }),
      width: textMeasure.width,
      height: textMeasure.height,
      done: false
    };
  }

  function next(jumpToPosition) {
    if (isNaN(jumpToPosition)) {
      if (reverse) {
        position--;
      } else {
        position++;
      }
    } else {
      position = clamp$1(jumpToPosition, 0, length - 1);
    }

    if (isNotDone(position)) {
      return peek(position);
    }

    return {
      done: true
    };
  }

  return {
    next: next,
    peek: peek,
    length: length
  };
}

var HYPHENS_CHAR = "\u2010";
var ELLIPSIS_CHAR = '…';

var BASE = 24;
var PAD = 4;
var BUMP = 1e-12;
var DEFAULT_FONT_HEIGHT = 16;
var DEFAULT_LINE_HEIGHT = 1.2;
var TEXT_REGEX = /^\s*\d+(\.\d+)?px\s*$/i;

function isValidFontSize(val) {
  var type = _typeof(val);

  if (type === 'string') {
    return TEXT_REGEX.test(val);
  }

  return false;
}

function fontSizeToHeight(fontSize) {
  if (isValidFontSize(fontSize)) {
    var size = parseFloat(fontSize);
    var m = PAD * Math.ceil((size + BUMP) / BASE);
    return size + m;
  }

  return DEFAULT_FONT_HEIGHT;
}
function fontSizeToLineHeight(node) {
  var fontSize = node['font-size'] || node.fontSize;

  if (isValidFontSize(fontSize)) {
    return parseFloat(fontSize) * Math.max(isNaN(node.lineHeight) ? DEFAULT_LINE_HEIGHT : node.lineHeight, 0);
  }

  return DEFAULT_FONT_HEIGHT * DEFAULT_LINE_HEIGHT;
}

function resolveMaxAllowedLines(node) {
  var maxHeight = node.maxHeight;
  var maxLines = Math.max(node.maxLines, 1) || Infinity;

  if (isNaN(maxHeight)) {
    return maxLines;
  }

  var computedLineHeight = fontSizeToLineHeight(node);
  return Math.max(1, Math.min(Math.floor(maxHeight / computedLineHeight), maxLines));
}

function initState$1(node, measureText) {
  return {
    lines: [],
    line: '',
    width: 0,
    maxLines: resolveMaxAllowedLines(node),
    maxWidth: node.maxWidth,
    hyphens: {
      enabled: node.hyphens === 'auto',
      char: HYPHENS_CHAR,
      metrics: measureText(HYPHENS_CHAR)
    }
  };
}

function newLine(state) {
  state.lines.push(state.line);
  state.line = '';
  state.width = 0;
}

function appendToLine(state, token) {
  state.line += token.value;
  state.width += token.width;
}

function insertHyphenAndJump(state, token, iterator) {
  if (token.width > state.maxWidth) {
    return token;
  }

  var startIndex = token.index;

  for (var i = 1; i < 5; i++) {
    var pairToken = iterator.peek(token.index - 1);

    if (!token.hyphenation || !pairToken.hyphenation || token.index === 0) {
      return token;
    }

    if (state.width + state.hyphens.metrics.width <= state.maxWidth) {
      state.line += state.hyphens.char;
      return token;
    }

    if (state.line.length === 1) {
      return token;
    }

    token = iterator.next(startIndex - i);
    state.line = state.line.slice(0, -1);
    state.width -= token.width;
  }

  return token;
}

function breakSequence(state, token, measureText) {
  var charTokenIterator = stringTokenizer({
    string: token.value,
    measureText: measureText
  });

  while (state.lines.length < state.maxLines) {
    var charToken = charTokenIterator.next();

    if (charToken.done) {
      break;
    } else if (state.width + charToken.width > state.maxWidth && charToken.breakOpportunity === BREAK_ALLOWED && state.line.length > 0) {
      charToken = state.hyphens.enabled ? insertHyphenAndJump(state, charToken, charTokenIterator) : charToken;
      newLine(state);
      appendToLine(state, charToken);
    } else {
      appendToLine(state, charToken);
    }
  }
}

function breakAll(node, measureText) {
  var text = node.text;
  var iterator = stringTokenizer({
    string: text,
    separator: '',
    measureText: measureText,
    noBreakAllowedIdentifiers: [function (chunk, i) {
      return i === 0;
    }]
  });
  var state = initState$1(node, measureText);
  var reduced = true;

  while (state.lines.length < state.maxLines) {
    var token = iterator.next();

    if (token.done) {
      newLine(state);
      reduced = false;
      break;
    } else if (token.breakOpportunity === MANDATORY) {
      newLine(state);
    } else if (state.width + token.width > state.maxWidth && token.breakOpportunity === BREAK_ALLOWED) {
      if (token.suppress) {
        // Token is suppressable and can be ignored
        state.width += token.width;
      } else {
        token = state.hyphens.enabled ? insertHyphenAndJump(state, token, iterator) : token;
        newLine(state);
        appendToLine(state, token);
      }
    } else {
      appendToLine(state, token);
    }
  }

  return {
    lines: state.lines,
    reduced: reduced
  };
}
function breakWord(node, measureText) {
  var text = node.text;
  var iterator = stringTokenizer({
    string: text,
    separator: /(\s|-|\u2010)/,
    measureText: measureText
  });
  var state = initState$1(node, measureText);
  var reduced = true;

  while (state.lines.length < state.maxLines) {
    var token = iterator.next();

    if (token.done) {
      newLine(state);
      reduced = false;
      break;
    } else if (token.breakOpportunity === MANDATORY) {
      newLine(state);
    } else if (state.width + token.width > state.maxWidth && token.breakOpportunity === BREAK_ALLOWED) {
      if (token.suppress) {
        // Token is suppressable and can be ignored
        newLine(state);
      } else if (token.width > state.maxWidth) {
        // Single sequence is wider then maxWidth, break sequence into multiple lines
        breakSequence(state, token, measureText);
      } else {
        newLine(state);
        appendToLine(state, token);
      }
    } else {
      appendToLine(state, token);
    }
  }

  return {
    lines: state.lines,
    reduced: reduced
  };
}

function generateLineNodes(result, item, halfLead, height) {
  var container = {
    type: 'container',
    children: []
  };

  if (typeof item.id !== 'undefined') {
    // TODO also inherit data attribute and more?
    container.id = item.id;
  }

  var currentY = 0;
  result.lines.forEach(function (line, i) {
    var node = extend({}, item);
    node.text = line;
    node._lineBreak = true; // Flag node as processed to avoid duplicate linebreak run

    currentY += halfLead; // leading height above

    if (result.reduced && i === result.lines.length - 1) {
      node.text += ELLIPSIS_CHAR;
    } else {
      delete node.maxWidth;
    }

    node.dy = isNaN(node.dy) ? currentY : node.dy + currentY;
    currentY += height;
    currentY += halfLead; // Leading height below

    container.children.push(node);
  });
  return container;
}

function shouldLineBreak(item) {
  // If type text and not already broken into lines
  return item.type === 'text' && !item._lineBreak;
}

function wrappedMeasureText(node, measureText) {
  return function (text) {
    return measureText({
      text: text,
      fontSize: node.fontSize,
      fontFamily: node.fontFamily
    });
  };
}

function resolveLineBreakAlgorithm(node) {
  var WORDBREAK = {
    'break-all': breakAll,
    'break-word': breakWord
  };
  return WORDBREAK[node.wordBreak];
}
/**
 * Apply wordBreak rules to text nodes.
 * @ignore
 * @param {function} measureText
 * @returns {function} Event function to convert a text node into multiple nodes
 */

function onLineBreak(measureText) {
  return function (state) {
    var item = state.node;

    if (shouldLineBreak(item)) {
      var wordBreakFn = resolveLineBreakAlgorithm(item);

      if (!wordBreakFn) {
        return;
      }

      var tm = measureText(item);

      if (tm.width > item.maxWidth || includesLineBreak(item.text)) {
        var diff = fontSizeToLineHeight(item) - tm.height;
        var halfLead = diff / 2;
        var result = wordBreakFn(item, wrappedMeasureText(item, measureText));
        state.node = generateLineNodes(result, item, halfLead, tm.height); // Convert node to container
      }
    }
  };
}

function ellipsText(_ref, measureText) {
  var text = _ref.text,
      fontSize = _ref['font-size'],
      fontFamily = _ref['font-family'],
      maxWidth = _ref.maxWidth;
  // eslint-disable-line import/prefer-default-export
  text = typeof text === 'string' ? text : "".concat(text);

  if (maxWidth === undefined) {
    return text;
  }

  var textWidth = measureText({
    text: text,
    fontSize: fontSize,
    fontFamily: fontFamily
  }).width;

  if (textWidth <= maxWidth) {
    return text;
  }

  var min = 0;
  var max = text.length - 1;

  while (min <= max) {
    var reduceIndex = Math.floor((min + max) / 2);
    var reduceText = text.substr(0, reduceIndex) + ELLIPSIS_CHAR;
    textWidth = measureText({
      text: reduceText,
      fontSize: fontSize,
      fontFamily: fontFamily
    }).width;

    if (textWidth <= maxWidth) {
      min = reduceIndex + 1;
    } else {
      // textWidth > maxWidth
      max = reduceIndex - 1;
    }
  }

  return text.substr(0, max) + ELLIPSIS_CHAR;
}

/**
 * Currently some browsers, IE11 and Edge confirmed, doesn't support the dominant-baseline svg-attribute and
 * the browser that does, have different implementations. Thus giving an unpredictable result when rendering'
 * text and predicting it's position (ex. in collision detection).
 *
 * To supplement and the aid in aligning/positioning text with various items, this function can be used
 * to follow a common heuristic across supported renderers.
 * @ignore
 * @param {object} textNode
 * @param {string|number} [textNode['font-size']=0] - String in px format or number
 * @param {string} [textNode['dominant-baseline']] - If baseline is omitted dominant-baseline is used
 * @param {string} [textNode.baseline]
 * @returns {number} Delta-y required to adjust for baseline
 */
function baselineHeuristic(textNode) {
  var baseline = textNode.baseline || textNode['dominant-baseline'];
  var dy = 0;
  var fontSize = parseInt(textNode.fontSize || textNode['font-size'], 10) || 0;

  switch (baseline) {
    case 'hanging':
      dy = fontSize * 0.75;
      break;

    case 'text-before-edge':
      dy = fontSize * 0.85;
      break;

    case 'middle':
      dy = fontSize * 0.25;
      break;

    case 'central':
      dy = fontSize * 0.35;
      break;

    case 'mathemetical':
      dy = fontSize / 2;
      break;

    case 'text-after-edge':
    case 'ideographic':
      dy = -fontSize * 0.2;
      break;

    default:
      dy = 0;
      break;
  }

  return dy;
}

var heightCache = {};
var widthCache = {};
var contextCache = {
  fontSize: undefined,
  fontFamily: undefined
};
var context;

function setContext() {
  context = context || document.createElement('canvas').getContext('2d');
}

function setFont(fontSize, fontFamily) {
  if (contextCache.fontSize === fontSize && contextCache.fontFamily === fontFamily) {
    return;
  }

  context.font = fontSize + ' ' + fontFamily; // eslint-disable-line

  contextCache.fontSize = fontSize;
  contextCache.fontFamily = fontFamily;
}

function measureTextWidth(text, fontSize, fontFamily) {
  var key = text + fontSize + fontFamily;

  if (typeof widthCache[key] !== 'number') {
    setContext();
    setFont(fontSize, fontFamily);
    widthCache[key] = context.measureText(text).width;
  }

  return widthCache[key];
}

function measureTextHeight(fontSize) {
  if (typeof heightCache[fontSize] !== 'number') {
    heightCache[fontSize] = fontSizeToHeight(fontSize);
  }

  return heightCache[fontSize];
}
/**
 * @private
 * @param {object} opts
 * @param {string} opts.text - Text to measure
 * @param {string} opts.fontSize - Font size with a unit definition, ex. 'px' or 'em'
 * @param {string} opts.fontFamily - Font family
 * @return {object} Width and height of text in pixels
 * @example
 * measureText({
 *  text: 'my text',
 *  fontSize: '12px',
 *  fontFamily: 'Arial'
 * }); // returns { width: 20, height: 12 }
 */


function measureText(_ref) {
  var text = _ref.text,
      fontSize = _ref.fontSize,
      fontFamily = _ref.fontFamily;
  var w = measureTextWidth(text, fontSize, fontFamily);
  var h = measureTextHeight(fontSize);
  return {
    width: w,
    height: h
  };
}
/**
 * Calculates the bounding rectangle of a text node.
 * The bounding rectangle is a approximate of the "em square" seen here (http://www.w3resource.com/html5-canvas/html5-canvas-text.php)
 * @ignore
 * @param {object} attrs - Text node definition
 * @param {number} [attrs.x] - X-coordinate
 * @param {number} [attrs.y] - Y-coordinate
 * @param {number} [attrs.dx] - Delta x-coordinate
 * @param {number} [attrs.dy] - Delta y-coordinate
 * @param {string} [attrs.anchor] - Text anchor
 * @param {number} [attrs.maxWidth] - Maximum allowed text width
 * @return {object} The bounding rectangle
 */

function calcTextBounds(attrs) {
  var measureFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : measureText;
  var fontSize = attrs['font-size'] || attrs.fontSize;
  var fontFamily = attrs['font-family'] || attrs.fontFamily;
  var textMeasure = measureFn({
    text: attrs.text,
    fontFamily: fontFamily,
    fontSize: fontSize
  });
  var calWidth = Math.min(attrs.maxWidth || textMeasure.width, textMeasure.width); // Use actual value if max is not set

  var x = attrs.x || 0;
  var y = attrs.y || 0;
  var dx = attrs.dx || 0;
  var dy = (attrs.dy || 0) + baselineHeuristic(attrs);
  var boundingRect = {
    x: 0,
    y: y + dy - textMeasure.height * 0.75,
    // Magic number for alphabetical baseline
    width: calWidth,
    height: textMeasure.height
  };
  var anchor = attrs['text-anchor'] || attrs.anchor;

  if (anchor === 'middle') {
    boundingRect.x = x + dx - calWidth / 2;
  } else if (anchor === 'end') {
    boundingRect.x = x + dx - calWidth;
  } else {
    boundingRect.x = x + dx;
  }

  return boundingRect;
}
/**
 * Calculates the bounding rectangle of a text node. Including any line breaks.
 * @ignore
 * @param {object} node
 * @param {string} node.text - Text to measure
 * @param {number} [node.x=0] - X-coordinate
 * @param {number} [node.y=0] - Y-coordinate
 * @param {number} [node.dx=0] - Delta x-coordinate
 * @param {number} [node.dy=0] - Delta y-coordinate
 * @param {string} [node.anchor='start'] - Text anchor
 * @param {string} [node.fontSize] - Font size
 * @param {string} [node.fontFamily] - Font family
 * @param {string} [node['font-size']] - Font size
 * @param {string} [node['font-family']] - Font family
 * @param {string} [node.wordBreak] - Word-break option
 * @param {number} [node.maxWidth] - Maximum allowed text width
 * @param {number} [node.maxHeight] - Maximum allowed text height. If both maxLines and maxHeight are set, the property that results in the fewest number of lines is used
 * @param {number} [node.maxLines] - Maximum number of lines allowed.
 * @param {number} [node.lineHeight=1.2] - Line height
 * @param {function} [measureFn] - Optional text measure function
 * @return {object} The bounding rectangle
 */


function textBounds(node) {
  var measureFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : measureText;
  var lineBreakFn = resolveLineBreakAlgorithm(node);
  var fontSize = node['font-size'] || node.fontSize;
  var fontFamily = node['font-family'] || node.fontFamily;
  var tm = measureFn({
    text: node.text,
    fontFamily: fontFamily,
    fontSize: fontSize
  });

  if (lineBreakFn && (tm.width > node.maxWidth || includesLineBreak(node.text))) {
    var resolvedLineBreaks = lineBreakFn(node, function (text) {
      return measureFn({
        text: text,
        fontFamily: fontFamily,
        fontSize: fontSize
      });
    });
    var nodeCopy = extend({}, node);
    var maxWidth = 0;
    var widestLine = '';

    for (var i = 0, len = resolvedLineBreaks.lines.length; i < len; i++) {
      var line = resolvedLineBreaks.lines[i];
      line += i === len - 1 && resolvedLineBreaks.reduced ? ELLIPSIS_CHAR : '';
      var width = measureFn({
        text: line,
        fontSize: fontSize,
        fontFamily: fontFamily
      }).width;

      if (width >= maxWidth) {
        maxWidth = width;
        widestLine = line;
      }
    }

    nodeCopy.text = widestLine;
    var bounds = calcTextBounds(nodeCopy, measureFn);
    bounds.height = fontSizeToLineHeight(node) * resolvedLineBreaks.lines.length;
    return bounds;
  }

  return calcTextBounds(node, measureFn);
}

/**
 * Get or create a gradient
 * @ignore
 * @param  {Object} g        Canvas 2d context
 * @param  {Object} node    Current node (for width/height properties)
 * @param  {Object} gradient The gradient properties
 * @return {Object}          A canvas compatible radial or linear gradient object
 */

function createCanvasGradient(g, node, gradient) {
  var orientation = gradient.orientation,
      degree = gradient.degree,
      _gradient$stops = gradient.stops,
      stops = _gradient$stops === void 0 ? [] : _gradient$stops;
  var newGradient = null;

  if (orientation === 'radial') {
    var bounds = node.boundingRect();
    newGradient = g.createRadialGradient(bounds.x + bounds.width / 2, bounds.y + bounds.height / 2, 1e-5, bounds.x + bounds.width / 2, bounds.y + bounds.height / 2, Math.max(bounds.width, bounds.height) / 2);
  } else {
    var points = degreesToPoints(degree);

    var _bounds = node.boundingRect();

    newGradient = g.createLinearGradient(_bounds.x + points.x1 * _bounds.width, _bounds.y + points.y1 * _bounds.height, _bounds.x + points.x2 * _bounds.width, _bounds.y + points.y2 * _bounds.height);
  }

  for (var i = 0, len = stops.length; i < len; i++) {
    var stop = stops[i];
    newGradient.addColorStop(stop.offset, stop.color);
  }

  return newGradient;
}

function getPattern(pattern, dummyCanvas, ctx) {
  dummyCanvas.width = pattern.width;
  dummyCanvas.height = pattern.height;
  ctx.save();
  ctx.fillStyle = pattern.fill;
  pattern.shapes.forEach(function (s) {
    switch (s.type) {
      case 'rect':
        ctx.rect(s.x, s.y, s.width, s.height);
        break;

      default:
        break;
    }
  });
  ctx.fill();
  ctx.restore();
  return ctx.createPattern(dummyCanvas, 'repeat');
}

function patternizer(document) {
  var dummyCanvas = document.createElement('canvas');
  var ctx = dummyCanvas.getContext('2d');
  var cache = {};
  return {
    create: function create(pattern) {
      var key = pattern.key;

      if (key) {
        cache[key] = cache[key] || getPattern(pattern, dummyCanvas, ctx);
        return cache[key];
      }

      return getPattern(pattern, dummyCanvas, ctx);
    },
    clear: function clear() {
      cache = {};
    }
  };
}

/**
 * @typedef {object} renderer-container-def
 * @property {number} [x] - x-coordinate
 * @property {number} [y] - y-coordinate
 * @property {number} [width] - Width
 * @property {number} [height] - Height
 * @property {object} [scaleRatio]
 * @property {number} [scaleRatio.x] - Scale ratio on x-axis
 * @property {number} [scaleRatio.y] - Scale ratio on y-axis
 * @property {object} [margin]
 * @property {number} [margin.left] - Left margin
 * @property {number} [margin.top] - Top margin
 */

/**
 * Create the renderer box
 * @private
 * @param {renderer-container-def} [opts]
 * @returns {renderer-container-def} A svg renderer instance
 */
function createRendererBox() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      x = _ref.x,
      y = _ref.y,
      width = _ref.width,
      height = _ref.height,
      scaleRatio = _ref.scaleRatio,
      margin = _ref.margin,
      edgeBleed = _ref.edgeBleed;

  var box = {
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    scaleRatio: {
      x: 1,
      y: 1
    },
    margin: {
      left: 0,
      top: 0
    },
    edgeBleed: {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0,
      bool: false
    }
  };
  box.x = isNaN(x) ? box.x : x;
  box.y = isNaN(y) ? box.y : y;
  box.width = isNaN(width) ? box.width : width;
  box.height = isNaN(height) ? box.height : height;

  if (typeof scaleRatio !== 'undefined') {
    box.scaleRatio.x = isNaN(scaleRatio.x) ? box.scaleRatio.x : scaleRatio.x;
    box.scaleRatio.y = isNaN(scaleRatio.y) ? box.scaleRatio.y : scaleRatio.y;
  }

  if (typeof margin !== 'undefined') {
    box.margin.left = isNaN(margin.left) ? 0 : margin.left;
    box.margin.top = isNaN(margin.top) ? 0 : margin.top;
  }

  if (_typeof(edgeBleed) === 'object') {
    ['left', 'right', 'top', 'bottom'].forEach(function (prop) {
      if (!isNaN(edgeBleed[prop]) && edgeBleed[prop] > 0) {
        box.edgeBleed[prop] = edgeBleed[prop];
        box.edgeBleed.bool = true;
      }
    });
  }

  box.computedPhysical = {
    x: Math.round(box.margin.left + (box.x - box.edgeBleed.left) * box.scaleRatio.x),
    y: Math.round(box.margin.top + (box.y - box.edgeBleed.top) * box.scaleRatio.y),
    width: Math.round((box.width + box.edgeBleed.left + box.edgeBleed.right) * box.scaleRatio.x),
    height: Math.round((box.height + box.edgeBleed.top + box.edgeBleed.bottom) * box.scaleRatio.y)
  };
  return box;
}

/**
 * Base renderer factory
 * @private
 */

function create$n() {
  /**
  * @interface
  * @alias renderer
  */
  var renderer = {
    /**
    * Get the element this renderer is attached to
    * @returns {HTMLElement}
    */
    element: function element() {},

    /**
     * Get the root element of the renderer
     * @returns {HTMLElement}
     */
    root: function root() {},

    /**
    * @param {HTMLElement} element - Element to attach renderer to
    * @returns {HTMLElement} Root element of the renderer
    */
    appendTo: function appendTo() {},

    /**
     * @param {node-def[]} nodes - Nodes to render
     * @returns {boolean} True if the nodes where rendered, otherwise false
     */
    render: function render() {
      return false;
    },

    /**
     * Get nodes renderer at area
     * @param {point|circle|rect|line|polygon} geometry - Get nodes that intersects with geometry
     * @returns {SceneNode[]}
     */
    itemsAt: function itemsAt() {
      return [];
    },

    /**
     * Get all nodes matching the provided selector
     * @param {string} selector CSS selector [type, attribute, universal, class]
     * @returns {SceneNode[]} Array of objects containing matching nodes
     */
    findShapes: function findShapes() {
      return [];
    },

    /**
     * Clear all child elements from the renderer root element
     * @returns {renderer} The renderer instance
     */
    clear: function clear() {},

    /**
     * Remove the renderer root element from its parent element
     */
    destory: function destory() {},

    /**
     * Set or Get the size definition of the renderer container.
     * @param {renderer-container-def} [opts] - Size definition
     * @returns {renderer-container-def} The current size definition
     */
    size: function size() {},

    /**
     * @function
     * @param {object} opts
     * @param {string} opts.text - Text to measure
     * @param {string} opts.fontSize - {@link https://www.w3.org/TR/SVG/text.html#FontPropertiesUsedBySVG}
     * @param {string} opts.fontFamily - {@link https://www.w3.org/TR/SVG/text.html#FontPropertiesUsedBySVG}
     * @returns {object} Width and height of text
     * @example
     * measureText({
     *  text: 'my text',
     *  fontSize: '12px',
     *  fontFamily: 'Arial'
     * }); // returns { width: 20, height: 12 }
     */
    measureText: measureText,

    /**
     * Calculates the bounding rectangle of a text node. Including any potential line breaks.
     * @function
     * @param {node--text-def} node
     * @return {rect} The bounding rectangle
     */
    textBounds: textBounds,
    setKey: function setKey(key) {
      renderer.element().setAttribute('data-key', key);
    }
  };
  return renderer;
}

function hasData$1(data) {
  return typeof data !== 'undefined' && data !== null;
}

function injectTextBoundsFn(renderer) {
  return function (_ref) {
    var node = _ref.node;

    if (node.type === 'text' && hasData$1(node.data) && !node.textBoundsFn) {
      node.textBoundsFn = renderer.textBounds;
    }
  };
}

var reg$5 = registryFactory();

function toLineDash(p) {
  if (Array.isArray(p)) {
    return p;
  }

  if (typeof p === 'string') {
    if (p.indexOf(',') !== -1) {
      return p.split(',');
    }

    return p.split(' ');
  }

  return [];
}

function dpiScale(g) {
  var dpr = typeof window === 'undefined' ? 1 : window.devicePixelRatio || 1;
  var backingStorePixelRatio = g.webkitBackingStorePixelRatio || g.mozBackingStorePixelRatio || g.msBackingStorePixelRatio || g.oBackingStorePixelRatio || g.backingStorePixelRatio || 1;
  return dpr / backingStorePixelRatio;
}

function resolveMatrix(p, g) {
  g.setTransform(p[0][0], p[1][0], p[0][1], p[1][1], p[0][2], p[1][2]);
}

function applyContext(g, s, shapeToCanvasMap) {
  var computed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var computedKeys = Object.keys(computed);

  for (var i = 0, len = shapeToCanvasMap.length; i < len; i++) {
    var cmd = shapeToCanvasMap[i];
    var shapeCmd = cmd[0];
    var canvasCmd = cmd[1];
    var convertCmd = cmd[2];

    if (shapeCmd in s.attrs && !(canvasCmd in computed) && g[canvasCmd] !== s.attrs[shapeCmd]) {
      var val = convertCmd ? convertCmd(s.attrs[shapeCmd]) : s.attrs[shapeCmd];

      if (typeof g[canvasCmd] === 'function') {
        g[canvasCmd](val);
      } else {
        g[canvasCmd] = val;
      }
    }
  }

  for (var _i = 0, _len = computedKeys.length; _i < _len; _i++) {
    var key = computedKeys[_i];
    g[key] = computed[key];
  }
}

function renderShapes(shapes, g, shapeToCanvasMap, deps) {
  for (var i = 0, len = shapes.length; i < len; i++) {
    var shape = shapes[i];
    var computed = {};
    g.save();

    if (shape.attrs && (shape.attrs.fill || shape.attrs.stroke)) {
      if (shape.attrs.fill && _typeof(shape.attrs.fill) === 'object' && shape.attrs.fill.type === 'gradient') {
        computed.fillStyle = createCanvasGradient(g, shape, shape.attrs.fill);
      } else if (shape.attrs.fill && _typeof(shape.attrs.fill) === 'object' && shape.attrs.fill.type === 'pattern') {
        computed.fillStyle = deps.patterns.create(shape.attrs.fill);
      }

      if (shape.attrs.stroke && _typeof(shape.attrs.stroke) === 'object' && shape.attrs.stroke.type === 'gradient') {
        computed.strokeStyle = createCanvasGradient(g, shape, shape.attrs.stroke);
      } else if (shape.attrs.stroke && _typeof(shape.attrs.stroke) === 'object' && shape.attrs.stroke.type === 'pattern') {
        computed.strokeStyle = deps.patterns.create(shape.attrs.stroke);
      }
    }

    applyContext(g, shape, shapeToCanvasMap, computed);

    if (shape.modelViewMatrix) {
      resolveMatrix(shape.modelViewMatrix.elements, g);
    }

    if (reg$5.has(shape.type)) {
      reg$5.get(shape.type)(shape.attrs, {
        g: g,
        doFill: 'fill' in shape.attrs && shape.attrs.fill !== 'none',
        doStroke: 'stroke' in shape.attrs && shape.attrs['stroke-width'] !== 0
      });
    }

    if (shape.children) {
      renderShapes(shape.children, g, shapeToCanvasMap, deps);
    }

    g.restore();
  }
}
/**
 * Create a new canvas renderer
 * @typedef {function} canvasRendererFactory
 * @param {function} sceneFn - Scene factory
 * @returns {renderer} A canvas renderer instance
 */


function renderer() {
  var sceneFn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : scene;
  var el;
  var scene$1;
  var hasChangedRect = false;
  var rect = createRendererBox();
  var shapeToCanvasMap = [['fill', 'fillStyle'], ['stroke', 'strokeStyle'], ['opacity', 'globalAlpha'], ['globalAlpha', 'globalAlpha'], ['stroke-width', 'lineWidth'], ['stroke-linejoin', 'lineJoin'], ['stroke-dasharray', 'setLineDash', toLineDash]];
  var patterns;
  var canvasRenderer = create$n();

  canvasRenderer.element = function () {
    return el;
  };

  canvasRenderer.root = function () {
    return el;
  };

  canvasRenderer.appendTo = function (element) {
    if (!el) {
      el = element.ownerDocument.createElement('canvas');
      el.style.position = 'absolute';
      el.style['-webkit-font-smoothing'] = 'antialiased';
      el.style['-moz-osx-font-smoothing'] = 'antialiased';
      el.style.pointerEvents = 'none';
    }

    element.appendChild(el);
    return el;
  };

  canvasRenderer.render = function (shapes) {
    if (!el) {
      return false;
    }

    if (!patterns) {
      patterns = patternizer(el.ownerDocument);
    }

    var g = el.getContext('2d');
    var dpiRatio = dpiScale(g);
    var scaleX = rect.scaleRatio.x;
    var scaleY = rect.scaleRatio.y;

    if (hasChangedRect) {
      el.style.left = "".concat(rect.computedPhysical.x, "px");
      el.style.top = "".concat(rect.computedPhysical.y, "px");
      el.style.width = "".concat(rect.computedPhysical.width, "px");
      el.style.height = "".concat(rect.computedPhysical.height, "px");
      el.width = Math.round(rect.computedPhysical.width * dpiRatio);
      el.height = Math.round(rect.computedPhysical.height * dpiRatio);
    }

    var sceneContainer = {
      type: 'container',
      children: shapes,
      transform: rect.edgeBleed.bool ? "translate(".concat(rect.edgeBleed.left * dpiRatio * scaleX, ", ").concat(rect.edgeBleed.top * dpiRatio * scaleY, ")") : ''
    };

    if (dpiRatio !== 1 || scaleX !== 1 || scaleY !== 1) {
      sceneContainer.transform += "scale(".concat(dpiRatio * scaleX, ", ").concat(dpiRatio * scaleY, ")");
    }

    var newScene = sceneFn({
      items: [sceneContainer],
      dpi: dpiRatio,
      on: {
        create: [onLineBreak(canvasRenderer.measureText), injectTextBoundsFn(canvasRenderer)]
      }
    });
    var hasChangedScene = scene$1 ? !newScene.equals(scene$1) : true;
    patterns.clear();
    var doRender = hasChangedRect || hasChangedScene;

    if (doRender) {
      canvasRenderer.clear();
      renderShapes(newScene.children, g, shapeToCanvasMap, {
        patterns: patterns
      });
    }

    hasChangedRect = false;
    scene$1 = newScene;
    return doRender;
  };

  canvasRenderer.itemsAt = function (input) {
    return scene$1 ? scene$1.getItemsFrom(input) : [];
  };

  canvasRenderer.findShapes = function (selector) {
    return scene$1 ? scene$1.findShapes(selector) : [];
  };

  canvasRenderer.clear = function () {
    if (el) {
      el.width = el.width;
    }

    scene$1 = null;
    return canvasRenderer;
  };

  canvasRenderer.size = function (opts) {
    if (opts) {
      var newRect = createRendererBox(opts);

      if (JSON.stringify(rect) !== JSON.stringify(newRect)) {
        hasChangedRect = true;
        rect = newRect;
      }
    }

    return rect;
  };

  canvasRenderer.destroy = function () {
    if (el) {
      if (el.parentElement) {
        el.parentElement.removeChild(el);
      }

      el = null;
    }

    scene$1 = null;
  };

  return canvasRenderer;
}
function register(type, renderFn) {
  reg$5.add(type, renderFn);
}

function clampRadius(max, value) {
  return Math.max(0, Math.min(max, value));
}
/**
 * Implementation details follow rx/ry restrictions from https://svgwg.org/svg2-draft/geometry.html#RX
 *
 * Using Quadratic Bézier curve it's not possible accurately represent a circle or ellipse but should for the case of a rounded rectangle be sufficent.
 * @private
 */


function quadraticRoundedRect(g, x, y, width, height, rx, ry) {
  rx = clampRadius(width / 2, rx > 0 ? rx : ry);
  ry = clampRadius(height / 2, ry > 0 ? ry : rx);
  g.moveTo(x, y + ry);
  g.lineTo(x, y + height - ry);
  g.quadraticCurveTo(x, y + height, x + rx, y + height);
  g.lineTo(x + width - rx, y + height);
  g.quadraticCurveTo(x + width, y + height, x + width, y + height - ry);
  g.lineTo(x + width, y + ry);
  g.quadraticCurveTo(x + width, y, x + width - rx, y);
  g.lineTo(x + rx, y);
  g.quadraticCurveTo(x, y, x, y + ry);
}

function render$4(rect, _ref) {
  var g = _ref.g,
      doFill = _ref.doFill,
      doStroke = _ref.doStroke;
  g.beginPath();

  if (rect.rx > 0 || rect.ry > 0) {
    quadraticRoundedRect(g, rect.x, rect.y, rect.width, rect.height, rect.rx, rect.ry);
  } else {
    g.rect(rect.x, rect.y, rect.width, rect.height);
  }

  if (doFill) {
    g.fill();
  }

  if (doStroke) {
    g.stroke();
  }
}

function render$5(circle, _ref) {
  var g = _ref.g,
      doFill = _ref.doFill,
      doStroke = _ref.doStroke;
  g.beginPath();
  g.moveTo(circle.cx + circle.r, circle.cy);
  g.arc(circle.cx, circle.cy, circle.r, 0, Math.PI * 2, false);

  if (doFill) {
    g.fill();
  }

  if (doStroke) {
    g.stroke();
  }
}

function render$6(line, _ref) {
  var g = _ref.g,
      doStroke = _ref.doStroke;
  g.beginPath();
  g.moveTo(line.x1, line.y1);
  g.lineTo(line.x2, line.y2);

  if (doStroke) {
    g.stroke();
  }
}

// Source: https://en.wikipedia.org/wiki/Bi-directional_text and http://www.unicode.org/Public/6.0.0/ucd/UnicodeData.txt
// 3 types of strong direction characters: L (strong left-to-right), R(strong right-to-left, Hebrew) and AL(strong right-to-left, Arabic language)
var rangesOfLChars = "[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02BB-\u02C1\u02D0-\u02D1\u02E0-\u02E4\u02EE\u0370-\u0373\u0376-\u037D\u0386\u0388-\u03F5\u03F7-\u0482\u048A-\u0589\u0903-\u0939\u093B\u093D-\u0940\u0949-\u094C\u094E-\u0950\u0958-\u0961\u0964-\u097F\u0982-\u09B9\u09BD-\u09C0\u09C7-\u09CC\u09CE-\u09E1\u09E6-\u09F1\u09F4-\u09FA\u0A03-\u0A39\u0A3E-\u0A40\u0A59-\u0A6F\u0A72-\u0A74\u0A83-\u0AB9\u0ABD-\u0AC0\u0AC9-\u0ACC\u0AD0-\u0AE1\u0AE6-\u0AEF\u0B02-\u0B39\u0B3D-\u0B3E\u0B40\u0B47-\u0B4C\u0B57-\u0B61\u0B66-\u0B77\u0B83-\u0BBF\u0BC1-\u0BCC\u0BD0-\u0BF2\u0C01-\u0C3D\u0C41-\u0C44\u0C58-\u0C61\u0C66-\u0C6F\u0C7F-\u0CB9\u0CBD-\u0CCB\u0CD5-\u0CE1\u0CE6-\u0D40\u0D46-\u0D4C\u0D4E-\u0D61\u0D66-\u0DC6\u0DCF-\u0DD1\u0DD8-\u0E30\u0E32-\u0E33\u0E40-\u0E46\u0E4F-\u0EB0\u0EB2-\u0EB3\u0EBD-\u0EC6\u0ED0-\u0F17\u0F1A-\u0F34\u0F36\u0F38\u0F3E-\u0F6C\u0F7F\u0F85\u0F88-\u0F8C\u0FBE-\u0FC5\u0FC7-\u102C\u1031\u1038\u103B-\u103C\u103F-\u1057\u105A-\u105D\u1061-\u1070\u1075-\u1081\u1083-\u1084\u1087-\u108C\u108E-\u109C\u109E-\u135A\u1360-\u138F\u13A0-\u13F4\u1401-\u167F\u1681-\u169A\u16A0-\u1711\u1720-\u1731\u1735-\u1751\u1760-\u1770\u1780-\u17B6\u17BE-\u17C5\u17C7-\u17C8\u17D4-\u17DA\u17DC\u17E0-\u17E9\u1810-\u18A8\u18AA-\u191C\u1923-\u1926\u1929-\u1931\u1933-\u1938\u1946-\u19DA\u1A00-\u1A16\u1A19-\u1A55\u1A57\u1A61\u1A63-\u1A64\u1A6D-\u1A72\u1A80-\u1AAD\u1B04-\u1B33\u1B35\u1B3B\u1B3D-\u1B41\u1B43-\u1B6A\u1B74-\u1B7C\u1B82-\u1BA1\u1BA6-\u1BA7\u1BAA-\u1BE5\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2-\u1C2B\u1C34-\u1C35\u1C3B-\u1C7F\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1DBF\u1E00-\u1FBC\u1FBE\u1FC2-\u1FCC\u1FD0-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FFC\u200E\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E-\u214F\u2160-\u2188\u2336-\u237A\u2395\u249C-\u24E9\u26AC\u2800-\u28FF\u2C00-\u2CE4\u2CEB-\u2CEE\u2D00-\u2D70\u2D80-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u31BA\u31F0-\u321C\u3220-\u324F\u3260-\u327B\u327F-\u32B0\u32C0-\u32CB\u32D0-\u3376\u337B-\u33DD\u33E0-\u33FE\u3400-\u4DB5\u4E00-\uA48C\uA4D0-\uA60C\uA610-\uA66E\uA680-\uA6EF\uA6F2-\uA6F7\uA722-\uA787\uA789-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA824\uA827\uA830-\uA837\uA840-\uA873\uA880-\uA8C3\uA8CE-\uA8D9\uA8F2-\uA925\uA92E-\uA946\uA952-\uA97C\uA983-\uA9B2\uA9B4-\uA9B5\uA9BA-\uA9BB\uA9BD-\uAA28\uAA2F-\uAA30\uAA33-\uAA34\uAA40-\uAA42\uAA44-\uAA4B\uAA4D-\uAAAF\uAAB1\uAAB5-\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2-\uABE4\uABE6-\uABE7\uABE9-\uABEC\uABF0-\uFB17\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFDC]";
var rangesOfRChars = "[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05F4\u07C0-\u07EA\u07F4-\u07F5\u07FA-\u0815\u081A\u0824\u0828\u0830-\u0858\u085E\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFB4F]";
var rangesOfALChars = "[\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5-\u06E6\u06EE-\u06EF\u06FA-\u070D\u0710\u0712-\u072F\u074D-\u07A5\u07B1\uFB50-\uFD3D\uFD50-\uFDFC\uFE70-\uFEFC]"; // let rangesOfNChars = '[\u0009-\u000D\u001C-\u0022\u0026-\u002A\u003B-\u0040\u005B-\u0060\u007B-\u007E\u0085\u00A1\u00A6-\u00A9\u00AB-\u00AC\u00AE-\u00AF\u00B4\u00B6-\u00B8\u00BB-\u00BF\u00D7\u00F7\u02B9-\u02BA\u02C2-\u02CF\u02D2-\u02DF\u02E5-\u02ED\u02EF-\u02FF\u0374-\u0375\u037E-\u0385\u0387\u03F6\u058A\u0606-\u0607\u060E-\u060F\u06DE\u06E9\u07F6-\u07F9\u0BF3-\u0BF8\u0BFA\u0C78-\u0C7E\u0F3A-\u0F3D\u1390-\u1399\u1400\u1680\u169B-\u169C\u17F0-\u180A\u180E\u1940-\u1945\u19DE-\u19FF\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD-\u200A\u2010-\u2029\u2035-\u2043\u2045-\u205F\u207C-\u207E\u208C-\u208E\u2100-\u2101\u2103-\u2106\u2108-\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u213A-\u213B\u2140-\u2144\u214A-\u214D\u2150-\u215F\u2189-\u2211\u2214-\u2335\u237B-\u2394\u2396-\u2487\u24EA-\u26AB\u26AD-\u27FF\u2900-\u2B59\u2CE5-\u2CEA\u2CF9-\u2CFF\u2E00-\u3004\u3008-\u3020\u3030\u3036-\u3037\u303D-\u303F\u309B-\u309C\u30A0\u30FB\u31C0-\u31E3\u321D-\u321E\u3250-\u325F\u327C-\u327E\u32B1-\u32BF\u32CC-\u32CF\u3377-\u337A\u33DE-\u33DF\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA60D-\uA60F\uA673\uA67E-\uA67F\uA700-\uA721\uA788\uA828-\uA82B\uA874-\uA877\uFD3E-\uFD3F\uFDFD\uFE10-\uFE19\uFE30-\uFE4F\uFE51\uFE54\uFE56-\uFE5E\uFE60-\uFE61\uFE64-\uFE68\uFE6B\uFF01-\uFF02\uFF06-\uFF0A\uFF1B-\uFF20\uFF3B-\uFF40\uFF5B-\uFF65\uFFE2-\uFFE4\uFFE8-\uFFFD]';

var rangesOfLRgExp = new RegExp(rangesOfLChars);
var rangesOfRRgExp = new RegExp(rangesOfRChars);
var rangesOfALRgExp = new RegExp(rangesOfALChars); // let rangesOfNRgExp = new RegExp(rangesOfNChars);
// let lrm = String.fromCharCode(8206); // left-to-right marker
// let rlm = String.fromCharCode(8207); // right-to-left marker

function isLtrChar(c) {
  return rangesOfLRgExp.test(c);
}

function isRtlChar(c) {
  return rangesOfRRgExp.test(c) || rangesOfALRgExp.test(c);
}

function detectTextDirection(s) {
  var n = s ? s.length : 0,
      i,
      c;

  for (i = 0; i < n; i++) {
    c = s[i];

    if (isLtrChar(c)) {
      return 'ltr';
    }

    if (isRtlChar(c)) {
      return 'rtl';
    }
  }

  return 'ltr';
}
var textAnchorRTLMap = {
  start: 'end',
  end: 'start',
  center: 'center',
  middle: 'middle'
};
/* let flippedTextAnchor = true;
let detected = false;
export function detectRtlSvgSupport(ns, ownerDoc) {
  if (!detected) {
    const body = ownerDoc.body;
    if (body) {
      const rtlTestSVG = ownerDoc.createElementNS(ns, 'svg');
      const textNode = ownerDoc.createElementNS(ns, 'text');
      const group = ownerDoc.createElementNS(ns, 'g');

      rtlTestSVG.setAttribute('xmlns', ns);
      rtlTestSVG.setAttribute('style', 'position: absolute; width: 100px; height: 100px; top: -100px; left: 0px');

      textNode.setAttribute('text-anchor', 'start');
      textNode.setAttribute('direction', 'rtl');
      textNode.setAttribute('font-size', '14px');
      textNode.setAttribute('x', 50);
      textNode.setAttribute('y', 50);
      textNode.textContent = 'ثعبان';

      group.appendChild(textNode);
      rtlTestSVG.appendChild(group);
      body.appendChild(rtlTestSVG);

      flippedTextAnchor = textNode.getBoundingClientRect().left < 50;
      body.removeChild(rtlTestSVG);
    }
  }
  detected = true;
} */

function flipTextAnchor(value, dir) {
  if (dir === 'rtl') {
    return textAnchorRTLMap[value];
  }

  return value;
}

function render$7(t, _ref) {
  var g = _ref.g;
  var text = ellipsText(t, measureText);
  g.font = "".concat(t['font-size'], " ").concat(t['font-family']);
  var dir = detectTextDirection(t.text);

  if (g.canvas.dir !== dir) {
    g.canvas.dir = dir;
  }

  var textAnchor = t['text-anchor'] === 'middle' ? 'center' : t['text-anchor'];
  var textAlign = flipTextAnchor(textAnchor, g.canvas.dir);

  if (textAlign && g.textAlign !== textAlign) {
    g.textAlign = textAlign;
  }

  var bdy = baselineHeuristic(t);
  g.fillText(text, t.x + t.dx, t.y + t.dy + bdy);
}

function render$8(path, _ref) {
  var g = _ref.g,
      doStroke = _ref.doStroke,
      doFill = _ref.doFill;
  var p = new Path2D(path.d);

  if (doFill) {
    g.fill(p);
  }

  if (doStroke) {
    g.stroke(p);
  }
}

register('rect', render$4);
register('circle', render$5);
register('line', render$6);
register('path', render$8);
register('text', render$7);
function rendererComponent(picasso) {
  picasso.renderer('canvas', renderer);
}

function diff$1(from, to) {
  var added = [];
  var items;
  var removed = [];
  var updatedNew = [];
  var updatedOld = [];
  var fromIds;
  var toIds;

  var idMapper = function idMapper(a) {
    return a.id;
  };

  var nodeMapper = function nodeMapper(node, i) {
    var id;

    if (_typeof(node) === 'object') {
      if ('id' in node) {
        id = node.id;
      } else {
        id = i;
      }
    } else {
      id = node;
    }

    return {
      content: node,
      id: "".concat(id, "__").concat(node.type || '')
    };
  };

  if (!from.isTree) {
    from = from.map(nodeMapper);
  }

  to = to.map(nodeMapper);
  fromIds = from.map(idMapper);
  toIds = to.map(idMapper); // TODO - handle duplicate values
  // added = to.filter( v => fromIds.indexOf( v.id ) < 0 );
  // updatedNew = to.filter( v => fromIds.indexOf( v.id ) >= 0 );
  // removed = from.filter( v => toIds.indexOf( v.id ) < 0 );
  // updatedOld = from.filter( v => toIds.indexOf( v.id ) >= 0 );

  for (var i = 0, len = to.length; i < len; i++) {
    var idx = fromIds.indexOf(to[i].id);

    if (idx === -1) {
      added.push(to[i]);
    } else {
      updatedNew.push(to[i]);
    }
  }

  for (var _i = 0, _len = from.length; _i < _len; _i++) {
    var _idx = toIds.indexOf(from[_i].id);

    if (_idx === -1) {
      removed.push(from[_i]);
    } else {
      updatedOld.push(from[_i]);
    }
  }

  for (var _i2 = 0, _len2 = added.length; _i2 < _len2; _i2++) {
    if (added[_i2].content.children) {
      added[_i2].diff = diff$1([], added[_i2].content.children);
      added[_i2].children = added[_i2].diff.updatedNew.concat(added[_i2].diff.added);
      added[_i2].children.isTree = true;
    }
  }

  for (var _i3 = 0, _len3 = updatedNew.length; _i3 < _len3; _i3++) {
    updatedNew[_i3].diff = diff$1(updatedOld[_i3].children || [], updatedNew[_i3].content.children || []);
    updatedNew[_i3].object = updatedOld[_i3].object;
    updatedNew[_i3].children = updatedNew[_i3].diff.items;
  }

  items = updatedNew.concat(added);
  added.isTree = true;
  removed.isTree = true;
  updatedNew.isTree = true;
  updatedOld.isTree = true;
  items.isTree = true;
  return {
    added: added,
    updatedNew: updatedNew,
    updatedOld: updatedOld,
    removed: removed,
    items: items
  };
}

function createNodes(nodes, parent, create) {
  for (var i = 0, len = nodes.length; i < len; i++) {
    nodes[i].object = create(nodes[i].content.type, parent);
  }
}

function destroyNodes(nodes, destroy) {
  for (var i = 0, len = nodes.length; i < len; i++) {
    if (nodes[i].object !== null && typeof nodes[i].object !== 'undefined') {
      destroy(nodes[i].object);
      nodes[i].object = null;
    }
  }
}

function updateNodes(nodes, creator, maintainer, destroyer) {
  var item;

  for (var i = 0, len = nodes.length; i < len; i++) {
    item = nodes[i];

    if (item.object !== null && typeof item.object !== 'undefined') {
      maintainer(item.object, item.content);

      if (item.diff) {
        createNodes(item.diff.added, item.object, creator);
        destroyNodes(item.diff.removed, destroyer);
        updateNodes(item.diff.items, creator, maintainer, destroyer);
      }
    }
  }
}

function createTree(oldItems, newItems, root, creator, maintainer, destroyer) {
  var d = diff$1(oldItems, newItems);
  createNodes(d.added, root, creator);
  destroyNodes(d.removed, destroyer);
  updateNodes(d.items, creator, maintainer, destroyer);
  return d.items;
}

var svgNs = 'http://www.w3.org/2000/svg';

var creator = function creator(type, parent) {
  if (!type || typeof type !== 'string') {
    throw new Error("Invalid type: ".concat(type));
  }

  var el = parent.ownerDocument.createElementNS(svgNs, type === 'container' ? 'g' : type);
  parent.appendChild(el);
  return el;
};

var destroyer = function destroyer(el) {
  if (el.parentNode) {
    el.parentNode.removeChild(el);
  }
};

var maintainer = function maintainer(element, item) {
  for (var attr in item.attrs) {
    if (attr === 'stroke' && item.strokeReference) {
      element.setAttribute('stroke', item.strokeReference);
    } else if (attr === 'fill' && item.fillReference) {
      element.setAttribute('fill', item.fillReference);
    } else if (attr === 'text') {
      element.setAttribute('style', 'white-space: pre');
      element.textContent = ellipsText(item.attrs, measureText);
      var dir = detectTextDirection(item.attrs.text);

      if (dir === 'rtl') {
        element.setAttribute('direction', 'rtl');
        element.setAttribute('dir', 'rtl');
        element.setAttribute('text-anchor', flipTextAnchor(element.getAttribute('text-anchor'), dir));
      }
    } else if (item.type === 'text' && (attr === 'dy' || attr === 'dominant-baseline')) {
      var dy = +element.getAttribute(attr) || 0;
      var val = 0;

      if (attr === 'dominant-baseline') {
        val = baselineHeuristic(item.attrs);
      } else {
        val = item.attrs[attr];
      }

      element.setAttribute('dy', val + dy);
    } else if (item.type === 'text' && attr === 'title' && item.attrs.title) {
      var t = element.ownerDocument.createElementNS(svgNs, 'title');
      t.textContent = item.attrs.title;
      element.appendChild(t);
    } else {
      element.setAttribute(attr, item.attrs[attr]);
    }
  }

  if (typeof item.data === 'string' || typeof item.data === 'number' || typeof item.data === 'boolean') {
    element.setAttribute('data', item.data);
  } else if (_typeof(item.data) === 'object' && item.data !== null) {
    for (var d in item.data) {
      if (typeof item.data[d] === 'string' || typeof item.data[d] === 'number' || typeof item.data[d] === 'boolean') {
        element.setAttribute("data-".concat(d), item.data[d]);
      }
    }
  }
};

var TreeItemRenderer =
/*#__PURE__*/
function () {
  /**
   * Constructor
   * @private
   * @param  {TreeCreator} treeCreator - Function used to create the DOM tree..
   * @param  {SVGCreator} nodeCreator - Function used to create nodes.
   * @param  {SVGMaintainer} nodeMaintainer - Function used to update nodes.
   * @param  {SVGDestroyer} nodeDestroyer - Function used to destroy nodes.
   */
  function TreeItemRenderer(treeCreator, nodeCreator, nodeMaintainer, nodeDestroyer) {
    _classCallCheck$1(this, TreeItemRenderer);

    this.create = treeCreator;
    this.nodeCreator = nodeCreator;
    this.nodeMaintainer = nodeMaintainer;
    this.nodeDestroyer = nodeDestroyer;
  }

  _createClass$1(TreeItemRenderer, [{
    key: "render",
    value: function render(newItems, root) {
      return this.create([], newItems, root, this.nodeCreator, this.nodeMaintainer, this.nodeDestroyer);
    }
  }]);

  return TreeItemRenderer;
}();

function tree() {
  return new TreeItemRenderer(createTree, creator, maintainer, destroyer);
}
/**
 * Create an SVGElement and attach to parent.
 * @private
 * @callback SVGCreator
 * @param {String} type - The type of element to create.
 * @param {SVGElement} parent - The parent element to append the new element to.
 * @return {SVGElement} The created element
 */

/**
 * Update the element with content from item.
 * @private
 * @callback SVGMaintainer
 * @param {SVGElement} el - The element to update
 * @param {Object} item - The object to use as input for the update
 */

/**
 * Detach element from its parent.
 * @private
 * @callback SVGDestroyer
 * @param {SVGElement} el - Element to destroy.
 */

/**
 * Create, update and destroy nodes.
 * @private
 * @callback TreeCreator
 * @param {Object[]} existing - The existing items in the tree.
 * @param {Object[]} active - The new items to create the tree from.
 * @param {SVGCreator} creator - Function used to create nodes.
 * @param {SVGMaintainer} maintainer - Function used to update nodes.
 * @param {SVGDestroyer} destroyer - Function used to destroy nodes.
 */

/* eslint import/prefer-default-export: 0 */

/**
 * Hash an object
 * Modified version of Java's HashCode function
 * Source: {@link http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/}
 * @ignore
 *
 * @param  {Object} item Item to hash
 * @return {String}      Unique hash id
 */
function hashObject(item) {
  var hash = 0;
  var i;
  var chr;
  var len;
  item = JSON.stringify(item);

  if (item.length === 0) {
    return hash;
  }

  for (i = 0, len = item.length; i < len; i++) {
    chr = item.charCodeAt(i);
    hash = (hash << 5) - hash + chr;
    hash &= hash; // Convert to 32bit integer
  }

  return hash;
}

function gradienter(bucket) {
  var hasher = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : hashObject;
  var cache = {};
  var uid = Date.now();
  var p = {
    getOrCreateGradient: function getOrCreateGradient() {
      var item = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var attr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'fill';
      var url = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      var gradientHash = hasher(item[attr]);
      var gradientId = "picasso-gradient-".concat(uid, "-").concat(gradientHash);

      if (!cache[gradientHash]) {
        var _item$attr = item[attr],
            orientation = _item$attr.orientation,
            degree = _item$attr.degree,
            _item$attr$stops = _item$attr.stops,
            stops = _item$attr$stops === void 0 ? [] : _item$attr$stops;
        var gradient = {};

        if (degree === undefined) {
          degree = 90;
        } // Default to linear


        if (orientation === 'radial') {
          gradient.type = 'radialGradient';
        } else {
          gradient = degreesToPoints(degree);
          gradient.type = 'linearGradient';
        }

        gradient.id = gradientId;
        gradient.children = stops.map(function (_ref) {
          var offset = _ref.offset,
              color = _ref.color,
              opacity = _ref.opacity;
          return {
            type: 'stop',
            offset: "".concat(offset * 100, "%"),
            style: "stop-color:".concat(color, ";stop-opacity:").concat(typeof opacity !== 'undefined' ? opacity : 1)
          };
        });
        bucket.push(gradient);
        cache[gradientHash] = gradientId;
      }

      return "url('".concat(url, "#").concat(gradientId, "')");
    },
    onCreate: function onCreate(state) {
      var url = '';

      if (typeof window !== 'undefined') {
        url = window.location.href.split('#')[0];
      }

      var item = state.node;

      if (item.fill && _typeof(item.fill) === 'object' && item.fill.type === 'gradient') {
        item.fillReference = p.getOrCreateGradient(item, 'fill', url);
      }

      if (item.stroke && _typeof(item.stroke) === 'object' && item.stroke.type === 'gradient') {
        item.strokeReference = p.getOrCreateGradient(item, 'stroke', url);
      }
    },
    clear: function clear() {
      cache = {};
    }
  };
  return p;
}

function patternizer$1(bucket) {
  var hasher = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : hashObject;
  var cache = {};
  var uid = Date.now();
  var p = {
    onCreate: function onCreate(state) {
      var inputs = {};

      if (state.node && _typeof(state.node.fill) === 'object' && state.node.fill.type === 'pattern' && state.node.fill.shapes) {
        inputs.fill = state.node.fill;
      }

      if (state.node && _typeof(state.node.stroke) === 'object' && state.node.stroke.type === 'pattern' && state.node.stroke.shapes) {
        inputs.stroke = state.node.stroke;
      }

      Object.keys(inputs).forEach(function (key) {
        var url = '';
        var input = inputs[key];
        var patternHash = hasher(input);
        var pnid = "picasso-pattern-".concat(uid, "-").concat(patternHash);

        if (typeof window !== 'undefined') {
          url = window.location.href.split('#')[0];
        }

        if (!cache[patternHash]) {
          var pn = {
            patternUnits: 'userSpaceOnUse',
            x: 0,
            y: 0,
            width: input.width,
            height: input.height,
            type: 'pattern',
            id: pnid,
            children: [],
            fill: input.fill
          };
          input.shapes.forEach(function (s) {
            pn.children.push(s);
          });
          bucket.push(pn);
          cache[patternHash] = true;
        }

        state.node["".concat(key, "Reference")] = "url('".concat(url, "#").concat(pnid, "')");
      });
    },
    clear: function clear() {
      cache = {};
    }
  };
  return p;
}

/**
 * Create a new svg renderer
 * @typedef {function} svgRendererFactory
 * @param {function} treeFactory - Node tree factory
 * @param {string} ns - Namespace definition
 * @param {function} sceneFn - Scene factory
 * @returns {renderer} A svg renderer instance
 */

function renderer$1() {
  var treeFn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : tree;
  var ns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : svgNs;
  var sceneFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : scene;
  var tree$1 = treeFn();
  var el;
  var group;
  var hasChangedRect = false;
  var rect = createRendererBox();
  var scene$1;
  var svg = create$n();
  var defs = {
    type: 'defs',
    children: []
  };
  var patterns = patternizer$1(defs.children);
  var gradients = gradienter(defs.children);

  svg.element = function () {
    return el;
  };

  svg.root = function () {
    return group;
  };

  svg.appendTo = function (element) {
    if (!el) {
      el = element.ownerDocument.createElementNS(ns, 'svg');
      el.style.position = 'absolute';
      el.style['-webkit-font-smoothing'] = 'antialiased';
      el.style['-moz-osx-font-smoothing'] = 'antialiased';
      el.style.pointerEvents = 'none';
      el.setAttribute('xmlns', ns);
      group = element.ownerDocument.createElementNS(ns, 'g');
      group.style.pointerEvents = 'auto';
      el.appendChild(group);
    }

    element.appendChild(el);
    return el;
  };

  svg.render = function (nodes) {
    if (!el) {
      return false;
    }

    var scaleX = rect.scaleRatio.x;
    var scaleY = rect.scaleRatio.y;

    if (hasChangedRect) {
      el.style.left = "".concat(rect.computedPhysical.x, "px");
      el.style.top = "".concat(rect.computedPhysical.y, "px");
      el.setAttribute('width', rect.computedPhysical.width);
      el.setAttribute('height', rect.computedPhysical.height);
    }

    gradients.clear();
    patterns.clear();
    defs.children.length = 0;
    var sceneContainer = {
      type: 'container',
      children: Array.isArray(nodes) ? [].concat(_toConsumableArray$1(nodes), [defs]) : nodes,
      transform: rect.edgeBleed.bool ? "translate(".concat(rect.edgeBleed.left * scaleX, ", ").concat(rect.edgeBleed.top * scaleY, ")") : ''
    };

    if (scaleX !== 1 || scaleY !== 1) {
      sceneContainer.transform += "scale(".concat(scaleX, ", ").concat(scaleY, ")");
    }

    var newScene = sceneFn({
      items: [sceneContainer],
      on: {
        create: [function (state) {
          state.node.fillReference = undefined;
          state.node.strokeReference = undefined;
        }, gradients.onCreate, patterns.onCreate, onLineBreak(svg.measureText), injectTextBoundsFn(svg)]
      }
    });
    var hasChangedScene = scene$1 ? !newScene.equals(scene$1) : true;
    var doRender = hasChangedRect || hasChangedScene;

    if (doRender) {
      svg.clear();
      tree$1.render(newScene.children, group);
    }

    hasChangedRect = false;
    scene$1 = newScene;
    return doRender;
  };

  svg.itemsAt = function (input) {
    return scene$1 ? scene$1.getItemsFrom(input) : [];
  };

  svg.findShapes = function (selector) {
    return scene$1 ? scene$1.findShapes(selector) : [];
  };

  svg.clear = function () {
    if (!group) {
      return svg;
    }

    scene$1 = null;
    var g = group.cloneNode(false);
    el.replaceChild(g, group);
    group = g;
    return svg;
  };

  svg.destroy = function () {
    // parentElement is not supported in IE11 for SVGElement.
    if (el && el.parentNode) {
      el.parentNode.removeChild(el);
    }

    el = null;
    group = null;
  };

  svg.size = function (opts) {
    if (opts) {
      var newRect = createRendererBox(opts);

      if (JSON.stringify(rect) !== JSON.stringify(newRect)) {
        hasChangedRect = true;
        rect = newRect;
      }
    }

    return rect;
  };

  return svg;
}
function rendererComponent$1(picasso) {
  picasso.renderer('svg', renderer$1);
}

var VNode = function VNode() {};

var options = {};

var stack$1 = [];

var EMPTY_CHILDREN = [];

function h(nodeName, attributes) {
	var children = EMPTY_CHILDREN,
	    lastSimple,
	    child,
	    simple,
	    i;
	for (i = arguments.length; i-- > 2;) {
		stack$1.push(arguments[i]);
	}
	if (attributes && attributes.children != null) {
		if (!stack$1.length) stack$1.push(attributes.children);
		delete attributes.children;
	}
	while (stack$1.length) {
		if ((child = stack$1.pop()) && child.pop !== undefined) {
			for (i = child.length; i--;) {
				stack$1.push(child[i]);
			}
		} else {
			if (typeof child === 'boolean') child = null;

			if (simple = typeof nodeName !== 'function') {
				if (child == null) child = '';else if (typeof child === 'number') child = String(child);else if (typeof child !== 'string') simple = false;
			}

			if (simple && lastSimple) {
				children[children.length - 1] += child;
			} else if (children === EMPTY_CHILDREN) {
				children = [child];
			} else {
				children.push(child);
			}

			lastSimple = simple;
		}
	}

	var p = new VNode();
	p.nodeName = nodeName;
	p.children = children;
	p.attributes = attributes == null ? undefined : attributes;
	p.key = attributes == null ? undefined : attributes.key;

	return p;
}

function extend$2(obj, props) {
  for (var i in props) {
    obj[i] = props[i];
  }return obj;
}

function applyRef(ref, value) {
  if (ref != null) {
    if (typeof ref == 'function') ref(value);else ref.current = value;
  }
}

var defer = typeof Promise == 'function' ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout;

var IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;

var items = [];

function enqueueRender(component) {
	if (!component._dirty && (component._dirty = true) && items.push(component) == 1) {
		(defer)(rerender);
	}
}

function rerender() {
	var p;
	while (p = items.pop()) {
		if (p._dirty) renderComponent(p);
	}
}

function isSameNodeType(node, vnode, hydrating) {
	if (typeof vnode === 'string' || typeof vnode === 'number') {
		return node.splitText !== undefined;
	}
	if (typeof vnode.nodeName === 'string') {
		return !node._componentConstructor && isNamedNode(node, vnode.nodeName);
	}
	return hydrating || node._componentConstructor === vnode.nodeName;
}

function isNamedNode(node, nodeName) {
	return node.normalizedNodeName === nodeName || node.nodeName.toLowerCase() === nodeName.toLowerCase();
}

function getNodeProps(vnode) {
	var props = extend$2({}, vnode.attributes);
	props.children = vnode.children;

	var defaultProps = vnode.nodeName.defaultProps;
	if (defaultProps !== undefined) {
		for (var i in defaultProps) {
			if (props[i] === undefined) {
				props[i] = defaultProps[i];
			}
		}
	}

	return props;
}

function createNode(nodeName, isSvg) {
	var node = isSvg ? document.createElementNS('http://www.w3.org/2000/svg', nodeName) : document.createElement(nodeName);
	node.normalizedNodeName = nodeName;
	return node;
}

function removeNode(node) {
	var parentNode = node.parentNode;
	if (parentNode) parentNode.removeChild(node);
}

function setAccessor(node, name, old, value, isSvg) {
	if (name === 'className') name = 'class';

	if (name === 'key') ; else if (name === 'ref') {
		applyRef(old, null);
		applyRef(value, node);
	} else if (name === 'class' && !isSvg) {
		node.className = value || '';
	} else if (name === 'style') {
		if (!value || typeof value === 'string' || typeof old === 'string') {
			node.style.cssText = value || '';
		}
		if (value && typeof value === 'object') {
			if (typeof old !== 'string') {
				for (var i in old) {
					if (!(i in value)) node.style[i] = '';
				}
			}
			for (var i in value) {
				node.style[i] = typeof value[i] === 'number' && IS_NON_DIMENSIONAL.test(i) === false ? value[i] + 'px' : value[i];
			}
		}
	} else if (name === 'dangerouslySetInnerHTML') {
		if (value) node.innerHTML = value.__html || '';
	} else if (name[0] == 'o' && name[1] == 'n') {
		var useCapture = name !== (name = name.replace(/Capture$/, ''));
		name = name.toLowerCase().substring(2);
		if (value) {
			if (!old) node.addEventListener(name, eventProxy, useCapture);
		} else {
			node.removeEventListener(name, eventProxy, useCapture);
		}
		(node._listeners || (node._listeners = {}))[name] = value;
	} else if (name !== 'list' && name !== 'type' && !isSvg && name in node) {
		try {
			node[name] = value == null ? '' : value;
		} catch (e) {}
		if ((value == null || value === false) && name != 'spellcheck') node.removeAttribute(name);
	} else {
		var ns = isSvg && name !== (name = name.replace(/^xlink:?/, ''));

		if (value == null || value === false) {
			if (ns) node.removeAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase());else node.removeAttribute(name);
		} else if (typeof value !== 'function') {
			if (ns) node.setAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase(), value);else node.setAttribute(name, value);
		}
	}
}

function eventProxy(e) {
	return this._listeners[e.type](e);
}

var mounts = [];

var diffLevel = 0;

var isSvgMode = false;

var hydrating = false;

function flushMounts() {
	var c;
	while (c = mounts.shift()) {
		if (c.componentDidMount) c.componentDidMount();
	}
}

function diff$2(dom, vnode, context, mountAll, parent, componentRoot) {
	if (!diffLevel++) {
		isSvgMode = parent != null && parent.ownerSVGElement !== undefined;

		hydrating = dom != null && !('__preactattr_' in dom);
	}

	var ret = idiff(dom, vnode, context, mountAll, componentRoot);

	if (parent && ret.parentNode !== parent) parent.appendChild(ret);

	if (! --diffLevel) {
		hydrating = false;

		if (!componentRoot) flushMounts();
	}

	return ret;
}

function idiff(dom, vnode, context, mountAll, componentRoot) {
	var out = dom,
	    prevSvgMode = isSvgMode;

	if (vnode == null || typeof vnode === 'boolean') vnode = '';

	if (typeof vnode === 'string' || typeof vnode === 'number') {
		if (dom && dom.splitText !== undefined && dom.parentNode && (!dom._component || componentRoot)) {
			if (dom.nodeValue != vnode) {
				dom.nodeValue = vnode;
			}
		} else {
			out = document.createTextNode(vnode);
			if (dom) {
				if (dom.parentNode) dom.parentNode.replaceChild(out, dom);
				recollectNodeTree(dom, true);
			}
		}

		out['__preactattr_'] = true;

		return out;
	}

	var vnodeName = vnode.nodeName;
	if (typeof vnodeName === 'function') {
		return buildComponentFromVNode(dom, vnode, context, mountAll);
	}

	isSvgMode = vnodeName === 'svg' ? true : vnodeName === 'foreignObject' ? false : isSvgMode;

	vnodeName = String(vnodeName);
	if (!dom || !isNamedNode(dom, vnodeName)) {
		out = createNode(vnodeName, isSvgMode);

		if (dom) {
			while (dom.firstChild) {
				out.appendChild(dom.firstChild);
			}
			if (dom.parentNode) dom.parentNode.replaceChild(out, dom);

			recollectNodeTree(dom, true);
		}
	}

	var fc = out.firstChild,
	    props = out['__preactattr_'],
	    vchildren = vnode.children;

	if (props == null) {
		props = out['__preactattr_'] = {};
		for (var a = out.attributes, i = a.length; i--;) {
			props[a[i].name] = a[i].value;
		}
	}

	if (!hydrating && vchildren && vchildren.length === 1 && typeof vchildren[0] === 'string' && fc != null && fc.splitText !== undefined && fc.nextSibling == null) {
		if (fc.nodeValue != vchildren[0]) {
			fc.nodeValue = vchildren[0];
		}
	} else if (vchildren && vchildren.length || fc != null) {
			innerDiffNode(out, vchildren, context, mountAll, hydrating || props.dangerouslySetInnerHTML != null);
		}

	diffAttributes(out, vnode.attributes, props);

	isSvgMode = prevSvgMode;

	return out;
}

function innerDiffNode(dom, vchildren, context, mountAll, isHydrating) {
	var originalChildren = dom.childNodes,
	    children = [],
	    keyed = {},
	    keyedLen = 0,
	    min = 0,
	    len = originalChildren.length,
	    childrenLen = 0,
	    vlen = vchildren ? vchildren.length : 0,
	    j,
	    c,
	    f,
	    vchild,
	    child;

	if (len !== 0) {
		for (var i = 0; i < len; i++) {
			var _child = originalChildren[i],
			    props = _child['__preactattr_'],
			    key = vlen && props ? _child._component ? _child._component.__key : props.key : null;
			if (key != null) {
				keyedLen++;
				keyed[key] = _child;
			} else if (props || (_child.splitText !== undefined ? isHydrating ? _child.nodeValue.trim() : true : isHydrating)) {
				children[childrenLen++] = _child;
			}
		}
	}

	if (vlen !== 0) {
		for (var i = 0; i < vlen; i++) {
			vchild = vchildren[i];
			child = null;

			var key = vchild.key;
			if (key != null) {
				if (keyedLen && keyed[key] !== undefined) {
					child = keyed[key];
					keyed[key] = undefined;
					keyedLen--;
				}
			} else if (min < childrenLen) {
					for (j = min; j < childrenLen; j++) {
						if (children[j] !== undefined && isSameNodeType(c = children[j], vchild, isHydrating)) {
							child = c;
							children[j] = undefined;
							if (j === childrenLen - 1) childrenLen--;
							if (j === min) min++;
							break;
						}
					}
				}

			child = idiff(child, vchild, context, mountAll);

			f = originalChildren[i];
			if (child && child !== dom && child !== f) {
				if (f == null) {
					dom.appendChild(child);
				} else if (child === f.nextSibling) {
					removeNode(f);
				} else {
					dom.insertBefore(child, f);
				}
			}
		}
	}

	if (keyedLen) {
		for (var i in keyed) {
			if (keyed[i] !== undefined) recollectNodeTree(keyed[i], false);
		}
	}

	while (min <= childrenLen) {
		if ((child = children[childrenLen--]) !== undefined) recollectNodeTree(child, false);
	}
}

function recollectNodeTree(node, unmountOnly) {
	var component = node._component;
	if (component) {
		unmountComponent(component);
	} else {
		if (node['__preactattr_'] != null) applyRef(node['__preactattr_'].ref, null);

		if (unmountOnly === false || node['__preactattr_'] == null) {
			removeNode(node);
		}

		removeChildren(node);
	}
}

function removeChildren(node) {
	node = node.lastChild;
	while (node) {
		var next = node.previousSibling;
		recollectNodeTree(node, true);
		node = next;
	}
}

function diffAttributes(dom, attrs, old) {
	var name;

	for (name in old) {
		if (!(attrs && attrs[name] != null) && old[name] != null) {
			setAccessor(dom, name, old[name], old[name] = undefined, isSvgMode);
		}
	}

	for (name in attrs) {
		if (name !== 'children' && name !== 'innerHTML' && (!(name in old) || attrs[name] !== (name === 'value' || name === 'checked' ? dom[name] : old[name]))) {
			setAccessor(dom, name, old[name], old[name] = attrs[name], isSvgMode);
		}
	}
}

var recyclerComponents = [];

function createComponent(Ctor, props, context) {
	var inst,
	    i = recyclerComponents.length;

	if (Ctor.prototype && Ctor.prototype.render) {
		inst = new Ctor(props, context);
		Component.call(inst, props, context);
	} else {
		inst = new Component(props, context);
		inst.constructor = Ctor;
		inst.render = doRender;
	}

	while (i--) {
		if (recyclerComponents[i].constructor === Ctor) {
			inst.nextBase = recyclerComponents[i].nextBase;
			recyclerComponents.splice(i, 1);
			return inst;
		}
	}

	return inst;
}

function doRender(props, state, context) {
	return this.constructor(props, context);
}

function setComponentProps(component, props, renderMode, context, mountAll) {
	if (component._disable) return;
	component._disable = true;

	component.__ref = props.ref;
	component.__key = props.key;
	delete props.ref;
	delete props.key;

	if (typeof component.constructor.getDerivedStateFromProps === 'undefined') {
		if (!component.base || mountAll) {
			if (component.componentWillMount) component.componentWillMount();
		} else if (component.componentWillReceiveProps) {
			component.componentWillReceiveProps(props, context);
		}
	}

	if (context && context !== component.context) {
		if (!component.prevContext) component.prevContext = component.context;
		component.context = context;
	}

	if (!component.prevProps) component.prevProps = component.props;
	component.props = props;

	component._disable = false;

	if (renderMode !== 0) {
		if (renderMode === 1 || options.syncComponentUpdates !== false || !component.base) {
			renderComponent(component, 1, mountAll);
		} else {
			enqueueRender(component);
		}
	}

	applyRef(component.__ref, component);
}

function renderComponent(component, renderMode, mountAll, isChild) {
	if (component._disable) return;

	var props = component.props,
	    state = component.state,
	    context = component.context,
	    previousProps = component.prevProps || props,
	    previousState = component.prevState || state,
	    previousContext = component.prevContext || context,
	    isUpdate = component.base,
	    nextBase = component.nextBase,
	    initialBase = isUpdate || nextBase,
	    initialChildComponent = component._component,
	    skip = false,
	    snapshot = previousContext,
	    rendered,
	    inst,
	    cbase;

	if (component.constructor.getDerivedStateFromProps) {
		state = extend$2(extend$2({}, state), component.constructor.getDerivedStateFromProps(props, state));
		component.state = state;
	}

	if (isUpdate) {
		component.props = previousProps;
		component.state = previousState;
		component.context = previousContext;
		if (renderMode !== 2 && component.shouldComponentUpdate && component.shouldComponentUpdate(props, state, context) === false) {
			skip = true;
		} else if (component.componentWillUpdate) {
			component.componentWillUpdate(props, state, context);
		}
		component.props = props;
		component.state = state;
		component.context = context;
	}

	component.prevProps = component.prevState = component.prevContext = component.nextBase = null;
	component._dirty = false;

	if (!skip) {
		rendered = component.render(props, state, context);

		if (component.getChildContext) {
			context = extend$2(extend$2({}, context), component.getChildContext());
		}

		if (isUpdate && component.getSnapshotBeforeUpdate) {
			snapshot = component.getSnapshotBeforeUpdate(previousProps, previousState);
		}

		var childComponent = rendered && rendered.nodeName,
		    toUnmount,
		    base;

		if (typeof childComponent === 'function') {

			var childProps = getNodeProps(rendered);
			inst = initialChildComponent;

			if (inst && inst.constructor === childComponent && childProps.key == inst.__key) {
				setComponentProps(inst, childProps, 1, context, false);
			} else {
				toUnmount = inst;

				component._component = inst = createComponent(childComponent, childProps, context);
				inst.nextBase = inst.nextBase || nextBase;
				inst._parentComponent = component;
				setComponentProps(inst, childProps, 0, context, false);
				renderComponent(inst, 1, mountAll, true);
			}

			base = inst.base;
		} else {
			cbase = initialBase;

			toUnmount = initialChildComponent;
			if (toUnmount) {
				cbase = component._component = null;
			}

			if (initialBase || renderMode === 1) {
				if (cbase) cbase._component = null;
				base = diff$2(cbase, rendered, context, mountAll || !isUpdate, initialBase && initialBase.parentNode, true);
			}
		}

		if (initialBase && base !== initialBase && inst !== initialChildComponent) {
			var baseParent = initialBase.parentNode;
			if (baseParent && base !== baseParent) {
				baseParent.replaceChild(base, initialBase);

				if (!toUnmount) {
					initialBase._component = null;
					recollectNodeTree(initialBase, false);
				}
			}
		}

		if (toUnmount) {
			unmountComponent(toUnmount);
		}

		component.base = base;
		if (base && !isChild) {
			var componentRef = component,
			    t = component;
			while (t = t._parentComponent) {
				(componentRef = t).base = base;
			}
			base._component = componentRef;
			base._componentConstructor = componentRef.constructor;
		}
	}

	if (!isUpdate || mountAll) {
		mounts.push(component);
	} else if (!skip) {

		if (component.componentDidUpdate) {
			component.componentDidUpdate(previousProps, previousState, snapshot);
		}
	}

	while (component._renderCallbacks.length) {
		component._renderCallbacks.pop().call(component);
	}if (!diffLevel && !isChild) flushMounts();
}

function buildComponentFromVNode(dom, vnode, context, mountAll) {
	var c = dom && dom._component,
	    originalComponent = c,
	    oldDom = dom,
	    isDirectOwner = c && dom._componentConstructor === vnode.nodeName,
	    isOwner = isDirectOwner,
	    props = getNodeProps(vnode);
	while (c && !isOwner && (c = c._parentComponent)) {
		isOwner = c.constructor === vnode.nodeName;
	}

	if (c && isOwner && (!mountAll || c._component)) {
		setComponentProps(c, props, 3, context, mountAll);
		dom = c.base;
	} else {
		if (originalComponent && !isDirectOwner) {
			unmountComponent(originalComponent);
			dom = oldDom = null;
		}

		c = createComponent(vnode.nodeName, props, context);
		if (dom && !c.nextBase) {
			c.nextBase = dom;

			oldDom = null;
		}
		setComponentProps(c, props, 1, context, mountAll);
		dom = c.base;

		if (oldDom && dom !== oldDom) {
			oldDom._component = null;
			recollectNodeTree(oldDom, false);
		}
	}

	return dom;
}

function unmountComponent(component) {

	var base = component.base;

	component._disable = true;

	if (component.componentWillUnmount) component.componentWillUnmount();

	component.base = null;

	var inner = component._component;
	if (inner) {
		unmountComponent(inner);
	} else if (base) {
		if (base['__preactattr_'] != null) applyRef(base['__preactattr_'].ref, null);

		component.nextBase = base;

		removeNode(base);
		recyclerComponents.push(component);

		removeChildren(base);
	}

	applyRef(component.__ref, null);
}

function Component(props, context) {
	this._dirty = true;

	this.context = context;

	this.props = props;

	this.state = this.state || {};

	this._renderCallbacks = [];
}

extend$2(Component.prototype, {
	setState: function setState(state, callback) {
		if (!this.prevState) this.prevState = this.state;
		this.state = extend$2(extend$2({}, this.state), typeof state === 'function' ? state(this.state, this.props) : state);
		if (callback) this._renderCallbacks.push(callback);
		enqueueRender(this);
	},
	forceUpdate: function forceUpdate(callback) {
		if (callback) this._renderCallbacks.push(callback);
		renderComponent(this, 2);
	},
	render: function render() {}
});

function render$9(vnode, parent, merge) {
  return diff$2(merge, vnode, {}, false, parent, false);
}

function renderer$2() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var _opts$createElement = opts.createElement,
      createElement = _opts$createElement === void 0 ? document.createElement.bind(document) : _opts$createElement;
  var el;
  var rect = createRendererBox();
  var dNode;
  var dom = create$n();

  dom.element = function () {
    return el;
  };

  dom.root = function () {
    return el;
  };

  dom.appendTo = function (element) {
    if (!el) {
      el = createElement('div');
      el.style.position = 'absolute';
      el.style['-webkit-font-smoothing'] = 'antialiased';
      el.style['-moz-osx-font-smoothing'] = 'antialiased';
      el.style.pointerEvents = 'none';
    }

    element.appendChild(el);
    return el;
  };

  dom.render = function (nodes) {
    if (!el) {
      return false;
    }

    el.style.left = "".concat(rect.computedPhysical.x, "px");
    el.style.top = "".concat(rect.computedPhysical.y, "px");
    el.style.width = "".concat(rect.computedPhysical.width, "px");
    el.style.height = "".concat(rect.computedPhysical.height, "px");
    var vNode;

    if (Array.isArray(nodes)) {
      vNode = h("div", null, nodes);
    } else {
      vNode = nodes;
    }

    dNode = render$9(vNode, el, dNode);
    return true;
  };

  dom.renderArgs = [h]; // Arguments to render functions using the DOM renderer

  dom.clear = function () {
    if (el) {
      var first = el.firstChild;

      while (first) {
        el.removeChild(first);
        first = el.firstChild;
      }

      dNode = null;
    }

    return dom;
  };

  dom.destroy = function () {
    if (el && el.parentElement) {
      el.parentElement.removeChild(el);
    }

    el = null;
    dNode = null;
  };

  dom.size = function (inner) {
    if (inner) {
      rect = createRendererBox(inner);
    }

    return rect;
  };

  return dom;
}

function rendererComponent$2(picasso) {
  picasso.renderer('dom', renderer$2);
}

var renderers = [rendererComponent$1, rendererComponent, rendererComponent$2];

var scales = [];

var LOG_LEVEL = {
  OFF: 0,
  ERROR: 1,
  WARN: 2,
  INFO: 3,
  DEBUG: 4
};

var loggerFn = function loggerFn() {
  var _LOG_FN;

  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$level = _ref.level,
      level = _ref$level === void 0 ? LOG_LEVEL.OFF : _ref$level,
      _ref$pipe = _ref.pipe,
      pipe = _ref$pipe === void 0 ? console : _ref$pipe;

  var currentlevel = level;
  var LOG_FN = (_LOG_FN = {}, _defineProperty(_LOG_FN, LOG_LEVEL.OFF, function () {}), _defineProperty(_LOG_FN, LOG_LEVEL.ERROR, function () {
    return pipe.error.apply(pipe, arguments);
  }), _defineProperty(_LOG_FN, LOG_LEVEL.WARN, function () {
    return pipe.warn.apply(pipe, arguments);
  }), _defineProperty(_LOG_FN, LOG_LEVEL.INFO, function () {
    return pipe.info.apply(pipe, arguments);
  }), _defineProperty(_LOG_FN, LOG_LEVEL.DEBUG, function () {
    return pipe.log.apply(pipe, arguments);
  }), _LOG_FN);

  var log = function log(lev) {
    if (!lev || currentlevel < lev) {
      return;
    }

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    (LOG_FN[lev] || LOG_FN[LOG_LEVEL.DEBUG]).apply(void 0, args);
  };
  /**
   * @typedef {object} logger
   * @private
   */


  return (
    /** @lends logger */
    {
      /**
       * Log a message
       * @param {number} lev - The log level
       * @param {...any} args
       * @kind function
       */
      log: log,

      /**
       * Log an error message
       * @param {...any} args
       */
      error: function error() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return log.apply(void 0, [LOG_LEVEL.ERROR].concat(args));
      },

      /**
       * Log a warning message
       * @param {...any} args
       */
      warn: function warn() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        return log.apply(void 0, [LOG_LEVEL.WARN].concat(args));
      },

      /**
       * Log an info message
       * @param {...any} args
       */
      info: function info() {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }

        return log.apply(void 0, [LOG_LEVEL.INFO].concat(args));
      },

      /**
       * Log a debug message
       * @param {...any} args
       */
      debug: function debug() {
        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          args[_key5] = arguments[_key5];
        }

        return log.apply(void 0, [LOG_LEVEL.DEBUG].concat(args));
      },

      /**
       * Set the current log level
       * @param {number} lev - The log level
       */
      level: function level(lev) {
        if (typeof lev === 'number') {
          currentlevel = lev;
        }

        return currentlevel;
      },
      LOG_LEVEL: LOG_LEVEL
    }
  );
};

var palettes = [{
  key: 'categorical',
  colors: [['#a54343', '#d76c6c', '#ec983d', '#ecc43d', '#f9ec86', '#cbe989', '#70ba6e', '#578b60', '#79d69f', '#26a0a7', '#138185', '#65d3da'] // breeze colors
  ]
}, {
  key: 'diverging',
  colors: [['#3d52a1', '#3a89c9', '#77b7e5', '#b4ddf7', '#e6f5fe', '#ffe3aa', '#f9bd7e', '#ed875e', '#d24d3e', '#ae1c3e']]
}, {
  key: 'sequential',
  colors: [['rgb(180,221,212)', 'rgb(34, 83, 90)']]
}];
/* eslint quote-props: 0 */

var style = {
  // -- FOUNDATION --
  // fonts
  '$font-family': "'Source Sans Pro', Arial, sans-serif",
  '$font-size': '12px',
  '$line-height': '16px',
  '$font-size--l': '16px',
  // base grays
  '$gray-100': '#ffffff',
  '$gray-98': '#f9f9f9',
  '$gray-95': '#f2f2f2',
  '$gray-90': '#e6e6e6',
  '$gray-35': '#595959',
  '$gray-30': '#4d4d4d',
  '$gray-25': '#404040',
  '$gray-20': '#333333',
  // borders
  '$border-95': 'rgba(255, 255, 255, 0.05)',
  '$border-90': 'rgba(255, 255, 255, 0.1)',
  '$border-80': 'rgba(255, 255, 255, 0.2)',
  '$border-20': 'rgba(0, 0, 0, 0.2)',
  '$border-10': 'rgba(0, 0, 0, 0.1)',
  '$border-5': 'rgba(0, 0, 0, 0.05)',
  // primary colors
  '$primary-blue': '#3F8AB3',
  '$primary-green': '#6CB33F',
  '$primary-red': '#DC423F',
  '$primary-orange': '#EF960F',
  // spacing
  '$spacing--s': 4,
  '$spacing': 8,
  '$spacing--l': 12,
  // -------------------------
  // -- ALIASES --
  '$font-color': '$gray-35',
  '$font-color--inverted': '$gray-90',
  '$guide-color': '$gray-90',
  '$guide-color--inverted': '$gray-35',
  '$border': '$border-80',
  '$border--inverted': '$border-10',
  // -------------------------
  // -- MIXINS --
  // data points
  '$shape': {
    // data shape
    fill: '$primary-blue',
    strokeWidth: 1,
    stroke: '$border'
  },
  '$shape-outline': {
    // data shape which usually does not have a fill, e.g. the line in a linechart
    stroke: '$primary-blue',
    strokeWidth: 2
  },
  '$shape-guide': {
    // lines that somehow belongs to a data shape, e.g. whiskers in a boxplot
    stroke: '$guide-color',
    strokeWidth: 1
  },
  '$shape-guide--inverted': {
    '@extend': '$shape-guide',
    stroke: '$guide-color--inverted'
  },
  '$label': {
    fontSize: '$font-size',
    fontFamily: '$font-family',
    fill: '$font-color'
  },
  '$label--inverted': {
    '$extend': '$label',
    fill: '$font-color--inverted'
  },
  // user interface
  '$label-overlay': {
    // e.g. selection range bubble
    fontSize: '$font-size--l',
    fontFamily: '$font-family',
    fill: '$gray-100',
    // background fill
    color: '$font-color',
    stroke: '$guide-color--inverted',
    strokeWidth: 1,
    borderRadius: 4
  },
  '$title': {
    '@extend': '$label',
    fontSize: '$font-size--l'
  },
  '$guide-line': {
    strokeWidth: 1,
    stroke: '$guide-color'
  },
  '$guide-line--minor': {
    strokeWidth: 1,
    stroke: '$gray-95' // needs alias

  },
  '$padding--s': {
    left: '$spacing--s',
    right: '$spacing--s',
    top: '$spacing--s',
    bottom: '$spacing--s'
  },
  '$padding': {
    left: '$spacing',
    right: '$spacing',
    top: '$spacing',
    bottom: '$spacing'
  },
  '$selection-area-target': {
    fill: '$primary-green',
    strokeWidth: 0,
    opacity: 0.2
  }
};

function usePlugin(plugin) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var api = arguments.length > 2 ? arguments[2] : undefined;
  plugin(api, options);
}

function pic() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var registries = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var logger = loggerFn(config.logger);
  /**
   * @lends picassojs
   */

  var regis = {
    // -- registries --

    /**
     * Component registry
     * @type {registry}
     */
    component: registryFactory(registries.component, 'component', logger),

    /**
     * Data registry
     * @type {registry}
     */
    data: registryFactory(registries.data, 'data', logger),

    /**
     * Formatter registry
     * @type {registry}
     */
    formatter: registryFactory(registries.formatter, 'formatter', logger),

    /**
     * Interaction registry
     * @type {registry}
     */
    interaction: registryFactory(registries.interaction, 'interaction', logger),

    /**
     * Renderer registry
     * @type {registry}
     */
    renderer: rendererRegistry(registries.renderer, 'renderer', logger),

    /**
     * Scale registry
     * @type {registry}
     */
    scale: registryFactory(registries.scale, 'scale', logger),

    /**
     * Symbol registry
     * @type {registry}
     * @private
     */
    symbol: registryFactory(registries.symbol, 'symbol', logger),
    // -- misc --

    /**
     * log some some stuff
     * @type {logger}
     * @private
     */
    logger: logger
  };

  if (config.renderer && config.renderer.prio) {
    regis.renderer.default(config.renderer.prio[0]);
  }
  /**
   * picasso.js entry point
   * @experimental
   * @entry
   * @alias picassojs
   * @param {object} cfg
   * @param {object} cfg.renderer
   * @param {Array<string>} cfg.renderer.prio
   * @param {object} cfg.logger
   * @param {number} cfg.logger.level
   * @param {object} cfg.style
   * @param {Array<object>} cfg.palettes
   * @returns {picassojs}
   */


  function picassojs() {
    var cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var cc = {
      palettes: config.palettes.concat(cfg.palettes || []),
      style: extend({}, config.style, cfg.style),
      logger: cfg.logger || config.logger,
      renderer: cfg.renderer || config.renderer
    };
    return pic(cc, regis);
  }
  /**
   * @callback picassojs~plugin
   * @param {picassojs~registries} registries
   * @param {object} options
   */

  /**
   * @param {picassojs~plugin} plugin
   * @param {object} [options]
   */


  picassojs.use = function (plugin) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return usePlugin(plugin, options, regis);
  };
  /**
   * @param {chart-definition} definition
   * @returns {chart}
   */


  picassojs.chart = function (definition) {
    return chartFn(definition, {
      registries: regis,
      logger: logger,
      style: config.style,
      palettes: config.palettes
    });
  };

  picassojs.config = function () {
    return config;
  };

  Object.keys(regis).forEach(function (key) {
    picassojs[key] = regis[key];
  });
  /**
   * picasso.js version
   * @type {string}
   */

  picassojs.version = about.version;
  return picassojs;
}

var p = pic({
  renderer: {
    prio: ['svg', 'canvas']
  },
  logger: {
    level: 0
  },
  style: style,
  palettes: palettes
}, {
  component: componentRegistry,
  data: dataRegistry,
  formatter: formatterRegistry,
  interaction: reg$2,
  renderer: rendererRegistry(),
  scale: scaleRegistry,
  symbol: reg$1
});
components.forEach(p.use);
renderers.forEach(p.use);
scales.forEach(p.use);

/* harmony default export */ __webpack_exports__["default"] = (p);
//# sourceMappingURL=picasso.esm.js.map


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,'__esModule',{value:!0});exports.enableSelectionOnFirstDimension=exports.interactionsSetup=void 0;var _picassoPluginQ=__webpack_require__(0),_picassoPluginQ2=_interopRequireDefault(_picassoPluginQ);function _interopRequireDefault(a){return a&&a.__esModule?a:{default:a}}var interactionsSetup=function(){'use strict';var a='rangex',b=[{type:'hammer',gestures:[{type:'Pan',options:{event:'range',dirction:Hammer.DIRECTION_HORIZONTAL},events:{rangestart:function c(b){if('undefined'!=typeof this.chart.component(a)){this.chart.component(a).emit('rangeStart',b)}},rangemove:function c(b){if('undefined'!=typeof this.chart.component(a)){this.chart.component(a).emit('rangeMove',b)}},rangeend:function c(b){if('undefined'!=typeof this.chart.component(a)){this.chart.component(a).emit('rangeEnd',b)}}}}]}];return b},enableSelectionOnFirstDimension=function(a,b,c){var d=b.brush(c);d.on('start',function(){});d.on('update',function(b,c){var e=_picassoPluginQ2.default.selections(d)[0];if('resetMadeSelections'===e.method){d.end();a.backendApi.clearSelections()}else if('selectHyperCubeValues'===e.method){var f=[],g=[];if(0<b.length)f=b[0].values.filter(function(a){return-2<a});if(0<c.length)g=c[0].values.filter(function(a){return-2<a});var h=f.concat(g);a.selectValues(e.params[1],h,!0)}else if('rangeSelectHyperCubeValues'===e.method){if(d.isActive){a.backendApi.selectRange(e.params[1],!0)}}});return d};exports.interactionsSetup=interactionsSetup;exports.enableSelectionOnFirstDimension=enableSelectionOnFirstDimension;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(5);


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,"__esModule",{value:!0});var _initialProperties=__webpack_require__(6),_initialProperties2=_interopRequireDefault(_initialProperties),_template=__webpack_require__(7),_template2=_interopRequireDefault(_template),_definition=__webpack_require__(8),_definition2=_interopRequireDefault(_definition),_controller=__webpack_require__(9),_controller2=_interopRequireDefault(_controller),_paint=__webpack_require__(14),_paint2=_interopRequireDefault(_paint),_resize=__webpack_require__(15),_resize2=_interopRequireDefault(_resize),_support=__webpack_require__(16),_support2=_interopRequireDefault(_support);__webpack_require__(17);var _picasso=__webpack_require__(2),_picasso2=_interopRequireDefault(_picasso),_picassoPluginQ=__webpack_require__(0),_picassoPluginQ2=_interopRequireDefault(_picassoPluginQ);function _interopRequireDefault(a){return a&&a.__esModule?a:{default:a}}exports.default=window.define([],function(){return{initialProperties:_initialProperties2.default,template:_template2.default,support:_support2.default,definition:_definition2.default,controller:_controller2.default,paint:_paint2.default,resize:_resize2.default}});

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,"__esModule",{value:!0});exports.default={qHyperCubeDef:{qDimensions:[],qMeasures:[],qInitialDataFetch:[{qWidth:3,qHeight:1e3}]}};

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = "<div class=\"lrp\" id=\"container\" style=\"height:100%;position:relative;\"></div>\r\n";

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,"__esModule",{value:!0});var colorsAndLegend={translation:"properties.colorsAndLegend",type:"items",grouped:!0,items:{colors:{type:"items",items:{autoColor:{ref:"color.auto",type:"boolean",translation:"properties.colors",component:"switch",defaultValue:!0,options:[{value:!0,translation:"Common.Auto"},{value:!1,translation:"Common.Custom"}]},positiveValueColor:{ref:"color.positiveValue.paletteColor",translation:"properties.waterfall.color.positiveValueColor",type:"object",component:"color-picker",dualOutput:!0,defaultValue:{index:6,color:null},show:function a(b){return!b.color.auto}},negativeValueColor:{ref:"color.negativeValue.paletteColor",translation:"properties.waterfall.color.negativeValueColor",type:"object",component:"color-picker",dualOutput:!0,defaultValue:{index:-1,color:"#cc6677"},show:function a(b){return!b.color.auto}},subtotalColor:{ref:"color.subtotal.paletteColor",label:"Start Value Color",type:"object",component:"color-picker",dualOutput:!0,defaultValue:{index:-1,color:"#c3c3c3"},show:function a(b){return!b.color.auto}},subtotalEndColor:{ref:"color.subtotalEnd.paletteColor",label:"End Value Color",type:"object",component:"color-picker",dualOutput:!0,defaultValue:{index:-1,color:"#c3c3c3"},show:function a(b){return!b.color.auto}}}},legend:{type:"items",items:{show:{ref:"legend.show",type:"boolean",translation:"properties.legend.show",component:"switch",defaultValue:!0,options:[{value:!0,translation:"Common.Auto"},{value:!1,translation:"properties.off"}]},dock:{type:"string",component:"dropdown",ref:"legend.dock",translation:"properties.legend.position",options:[{value:"auto",translation:"Common.Auto"},{value:"right",translation:"properties.dock.right"},{value:"bottom",translation:"Common.Bottom"},{value:"left",translation:"properties.dock.left"},{value:"top",translation:"Common.Top"}],defaultValue:"auto",show:function a(b){return b.legend.show}}}}}},s={type:"items",translation:"properties.presentation",grouped:!0,items:{gridLines:{type:"items",snapshot:{tid:"property-gridLines"},items:{showGridLines:{ref:"gridlines.auto",type:"boolean",translation:"properties.gridLine.spacing",component:"switch",defaultValue:!0,options:[{value:!0,translation:"Common.Auto"},{value:!1,translation:"Common.Custom"}]},gridSpacing:{ref:"gridlines.spacing",type:"number",component:"dropdown",defaultValue:2,options:[{value:0,translation:"properties.gridLine.noLines"},{value:2,translation:"properties.gridLine.medium"},{value:3,translation:"properties.gridLine.narrow"}],show:function(a){return a.gridlines&&!a.gridlines.auto}}}},showLabels:{ref:"dataPoint.showLabels",type:"boolean",translation:"properties.dataPoints.labelmode",component:"switch",defaultValue:!0,options:[{value:!0,translation:"Common.Auto"},{value:!1,translation:"properties.off"}],snapshot:{tid:"property-dataPoints"}},names:{type:"items",items:{showLabels:{ref:"labelsshow",type:"boolean",label:"Labels",component:"switch",defaultValue:!0,options:[{value:!0,translation:"Common.Auto"},{value:!1,translation:"Common.Custom"}]},startName:{ref:"startName",type:"string",label:"Start Value Label",expression:"optional",defaultValue:"Start Value",show:function(a){return!a.labelsshow}},endName:{ref:"endName",type:"string",label:"End Value Label",expression:"optional",defaultValue:"End Value",show:function(a){return!a.labelsshow}},posName:{ref:"posName",type:"string",label:"Positive Label",expression:"optional",defaultValue:"Positive Variance",show:function(a){return!a.labelsshow}},negName:{ref:"negName",type:"string",label:"Negative Label",expression:"optional",defaultValue:"Negative Variance",show:function(a){return!a.labelsshow}}}}}},u={uses:"axis.picasso.measureAxis",label:"Y-axis",items:{title:{ref:"measureAxis.title",type:"string",label:"Axis Title",defaultValue:"",expression:"optional"}}},c={uses:"axis.picasso.dimensionAxis"},d={type:"items",component:"expandable-items",translation:"properties.addons",items:{dataHandling:{uses:"dataHandling",items:{suppressZero:null,calcCond:{uses:"calcCond"}}}}},about={type:"items",label:"About",items:{about1:{type:"string",component:"text",label:"Steven Pressland 2019"},about1a:{type:"string",component:"text",label:"v1.1.4"},about2:{type:"string",component:"text",label:"GitHub: www.github.com/analyticsearth"},about3:{type:"string",component:"text",label:"A Waterfall chart for displaying variance between two metrics, walking through a set of dimension values."}}};exports.default={type:"items",component:"accordion",items:{data:{uses:"data",items:{dimensions:{min:1,max:1,disabledRef:"",description:function a(){return"Bridge Dimension"}},measures:{min:2,max:2,disabledRef:"",description:function b(c,a){return["Start Value","End Value"][a]},items:{variance:{show:function b(c,a){if(a.properties.qHyperCubeDef.qMeasures[0]==c){return!0}else{return!1}},type:"string",label:"Variance Formula",component:"expression",ref:"qAttributeExpressions.0.qExpression",defaultValue:function a(){return"num(Column(2) - Column(1),'#,##0.00')"}}}}}},sorting:{uses:"sorting"},addons:d,settings:{uses:"settings",items:{presentation:s,colors:colorsAndLegend,measureAxis:u,dimensionAxis:c}},about:about}};

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,'__esModule',{value:!0});var _converthypercube=__webpack_require__(10),_converthypercube2=_interopRequireDefault(_converthypercube),_picasso=__webpack_require__(2),_picasso2=_interopRequireDefault(_picasso),_picassoPluginQ=__webpack_require__(0),_picassoPluginQ2=_interopRequireDefault(_picassoPluginQ),_picassoPluginHammer=__webpack_require__(12),_picassoPluginHammer2=_interopRequireDefault(_picassoPluginHammer),_bridgepicassospec=__webpack_require__(13),_bridgepicassospec2=_interopRequireDefault(_bridgepicassospec),_theme=__webpack_require__(1),_theme2=_interopRequireDefault(_theme),_interactions=__webpack_require__(3);function _interopRequireDefault(a){return a&&a.__esModule?a:{default:a}}var qlik=window.require('qlik');exports.default=['$scope','$element',function(a,b){a.qlik=qlik;a.theme=null;a.updated=!1;a.app=qlik.currApp(this);_picasso2.default.use(_picassoPluginQ2.default);_picasso2.default.use(_picassoPluginHammer2.default);a.pic=(0,_picasso2.default)({renderer:{prio:['canvas']},logger:{// experimental
level:4},style:_theme2.default.getPicassoTheme()});a.chart=a.pic.chart({element:b.find('.lrp')[0],updated:function b(){a.updated=!0},beforeUpdated:function b(){a.updated=!1}});a.chartBrush=(0,_interactions.enableSelectionOnFirstDimension)(a,a.chart,'highlight',a.layout);a.updatedData=function(b,c,d){var e={};if(d){var f=_converthypercube2.default.convertHypercube(a.layout.qHyperCube);e.data=[{type:'q',key:'qHyperCube',data:f}]}if('edit'===c||'undefined'==typeof a.chart.settings){e.settings=(0,_bridgepicassospec2.default)(b,a.$parent.options.direction)}a.chart.update(e)}}];

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,"__esModule",{value:!0});var _createClass=function(){function a(a,b){for(var c=0,d;c<b.length;c++){d=b[c];d.enumerable=d.enumerable||!1;d.configurable=!0;if("value"in d)d.writable=!0;Object.defineProperty(a,d.key,d)}}return function(b,c,d){if(c)a(b.prototype,c);if(d)a(b,d);return b}}();function _toConsumableArray(a){if(Array.isArray(a)){for(var b=0,c=Array(a.length);b<a.length;b++){c[b]=a[b]}return c}else{return Array.from(a)}}function _classCallCheck(a,b){if(!(a instanceof b)){throw new TypeError("Cannot call a class as a function")}}var ConvertHypercube=function(){function a(){_classCallCheck(this,a)}_createClass(a,null,[{key:"convertHypercube",value:function g(a){var b=this.createDataPage(a),c=b.qMatrix.map(function(a){return a[2].qNum}),d=Math.min.apply(Math,_toConsumableArray(c)),e=Math.max.apply(Math,_toConsumableArray(c)),f={qColumnOrder:[],qDataPages:[b],qDimensionInfo:[this.createDimensionInfo(a.qDimensionInfo[0])],qEffectiveInterColumnSortOrder:[0,1,2],qMeasureInfo:[this.createMeasureInfo(a.qMeasureInfo[0],d,e),this.createMeasureInfo(a.qMeasureInfo[1],d,e),this.staticMeasureInfo()],qMode:"S",qNoOfLeftDims:-1,qSize:{qcx:4,qcy:a.qSize.qcy+2}};return f}},{key:"createDimensionInfo",value:function b(a){return{cId:a.cId,qCardinal:a.qCardinal+2,qCardinalities:{qCardinal:a.qCardinalities.qCardinal+2,qHypercubeCardinal:a.qCardinalities.qHypercubeCardinal+2},qDimensionType:a.qDimensionType,qFallbackTitle:a.qFallbackTitle,qGroupFallbackTitles:[a.qFallbackTitle],qGroupFieldDefs:[a.qGroupFieldDefs[0]],qGroupPos:0,qGrouping:"N",qIsAutoFormat:a.qIsAutoFormat,qMax:a.qMax,qMin:a.qMin,qSortIndicator:a.qSortIndicator,qStateCounts:{qAlternative:a.qStateCounts.qAlternative,qDeselected:a.qStateCounts.qDeselected,qExcluded:a.qStateCounts.qExcluded,qLocked:a.qStateCounts.qLocked,qLockedExcluded:a.qStateCounts.qLockedExcluded,qOption:a.qStateCounts.qOption+2,qSelected:a.qStateCounts.qSelected,qSelectedExcluded:a.qStateCounts.qSelectedExcluded},qTags:a.qTags.map(function(a){return a})}}},{key:"createMeasureInfo",value:function d(a,b,c){return{autoSort:!0,cId:a.cId,numFormatFromTemplate:a.numFormatFromTemplate,qApproxMaxGlyphCount:a.qApproxMaxGlyphCount,qAttrDimInfo:a.qAttrDimInfo.map(function(a){return a}),qAttrExprInfo:a.qAttrExprInfo.map(function(a){return a}),qCardinal:a.qCardinal,qFallbackTitle:a.qFallbackTitle,qMax:c,//mesInfo.qMax,
qMin:b,//mesInfo.qMin,
qSortIndicator:a.qSortIndicator,qNumFormat:{qDec:a.qNumFormat.qDec,qFmt:a.qNumFormat.qFmt,qThou:a.qNumFormat.qThou,qType:a.qNumFormat.qType,qUseThou:a.qNumFormat.qUseThou,qnDec:a.qNumFormat.qnDec}}}},{key:"staticMeasureInfo",value:function a(){return{qFallbackTitle:"Variance"}}},{key:"createDataPage",value:function e(a){var b=a.qDataPages[0],c=this.createMatrix(a),d={qArea:{qHeight:b.qArea.qHeight+2,qLeft:0,qTop:0,qWidth:4},qMatrix:c,qTails:[{qUp:0,qDown:0}]};return d}},{key:"createMatrix",value:function h(a){var b=a.qDataPages[0].qMatrix,c=b.map(function(a){return[{qText:a[0].qText,qNum:a[0].qNum,qElemNumber:a[0].qElemNumber,qState:a[0].qState},{qText:"0",qNum:0,qElemNumber:a[1].qElemNumber,qState:a[1].qState},{qText:a[1].qAttrExps.qValues[0].qText,qNum:a[1].qAttrExps.qValues[0].qNum,qElemNumber:a[2].qElemNumber,qState:a[2].qState},{qText:a[1].qAttrExps.qValues[0].qText,qNum:a[1].qAttrExps.qValues[0].qNum,qElemNumber:a[2].qElemNumber,qState:a[2].qState}]});var d=a.qGrandTotalRow[0],e=a.qMeasureInfo[0];c.unshift([{qText:e.qFallbackTitle,qNum:"NaN",qElemNumber:-4,qState:"X"},{qText:"0",qNum:0,qElemNumber:0,qState:"L"},{qText:d.qText,qNum:d.qNum,qElemNumber:0,qState:"L"},{qText:d.qText,qNum:d.qNum,qElemNumber:0,qState:"L"}]);var f=a.qGrandTotalRow[1],g=a.qMeasureInfo[1];c.push([{qText:g.qFallbackTitle,qNum:"NaN",qElemNumber:-5,qState:"X"},{qText:"0",qNum:0,qElemNumber:0,qState:"L"},{qText:f.qText,qNum:f.qNum,qElemNumber:0,qState:"L"},{qText:f.qText,qNum:f.qNum,qElemNumber:0,qState:"L"}]);c.forEach(function(a,b){if(0<b&&b<c.length-1){a[1].qNum=c[b-1][2].qNum;a[2].qNum=c[b-1][2].qNum+a[2].qNum}});return c}}]);return a}();exports.default=ConvertHypercube;

/***/ }),
/* 11 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/*
* picasso-plugin-hammer v0.25.3
* Copyright (c) 2019 QlikTech International AB
* Released under the MIT license.
*/


/* global Hammer */
var translateKnownTypes = {
  click: 'Tap',
  Click: 'Tap',
  tap: 'Tap',
  pan: 'Pan',
  swipe: 'Swipe',
  rotate: 'Rotate',
  press: 'Press',
  pinch: 'Pinch'
};
/**
 * Helper function for translating typical non-hammer gesture to a hammer gesture. Currently only supporting 'click'
 * @param {String} type Gesture type
 * @private
 */

function getGestureType(type) {
  return translateKnownTypes[type] || type;
}
/**
 * Manages event handlers for HammerJS. Assumes Hammer is loaded and added to the global namespace
 */


function hammer(chart, mediator, element) {
  var settings;
  var instance;
  var mc;
  var key;
  var hammerGestures = [];
  var isOn = true;
  /**
   * Set default settings
   * @private
   */

  function setDefaultSettings(newSettings) {
    key = newSettings.key; //eslint-disable-line

    settings = newSettings;
    instance = {
      chart: chart,
      mediator: mediator,
      settings: settings
    };
    settings.gestures = settings.gestures || [];

    if (settings.enable === undefined) {
      settings.enable = true;
    }
  }
  /**
   * @private
   * add hammer recognizers based on settings
   */


  function addRecognizers() {
    if (typeof settings.enable === 'function') {
      settings.enable = settings.enable.bind(instance)();
    }

    if (!settings.enable) {
      return; // interaction is disabled
    }

    settings.gestures.forEach(function (gesture) {
      gesture.options = gesture.options || {}; // handle action enable

      if (gesture.options.enable === undefined) {
        gesture.options.enable = true;
      }

      if (typeof gesture.options.enable === 'function') {
        gesture.options.enable = gesture.options.enable.bind(instance);
      } // setup hammer gestures


      var type = getGestureType(gesture.type);

      if (Hammer && Hammer[type]) {
        gesture.options.event = gesture.options.event || gesture.type.toLowerCase();
        mc = mc || new Hammer.Manager(element);
        mc.add(new Hammer[type](gesture.options));
        Object.keys(gesture.events).forEach(function (eventName) {
          gesture.events[eventName] = gesture.events[eventName].bind(instance);
          mc.on(eventName, gesture.events[eventName]);
        });
        hammerGestures.push(gesture);
      }
    }); // setup mixing hammer gestures

    settings.gestures.forEach(function (gesture) {
      var type = getGestureType(gesture.type);

      if (Hammer && Hammer[type]) {
        if (gesture.recognizeWith) {
          mc.get(gesture.options.event).recognizeWith(gesture.recognizeWith.split(' ').filter(function (e) {
            return e !== '';
          }));
        }

        if (gesture.requireFailure) {
          mc.get(gesture.options.event).requireFailure(gesture.requireFailure.split(' ').filter(function (e) {
            return e !== '';
          }));
        }
      }
    });
  }
  /**
   * @private
   * removes all added hammer recognizers and native events
   */


  function removeAddedEvents() {
    // remove hammer recognizers and registered events
    hammerGestures.forEach(function (gesture) {
      Object.keys(gesture.events).forEach(function (eventName) {
        mc.off(eventName, gesture.events[eventName]);
      });
      mc.remove(gesture.options.event);
    });
    hammerGestures = [];
  }

  return {
    /**
     * Getter for the key.
     */
    get key() {
      return key;
    },

    /**
     * Updates this with new settings
     * @typedef settings
     * @type {object}
     * @property {string} [type] - The interaction type. Is 'hammer' for this component
     * @property {boolean|function} [enable] - Should the interaction be enabled or not.
     * This is only run when adding event handlers. In effect at startup, update or during on/off.
     * It does not run during every event loop.
     * @property {object} [events] - The keys in this object is the names of native events
     * that should be added to the chart element and they should all point to function which
     * will be the corresponding event handler.
     */
    set: function set(newSettings) {
      setDefaultSettings(newSettings);
      removeAddedEvents();

      if (isOn) {
        addRecognizers();
      }
    },

    /**
     * Turns off interactions
     */
    off: function off() {
      isOn = false;
      removeAddedEvents();
    },

    /**
     * Turns off interactions
     */
    on: function on() {
      isOn = true;

      if (hammerGestures.length === 0) {
        addRecognizers();
      }
    },

    /**
     * Destroys and unbinds all event handlers
     */
    destroy: function destroy() {
      removeAddedEvents();

      if (mc) {
        mc.destroy();
      }

      mc = null;
      instance = null;
      settings = null;
    }
  };
}

function initialize(picasso) {
  picasso.interaction('hammer', hammer);
}

/* harmony default export */ __webpack_exports__["default"] = (initialize);
//# sourceMappingURL=picasso-hammer.esm.js.map


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,'__esModule',{value:!0});exports.default=function(a,b){var c={startvalue:a.labelsshow?'Start Value':a.startName,endvalue:a.labelsshow?'End Value':a.endName,negative:a.labelsshow?'Negative Variance':a.negName,positive:a.labelsshow?'Positive Variance':a.posName},d={startvalue:a.color.auto?_theme2.default.colorOther(2):_theme2.default.colorFromPicker(a.color.subtotal.paletteColor),endvalue:a.color.auto?_theme2.default.colorOther(2):_theme2.default.colorFromPicker(a.color.subtotalEnd.paletteColor),negative:a.color.auto?_theme2.default.colorFromSeq(1):_theme2.default.colorFromPicker(a.color.negativeValue.paletteColor),positive:a.color.auto?_theme2.default.colorFromSeq(0):_theme2.default.colorFromPicker(a.color.positiveValue.paletteColor)},e=!0,f='left',g='right';if('rtl'===b){e=!1;f='right';g='left'}return{interactions:(0,_interactions.interactionsSetup)(),scales:{v:{data:{fields:['qMeasureInfo/0','qMeasureInfo/1']},type:'linear',invert:!0,expand:.01,min:!a.measureAxis.autoMinMax&&('min'==a.measureAxis.minMax||'minMax'==a.measureAxis.minMax)?a.measureAxis.min:NaN,max:!a.measureAxis.autoMinMax&&('max'==a.measureAxis.minMax||'minMax'==a.measureAxis.minMax)?a.measureAxis.max:NaN,include:[0],spacing:.5,ticks:{distance:150*a.measureAxis.spacing},minorTicks:{count:1}},t:{data:{extract:{field:'qDimensionInfo/0'}},type:'band',invert:!e,padding:.2}},components:[{type:'text',show:'none'!=a.measureAxis.show&&'labels'!=a.measureAxis.show&&''!=a.measureAxis.title,text:a.measureAxis.title,layout:{dock:'near'===a.measureAxis.dock?f:g,displayOrder:1},style:{text:{fontSize:'13px',fontFamily:_theme2.default.getPicassoTheme()['$font-family']}}},{type:'text',show:'none'!=a.dimensionAxis.show&&'labels'!=a.dimensionAxis.show,text:a.qHyperCube.qDimensionInfo[0].qFallbackTitle,layout:{dock:'near'===a.dimensionAxis.dock?'bottom':'top',displayOrder:1},style:{text:{fontSize:'13px',fontFamily:_theme2.default.getPicassoTheme()['$font-family']}}},{type:'axis',key:'xaxis',scale:'t',layout:{dock:'near'===a.dimensionAxis.dock?'bottom':'top',displayOrder:0},brush:{trigger:[{on:'tap',contexts:['highlight'],globalPropagation:'stop',propagation:'stop'}]},settings:{labels:{show:'none'!=a.dimensionAxis.show&&'title'!=a.dimensionAxis.show,mode:a.dimensionAxis.label,tiltAngle:e?40:-40},ticks:{show:!0},line:{show:!0}}},{type:'axis',scale:'v',layout:{dock:'near'===a.measureAxis.dock?f:g,displayOrder:0},settings:{labels:{show:'none'!=a.measureAxis.show&&'title'!=a.measureAxis.show,mode:a.measureAxis.label},ticks:{show:'none'!=a.measureAxis.show&&'title'!=a.measureAxis.show},minorTicks:{/* Toggle minor-ticks on/off */show:!0,// Optional
/* Size of the ticks in pixels. */tickSize:3,// Optional
/* Space in pixels between the ticks and the line. */margin:0// Optional
},line:{show:!0}}},{type:'box',key:'bars',layout:{displayOrder:1},data:{extract:{field:'qDimensionInfo/0',props:{start:{field:'qMeasureInfo/0'},end:{field:'qMeasureInfo/1'},var:{field:'qMeasureInfo/2'}}}},brush:{trigger:[{on:'tap',contexts:['highlight'],globalPropagation:'stop',propagation:'stop'}],consume:[{context:'highlight',style:{inactive:{opacity:.3}}}]},settings:{major:{scale:'t'},minor:{scale:'v'},orientation:'vertical',box:{width:1,minHeightPx:2,fill:function b(a){//console.log(d);
if(-4===a.datum.value){return d.startvalue}else if(-5===a.datum.value){return d.endvalue}else{if(0>a.datum.var.value){return d.negative}else{return d.positive}}}}}},{key:'p',type:'point',data:{extract:{field:'qDimensionInfo/0',props:{mm:{field:'qMeasureInfo/1'}}}},settings:{x:{scale:'t',fn:function b(a){if(e){return a.scale(a.datum.value)+a.scale.bandwidth()+(a.scale.step()-a.scale.bandwidth())/2;// + d.scale.bandwidth() - (d.scale.step() - d.scale.bandwidth());
}else{return a.scale(a.datum.value)-(a.scale.step()-a.scale.bandwidth())/2}}},y:{scale:'v',ref:'mm'},opacity:function b(a){if(a.datum.value===a.data.items[a.data.items.length-1].value){return 0}else{return 1}},size:function b(a){if(a.datum.value===a.data.items[a.data.items.length-1].value){return 0}else{return a.scale.step()}},fill:'none',shape:'line',stroke:'#7b7a78',/*function(d) {
            return ThemeManager.colorFromTheme(14);
          },*/strokeDasharray:'4 4',strokeWidth:1,sizeLimits:{maxRelExtent:1}}},{type:'grid-line',show:a.gridlines.auto||0<a.gridlines.spacing,y:{scale:'v'},ticks:{show:a.gridlines.auto||1<a.gridlines.spacing,strokeWidth:1},minorTicks:{show:!a.gridlines.auto&&2<a.gridlines.spacing,strokeWidth:1}},{type:'labels',show:a.dataPoint.showLabels,layout:{displayOrder:2// must be larger than the displayOrder for the 'bars' component
},settings:{sources:[{component:'bars',selector:'rect',// select all 'rect' shapes from the 'bars' component
strategy:{type:'bar',// the strategy type
settings:{direction:function(a){var b=a.data;// data argument is the data bound to the shape in the referenced component
return b&&b.end.value>b.start.value?'up':'down'},fontSize:12,align:.5,justify:1,labels:[{label:function c(a){var b=a.data;return b?b.end.label:''},placements:[// label placements in prio order. Label will be placed in the first place it fits into
{position:'inside',fill:'#fff',align:.5,justify:.98},{position:'outside',fill:'#666',align:.5,justify:.01},{position:'opposite',fill:'#666',align:.5,justify:.01}]}]}}}]}},{scale:{type:'categorical-color',data:[c.startvalue,c.positive,c.negative,c.endvalue],range:[d.startvalue,d.positive,d.negative,d.endvalue]},type:'legend-cat',show:a.legend.show,layout:{dock:'auto'===a.legend.dock?'top':a.legend.dock,displayOrder:2},settings:{layout:{// Optional
/* Maximum number of columns (vertical) or rows (horizontal) */size:1,// Optional
/* Layout direction. Either `'ltr'` or `'rtl'` */direction:b,// Optional
/* Initial scroll offset */scrollOffset:0// Optional
},/* Settings applied per item */item:{// Optional
/* Whether to show the current item */show:!0,// Optional
label:{// Optional
/* Word break rule, how to apply line break if label text overflows its maxWidth property. Either `'break-word'` or `'break-all'` */wordBreak:'none',// Optional
/* Max number of lines allowed if label is broken into multiple lines (only applicable with wordBreak) */maxLines:2,// Optional
/* Maximum width of label, in px */maxWidth:136// Optional
},shape:{// Optional
type:'square',// Optional
size:12// Optional
}},title:{// Optional
/* Whether to show the title */show:!1,// Optional
/* Title text. Defaults to the title of the provided data field *///text: /* string */ , // Optional
/* Horizontal alignment of the text. Allowed values are `'start'`, `'middle'` and `'end'` */anchor:'start',/* Word break rule, how to apply line break if label text overflows its maxWidth property. Either `'break-word'` or `'break-all'` */wordBreak:'none',// Optional
/* Max number of lines allowed if label is broken into multiple lines, is only appled when `wordBreak` is not set to `'none'` */maxLines:2,// Optional
/* Maximum width of title, in px */maxWidth:156// Optional
}}},{key:'rangex',layout:{displayOrder:5},type:'brush-range',settings:{brush:'highlight',direction:'horizontal',scale:'t',target:{component:'xaxis'},bubbles:{align:'start'}}}]}};var _theme=__webpack_require__(1),_theme2=_interopRequireDefault(_theme),_interactions=__webpack_require__(3);function _interopRequireDefault(a){return a&&a.__esModule?a:{default:a}}

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,'__esModule',{value:!0});exports.default=function(a,b){var c=this,d=this.$scope.qlik.currApp(this),e=this.$scope.qlik.navigation.getMode();this.$scope.updatedData(b,e,!0);d.theme.getApplied().then(function(a){c.$scope.theme=a;_theme2.default.setAppTheme(c.$scope.theme);//let navmode = this.$scope.qlik.navigation.getMode();
c.$scope.updatedData(b,e,!0);return c.$scope.qlik.Promise.resolve()})};var _theme=__webpack_require__(1),_theme2=_interopRequireDefault(_theme);function _interopRequireDefault(a){return a&&a.__esModule?a:{default:a}}

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,"__esModule",{value:!0});exports.default=function(a,b){var c=this,d=c.$scope.viz,e=this.$scope.qlik.navigation.getMode();this.$scope.updatedData(b,e,!1);return this.$scope.qlik.Promise.resolve()};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,"__esModule",{value:!0});exports.default={snapshot:!0,export:!0,exportData:!0,viewData:!0};

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(18);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {"hmr":true}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(20)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../node_modules/css-loader/index.js!../node_modules/sass-loader/lib/loader.js!./style.scss", function() {
			var newContent = require("!!../node_modules/css-loader/index.js!../node_modules/sass-loader/lib/loader.js!./style.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(19)(false);
// imports


// module
exports.push([module.i, "", ""]);

// exports


/***/ }),
/* 19 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getElement = (function (fn) {
	var memo = {};

	return function(selector) {
		if (typeof memo[selector] === "undefined") {
			var styleTarget = fn.call(this, selector);
			// Special case to return head of iframe instead of iframe itself
			if (styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[selector] = styleTarget;
		}
		return memo[selector]
	};
})(function (target) {
	return document.querySelector(target)
});

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(21);

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertInto + " " + options.insertAt.before);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 21 */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ })
/******/ ]);