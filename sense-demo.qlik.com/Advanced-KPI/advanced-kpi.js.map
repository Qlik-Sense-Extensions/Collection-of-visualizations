{
    "version": 3,
    "sources": [
        "webpack:///webpack/bootstrap",
        "webpack:///./src/style.css",
        "webpack:///./node_modules/css-loader/dist/runtime/api.js",
        "webpack:///./node_modules/picasso-plugin-q/dist/picasso-q.esm.js",
        "webpack:///./node_modules/picasso.js/dist/picasso.esm.js",
        "webpack:///./node_modules/style-loader/lib/addStyles.js",
        "webpack:///./node_modules/style-loader/lib/urls.js",
        "webpack:///(webpack)/buildin/global.js",
        "webpack:///./src/chartdef.js",
        "webpack:///./src/controller.js",
        "webpack:///./src/definition.js",
        "webpack:///./src/index.js",
        "webpack:///./src/initial-properties.js",
        "webpack:///./src/style.css?8f34",
        "webpack:///./src/template.html",
        "webpack:///external {\"amd\":\"jquery\",\"commonjs\":\"jquery\",\"commonjs2\":\"jquery\",\"root\":\"_\"}",
        "webpack:///external {\"amd\":\"qlik\",\"commonjs\":\"qlik\",\"commonjs2\":\"qlik\",\"root\":\"_\"}"
    ],
    "names": [
        "bar1mes",
        "prop",
        "scales",
        "y",
        "data",
        "field",
        "invert",
        "include",
        "t",
        "extract",
        "padding",
        "minichart",
        "barpadding",
        "components",
        "type",
        "gridlinehor",
        "x",
        "gridlinever",
        "key",
        "props",
        "start",
        "end",
        "settings",
        "major",
        "scale",
        "minor",
        "box",
        "fill",
        "colorone",
        "color",
        "show",
        "ref",
        "lines",
        "value",
        "line",
        "strokeWidth",
        "strokewidth",
        "stroke",
        "label",
        "background",
        "opacity",
        "bar2mes",
        "fields",
        "align",
        "baraligncompare1",
        "v",
        "baraligncompare2",
        "colortwo",
        "line1mes",
        "expand",
        "linescaleexpand",
        "coordinates",
        "layers",
        "size",
        "dotsize",
        "line2mes",
        "gauge1mes",
        "qlik",
        "window",
        "require",
        "$scope",
        "$element",
        "app",
        "currApp",
        "id",
        "pictureUrl",
        "layout",
        "picture",
        "includes",
        "split",
        "join",
        "picasso",
        "use",
        "picassoQ",
        "ds",
        "qHyperCube",
        "picassoSettings",
        "getSettings",
        "chartType",
        "amountMes",
        "qMeasureInfo",
        "length",
        "chartdef",
        "createChart",
        "chart",
        "element",
        "find",
        "beforeRender",
        "resize",
        "$watch",
        "qDimensionInfo",
        "update",
        "destroy",
        "cssswitch",
        "css",
        "backgroundcss",
        "JSON",
        "parse",
        "pictureswitch",
        "switchfxpick",
        "colorfx",
        "err",
        "console",
        "log",
        "customcss",
        "switch",
        "replace",
        "qInfo",
        "qId",
        "define",
        "utils",
        "uses",
        "translation",
        "items",
        "dimensions",
        "description",
        "a",
        "b",
        "disabledRef",
        "min",
        "max",
        "measures",
        "measure1Fx",
        "expression",
        "measure1Name",
        "measure1Align",
        "component",
        "options",
        "defaultValue",
        "measure1KpiStyleSize",
        "measure1KpiFont",
        "measure1KpiStyleBold",
        "measure1KpiStyleItalic",
        "measure1KpiStyleUnderline",
        "measure1KpiStyleColor",
        "measure1TitleStyleSize",
        "measure1TitleFont",
        "measure1TitleStyleBold",
        "measure1TitleStyleItalic",
        "measure1TitleStyleUnderline",
        "measure1TitleStyleColor",
        "measure1TrendSwitch",
        "measure1TrendSide",
        "measure1",
        "trend",
        "measure1TrendIcon",
        "measure1TrendIconColor",
        "measure1TrendFontSize",
        "measure2Fx",
        "measure2Name",
        "measure2Align",
        "measure2KpiStyleSize",
        "measure2KpiFont",
        "measure2KpiStyleBold",
        "measure2KpiStyleItalic",
        "measure2KpiStyleUnderline",
        "measure2KpiStyleColor",
        "measure2TitleStyleSize",
        "measure2TitleFont",
        "measure2TitleStyleBold",
        "measure2TitleStyleItalic",
        "measure2TitleStyleUnderline",
        "measure2TitleStyleColor",
        "measure2TrendSwitch",
        "measure2TrendIcon",
        "measure2",
        "measure2TrendIconColor",
        "measure2TrendFontSize",
        "measure3Fx",
        "measure3Name",
        "measure3Align",
        "measure3KpiStyleSize",
        "measure3KpiFont",
        "measure3KpiStyleBold",
        "measure3KpiStyleItalic",
        "measure3KpiStyleUnderline",
        "measure3KpiStyleColor",
        "measure3TitleStyleSize",
        "measure3TitleFont",
        "measure3TitleStyleBold",
        "measure3TitleStyleItalic",
        "measure3TitleStyleUnderline",
        "measure3TitleStyleColor",
        "measure3TrendSwitch",
        "measure3TrendIcon",
        "measure3",
        "measure3TrendIconColor",
        "measure3TrendFontSize",
        "measure4Fx",
        "measure4Name",
        "measure4Align",
        "measure4KpiStyleSize",
        "measure4KpiFont",
        "measure4KpiStyleBold",
        "measure4KpiStyleItalic",
        "measure4KpiStyleUnderline",
        "measure4KpiStyleColor",
        "measure4TitleStyleSize",
        "measure4TitleFont",
        "measure4TitleStyleBold",
        "measure4TitleStyleItalic",
        "measure4TitleStyleUnderline",
        "measure4TitleStyleColor",
        "measure4TrendSwitch",
        "measure4TrendIcon",
        "measure4",
        "measure4TrendIconColor",
        "measure4TrendFontSize",
        "minichartType",
        "minichartGridhor",
        "minichartGridver",
        "minichartColor1",
        "minichartColor2",
        "qHyperCubeDef",
        "qMeasures",
        "minichartDotSize",
        "step",
        "minichartLineScaleExpand",
        "minichartBarPadding",
        "minichartBarAlignCompare1",
        "minichartBarAlignCompare2",
        "minichartOpacity",
        "minichartRefShow",
        "minichartArea",
        "minichartRefValue",
        "minichartRefStrokeWidth",
        "minichartRefColor",
        "index",
        "minichartFullScreen",
        "horizontalrulerLineSwitch",
        "horizontalrulerLineType",
        "luiIconLink",
        "url",
        "backgroundswitch",
        "backgroundswitchfxpick",
        "backgroundcolor",
        "backgroundcolorfx",
        "default",
        "backgroundcssswitch",
        "backgroundpictureswitch",
        "backgroundpicture",
        "layoutRef",
        "paragraphbackground",
        "customcssswitch",
        "customcsscss",
        "actionsJumpSwitch",
        "actionsJumpDropdown",
        "actions",
        "jump",
        "action",
        "hyperCubeHandler",
        "getSheetList",
        "sheets",
        "map",
        "sheet",
        "qMeta",
        "title",
        "actionsVariableSwitch",
        "variableList",
        "variableListPromise",
        "getPromiseVariable",
        "createGenericObject",
        "qVariableListDef",
        "qType",
        "then",
        "reply",
        "qVariableList",
        "qItems",
        "item",
        "qName",
        "actionsVariableDropdown",
        "variable",
        "actionsVariableSet",
        "actionsBookmarkSwitch",
        "bookmarkList",
        "bookmarkListPromise",
        "getPromiseBookmark",
        "qBookmarkListDef",
        "qBookmarkList",
        "actionsBookmarkDropdown",
        "bookmark",
        "actionsOverlayHeadline",
        "actionsOverlaySubline",
        "sorting",
        "addons",
        "dataHandling",
        "appearance",
        "general",
        "showTitles",
        "details",
        "horizontalruler",
        "customCSS",
        "paragraph",
        "paragraph1",
        "measure_top",
        "measure1KPI",
        "grouped",
        "headermeasure1Kpi",
        "measure1Label",
        "headermeasure1Title",
        "measure1Trend",
        "headermeasure1Trend",
        "measure_left",
        "measure2KPI",
        "headermeasure2Kpi",
        "measure2Label",
        "headermeasure2Title",
        "measure2Trend",
        "headermeasure2Trend",
        "measure_center",
        "measure3KPI",
        "headermeasure3Kpi",
        "measure3Label",
        "headermeasure3Title",
        "measure3Trend",
        "headermeasure3Trend",
        "measure_right",
        "measure4KPI",
        "headermeasure4Kpi",
        "measure4Label",
        "headermeasure4Title",
        "measure4Trend",
        "headermeasure4Trend",
        "actionItems",
        "actionsJump",
        "actionsVariable",
        "actionsBookmark",
        "aboutDefinition",
        "header",
        "style",
        "paragraph2",
        "paragraph3",
        "initialProperties",
        "template",
        "definition",
        "controller",
        "support",
        "snapshot",
        "export",
        "exportData",
        "viewData",
        "paint",
        "closest",
        "remove",
        "scope",
        "isInEdit",
        "interactionState",
        "init",
        "fx",
        "name",
        "ChartOffset",
        "clientHeight",
        "area",
        "fullscreen",
        "KPIPosition",
        "Promise",
        "resolve",
        "hover",
        "on",
        "navigation",
        "gotoSheet",
        "setContent",
        "var",
        "set",
        "apply",
        "qDimensions",
        "qInitialDataFetch",
        "qWidth",
        "qHeight"
    ],
    "mappings": "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,OAAO;AACP,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2EAA2E;AAC3E;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iDAAiD,gBAAgB;;AAEjE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,+BAA+B;AAC5E;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,YAAY;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,2BAA2B,kDAAkD;;AAE7E;AACA,MAAM;AACN,2BAA2B,6BAA6B;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,gCAAgC;AACnD;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,+JAA+J;;AAE/J;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,qBAAqB,4BAA4B;AACjD;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA,uBAAuB,uCAAuC;AAC9D;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;;AAEA,yBAAyB,qBAAqB;AAC9C;AACA;;AAEA;AACA;AACA,aAAa;AACb;;;AAGA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA,OAAO;;;AAGP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,OAAO;AAC3D;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,wBAAwB;AACxB,kBAAkB,kCAAkC;AACpD;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,eAAe,UAAU;AACzB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC,oCAAoC,KAAK,EAAE;AAC/E;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,YAAY,oBAAoB;AAChC,cAAc;AACd;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,gBAAgB;AACjC;AACA;AACA;;AAEA,qBAAqB,sBAAsB;AAC3C,+CAA+C;;AAE/C;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA,kBAAkB;AAClB;;AAEA;AACA;;AAEA;;AAEA,sBAAsB,uBAAuB;AAC7C;AACA;;AAEA,mBAAmB;AACnB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,0DAA0D,IAAI;AAC9D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA,uCAAuC;AACvC,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,+JAA+J;;AAE/J;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,gBAAgB;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAmB;AACpC;AACA,sBAAsB;;AAEtB;;AAEA,mBAAmB,uBAAuB;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,qBAAqB;AACtC;AACA;;AAEA,mBAAmB,gBAAgB;AACnC;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC;;AAEtC,4CAA4C;;AAE5C,0CAA0C;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,aAAa;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,8DAA8D,qBAAqB;AACnF;AACA,yDAAyD;AACzD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sEAAsE;AACtE;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA,6BAA6B;;AAE7B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,EAAE;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA,OAAO;;;AAGP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,kBAAkB,YAAY,EAAE;AAChC;;AAEA;AACA;AACA,eAAe,oBAAoB,2BAA2B,qBAAqB,0BAA0B,gOAAgO,6VAA6V,0BAA0B,eAAe,0BAA0B,0DAA0D,4CAA4C,IAAI,+CAA+C,QAAQ,0FAA0F;AACx+B,CAAC;;AAED;AACA,8BAA8B;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AACD;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,gBAAgB;AAC7B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,0CAA0C,EAAE;AAC5C,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,sDAAsD;AACtD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,0GAA0G;;AAE1G,8BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA,6BAA6B,uBAAuB,SAAS;AAC7D,gCAAgC;AAChC,gCAAgC;AAChC;AACA,mCAAmC;AACnC,iCAAiC;AACjC;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oCAAoC;;AAEpC;AACA,sDAAsD;AACtD,WAAW;AACX;AACA;AACA,wDAAwD;AACxD,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA,uBAAuB,UAAU;AACjC;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA,iFAAiF;;AAEjF;AACA,oHAAoH;;AAEpH,wCAAwC,aAAa;AACrD;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;AACA,qEAAqE,aAAa;AAClF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,eAAe;;AAEf;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,UAAU;AACxB;;AAEA;AACA;AACA;AACA;AACA,IAAI;;;AAGJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,OAAO;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,OAAO;AAChC;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,KAAK;AACL,OAAO,IAAI,GAAG,IAAI;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wCAAwC;AACxC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;;;AAGP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;AACA,qEAAqE,aAAa;AAClF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,KAAK;AACnB,cAAc,OAAO;AACrB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,KAAK;AACpB,eAAe,OAAO;AACtB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,UAAU;AACxB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mFAAmF;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,+EAA+E;AAC/E;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL,gFAAgF;AAChF;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL,+EAA+E;AAC/E;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA,GAAG;AACH;;AAEA;AACA;;AAEA,mFAAmF;AACnF;AACA;AACA;AACA,0CAA0C;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH,2JAA2J;AAC3J;AACA;AACA,GAAG;;AAEH,2JAA2J;AAC3J;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK,kBAAkB;AACvB;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;;AAGF;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4EAA4E;;AAE5E;AACA,GAAG;AACH,0EAA0E;;AAE1E;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA2C;;AAE3C,mDAAmD;AACnD;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA,SAAS,cAAc;;AAEvB;AACA;AACA,SAAS;AACT,OAAO;;;AAGP;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,SAAS;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA,eAAe;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,iBAAiB;AACjB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,iBAAiB;AACjB;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA,eAAe;AACf;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;;AAEjC;;AAEe,yEAAU,EAAC;AAC1B;;;;;;;;;;;;;;ACvyGA;AAAA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;;;AAGA;AACA;AACA,8BAA8B;;AAE9B;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B;;AAE7B;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;;AAEA,wEAAwE;AACxE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iDAAiD,gBAAgB;AACjE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,qBAAqB;AACxC;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA,oBAAoB;;AAEpB,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA;AACA;AACA,wCAAwC;;AAExC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA;;AAEA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B;;AAE9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B;;AAE9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC,SAAS,sBAAsB;;AAEtE;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uEAAuE,aAAa;AACpF;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,YAAY;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,2BAA2B,kDAAkD;;AAE7E;AACA,MAAM;AACN,2BAA2B,6BAA6B;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,sBAAsB;AACvC;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2EAA2E;AAC3E;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iDAAiD,gBAAgB;;AAEjE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,+BAA+B;AAC5E;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;;;AAGhE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,cAAc;AAC/B;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,GAAG;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,cAAc;AAC7B,iBAAiB,mBAAmB;AACpC;AACA;AACA,qCAAqC,0BAA0B;AAC/D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F;;AAE1F,4FAA4F;;AAE5F,mEAAmE;;AAEnE,qEAAqE;;AAErE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa,QAAQ;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa,QAAQ;AACrB;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,aAAa,OAAO;AACpB;;AAEA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,EAAE;;AAEP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B;AAC/B,8BAA8B;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,OAAO;AACpB;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,iBAAiB,oBAAoB;AACrC;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,EAAE;;AAEL,iBAAiB,6BAA6B;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iDAAiD;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;;AAEX;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;;AAElB,iBAAiB,uBAAuB;AACxC;AACA,4BAA4B;;AAE5B;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,gBAAgB,8BAA8B,EAAE;AAC9D;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,6BAA6B;;AAE7B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,IAAI,EAAE;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe;AACf;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,IAAI;AAClB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,8BAA8B,sEAAsE;AACpG,8BAA8B;AAC9B,0CAA0C;AAC1C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA,uDAAuD,qCAAqC,EAAE;AAC9F,sDAAsD,+BAA+B,EAAE;;AAEvF;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,8CAA8C;AAC9C,uDAAuD;AACvD;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,8BAA8B,sEAAsE;AACpG,8BAA8B;AAC9B,8BAA8B,oFAAoF;AAClH,iCAAiC;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,uDAAuD;AACvD,gDAAgD;AAChD;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,8BAA8B,sEAAsE;AACpG,8BAA8B,4BAA4B;AAC1D,8BAA8B;AAC9B,mCAAmC;AACnC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,uDAAuD;AACvD,6CAA6C;AAC7C;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,sEAAsE;AACpG,8BAA8B;AAC9B,8BAA8B;AAC9B,mCAAmC;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,uDAAuD;AACvD,8DAA8D;AAC9D;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,iDAAiD;AACjD;AACA,8BAA8B,sEAAsE;AACpG,8BAA8B;AAC9B,8BAA8B,0DAA0D;AACxF,gEAAgE;AAChE;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0BAA0B,4BAA4B,EAAE;AACxD,yBAAyB,2BAA2B,EAAE;AACtD,0BAA0B,4BAA4B,EAAE;AACxD,iDAAiD,mDAAmD;AACpG;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB;AACA,aAAa,OAAO;AACpB;AACA,iBAAiB,QAAQ;AACzB;AACA,aAAa,WAAW;AACxB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,8BAA8B,sEAAsE;AACpG,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iEAAiE,OAAO;AACxE;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,OAAO;AACtB,iEAAiE,OAAO;AACxE;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,OAAO;AACtC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gDAAgD,OAAO;AACvD,mBAAmB,OAAO;AAC1B,sBAAsB,OAAO;AAC7B;AACA;AACA;;AAEA;AACA;AACA,mEAAmE,OAAO;AAC1E,4BAA4B,OAAO;AACnC;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0DAA0D,OAAO;AACjE,0BAA0B,OAAO;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,OAAO;AACzC,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qDAAqD,4BAA4B,EAAE;AACnF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qDAAqD,0BAA0B,EAAE;AACjF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,IAAI;AACjB,cAAc,UAAU;AACxB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,IAAI;AACjB;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;;AAE1B;AACA;;AAEA;AACA;AACA;AACA;AACA,+FAA+F;AAC/F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA,sDAAsD;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iDAAiD,OAAO;AACxD;AACA,4BAA4B;AAC5B,qCAAqC,QAAQ;AAC7C,4BAA4B,uBAAuB,QAAQ,EAAE;AAC7D;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF;AACxF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,6BAA6B,EAAE;AACtD,oBAAoB,kCAAkC,EAAE;AACxD,oBAAoB,eAAe,EAAE;AACrC,oBAAoB,mCAAmC,EAAE;AACzD,uBAAuB,2BAA2B,EAAE;AACpD,uBAAuB,qBAAqB,EAAE;AAC9C,uBAAuB,yBAAyB,EAAE;AAClD,oBAAoB,kCAAkC,EAAE;AACxD,uBAAuB,kCAAkC,EAAE;AAC3D;AACA;AACA,oBAAoB,iDAAiD,EAAE;AACvE,oBAAoB,mCAAmC;AACvD;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sEAAsE;AACtE,sEAAsE;AACtE,qIAAqI;AACrI,qEAAqE;AACrE;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,UAAU;AACzB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,mDAAmD;AACnD,SAAS;AACT,mDAAmD;AACnD;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8BAA8B;AAC3D,6BAA6B,0CAA0C,EAAE;AACzE;AACA;;AAEA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;;AAED;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;;AAED;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;;AAED;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;;AAED;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;;AAED;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA,KAAK;AACL;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA,KAAK;AACL;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA,KAAK;AACL;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;;AAEA,YAAY,4BAA4B;AACxC;AACA;AACA,kCAAkC;;AAElC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,cAAc,KAAK;AACnB,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,KAAK;AACpB,eAAe,OAAO;AACtB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,UAAU;AACxB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,KAAK;AACnB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;;AAEA;AACA,mFAAmF;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,uBAAuB;AACxC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG,2BAA2B;;AAE9B;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA,mCAAmC;AACnC,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE,wBAAwB;AACrC;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B;AAC/B,8CAA8C;AAC9C;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,yEAAyE,8CAA8C;AACvH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+DAA+D,qBAAqB,EAAE;;AAEtF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,0DAA0D,gBAAgB,EAAE;;AAE5E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,gBAAgB;;AAEhB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,yBAAyB,EAAE;AACzE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,EAAE;AAC5B,0BAA0B,EAAE;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,QAAQ;AACrB,QAAQ,QAAQ;;AAEhB;AACA,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ,YAAY;AACZ;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,2BAA2B;AAC3B;AACA;AACA,wCAAwC;AACxC,2BAA2B;AAC3B;AACA,KAAK,OAAO;AACZ;AACA,cAAc,mCAAmC;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,oBAAoB;AACzC;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,oCAAoC;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+FAA+F;AAC/F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,0DAA0D;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iDAAiD,OAAO;AACxD;AACA,4BAA4B;AAC5B,qCAAqC,QAAQ;AAC7C,4BAA4B,uBAAuB,QAAQ,EAAE;AAC7D;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F;AAC1F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,6BAA6B,EAAE;AACtD,oBAAoB,kCAAkC,EAAE;AACxD,oBAAoB,eAAe,EAAE;AACrC,oBAAoB,mCAAmC,EAAE;AACzD,uBAAuB,2BAA2B,EAAE;AACpD,uBAAuB,qBAAqB,EAAE;AAC9C,uBAAuB,yBAAyB,EAAE;AAClD,oBAAoB,kCAAkC,EAAE;AACxD,uBAAuB,oCAAoC,EAAE;AAC7D;AACA;AACA,oBAAoB,iDAAiD,EAAE;AACvE,oBAAoB,mCAAmC;AACvD;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sEAAsE;AACtE,sEAAsE;AACtE,qIAAqI;AACrI,qEAAqE;AACrE;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,YAAY;AAC7B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,iBAAiB,uBAAuB;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;;AAE/C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH,6BAA6B;AAC7B;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH,6BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,kBAAkB;AAChC,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,UAAU;AACrB,YAAY;AACZ;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,cAAc;AACd;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN,aAAa,SAAS;AACtB,cAAc,SAAS;AACvB;;;AAGA;AACA;AACA;AACA;AACA,MAAM;AACN,aAAa,WAAW;AACxB,cAAc,SAAS;AACvB;;;AAGA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,aAAa,UAAU;AACvB,cAAc,SAAS;AACvB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;;AAGA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;;AAGA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,aAAa,SAAS;AACtB,cAAc,oBAAoB;AAClC;;;AAGA;AACA;AACA,4CAA4C;;AAE5C,sCAAsC;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN,aAAa,SAAS;AACtB,cAAc,SAAS;AACvB;;;AAGA;AACA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB,cAAc,oBAAoB;AAClC;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,WAAW;AACxB,cAAc,oBAAoB;AAClC;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;;;AAGA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;;AAGA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;;AAGA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;;AAGA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,eAAe;AACf;;;AAGA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA,mBAAmB;AACnB,cAAc;AACd;AACA;AACA,mBAAmB;AACnB;;;AAGA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA,2BAA2B;AAC3B,wBAAwB;AACxB;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO,cAAc;AACnC,cAAc,OAAO,mBAAmB;AACxC,cAAc,OAAO,mBAAmB;AACxC,cAAc,OAAO,YAAY;AACjC,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,uBAAuB;AACrC;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,WAAW;AACtB,WAAW,UAAU;AACrB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,aAAa,SAAS;AACtB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;;AAGA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,cAAc;AACd;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C;;AAE3C;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA,cAAc,OAAO,wBAAwB;AAC7C,cAAc,QAAQ,6BAA6B;AACnD,cAAc,SAAS,6BAA6B;AACpD,cAAc,OAAO,wBAAwB;AAC7C,cAAc,QAAQ;AACtB;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,WAAW;AACtB,WAAW,UAAU;AACrB,YAAY;AACZ;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB,cAAc;AACd;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd,aAAa,WAAW;AACxB,cAAc;AACd;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd,aAAa,WAAW;AACxB,cAAc;AACd;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;;AAGA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB,cAAc,SAAS;AACvB;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,WAAW;AACzB;;;AAGA;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW;AACzB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,WAAW;AACxB;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ,IAAI,+BAA+B;AACnC,IAAI,gCAAgC;AACpC,MAAM;AACN;AACA,WAAW,kBAAkB;AAC7B,IAAI,gCAAgC;AACpC,MAAM;AACN;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,WAAW;AACtB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,cAAc,SAAS;AACvB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,uBAAuB;AACxC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;;AAGH;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,WAAW;AACtB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,UAAU;AACrB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,cAAc;AACd,aAAa;AACb;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,cAAc,SAAS;AACvB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB;AACnB;AACA;AACA,aAAa;AACb,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB,cAAc,OAAO,cAAc;AACnC,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,wFAAwF;;AAExF;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;;AAEA;AACA,sBAAsB,4BAA4B;AAClD;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;;;AAGL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,eAAe,SAAS;AACxB;;AAEA;AACA;AACA,eAAe,SAAS;AACxB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;;AAGP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB;;AAEA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,4BAA4B;AAC1C;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY,SAAS;AACrB;;AAEA;AACA;AACA,YAAY,SAAS;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,SAAS;AAC9C;;AAEA;AACA;AACA;;AAEA;;AAEA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,sCAAsC,WAAW;AACjD;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,SAAS;AAC9C;;AAEA;AACA;AACA;;AAEA;;AAEA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,wCAAwC,aAAa;AACrD;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qCAAqC,SAAS;AAC9C;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,oBAAoB;AACxC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC,SAAS;AAChD;AACA;;AAEA,oCAAoC,SAAS;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,6CAA6C,aAAa;AAC1D;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA,+CAA+C,aAAa;AAC5D;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oCAAoC,SAAS;AAC7C;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA,0CAA0C,aAAa;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,SAAS;AAC1B,gDAAgD;AAChD;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA,qBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,oFAAoF;AACpF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA,YAAY;AACZ,aAAa,cAAc;AAC3B,aAAa,cAAc;AAC3B;;AAEA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA,cAAc,aAAa;AAC3B;AACA;AACA;AACA,WAAW,qCAAqC;AAChD,WAAW,qCAAqC;AAChD;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA,mBAAmB;AACnB,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;;AAET;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO,EAAE;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,qCAAqC;;AAErC;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,aAAa,SAAS;AACtB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,cAAc;AAC5B;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,aAAa,SAAS;AACtB;;;AAGA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,cAAc;AAC5B;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,aAAa,SAAS;AACtB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,cAAc;AAC5B,cAAc;AACd;AACA;AACA,gDAAgD;AAChD,8CAA8C;AAC9C,gDAAgD;AAChD;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,8BAA8B,mBAAmB;AACjD;;;AAGA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,WAAW;AACX,aAAa,SAAS;AACtB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;;;AAGA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,WAAW;AACX,aAAa,SAAS;AACtB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;;;AAGA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,WAAW;AACX,aAAa,SAAS;AACtB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;;;AAGA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,WAAW;AACX,aAAa,SAAS;AACtB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc;AACd;AACA,8BAA8B,mBAAmB;AACjD,2CAA2C;AAC3C,0CAA0C;AAC1C;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc;AACd;AACA,8BAA8B,mBAAmB;AACjD,mCAAmC,mBAAmB,EAAE;AACxD,mCAAmC,kBAAkB,EAAE;AACvD,mCAAmC,mBAAmB,EAAE;AACxD;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC,SAAS;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT,OAAO;;;AAGP;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA,MAAM;AACN;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA,8CAA8C;AAC9C,6CAA6C;AAC7C,mDAAmD;AACnD;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,sCAAsC,6BAA6B;AACnE,mCAAmC,qBAAqB;;AAExD;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA,WAAW;AACX;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;;;AAGP;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,sFAAsF;AACtF;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,eAAe;AAC7B,cAAc,OAAO;AACrB;;AAEA;AACA,aAAa,mCAAmC;AAChD;;AAEA;AACA,aAAa,mCAAmC;AAChD;;AAEA;AACA,aAAa,oCAAoC;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,IAAI;AACf,WAAW,IAAI;AACf,WAAW,IAAI;AACf,aAAa;AACb;;;AAGA;AACA,6BAA6B;AAC7B,sBAAsB;AACtB;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA,qHAAqH;;AAErH;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;;AAEA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,+BAA+B;;AAE/B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,4CAA4C;AAC5C,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C;;AAE1C;AACA;AACA;AACA,OAAO;AACP;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,iBAAiB,uBAAuB;AACxC;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,4DAA4D;AAC5D;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,mBAAmB;AACpC;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA,kCAAkC;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,WAAW,qJAAqJ;AAChK,aAAa,OAAO;AACpB;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;;;AAGH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG,EAAE;;AAEL;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,wGAAwG,aAAa;;AAErH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA,iGAAiG;;AAEjG;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA,2FAA2F,aAAa;AACxG;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;;AAEA,iCAAiC;;AAEjC;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,UAAU;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4EAA4E,eAAe;AAC3F;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;;;AAGJ;AACA;;AAEA;AACA;AACA,iCAAiC;AACjC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA,8CAA8C;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,+HAA+H;;AAE/H;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI;;;AAGJ;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP,uBAAuB,uBAAuB;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;;AAEA,wCAAwC,SAAS;AACjD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;;AAEA,wCAAwC,SAAS;AACjD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,MAAM;AACnB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,MAAM;AACnB,aAAa,MAAM;AACnB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,iBAAiB,SAAS;AAC1B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,MAAM;AACnB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,MAAM;AACnB,aAAa,MAAM;AACnB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,aAAa;AAC9B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,MAAM;AACnB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,MAAM;AACnB,aAAa,MAAM;AACnB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;;AAEA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C,SAAS;AACtD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,MAAM;AACnB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,MAAM;AACnB,aAAa,MAAM;AACnB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;;AAEA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C,SAAS;AACtD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4BAA4B;AAC5B;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B;AAC9B;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,aAAa,OAAO;AACpB;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI,EAAE,KAAK,SAAS,wCAAwC;AAC5D;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,8BAA8B;;AAE9B,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,cAAc;AAC5B,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,UAAU,+BAA+B;AACvD,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA;AACA;AACA;AACA;AACA,kCAAkC;;AAElC;AACA;AACA;AACA;AACA;;AAEA;AACA,uDAAuD,SAAS;AAChE;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,8BAA8B;;AAE9B,kBAAkB;;AAElB;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B;AACA,6BAA6B;;AAE7B;AACA,2BAA2B;;AAE3B,+BAA+B;;AAE/B,+BAA+B;;AAE/B;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;;AAEA,yEAAyE,aAAa;AACtF;AACA;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,8BAA8B;AACjD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,8BAA8B;AACjD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qFAAqF;AACrF;;AAEA;AACA,yDAAyD;AACzD;AACA,iDAAiD;AACjD;AACA,iDAAiD;AACjD;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,mBAAmB;AACxB;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK,mBAAmB;AACxB;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;;AAEnC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oCAAoC,QAAQ;AAC5C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oCAAoC,QAAQ;AAC5C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C;;AAE1C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA,8CAA8C,QAAQ;AACtD;AACA,KAAK;;;AAGL;AACA,kDAAkD;;AAElD;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;;AAGP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA,iCAAiC;;;AAGjC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK,EAAE;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,cAAc;AAC3B,aAAa,OAAO;AACpB,cAAc,cAAc;AAC5B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,eAAe,yBAAyB;AACxC;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,uBAAuB;AACpC,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,WAAW,mCAAmC;AAC9C,WAAW;AACX;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,kCAAkC;;AAElC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB,aAAa,OAAO;AACpB,aAAa,cAAc;AAC3B,aAAa,OAAO;AACpB,aAAa,cAAc;AAC3B,aAAa,cAAc;AAC3B,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;;AAEA,mBAAmB,8BAA8B;AACjD;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe;AACf;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe;AACf;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;;AAGA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;;AAGA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe;AACf;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B,eAAe;AACf;AACA,qCAAqC;AACrC,qBAAqB,yBAAyB,EAAE;AAChD,qBAAqB,gCAAgC,EAAE;AACvD;;;AAGA;AACA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B,eAAe;AACf;AACA,6CAA6C;AAC7C,yBAAyB,iCAAiC,EAAE;AAC5D,yBAAyB,YAAY,EAAE;AACvC;AACA;AACA;AACA;AACA,MAAM,EAAE;AACR;;;AAGA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,kBAAkB;AACjC;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,kCAAkC;AAClC,6BAA6B;AAC7B,8BAA8B;AAC9B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;;AAGH,iBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA,GAAG;;;AAGH,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,iBAAiB;AACzC,MAAM,WAAW;AACjB,MAAM,6BAA6B;AACnC,MAAM,kCAAkC;AACxC,MAAM;AACN,CAAC;AACD;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;;AAEA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sFAAsF;AACtF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA,6CAA6C;;AAE7C;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,+JAA+J;;AAE/J;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,EAAE;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW,EAAE;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA,yBAAyB,oBAAoB;AAC7C;;AAEA;AACA,SAAS;;;AAGT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;;AAEA,iBAAiB,oBAAoB;AACrC;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA,KAAK;AACL,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,gCAAgC;;AAEhC,mBAAmB,oBAAoB;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,YAAY;AACZ;;;AAGA;AACA,oFAAoF;AACpF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,oBAAoB;AACnC,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;;AAEL;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,4BAA4B;AAC1C,cAAc,4BAA4B;AAC1C,cAAc,8BAA8B;AAC5C,cAAc,6BAA6B;AAC3C,cAAc,kCAAkC;AAChD,cAAc,6BAA6B;AAC3C,cAAc,OAAO;AACrB;;AAEA;AACA;AACA,WAAW,IAAI;AACf,aAAa;AACb;;AAEA;AACA;AACA,WAAW,IAAI;AACf,aAAa;AACb;;AAEA;AACA;AACA,WAAW,IAAI;AACf,aAAa;AACb;;AAEA;AACA;AACA,WAAW,IAAI;AACf,aAAa;AACb;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,aAAa;AACb;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,IAAI;AACf,aAAa;AACb;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,IAAI;AAClB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA;AACA;AACA;AACA,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,iBAAiB;AAChC;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,yBAAyB;AAClD;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA,kBAAkB;AAClB;AACA,GAAG,wQAAwQ;AAC3Q;AACA,GAAG;AACH;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA,GAAG,yRAAyR;AAC5R;AACA,GAAG;AACH;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG,2BAA2B,6hBAA6hB;AAC3jB;AACA,GAAG;AACH;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,mBAAmB;AACtC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA,yBAAyB;AACzB;AACA;AACA,KAAK;;AAEL,mBAAmB,aAAa;AAChC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB,aAAa;AACpE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,6BAA6B;AAC7B,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,UAAU;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,oBAAoB;AAClC,cAAc,wBAAwB;AACtC;AACA;AACA;AACA;AACA;AACA,cAAc,uCAAuC;AACrD,gBAAgB,uCAAuC;AACvD,cAAc,uCAAuC;AACrD,cAAc,uCAAuC;AACrD,cAAc,uCAAuC;AACrD,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,gBAAgB;AAChB,OAAO;AACP;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,8CAA8C;AAC5D,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;;AAEA;AACA,YAAY,cAAc;AAC1B;;AAEA;AACA,YAAY,cAAc;AAC1B;;AAEA;AACA,YAAY,cAAc;AAC1B;;AAEA;AACA,YAAY,QAAQ;AACpB;;AAEA;AACA,YAAY,cAAc;AAC1B;;AAEA;AACA,YAAY,cAAc;AAC1B;;AAEA;AACA,YAAY,cAAc;AAC1B;;AAEA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB;;AAEA;AACA,YAAY,QAAQ;AACpB;;AAEA;AACA,YAAY,QAAQ;AACpB;;AAEA;AACA,YAAY,QAAQ;AACpB;;AAEA;AACA,YAAY,QAAQ;AACpB;;AAEA;AACA,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,gBAAgB;AAChB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,iDAAiD;AACjD;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB;;AAEA;AACA,YAAY,QAAQ;AACpB;;AAEA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA,cAAc,QAAQ;AACtB;;AAEA;AACA,cAAc,SAAS;AACvB;;AAEA;AACA,cAAc,QAAQ;AACtB;;AAEA;AACA,cAAc,QAAQ;AACtB;;AAEA;AACA,cAAc,QAAQ;AACtB;;AAEA;AACA,cAAc,QAAQ;AACtB;;AAEA;AACA,cAAc,QAAQ;AACtB;;AAEA;AACA,cAAc,QAAQ;AACtB;;AAEA;AACA,cAAc,QAAQ;AACtB;;AAEA;AACA,cAAc,QAAQ;AACtB;;AAEA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB;AACzB;AACA,KAAK;AACL;;AAEA;;AAEA,uCAAuC,SAAS;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,UAAU;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB,cAAc,UAAU;AACxB;;;AAGA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,mDAAmD,WAAW;AAC9D;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;;AAEA,GAAG;AACH;AACA;AACA;;AAEA,8CAA8C,OAAO;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;AACA,uEAAuE,cAAc;AACrF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,iDAAiD;;AAEjD;AACA;AACA;;AAEA;AACA;AACA,KAAK,6CAA6C;AAClD;AACA;AACA,KAAK,uDAAuD,EAAE;;AAE9D;AACA;AACA;AACA,MAAM;;AAEN;AACA,qDAAqD;AACrD;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC,SAAS;AAChD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mCAAmC,EAAE;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;;AAEH;AACA,iFAAiF;AACjF;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;;AAGL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oCAAoC;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;;AAGP,yCAAyC,SAAS;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;AAGA,mBAAmB;;AAEnB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA,cAAc,sBAAsB;AACpC,cAAc,OAAO;AACrB,cAAc,aAAa;AAC3B,cAAc,aAAa;AAC3B;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,kBAAkB;AAChC,cAAc,aAAa;AAC3B,cAAc,mBAAmB;AACjC;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,qBAAqB;AACnC,cAAc,uBAAuB;AACrC,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,MAAM;AACpB,cAAc,uBAAuB;AACrC,cAAc,mBAAmB;AACjC;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,cAAc;AAC5B,cAAc,cAAc;AAC5B,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,8BAA8B;AAC5C;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;;AAGA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA,iCAAiC;;AAEjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,OAAO;AACP,KAAK,EAAE;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK,EAAE;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL,mBAAmB;;AAEnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK,EAAE;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,2FAA2F;;AAE3F;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,mFAAmF;;AAEnF;AACA;AACA;AACA,8EAA8E;;AAE9E;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL,GAAG,EAAE;AACL;;AAEA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH,iBAAiB,uBAAuB;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oGAAoG;;AAEpG,0CAA0C;;AAE1C;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,gCAAgC;;AAEhC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,0DAA0D;;AAE1D;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,0EAA0E;;AAE1E;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA,qBAAqB,mCAAmC;AACxD;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,2EAA2E;;;AAG3E;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,wBAAwB;AACzC,uBAAuB,+CAA+C;AACtE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;;;AAGP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oCAAoC;AACpC;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa,SAAS;AACtB;;AAEA;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,GAAG;;AAEH;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa,SAAS;AACtB;;AAEA;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA,GAAG;;AAEH;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA,GAAG;;AAEH;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa,SAAS;AACtB;;AAEA;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,GAAG;;AAEH;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa,SAAS;AACtB;;AAEA;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA,GAAG;;AAEH;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa,SAAS;AACtB;;AAEA;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA,GAAG;;AAEH;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA,GAAG;;AAEH;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc;AACd;AACA;AACA;AACA,WAAW,OAAO;AAClB;;;AAGA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,mDAAmD;;AAEnD;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,gBAAgB;AAC9B,cAAc,yBAAyB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA,yEAAyE;;AAEzE;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG,WAAW;;AAEd;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;;AAGN;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wEAAwE;;AAExE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG,IAAI;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B,mCAAmC;;AAEnC;AACA,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG,IAAI;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAmB;AACpC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,cAAc;AAC5B,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;;AAGL;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,MAAM;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;;AAGA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,aAAa,OAAO;AACpB;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB;;;AAGA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,6BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,4CAA4C;;AAE5C;AACA;AACA,KAAK;;;AAGL;;AAEA,gCAAgC,yBAAyB;AACzD;AACA;AACA;AACA,KAAK;;;AAGL;AACA;;AAEA,gCAAgC,yBAAyB;AACzD,sCAAsC;;AAEtC;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;;AAEA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2CAA2C;AAC3C;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,8BAA8B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,yBAAyB;AAC5C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;;AAEA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,gBAAgB;AAC9B,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,cAAc;AAC5B,cAAc,gBAAgB;AAC9B,cAAc,SAAS;AACvB,cAAc,cAAc;AAC5B,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,gBAAgB;AAC9B,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,oBAAoB;AACpB,GAAG;AACH;AACA;AACA,sBAAsB;AACtB,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA,mCAAmC;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG,EAAE;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,8BAA8B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,gBAAgB;AAC9B,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,cAAc;AAC5B,cAAc,gBAAgB;AAC9B,cAAc,SAAS;AACvB,cAAc,cAAc;AAC5B,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,oBAAoB;AACpB,GAAG;AACH;AACA;AACA,sBAAsB;AACtB,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,SAAS;AAC9C;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mFAAmF;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,iBAAiB,OAAO;AACxB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB;AACxB;AACA,2BAA2B;;AAE3B,yBAAyB;;AAEzB;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,yBAAyB;;AAEzB;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,6CAA6C;;AAE7C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,IAAI,EAAE,aAAa;AACnB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,kFAAkF;;AAElF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,YAAY,OAAO;AACnB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,4BAA4B;AAC5B;AACA;;AAEA,0DAA0D,SAAS;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,cAAc;AAC5B,cAAc,gBAAgB;AAC9B,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB,cAAc,gBAAgB;AAC9B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,6BAA6B;AAC7B;AACA,oBAAoB;AACpB,GAAG;AACH;AACA;;AAEA,qCAAqC,SAAS;AAC9C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA,eAAe,gBAAgB;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,cAAc;AAC5B,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,iCAAiC;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc,QAAQ;AACtB;AACA,GAAG;;AAEH;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,QAAQ;AACxB;;AAEA;AACA,gBAAgB,QAAQ;AACxB;;AAEA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA,KAAK;;AAEL;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA,gBAAgB,QAAQ;AACxB;;AAEA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA,GAAG;;AAEH;AACA,eAAe,QAAQ;AACvB;AACA;AACA,cAAc,SAAS;AACvB;;AAEA;AACA,cAAc,QAAQ;AACtB;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,QAAQ;AACtB;;AAEA;AACA,cAAc,QAAQ;AACtB;;AAEA;AACA,cAAc,QAAQ;AACtB;AACA;AACA,GAAG;;AAEH;AACA,eAAe,QAAQ;AACvB;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA,gBAAgB,yBAAyB;AACzC;;AAEA;AACA,gBAAgB,SAAS;AACzB;AACA,KAAK;;AAEL;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,8CAA8C;AAC9C;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL,6BAA6B;AAC7B;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,6BAA6B;AAC7B,gDAAgD;AAChD,GAAG;AACH,qCAAqC,oCAAoC;;AAEzE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B;AAC7B;AACA,GAAG;AACH;AACA;AACA,6BAA6B;AAC7B;AACA,KAAK;AACL;AACA,8CAA8C;AAC9C;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wFAAwF;;AAExF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,wBAAwB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,yBAAyB;;AAEzB,mBAAmB;AACnB,OAAO;AACP,uBAAuB;;AAEvB,mBAAmB;AACnB;AACA,KAAK;AACL,qBAAqB;AACrB,KAAK;AACL,uBAAuB;AACvB;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,wBAAwB;AACzC;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F;AAC9F,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,8DAA8D;;AAE9D;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB;AACnB;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,oFAAoF;AACpF,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,sBAAsB;AACtB,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,iBAAiB;;AAEjB;AACA,iBAAiB;;AAEjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,kCAAkC;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB;AACvB;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,4CAA4C;;AAE5C,mCAAmC;;AAEnC;AACA,yBAAyB;;AAEzB;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA,wCAAwC;;AAExC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,qBAAqB;AAChC;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,cAAc,OAAO;AACrB;;AAEA;AACA,cAAc,OAAO;AACrB;;AAEA;AACA,cAAc,QAAQ;AACtB;AACA,GAAG;;AAEH;AACA,YAAY,SAAS;AACrB;;AAEA;AACA,YAAY,QAAQ;AACpB;;AAEA;AACA,eAAe,OAAO;AACtB;AACA;AACA,cAAc,QAAQ;AACtB;;AAEA;AACA,cAAc,SAAS;AACvB;;AAEA;AACA,cAAc,2BAA2B;AACzC;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA,gBAAgB,QAAQ;AACxB;;AAEA;AACA,gBAAgB,QAAQ;AACxB;;AAEA;AACA,gBAAgB,QAAQ;AACxB;;AAEA;AACA,gBAAgB,QAAQ;AACxB;;AAEA;AACA,gBAAgB,QAAQ;AACxB;;AAEA;AACA,gBAAgB,SAAS;AACzB;AACA,KAAK;;AAEL;AACA,iBAAiB,OAAO;AACxB;AACA;AACA,gBAAgB,QAAQ;AACxB;;AAEA;AACA,gBAAgB,QAAQ;AACxB;;AAEA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC,6BAA6B;AAC7B,6BAA6B;AAC7B;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,wFAAwF;;AAExF;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA,OAAO,WAAW;;AAElB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,GAAG,EAAE;AACL;AACA;AACA;AACA;;AAEA,gKAAgK;;AAEhK;AACA;;AAEA,iBAAiB,8BAA8B;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,uBAAuB;AACvB;AACA,GAAG;AACH;AACA;AACA,uBAAuB;AACvB;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,wBAAwB;AAC3C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,OAAO;AACP,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa;AACb;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,SAAS;AACtB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB;;;AAGA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa;AACb;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH,8BAA8B;AAC9B;AACA;AACA,0CAA0C;;AAE1C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL,oBAAoB;AACpB,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA,MAAM;;;AAGN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,sBAAsB;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;;AAE1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;;AAEnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;;AAEjD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe;;AAEf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA,YAAY;AACZ,eAAe,OAAO;AACtB;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,YAAY;AACZ,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA,YAAY;AACZ,eAAe;AACf;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,GAAG;;AAEH;AACA;AACA,WAAW;AACX;AACA,kBAAkB;;AAElB;AACA;AACA,WAAW;AACX;AACA,kBAAkB;;AAElB;AACA;AACA,WAAW;AACX;AACA,gBAAgB;;AAEhB;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA,sFAAsF;AACtF;AACA;AACA;;AAEA;AACA;AACA,KAAK;;;AAGL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,kCAAkC;;AAElC;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA,cAAc;AACd,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,KAAK,EAAE;;AAEP;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH,8BAA8B;AAC9B;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;;AAEtC;AACA;AACA;AACA;AACA;AACA,kCAAkC;;AAElC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC;;AAEjC;AACA;AACA;AACA,kCAAkC;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,QAAQ;AACrB;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;;AAEvB,uBAAuB;;AAEvB,iCAAiC;;AAEjC,iCAAiC;;AAEjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,QAAQ;AACrB;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,iBAAiB,uBAAuB;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;;;AAGA;AACA;AACA,4BAA4B;;AAE5B,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF;;AAEpF;AACA;;AAEA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA,gCAAgC;;AAEhC;AACA;AACA;AACA,KAAK;AACL,GAAG,iBAAiB,eAAe;;;AAGnC;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,eAAe;AAC5B;;;AAGA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA,iBAAiB;;AAEjB;AACA,kBAAkB;;AAElB;;AAEA,iBAAiB,qBAAqB;AACtC;AACA,0BAA0B;;AAE1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,yBAAyB;;AAEzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,qBAAqB;;AAErB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,yBAAyB;;AAEzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,qBAAqB;;AAErB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,sBAAsB;;AAEtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,0BAA0B;;AAE1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,KAAK,EAAE;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH,8BAA8B;AAC9B;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA,GAAG;AACH;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;;AAGP,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,SAAS;AAC/B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,wFAAwF;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;AACA,qEAAqE,aAAa;AAClF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,wFAAwF;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;AACA,qEAAqE,aAAa;AAClF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,wFAAwF;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;AACA,qEAAqE,aAAa;AAClF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,yBAAyB;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,qFAAqF;AACrF;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;;;AAGA;AACA;AACA;AACA,wFAAwF;AACxF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,0BAA0B;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,8CAA8C,SAAS;AACvD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;AACD;AACA;AACA,UAAU,OAAO;AACjB,UAAU,QAAQ;AAClB,YAAY,WAAW;AACvB;AACA;;;AAGA;AACA,kEAAkE,aAAa;AAC/E;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,qFAAqF;AACrF;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,wFAAwF;AACxF;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sDAAsD,SAAS;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;AACA,kEAAkE,aAAa;AAC/E;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,aAAa;AAC3B;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,aAAa;AAC3B;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;AACA,qEAAqE,aAAa;AAClF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA,2CAA2C;AAC3C;;AAEA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;;AAEA,GAAG;AACH;AACA;AACA;AACA;;AAEA,iBAAiB,2BAA2B;AAC5C,mBAAmB,8BAA8B;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B,cAAc,oBAAoB;AAClC;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,2BAA2B;AAC9C;AACA,qBAAqB,8BAA8B;AACnD;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA,mBAAmB,2BAA2B;AAC9C,qBAAqB,8BAA8B;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA,4CAA4C;;AAE5C;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,2BAA2B;AAC5C;AACA,mBAAmB,8BAA8B;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;;AAEA,mBAAmB,2BAA2B;AAC9C;AACA,qBAAqB,8BAA8B;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0CAA0C,SAAS;AACnD;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,4BAA4B;AACjC;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,MAAM;AAChB,YAAY,SAAS;AACrB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,oBAAoB;AAC5C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA,0CAA0C,WAAW;AACrD;AACA;;AAEA,8CAA8C,SAAS;AACvD,qDAAqD,WAAW;AAChE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;AACA,kEAAkE,aAAa;AAC/E;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;AACD;AACA,kEAAkE,aAAa;AAC/E;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,QAAQ;AAC/B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,kDAAkD;AAClD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;;AAEA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,gCAAgC,WAAW;AACzD,cAAc,gCAAgC,aAAa;AAC3D,cAAc,OAAO,kBAAkB;AACvC,cAAc,gBAAgB,sBAAsB;AACpD,cAAc,OAAO,cAAc;AACnC,cAAc,OAAO,gBAAgB;AACrC,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mCAAmC;AACnC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,EAAE;AACnB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,qBAAqB;AAC1C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;;AAGP;AACA;;AAEA;AACA;AACA,OAAO;;;AAGP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;;;AAGP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,KAAK;AACtB;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;AACA;AACA,aAAa,OAAO;AACpB,cAAc,WAAW;AACzB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,qBAAqB,SAAS;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,SAAS;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ,iBAAiB,SAAS;AAC1B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;AACD;AACA,kEAAkE,aAAa;AAC/E;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;AACD;AACA,kEAAkE,aAAa;AAC/E;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB,cAAc,OAAO,kBAAkB;AACvC,cAAc,OAAO,wBAAwB;AAC7C,cAAc,OAAO,mBAAmB;AACxC,cAAc,OAAO;AACrB;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO,OAAO;AAC5B,cAAc,OAAO,OAAO;AAC5B,cAAc,OAAO,OAAO;AAC5B,cAAc,OAAO,OAAO;AAC5B,cAAc,OAAO,WAAW;AAChC,cAAc,OAAO,UAAU;AAC/B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,gDAAgD,WAAW;AAC3D;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ,iBAAiB,SAAS;AAC1B;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;AACD;AACA,kEAAkE,aAAa;AAC/E;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,UAAU;AACxB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAgD;AACxD,QAAQ,gDAAgD;AACxD,QAAQ,gDAAgD;AACxD,QAAQ,gDAAgD;AACxD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,kDAAkD,WAAW;AAC7D;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ,iBAAiB,SAAS;AAC1B;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;AACD;AACA,kEAAkE,aAAa;AAC/E;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO,MAAM;AAC3B,cAAc,OAAO,MAAM;AAC3B,cAAc,OAAO,UAAU;AAC/B,cAAc,OAAO,UAAU;AAC/B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;;AAEH;AACA,CAAC;AACD;AACA,kEAAkE,aAAa;AAC/E;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO,OAAO;AAC5B,cAAc,OAAO,OAAO;AAC5B,cAAc,OAAO,MAAM;AAC3B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,OAAO;;;AAGP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;AACD;AACA,kEAAkE,aAAa;AAC/E;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO,OAAO;AAC5B,cAAc,OAAO,OAAO;AAC5B,cAAc,OAAO,OAAO;AAC5B,cAAc,OAAO,OAAO;AAC5B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;;AAEH;AACA,CAAC;AACD;AACA,kEAAkE,aAAa;AAC/E;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;;AAEA,mBAAmB,cAAc;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO,MAAM;AAC3B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;;AAEH;AACA,CAAC;AACD;AACA,kEAAkE,aAAa;AAC/E;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO,MAAM;AAC3B,cAAc,OAAO,MAAM;AAC3B,cAAc,OAAO,SAAS;AAC9B,cAAc,OAAO,SAAS;AAC9B,cAAc,OAAO,eAAe;AACpC,cAAc,OAAO,iBAAiB;AACtC,cAAc,KAAK;AACnB,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB,cAAc,OAAO,uBAAuB;AAC5C,cAAc,OAAO;AACrB,cAAc,OAAO,iBAAiB;AACtC,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;;AAEH;AACA,CAAC;AACD;AACA,kEAAkE,aAAa;AAC/E;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,SAAS;AACrB;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO,SAAS;AAC9B,cAAc,OAAO;AACrB;;;AAGA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB,mBAAmB,sBAAsB;AACzC;;AAEA;AACA;AACA;AACA,KAAK;;;AAGL,sBAAsB;;AAEtB,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA,cAAc,UAAU;AACxB;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,yCAAyC,SAAS;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,SAAS;AAC9C;AACA;AACA;;AAEA;AACA;AACA,KAAK;;;AAGL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kCAAkC;;AAElC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA,qCAAqC,SAAS;AAC9C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA;AACA;AACA;AACA,WAAW,uBAAuB;AAClC,aAAa,uBAAuB;AACpC;AACA;AACA,mFAAmF;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,kCAAkC;;AAElC;AACA;AACA,iBAAiB;AACjB;AACA,4BAA4B;;AAE5B;AACA,cAAc,YAAY;AAC1B,gBAAgB,YAAY;AAC5B;AACA,oCAAoC;;AAEpC;AACA,eAAe,WAAW;AAC1B,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,+BAA+B;AAC9C,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA,8BAA8B;;AAE9B;AACA;AACA;AACA,kCAAkC;;AAElC;AACA;AACA,eAAe,uBAAuB;AACtC,iBAAiB,uBAAuB;AACxC;AACA,4BAA4B;;AAE5B;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO,kBAAkB;AACxC,eAAe,OAAO,oBAAoB;AAC1C,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA,QAAQ,EAAE,aAAa;AACvB;AACA;;AAEA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA,8CAA8C,WAAW;AACzD;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wMAAwM;;AAExM;AACA;AACA,kDAAkD;AAClD,uCAAuC;AACvC,uCAAuC;;AAEvC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,aAAa,OAAO;AACpB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2DAA2D,cAAc,eAAe,aAAa;;AAErG;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;;AAEA,kCAAkC,SAAS;AAC3C;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,sCAAsC,WAAW;AACjD;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,yCAAyC,aAAa;AACtD;AACA;AACA;AACA;AACA;AACA;;AAEA,8CAA8C,aAAa;AAC3D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA;;AAEA;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qCAAqC,SAAS;AAC9C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,YAAY;AAC1B,cAAc,WAAW;AACzB,cAAc,cAAc;AAC5B,cAAc,aAAa;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,WAAW;AACtB,YAAY,WAAW;AACvB;;AAEA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,WAAW;AACtB,WAAW,cAAc;AACzB,WAAW,aAAa;AACxB;;AAEA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gCAAgC,SAAS;AACzC;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;;AAGT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,KAAK;AAC9B;AACA;AACA,GAAG;AACH;;AAEA;AACA,kCAAkC,0DAA0D;AAC5F;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,6CAA6C;AAC7C;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAsB;AACtB;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,2CAA2C;AAC3C,EAAE;AACF;AACA;AACA,GAAG;AACH;AACA,EAAE;AACF;;AAEA;AACA,sFAAsF;AACtF,GAAG;AACH,0FAA0F;AAC1F;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,KAAK;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,UAAU;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,iCAAiC;AACjC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,EAAE;AACF;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC;;AAED;AACA,gCAAgC;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB;;AAEvB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mFAAmF;AACnF;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,wDAAwD;AACpF;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA,0FAA0F,aAAa;AACvG;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA,8EAA8E,eAAe;AAC7F;AACA;;AAEA;AACA,OAAO;;AAEP;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA,8EAA8E,eAAe;AAC7F;AACA;;AAEA;AACA,OAAO;;AAEP;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA,8EAA8E,eAAe;AAC7F;AACA;;AAEA;AACA,OAAO;;AAEP;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA,8EAA8E,eAAe;AAC7F;AACA;;AAEA;AACA,OAAO;;AAEP;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,cAAc;AAC3B,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,cAAc;AAC3B,eAAe;AACf;;;AAGA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC,aAAa,OAAO;AACpB;;AAEA;AACA,aAAa,iBAAiB;AAC9B,aAAa,OAAO;AACpB;;;AAGA;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B,eAAe;AACf;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEe,gEAAC,EAAC;AACjB;;;;;;;;;;;;ACnhlCA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA,cAAc,mBAAO,CAAC,uDAAQ;;AAE9B;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,iBAAiB,mBAAmB;AACpC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,sBAAsB;AACvC;;AAEA;AACA,mBAAmB,2BAA2B;;AAE9C;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,mBAAmB;AACnC;AACA;;AAEA;AACA;;AAEA,iBAAiB,2BAA2B;AAC5C;AACA;;AAEA,QAAQ,uBAAuB;AAC/B;AACA;AACA,GAAG;AACH;;AAEA,iBAAiB,uBAAuB;AACxC;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd,kDAAkD,sBAAsB;AACxE;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA,KAAK,KAAwC,EAAE,EAE7C;;AAEF,QAAQ,sBAAiB;AACzB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD;AACvD;;AAEA,6BAA6B,mBAAmB;;AAEhD;;AAEA;;AAEA;AACA;;;;;;;;;;;;;AC9YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;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",
    "file": "advanced-kpi.js",
    "sourcesContent": [
        " \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n",
        "exports = module.exports = require(\"../node_modules/css-loader/dist/runtime/api.js\")(false);\n// Module\nexports.push([module.id, \".adv-kpi-background{\\r\\n    position: absolute;\\r\\n    height: calc(100% + 10px);\\r\\n    width: calc(100% + 20px);\\r\\n    top: 0px;\\r\\n    left: -10px;\\r\\n}\\r\\n\\r\\n.adv-kpi-measure {\\r\\n    display: -webkit-inline-box;\\r\\n    display: -ms-inline-flexbox;\\r\\n    z-index: 2;\\r\\n    padding: 0 5px;\\r\\n}\\r\\n\\r\\n.adv-kpi-trend-a, .adv-kpi-trend-b {\\r\\n    display: -webkit-inline-box;\\r\\n    display: ruby-base-container;\\r\\n    z-index: 2;\\r\\n}\\r\\n\\r\\n.adv-kpi-name {\\r\\n    z-index: 2;\\r\\n    padding: 0 5px;\\r\\n}\\r\\n\\r\\n.col-xs-4 {\\r\\n    z-index: 2;\\r\\n}\\r\\n\\r\\n.adv-kpi-chart {\\r\\n    position: absolute;\\r\\n    left: -10px;\\r\\n    right: -10px;\\r\\n    bottom: 0px;\\r\\n    top:5px;\\r\\n    height: 100%;\\r\\n    width: calc(100% + 20px);\\r\\n}\\r\\n\\r\\n.adv-kpi-container {\\r\\n    position: relative;\\r\\n}\\r\\n.adv-kpi-1 {\\r\\n    position: relative;\\r\\n    /* z-index: 100; */\\r\\n}\\r\\n\\r\\n.adv-kpi-trend-a > span, .adv-kpi-trend-b > span {\\r\\n    display: inline-block !important;\\r\\n    vertical-align: middle !important;\\r\\n    margin: auto 5px !important;\\r\\n}\\r\\n\\r\\n.adv-kpi-trend-a > span.lui-icon::before, .adv-kpi-trend-b > span.lui-icon::before {\\r\\n    display: block;\\r\\n    margin: -0.2em auto 0px;\\r\\n}\\r\\n\\r\\nhr.style-one {\\r\\n    border: 0;\\r\\n    height: 1px;\\r\\n    background-image: linear-gradient(to right, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.75), rgba(0, 0, 0, 0));\\r\\n    margin: 0.5em 0 !important;\\r\\n    z-index: 2;\\r\\n}\\r\\n\\r\\nhr.style-two {\\r\\n    border: 0;\\r\\n    height: 1px;\\r\\n    background: #333333;\\r\\n    background-image: linear-gradient(to right, #ccc, #333, #ccc);\\r\\n    margin: 0.5em 0 !important;\\r\\n    z-index: 2;\\r\\n}\\r\\n\\r\\nhr.style-three {\\r\\n    border: 0;\\r\\n    height: 0;\\r\\n    border-top: 1px solid rgba(0, 0, 0, 0.1);\\r\\n    border-bottom: 1px solid rgba(255, 255, 255, 0.3);\\r\\n    margin: 0.5em 0 !important;\\r\\n    z-index: 2;\\r\\n}\\r\\n\\r\\nhr.style-four {\\r\\n  border: 0;\\r\\n  height: 0;\\r\\n  border-top: 1px solid rgba(255, 255, 255, 0.5);\\r\\n  margin: 0.5em 0 !important;\\r\\n  z-index: 2;\\r\\n}\\r\\n\\r\\nhr.style-five {\\r\\n  border-top: 1px solid #8c8b8b;\\r\\n  margin: 0.5em 0;\\r\\n  z-index: 2;\\r\\n}\\r\\n\\r\\nhr.style-six {\\r\\n  border-top: 1px dotted #8c8b8b;\\r\\n  margin: 0.5em 0;\\r\\n  z-index: 2;\\r\\n}\\r\\n\\r\\n.qv-client.qv-card #qv-stage-container #grid .qv-object-advanced-kpi .qv-inner-object .qv-object-header.thin {\\r\\n    height: 0px !important;\\r\\n}\\r\\n\\r\\n.qv-object-advanced-kpi .qv-inner-object .qv-object-content-container .qv-object-content {\\r\\n    display: flex;\\r\\n    flex-direction: column;\\r\\n    justify-content: center;\\r\\n    width: 100%;\\r\\n    height: 100%;\\r\\n}\\r\\n\\r\\nheader.qv-object-header .qv-object-advanced-kpi {\\r\\n    padding-bottom: 0px !important;\\r\\n}\\r\\n\\r\\n.adv-kpi-overlay {\\r\\n  background: rgba(0,0,0,0.5);\\r\\n  position: absolute;\\r\\n  height: calc(100% + 10px);\\r\\n  width: calc(100% + 20px);\\r\\n  left: -10px;\\r\\n  top: 0;\\r\\n  bottom: 0;\\r\\n  right: 0;\\r\\n  opacity: 0;\\r\\n  -webkit-transition: all 0.4s ease-in-out 0s;\\r\\n  -moz-transition: all 0.4s ease-in-out 0s;\\r\\n  transition: all 0.4s ease-in-out 0s;\\r\\n  z-index: 3;\\r\\n  cursor: pointer;\\r\\n}\\r\\n\\r\\n.adv-kpi-overlay:hover{\\r\\n  opacity: 1;\\r\\n}\\r\\n\\r\\n.adv-kpi-overlay:hover .adv-kpi-overlay-details{\\r\\n  top: 50%;\\r\\n  left: 50%;\\r\\n  opacity: 1;\\r\\n}\\r\\n\\r\\n.adv-kpi-overlay-details {\\r\\n  position: absolute;\\r\\n  text-align: center;\\r\\n  padding-left: 1em;\\r\\n  padding-right: 1em;\\r\\n  width: 100%;\\r\\n  top: 50%;\\r\\n  left: 50%;\\r\\n  opacity: 0;\\r\\n  -webkit-transform: translate(-50%, -50%);\\r\\n  -moz-transform: translate(-50%, -50%);\\r\\n  transform: translate(-50%, -50%);\\r\\n  -webkit-transition: all 0.3s ease-in-out 0s;\\r\\n  -moz-transition: all 0.3s ease-in-out 0s;\\r\\n  transition: all 0.3s ease-in-out 0s;\\r\\n  z-index: 4;\\r\\n}\\r\\n\\r\\n.adv-kpi-overlay-details h3{\\r\\n  color: #fff;\\r\\n  font-weight: 500;\\r\\n  margin-bottom: 0.5em;\\r\\n  z-index: 3;\\r\\n  font-size: 1.5em;\\r\\n}\\r\\n\\r\\n.adv-kpi-overlay-details p{\\r\\n  color: #fff;\\r\\n  font-size: 0.8em;\\r\\n  z-index: 4;\\r\\n}\\r\\n\\r\\n.adv-kpi-fadeIn-top{\\r\\n  top: 20%;\\r\\n}\\r\\n\\r\\n#grid-wrap.sheet-list .qv-object-advanced-kpi .qv-object-content-container {\\r\\n   overflow: unset !important; \\r\\n}\\r\\n\\r\\n.pp-expandable-list .pp-expandable-list .pp-expandable-list-header {\\r\\n  background-color: white !important;\\r\\n  border-top: 1px solid #e6e6e6 !important;\\r\\n  -webkit-border-radius: 0px !important;\\r\\n  border-radius: 0px !important;\\r\\n}\\r\\n\\r\\n.pp-header-with-switch-component .switch-container>.label {\\r\\n  color: #595959; \\r\\n}\\r\\n\\r\\n.qv-object-advanced-kpi .requirements-wrapper {\\r\\n  position: absolute !important;\\r\\n}\\r\\n\\r\\n.qv-object-advanced-kpi .requirements {\\r\\n  text-align: center !important;\\r\\n}\\r\\n\\r\\n.qv-object-advanced-kpi .text {\\r\\n  text-align: center !important;\\r\\n}\\r\\n\\r\\n\\r\\n/* flexbox start */\\r\\n.container-fluid {\\r\\n    margin-right: auto;\\r\\n    margin-left: auto;\\r\\n    padding-right: 2rem;\\r\\n    padding-left: 2rem;\\r\\n  }\\r\\n  \\r\\n  .row {\\r\\n    box-sizing: border-box;\\r\\n    display: -ms-flexbox;\\r\\n    display: -webkit-box;\\r\\n    display: flex;\\r\\n    -ms-flex: 0 1 auto;\\r\\n    -webkit-box-flex: 0;\\r\\n    flex: 0 1 auto;\\r\\n    -ms-flex-direction: row;\\r\\n    -webkit-box-orient: horizontal;\\r\\n    -webkit-box-direction: normal;\\r\\n    flex-direction: row;\\r\\n    -ms-flex-wrap: wrap;\\r\\n    flex-wrap: wrap;\\r\\n    margin-right: -1rem;\\r\\n    margin-left: -1rem;\\r\\n  }\\r\\n  \\r\\n  .row.reverse {\\r\\n    -ms-flex-direction: row-reverse;\\r\\n    -webkit-box-orient: horizontal;\\r\\n    -webkit-box-direction: reverse;\\r\\n    flex-direction: row-reverse;\\r\\n  }\\r\\n  \\r\\n  .col.reverse {\\r\\n    -ms-flex-direction: column-reverse;\\r\\n    -webkit-box-orient: vertical;\\r\\n    -webkit-box-direction: reverse;\\r\\n    flex-direction: column-reverse;\\r\\n  }\\r\\n  \\r\\n  .col-xs,\\r\\n  .col-xs-1,\\r\\n  .col-xs-2,\\r\\n  .col-xs-3,\\r\\n  .col-xs-4,\\r\\n  .col-xs-5,\\r\\n  .col-xs-6,\\r\\n  .col-xs-7,\\r\\n  .col-xs-8,\\r\\n  .col-xs-9,\\r\\n  .col-xs-10,\\r\\n  .col-xs-11,\\r\\n  .col-xs-12 {\\r\\n    box-sizing: border-box;\\r\\n    -ms-flex: 0 0 auto;\\r\\n    -webkit-box-flex: 0;\\r\\n    flex: 0 0 auto;\\r\\n    padding-right: 1rem;\\r\\n    padding-left: 1rem;\\r\\n  }\\r\\n  \\r\\n  .col-xs {\\r\\n    -webkit-flex-grow: 1;\\r\\n    -ms-flex-positive: 1;\\r\\n    -webkit-box-flex: 1;\\r\\n    flex-grow: 1;\\r\\n    -ms-flex-preferred-size: 0;\\r\\n    flex-basis: 0;\\r\\n    max-width: 100%;\\r\\n  }\\r\\n  \\r\\n  .col-xs-1 {\\r\\n    -ms-flex-preferred-size: 8.333%;\\r\\n    flex-basis: 8.333%;\\r\\n    max-width: 8.333%;\\r\\n  }\\r\\n  \\r\\n  .col-xs-2 {\\r\\n    -ms-flex-preferred-size: 16.667%;\\r\\n    flex-basis: 16.667%;\\r\\n    max-width: 16.667%;\\r\\n  }\\r\\n  \\r\\n  .col-xs-3 {\\r\\n    -ms-flex-preferred-size: 25%;\\r\\n    flex-basis: 25%;\\r\\n    max-width: 25%;\\r\\n  }\\r\\n  \\r\\n  .col-xs-4 {\\r\\n    -ms-flex-preferred-size: 33.333%;\\r\\n    flex-basis: 33.333%;\\r\\n    max-width: 33.333%;\\r\\n  }\\r\\n  \\r\\n  .col-xs-5 {\\r\\n    -ms-flex-preferred-size: 41.667%;\\r\\n    flex-basis: 41.667%;\\r\\n    max-width: 41.667%;\\r\\n  }\\r\\n  \\r\\n  .col-xs-6 {\\r\\n    -ms-flex-preferred-size: 50%;\\r\\n    flex-basis: 50%;\\r\\n    max-width: 50%;\\r\\n  }\\r\\n  \\r\\n  .col-xs-7 {\\r\\n    -ms-flex-preferred-size: 58.333%;\\r\\n    flex-basis: 58.333%;\\r\\n    max-width: 58.333%;\\r\\n  }\\r\\n  \\r\\n  .col-xs-8 {\\r\\n    -ms-flex-preferred-size: 66.667%;\\r\\n    flex-basis: 66.667%;\\r\\n    max-width: 66.667%;\\r\\n  }\\r\\n  \\r\\n  .col-xs-9 {\\r\\n    -ms-flex-preferred-size: 75%;\\r\\n    flex-basis: 75%;\\r\\n    max-width: 75%;\\r\\n  }\\r\\n  \\r\\n  .col-xs-10 {\\r\\n    -ms-flex-preferred-size: 83.333%;\\r\\n    flex-basis: 83.333%;\\r\\n    max-width: 83.333%;\\r\\n  }\\r\\n  \\r\\n  .col-xs-11 {\\r\\n    -ms-flex-preferred-size: 91.667%;\\r\\n    flex-basis: 91.667%;\\r\\n    max-width: 91.667%;\\r\\n  }\\r\\n  \\r\\n  .col-xs-12 {\\r\\n    -ms-flex-preferred-size: 100%;\\r\\n    flex-basis: 100%;\\r\\n    max-width: 100%;\\r\\n  }\\r\\n  \\r\\n  .col-xs-offset-1 {\\r\\n    margin-left: 8.333%;\\r\\n  }\\r\\n  \\r\\n  .col-xs-offset-2 {\\r\\n    margin-left: 16.667%;\\r\\n  }\\r\\n  \\r\\n  .col-xs-offset-3 {\\r\\n    margin-left: 25%;\\r\\n  }\\r\\n  \\r\\n  .col-xs-offset-4 {\\r\\n    margin-left: 33.333%;\\r\\n  }\\r\\n  \\r\\n  .col-xs-offset-5 {\\r\\n    margin-left: 41.667%;\\r\\n  }\\r\\n  \\r\\n  .col-xs-offset-6 {\\r\\n    margin-left: 50%;\\r\\n  }\\r\\n  \\r\\n  .col-xs-offset-7 {\\r\\n    margin-left: 58.333%;\\r\\n  }\\r\\n  \\r\\n  .col-xs-offset-8 {\\r\\n    margin-left: 66.667%;\\r\\n  }\\r\\n  \\r\\n  .col-xs-offset-9 {\\r\\n    margin-left: 75%;\\r\\n  }\\r\\n  \\r\\n  .col-xs-offset-10 {\\r\\n    margin-left: 83.333%;\\r\\n  }\\r\\n  \\r\\n  .col-xs-offset-11 {\\r\\n    margin-left: 91.667%;\\r\\n  }\\r\\n  \\r\\n  .start-xs {\\r\\n    -ms-flex-pack: start;\\r\\n    -webkit-box-pack: start;\\r\\n    justify-content: flex-start;\\r\\n    text-align: start;\\r\\n  }\\r\\n  \\r\\n  .center-xs {\\r\\n    -ms-flex-pack: center;\\r\\n    -webkit-box-pack: center;\\r\\n    justify-content: center;\\r\\n    text-align: center;\\r\\n  }\\r\\n  \\r\\n  .end-xs {\\r\\n    -ms-flex-pack: end;\\r\\n    -webkit-box-pack: end;\\r\\n    justify-content: flex-end;\\r\\n    text-align: end;\\r\\n  }\\r\\n  \\r\\n  .top-xs {\\r\\n    -ms-flex-align: start;\\r\\n    -webkit-box-align: start;\\r\\n    align-items: flex-start;\\r\\n  }\\r\\n  \\r\\n  .middle-xs {\\r\\n    -ms-flex-align: center;\\r\\n    -webkit-box-align: center;\\r\\n    align-items: center;\\r\\n  }\\r\\n  \\r\\n  .bottom-xs {\\r\\n    -ms-flex-align: end;\\r\\n    -webkit-box-align: end;\\r\\n    align-items: flex-end;\\r\\n  }\\r\\n  \\r\\n  .around-xs {\\r\\n    -ms-flex-pack: distribute;\\r\\n    justify-content: space-around;\\r\\n  }\\r\\n  \\r\\n  .between-xs {\\r\\n    -ms-flex-pack: justify;\\r\\n    -webkit-box-pack: justify;\\r\\n    justify-content: space-between;\\r\\n  }\\r\\n  \\r\\n  .first-xs {\\r\\n    -ms-flex-order: -1;\\r\\n    -webkit-box-ordinal-group: 0;\\r\\n    order: -1;\\r\\n  }\\r\\n  \\r\\n  .last-xs {\\r\\n    -ms-flex-order: 1;\\r\\n    -webkit-box-ordinal-group: 2;\\r\\n    order: 1;\\r\\n  }\\r\\n  \\r\\n  @media only screen and (min-width: 48em) {\\r\\n    .container-kpi {\\r\\n      width: 46rem;\\r\\n    }\\r\\n  \\r\\n    .col-sm,\\r\\n    .col-sm-1,\\r\\n    .col-sm-2,\\r\\n    .col-sm-3,\\r\\n    .col-sm-4,\\r\\n    .col-sm-5,\\r\\n    .col-sm-6,\\r\\n    .col-sm-7,\\r\\n    .col-sm-8,\\r\\n    .col-sm-9,\\r\\n    .col-sm-10,\\r\\n    .col-sm-11,\\r\\n    .col-sm-12 {\\r\\n      box-sizing: border-box;\\r\\n      -ms-flex: 0 0 auto;\\r\\n      -webkit-box-flex: 0;\\r\\n      flex: 0 0 auto;\\r\\n      padding-right: 1rem;\\r\\n      padding-left: 1rem;\\r\\n    }\\r\\n  \\r\\n    .col-sm {\\r\\n      -webkit-flex-grow: 1;\\r\\n      -ms-flex-positive: 1;\\r\\n      -webkit-box-flex: 1;\\r\\n      flex-grow: 1;\\r\\n      -ms-flex-preferred-size: 0;\\r\\n      flex-basis: 0;\\r\\n      max-width: 100%;\\r\\n    }\\r\\n  \\r\\n    .col-sm-1 {\\r\\n      -ms-flex-preferred-size: 8.333%;\\r\\n      flex-basis: 8.333%;\\r\\n      max-width: 8.333%;\\r\\n    }\\r\\n  \\r\\n    .col-sm-2 {\\r\\n      -ms-flex-preferred-size: 16.667%;\\r\\n      flex-basis: 16.667%;\\r\\n      max-width: 16.667%;\\r\\n    }\\r\\n  \\r\\n    .col-sm-3 {\\r\\n      -ms-flex-preferred-size: 25%;\\r\\n      flex-basis: 25%;\\r\\n      max-width: 25%;\\r\\n    }\\r\\n  \\r\\n    .col-sm-4 {\\r\\n      -ms-flex-preferred-size: 33.333%;\\r\\n      flex-basis: 33.333%;\\r\\n      max-width: 33.333%;\\r\\n    }\\r\\n  \\r\\n    .col-sm-5 {\\r\\n      -ms-flex-preferred-size: 41.667%;\\r\\n      flex-basis: 41.667%;\\r\\n      max-width: 41.667%;\\r\\n    }\\r\\n  \\r\\n    .col-sm-6 {\\r\\n      -ms-flex-preferred-size: 50%;\\r\\n      flex-basis: 50%;\\r\\n      max-width: 50%;\\r\\n    }\\r\\n  \\r\\n    .col-sm-7 {\\r\\n      -ms-flex-preferred-size: 58.333%;\\r\\n      flex-basis: 58.333%;\\r\\n      max-width: 58.333%;\\r\\n    }\\r\\n  \\r\\n    .col-sm-8 {\\r\\n      -ms-flex-preferred-size: 66.667%;\\r\\n      flex-basis: 66.667%;\\r\\n      max-width: 66.667%;\\r\\n    }\\r\\n  \\r\\n    .col-sm-9 {\\r\\n      -ms-flex-preferred-size: 75%;\\r\\n      flex-basis: 75%;\\r\\n      max-width: 75%;\\r\\n    }\\r\\n  \\r\\n    .col-sm-10 {\\r\\n      -ms-flex-preferred-size: 83.333%;\\r\\n      flex-basis: 83.333%;\\r\\n      max-width: 83.333%;\\r\\n    }\\r\\n  \\r\\n    .col-sm-11 {\\r\\n      -ms-flex-preferred-size: 91.667%;\\r\\n      flex-basis: 91.667%;\\r\\n      max-width: 91.667%;\\r\\n    }\\r\\n  \\r\\n    .col-sm-12 {\\r\\n      -ms-flex-preferred-size: 100%;\\r\\n      flex-basis: 100%;\\r\\n      max-width: 100%;\\r\\n    }\\r\\n  \\r\\n    .col-sm-offset-1 {\\r\\n      margin-left: 8.333%;\\r\\n    }\\r\\n  \\r\\n    .col-sm-offset-2 {\\r\\n      margin-left: 16.667%;\\r\\n    }\\r\\n  \\r\\n    .col-sm-offset-3 {\\r\\n      margin-left: 25%;\\r\\n    }\\r\\n  \\r\\n    .col-sm-offset-4 {\\r\\n      margin-left: 33.333%;\\r\\n    }\\r\\n  \\r\\n    .col-sm-offset-5 {\\r\\n      margin-left: 41.667%;\\r\\n    }\\r\\n  \\r\\n    .col-sm-offset-6 {\\r\\n      margin-left: 50%;\\r\\n    }\\r\\n  \\r\\n    .col-sm-offset-7 {\\r\\n      margin-left: 58.333%;\\r\\n    }\\r\\n  \\r\\n    .col-sm-offset-8 {\\r\\n      margin-left: 66.667%;\\r\\n    }\\r\\n  \\r\\n    .col-sm-offset-9 {\\r\\n      margin-left: 75%;\\r\\n    }\\r\\n  \\r\\n    .col-sm-offset-10 {\\r\\n      margin-left: 83.333%;\\r\\n    }\\r\\n  \\r\\n    .col-sm-offset-11 {\\r\\n      margin-left: 91.667%;\\r\\n    }\\r\\n  \\r\\n    .start-sm {\\r\\n      -ms-flex-pack: start;\\r\\n      -webkit-box-pack: start;\\r\\n      justify-content: flex-start;\\r\\n      text-align: start;\\r\\n    }\\r\\n  \\r\\n    .center-sm {\\r\\n      -ms-flex-pack: center;\\r\\n      -webkit-box-pack: center;\\r\\n      justify-content: center;\\r\\n      text-align: center;\\r\\n    }\\r\\n  \\r\\n    .end-sm {\\r\\n      -ms-flex-pack: end;\\r\\n      -webkit-box-pack: end;\\r\\n      justify-content: flex-end;\\r\\n      text-align: end;\\r\\n    }\\r\\n  \\r\\n    .top-sm {\\r\\n      -ms-flex-align: start;\\r\\n      -webkit-box-align: start;\\r\\n      align-items: flex-start;\\r\\n    }\\r\\n  \\r\\n    .middle-sm {\\r\\n      -ms-flex-align: center;\\r\\n      -webkit-box-align: center;\\r\\n      align-items: center;\\r\\n    }\\r\\n  \\r\\n    .bottom-sm {\\r\\n      -ms-flex-align: end;\\r\\n      -webkit-box-align: end;\\r\\n      align-items: flex-end;\\r\\n    }\\r\\n  \\r\\n    .around-sm {\\r\\n      -ms-flex-pack: distribute;\\r\\n      justify-content: space-around;\\r\\n    }\\r\\n  \\r\\n    .between-sm {\\r\\n      -ms-flex-pack: justify;\\r\\n      -webkit-box-pack: justify;\\r\\n      justify-content: space-between;\\r\\n    }\\r\\n  \\r\\n    .first-sm {\\r\\n      -ms-flex-order: -1;\\r\\n      -webkit-box-ordinal-group: 0;\\r\\n      order: -1;\\r\\n    }\\r\\n  \\r\\n    .last-sm {\\r\\n      -ms-flex-order: 1;\\r\\n      -webkit-box-ordinal-group: 2;\\r\\n      order: 1;\\r\\n    }\\r\\n  }\\r\\n  \\r\\n  @media only screen and (min-width: 62em) {\\r\\n    .container-kpi {\\r\\n      width: 61rem;\\r\\n    }\\r\\n  \\r\\n    .col-md,\\r\\n    .col-md-1,\\r\\n    .col-md-2,\\r\\n    .col-md-3,\\r\\n    .col-md-4,\\r\\n    .col-md-5,\\r\\n    .col-md-6,\\r\\n    .col-md-7,\\r\\n    .col-md-8,\\r\\n    .col-md-9,\\r\\n    .col-md-10,\\r\\n    .col-md-11,\\r\\n    .col-md-12 {\\r\\n      box-sizing: border-box;\\r\\n      -ms-flex: 0 0 auto;\\r\\n      -webkit-box-flex: 0;\\r\\n      flex: 0 0 auto;\\r\\n      padding-right: 1rem;\\r\\n      padding-left: 1rem;\\r\\n    }\\r\\n  \\r\\n    .col-md {\\r\\n      -webkit-flex-grow: 1;\\r\\n      -ms-flex-positive: 1;\\r\\n      -webkit-box-flex: 1;\\r\\n      flex-grow: 1;\\r\\n      -ms-flex-preferred-size: 0;\\r\\n      flex-basis: 0;\\r\\n      max-width: 100%;\\r\\n    }\\r\\n  \\r\\n    .col-md-1 {\\r\\n      -ms-flex-preferred-size: 8.333%;\\r\\n      flex-basis: 8.333%;\\r\\n      max-width: 8.333%;\\r\\n    }\\r\\n  \\r\\n    .col-md-2 {\\r\\n      -ms-flex-preferred-size: 16.667%;\\r\\n      flex-basis: 16.667%;\\r\\n      max-width: 16.667%;\\r\\n    }\\r\\n  \\r\\n    .col-md-3 {\\r\\n      -ms-flex-preferred-size: 25%;\\r\\n      flex-basis: 25%;\\r\\n      max-width: 25%;\\r\\n    }\\r\\n  \\r\\n    .col-md-4 {\\r\\n      -ms-flex-preferred-size: 33.333%;\\r\\n      flex-basis: 33.333%;\\r\\n      max-width: 33.333%;\\r\\n    }\\r\\n  \\r\\n    .col-md-5 {\\r\\n      -ms-flex-preferred-size: 41.667%;\\r\\n      flex-basis: 41.667%;\\r\\n      max-width: 41.667%;\\r\\n    }\\r\\n  \\r\\n    .col-md-6 {\\r\\n      -ms-flex-preferred-size: 50%;\\r\\n      flex-basis: 50%;\\r\\n      max-width: 50%;\\r\\n    }\\r\\n  \\r\\n    .col-md-7 {\\r\\n      -ms-flex-preferred-size: 58.333%;\\r\\n      flex-basis: 58.333%;\\r\\n      max-width: 58.333%;\\r\\n    }\\r\\n  \\r\\n    .col-md-8 {\\r\\n      -ms-flex-preferred-size: 66.667%;\\r\\n      flex-basis: 66.667%;\\r\\n      max-width: 66.667%;\\r\\n    }\\r\\n  \\r\\n    .col-md-9 {\\r\\n      -ms-flex-preferred-size: 75%;\\r\\n      flex-basis: 75%;\\r\\n      max-width: 75%;\\r\\n    }\\r\\n  \\r\\n    .col-md-10 {\\r\\n      -ms-flex-preferred-size: 83.333%;\\r\\n      flex-basis: 83.333%;\\r\\n      max-width: 83.333%;\\r\\n    }\\r\\n  \\r\\n    .col-md-11 {\\r\\n      -ms-flex-preferred-size: 91.667%;\\r\\n      flex-basis: 91.667%;\\r\\n      max-width: 91.667%;\\r\\n    }\\r\\n  \\r\\n    .col-md-12 {\\r\\n      -ms-flex-preferred-size: 100%;\\r\\n      flex-basis: 100%;\\r\\n      max-width: 100%;\\r\\n    }\\r\\n  \\r\\n    .col-md-offset-1 {\\r\\n      margin-left: 8.333%;\\r\\n    }\\r\\n  \\r\\n    .col-md-offset-2 {\\r\\n      margin-left: 16.667%;\\r\\n    }\\r\\n  \\r\\n    .col-md-offset-3 {\\r\\n      margin-left: 25%;\\r\\n    }\\r\\n  \\r\\n    .col-md-offset-4 {\\r\\n      margin-left: 33.333%;\\r\\n    }\\r\\n  \\r\\n    .col-md-offset-5 {\\r\\n      margin-left: 41.667%;\\r\\n    }\\r\\n  \\r\\n    .col-md-offset-6 {\\r\\n      margin-left: 50%;\\r\\n    }\\r\\n  \\r\\n    .col-md-offset-7 {\\r\\n      margin-left: 58.333%;\\r\\n    }\\r\\n  \\r\\n    .col-md-offset-8 {\\r\\n      margin-left: 66.667%;\\r\\n    }\\r\\n  \\r\\n    .col-md-offset-9 {\\r\\n      margin-left: 75%;\\r\\n    }\\r\\n  \\r\\n    .col-md-offset-10 {\\r\\n      margin-left: 83.333%;\\r\\n    }\\r\\n  \\r\\n    .col-md-offset-11 {\\r\\n      margin-left: 91.667%;\\r\\n    }\\r\\n  \\r\\n    .start-md {\\r\\n      -ms-flex-pack: start;\\r\\n      -webkit-box-pack: start;\\r\\n      justify-content: flex-start;\\r\\n      text-align: start;\\r\\n    }\\r\\n  \\r\\n    .center-md {\\r\\n      -ms-flex-pack: center;\\r\\n      -webkit-box-pack: center;\\r\\n      justify-content: center;\\r\\n      text-align: center;\\r\\n    }\\r\\n  \\r\\n    .end-md {\\r\\n      -ms-flex-pack: end;\\r\\n      -webkit-box-pack: end;\\r\\n      justify-content: flex-end;\\r\\n      text-align: end;\\r\\n    }\\r\\n  \\r\\n    .top-md {\\r\\n      -ms-flex-align: start;\\r\\n      -webkit-box-align: start;\\r\\n      align-items: flex-start;\\r\\n    }\\r\\n  \\r\\n    .middle-md {\\r\\n      -ms-flex-align: center;\\r\\n      -webkit-box-align: center;\\r\\n      align-items: center;\\r\\n    }\\r\\n  \\r\\n    .bottom-md {\\r\\n      -ms-flex-align: end;\\r\\n      -webkit-box-align: end;\\r\\n      align-items: flex-end;\\r\\n    }\\r\\n  \\r\\n    .around-md {\\r\\n      -ms-flex-pack: distribute;\\r\\n      justify-content: space-around;\\r\\n    }\\r\\n  \\r\\n    .between-md {\\r\\n      -ms-flex-pack: justify;\\r\\n      -webkit-box-pack: justify;\\r\\n      justify-content: space-between;\\r\\n    }\\r\\n  \\r\\n    .first-md {\\r\\n      -ms-flex-order: -1;\\r\\n      -webkit-box-ordinal-group: 0;\\r\\n      order: -1;\\r\\n    }\\r\\n  \\r\\n    .last-md {\\r\\n      -ms-flex-order: 1;\\r\\n      -webkit-box-ordinal-group: 2;\\r\\n      order: 1;\\r\\n    }\\r\\n  }\\r\\n  \\r\\n  @media only screen and (min-width: 75em) {\\r\\n    .container-kpi {\\r\\n      width: 71rem;\\r\\n    }\\r\\n  \\r\\n    .col-lg,\\r\\n    .col-lg-1,\\r\\n    .col-lg-2,\\r\\n    .col-lg-3,\\r\\n    .col-lg-4,\\r\\n    .col-lg-5,\\r\\n    .col-lg-6,\\r\\n    .col-lg-7,\\r\\n    .col-lg-8,\\r\\n    .col-lg-9,\\r\\n    .col-lg-10,\\r\\n    .col-lg-11,\\r\\n    .col-lg-12 {\\r\\n      box-sizing: border-box;\\r\\n      -ms-flex: 0 0 auto;\\r\\n      -webkit-box-flex: 0;\\r\\n      flex: 0 0 auto;\\r\\n      padding-right: 1rem;\\r\\n      padding-left: 1rem;\\r\\n    }\\r\\n  \\r\\n    .col-lg {\\r\\n      -webkit-flex-grow: 1;\\r\\n      -ms-flex-positive: 1;\\r\\n      -webkit-box-flex: 1;\\r\\n      flex-grow: 1;\\r\\n      -ms-flex-preferred-size: 0;\\r\\n      flex-basis: 0;\\r\\n      max-width: 100%;\\r\\n    }\\r\\n  \\r\\n    .col-lg-1 {\\r\\n      -ms-flex-preferred-size: 8.333%;\\r\\n      flex-basis: 8.333%;\\r\\n      max-width: 8.333%;\\r\\n    }\\r\\n  \\r\\n    .col-lg-2 {\\r\\n      -ms-flex-preferred-size: 16.667%;\\r\\n      flex-basis: 16.667%;\\r\\n      max-width: 16.667%;\\r\\n    }\\r\\n  \\r\\n    .col-lg-3 {\\r\\n      -ms-flex-preferred-size: 25%;\\r\\n      flex-basis: 25%;\\r\\n      max-width: 25%;\\r\\n    }\\r\\n  \\r\\n    .col-lg-4 {\\r\\n      -ms-flex-preferred-size: 33.333%;\\r\\n      flex-basis: 33.333%;\\r\\n      max-width: 33.333%;\\r\\n    }\\r\\n  \\r\\n    .col-lg-5 {\\r\\n      -ms-flex-preferred-size: 41.667%;\\r\\n      flex-basis: 41.667%;\\r\\n      max-width: 41.667%;\\r\\n    }\\r\\n  \\r\\n    .col-lg-6 {\\r\\n      -ms-flex-preferred-size: 50%;\\r\\n      flex-basis: 50%;\\r\\n      max-width: 50%;\\r\\n    }\\r\\n  \\r\\n    .col-lg-7 {\\r\\n      -ms-flex-preferred-size: 58.333%;\\r\\n      flex-basis: 58.333%;\\r\\n      max-width: 58.333%;\\r\\n    }\\r\\n  \\r\\n    .col-lg-8 {\\r\\n      -ms-flex-preferred-size: 66.667%;\\r\\n      flex-basis: 66.667%;\\r\\n      max-width: 66.667%;\\r\\n    }\\r\\n  \\r\\n    .col-lg-9 {\\r\\n      -ms-flex-preferred-size: 75%;\\r\\n      flex-basis: 75%;\\r\\n      max-width: 75%;\\r\\n    }\\r\\n  \\r\\n    .col-lg-10 {\\r\\n      -ms-flex-preferred-size: 83.333%;\\r\\n      flex-basis: 83.333%;\\r\\n      max-width: 83.333%;\\r\\n    }\\r\\n  \\r\\n    .col-lg-11 {\\r\\n      -ms-flex-preferred-size: 91.667%;\\r\\n      flex-basis: 91.667%;\\r\\n      max-width: 91.667%;\\r\\n    }\\r\\n  \\r\\n    .col-lg-12 {\\r\\n      -ms-flex-preferred-size: 100%;\\r\\n      flex-basis: 100%;\\r\\n      max-width: 100%;\\r\\n    }\\r\\n  \\r\\n    .col-lg-offset-1 {\\r\\n      margin-left: 8.333%;\\r\\n    }\\r\\n  \\r\\n    .col-lg-offset-2 {\\r\\n      margin-left: 16.667%;\\r\\n    }\\r\\n  \\r\\n    .col-lg-offset-3 {\\r\\n      margin-left: 25%;\\r\\n    }\\r\\n  \\r\\n    .col-lg-offset-4 {\\r\\n      margin-left: 33.333%;\\r\\n    }\\r\\n  \\r\\n    .col-lg-offset-5 {\\r\\n      margin-left: 41.667%;\\r\\n    }\\r\\n  \\r\\n    .col-lg-offset-6 {\\r\\n      margin-left: 50%;\\r\\n    }\\r\\n  \\r\\n    .col-lg-offset-7 {\\r\\n      margin-left: 58.333%;\\r\\n    }\\r\\n  \\r\\n    .col-lg-offset-8 {\\r\\n      margin-left: 66.667%;\\r\\n    }\\r\\n  \\r\\n    .col-lg-offset-9 {\\r\\n      margin-left: 75%;\\r\\n    }\\r\\n  \\r\\n    .col-lg-offset-10 {\\r\\n      margin-left: 83.333%;\\r\\n    }\\r\\n  \\r\\n    .col-lg-offset-11 {\\r\\n      margin-left: 91.667%;\\r\\n    }\\r\\n  \\r\\n    .start-lg {\\r\\n      -ms-flex-pack: start;\\r\\n      -webkit-box-pack: start;\\r\\n      justify-content: flex-start;\\r\\n      text-align: start;\\r\\n    }\\r\\n  \\r\\n    .center-lg {\\r\\n      -ms-flex-pack: center;\\r\\n      -webkit-box-pack: center;\\r\\n      justify-content: center;\\r\\n      text-align: center;\\r\\n    }\\r\\n  \\r\\n    .end-lg {\\r\\n      -ms-flex-pack: end;\\r\\n      -webkit-box-pack: end;\\r\\n      justify-content: flex-end;\\r\\n      text-align: end;\\r\\n    }\\r\\n  \\r\\n    .top-lg {\\r\\n      -ms-flex-align: start;\\r\\n      -webkit-box-align: start;\\r\\n      align-items: flex-start;\\r\\n    }\\r\\n  \\r\\n    .middle-lg {\\r\\n      -ms-flex-align: center;\\r\\n      -webkit-box-align: center;\\r\\n      align-items: center;\\r\\n    }\\r\\n  \\r\\n    .bottom-lg {\\r\\n      -ms-flex-align: end;\\r\\n      -webkit-box-align: end;\\r\\n      align-items: flex-end;\\r\\n    }\\r\\n  \\r\\n    .around-lg {\\r\\n      -ms-flex-pack: distribute;\\r\\n      justify-content: space-around;\\r\\n    }\\r\\n  \\r\\n    .between-lg {\\r\\n      -ms-flex-pack: justify;\\r\\n      -webkit-box-pack: justify;\\r\\n      justify-content: space-between;\\r\\n    }\\r\\n  \\r\\n    .first-lg {\\r\\n      -ms-flex-order: -1;\\r\\n      -webkit-box-ordinal-group: 0;\\r\\n      order: -1;\\r\\n    }\\r\\n  \\r\\n    .last-lg {\\r\\n      -ms-flex-order: 1;\\r\\n      -webkit-box-ordinal-group: 2;\\r\\n      order: 1;\\r\\n    }\\r\\n  }\\r\\n\\r\\n/* flexbox end */\", \"\"]);\n\n",
        "\"use strict\";\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return '@media ' + item[2] + '{' + content + '}';\n      } else {\n        return content;\n      }\n    }).join('');\n  }; // import a list of modules into the list\n\n\n  list.i = function (modules, mediaQuery) {\n    if (typeof modules === 'string') {\n      modules = [[null, modules, '']];\n    }\n\n    var alreadyImportedModules = {};\n\n    for (var i = 0; i < this.length; i++) {\n      var id = this[i][0];\n\n      if (id != null) {\n        alreadyImportedModules[id] = true;\n      }\n    }\n\n    for (i = 0; i < modules.length; i++) {\n      var item = modules[i]; // skip already imported module\n      // this implementation is not 100% perfect for weird media query combinations\n      // when a module is imported multiple times with different media queries.\n      // I hope this will never occur (Hey this way we have smaller bundles)\n\n      if (item[0] == null || !alreadyImportedModules[item[0]]) {\n        if (mediaQuery && !item[2]) {\n          item[2] = mediaQuery;\n        } else if (mediaQuery) {\n          item[2] = '(' + item[2] + ') and (' + mediaQuery + ')';\n        }\n\n        list.push(item);\n      }\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || '';\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === 'function') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n  }\n\n  return [content].join('\\n');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n  return '/*# ' + data + ' */';\n}",
        "/*\n* picasso-plugin-q v0.27.0\n* Copyright (c) 2019 QlikTech International AB\n* Released under the MIT license.\n*/\n\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\nvar defineProperty = Object.defineProperty;\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) { /**/ }\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\n// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target\nvar setProperty = function setProperty(target, options) {\n\tif (defineProperty && options.name === '__proto__') {\n\t\tdefineProperty(target, options.name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\tvalue: options.newValue,\n\t\t\twritable: true\n\t\t});\n\t} else {\n\t\ttarget[options.name] = options.newValue;\n\t}\n};\n\n// Return undefined instead of __proto__ if '__proto__' is not an own property\nvar getProperty = function getProperty(obj, name) {\n\tif (name === '__proto__') {\n\t\tif (!hasOwn.call(obj, name)) {\n\t\t\treturn void 0;\n\t\t} else if (gOPD) {\n\t\t\t// In early versions of node, obj['__proto__'] is buggy when obj has\n\t\t\t// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.\n\t\t\treturn gOPD(obj, name).value;\n\t\t}\n\t}\n\n\treturn obj[name];\n};\n\nvar extend = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone;\n\tvar target = arguments[0];\n\tvar i = 1;\n\tvar length = arguments.length;\n\tvar deep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\tif (target == null || (typeof target !== 'object' && typeof target !== 'function')) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = getProperty(target, name);\n\t\t\t\tcopy = getProperty(options, name);\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: extend(deep, clone, copy) });\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: copy });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\nfunction getFieldAccessor(field, page, deps) {\n  if (!field) {\n    return -1;\n  }\n\n  var cache = deps.cache;\n  var origin = field.origin ? field.origin() : null;\n\n  if (origin) {\n    field = origin;\n  }\n\n  var fieldIdx = cache.fields.indexOf(field);\n  var attrIdx = -1;\n  var attrDimIdx = -1;\n\n  if (fieldIdx === -1) {\n    for (var i = 0; i < cache.wrappedFields.length; i++) {\n      attrDimIdx = cache.wrappedFields[i].attrDims.map(function (v) {\n        return v.instance;\n      }).indexOf(field);\n      attrIdx = cache.wrappedFields[i].attrExps.map(function (v) {\n        return v.instance;\n      }).indexOf(field);\n\n      if (attrDimIdx !== -1 || attrIdx !== -1) {\n        fieldIdx = i;\n        break;\n      }\n    }\n  }\n\n  fieldIdx -= page.qArea.qLeft;\n\n  if (fieldIdx < 0 || fieldIdx >= page.qArea.qWidth) {\n    // throw new Error('Field out of range');\n    return -1;\n  }\n\n  if (attrDimIdx >= 0) {\n    return function (row) {\n      return row[fieldIdx].qAttrDims.qValues[attrDimIdx];\n    };\n  }\n\n  if (attrIdx >= 0) {\n    return function (row) {\n      return row[fieldIdx].qAttrExps.qValues[attrIdx];\n    };\n  }\n\n  return function (row) {\n    return row[fieldIdx];\n  };\n} // TODO - handle 'other' value\n// const specialTextValues = {\n//   '-3': (meta) => {\n//     if ('othersLabel' in meta) {\n//       return meta.othersLabel;\n//     }\n//     return '';\n//   }\n// };\n\nfunction datumExtract(propCfg, cell, _ref) {\n  var key = _ref.key;\n  var datum = {\n    value: typeof propCfg.value === 'function' ? propCfg.value(cell) : typeof propCfg.value !== 'undefined' ? propCfg.value : cell // eslint-disable-line no-nested-ternary\n\n  };\n  datum.label = typeof propCfg.label === 'function' ? propCfg.label(cell) : typeof propCfg.label !== 'undefined' ? String(propCfg.label) : String(datum.value); // eslint-disable-line no-nested-ternary\n\n  if (propCfg.field) {\n    datum.source = {\n      key: key,\n      field: propCfg.field.key()\n    };\n  }\n\n  return datum;\n}\n\nfunction cellToValue(_ref2) {\n  var cache = _ref2.cache,\n      f = _ref2.f,\n      mainCell = _ref2.mainCell,\n      p = _ref2.p,\n      prop = _ref2.prop,\n      page = _ref2.page,\n      rowIdx = _ref2.rowIdx,\n      row = _ref2.row,\n      sourceKey = _ref2.sourceKey,\n      target = _ref2.target,\n      targetProp = _ref2.targetProp;\n  var propCell = mainCell;\n\n  if (p.field && p.field !== f) {\n    var propCellFn = getFieldAccessor(p.field, page, {\n      cache: cache\n    });\n\n    if (propCellFn === -1) {\n      return;\n    }\n\n    propCell = extend({\n      qRow: rowIdx\n    }, propCellFn(row));\n  }\n\n  target[targetProp] = datumExtract(p, propCell, {\n    key: sourceKey\n  });\n}\n\nfunction extract(config, dataset, cache, util) {\n  var cfgs = Array.isArray(config) ? config : [config];\n  var dataItems = [];\n\n  for (var i = 0; i < cfgs.length; i++) {\n    if (typeof cfgs[i].field !== 'undefined') {\n      var cube = dataset.raw();\n      var sourceKey = dataset.key();\n      var f = _typeof(cfgs[i].field) === 'object' ? cfgs[i].field : dataset.field(cfgs[i].field);\n\n      var _util$normalizeConfig = util.normalizeConfig(cfgs[i], dataset),\n          props = _util$normalizeConfig.props,\n          main = _util$normalizeConfig.main;\n\n      var propsArr = Object.keys(props);\n      var track = !!cfgs[i].trackBy;\n\n      var trackType = _typeof(cfgs[i].trackBy);\n\n      var tracker = {};\n      var trackedItems = [];\n      var items = [];\n\n      for (var j = 0; j < cube.qDataPages.length; j++) {\n        var fn = getFieldAccessor(f, cube.qDataPages[j], {\n          cache: cache\n        });\n\n        if (fn === -1) {\n          continue;\n        }\n\n        for (var k = 0; k < cube.qDataPages[j].qMatrix.length; k++) {\n          var rowIdx = cube.qDataPages[j].qArea.qTop + k;\n          var mainCell = extend({\n            qRow: rowIdx\n          }, fn(cube.qDataPages[j].qMatrix[k]));\n          var ret = datumExtract(main, mainCell, {\n            key: sourceKey\n          });\n          var exclude = main.filter && !main.filter(mainCell);\n\n          if (exclude) {\n            continue;\n          }\n\n          for (var l = 0; l < propsArr.length; l++) {\n            var p = props[propsArr[l]];\n            var arr = p.fields || [p];\n\n            if (p.fields) {\n              ret[propsArr[l]] = [];\n            } // loop through all props that need to be mapped and\n            // assign 'value' and 'source' to each property\n\n\n            for (var m = 0; m < arr.length; m++) {\n              cellToValue({\n                cache: cache,\n                f: f,\n                mainCell: mainCell,\n                p: arr[m],\n                prop: propsArr[l],\n                props: props,\n                page: cube.qDataPages[j],\n                rowIdx: rowIdx,\n                row: cube.qDataPages[j].qMatrix[k],\n                sourceKey: sourceKey,\n                target: p.fields ? ret[propsArr[l]] : ret,\n                targetProp: p.fields ? m : propsArr[l]\n              });\n            }\n\n            if (p.fields) {\n              var fieldValues = ret[propsArr[l]].map(function (v) {\n                return v.value;\n              });\n              var fieldLabels = ret[propsArr[l]].map(function (v) {\n                return v.label;\n              });\n              ret[propsArr[l]] = {\n                value: typeof p.value === 'function' ? p.value(fieldValues) : typeof p.value !== 'undefined' ? p.value : fieldValues,\n                label: typeof p.label === 'function' ? p.label(fieldLabels) : typeof p.label !== 'undefined' ? String(p.label) : String(ret[propsArr[l]].value)\n              };\n            }\n          } // collect items based on the trackBy value\n          // items with the same trackBy value are placed in an array and reduced later\n\n\n          if (track) {\n            util.track({\n              cfg: cfgs[i],\n              itemData: mainCell,\n              obj: ret,\n              target: trackedItems,\n              tracker: tracker,\n              trackType: trackType\n            });\n          }\n\n          items.push(ret);\n        }\n      } // reduce if items have been grouped\n\n\n      if (track) {\n        dataItems.push.apply(dataItems, _toConsumableArray(util.collect(trackedItems, {\n          main: main,\n          propsArr: propsArr,\n          props: props\n        })));\n      } else {\n        dataItems.push.apply(dataItems, items);\n      }\n    }\n  }\n\n  return dataItems;\n}\n\nfunction count(node) {\n  var sum = 0,\n      children = node.children,\n      i = children && children.length;\n  if (!i) sum = 1;\n  else while (--i >= 0) sum += children[i].value;\n  node.value = sum;\n}\n\nfunction node_count() {\n  return this.eachAfter(count);\n}\n\nfunction node_each(callback) {\n  var node = this, current, next = [node], children, i, n;\n  do {\n    current = next.reverse(), next = [];\n    while (node = current.pop()) {\n      callback(node), children = node.children;\n      if (children) for (i = 0, n = children.length; i < n; ++i) {\n        next.push(children[i]);\n      }\n    }\n  } while (next.length);\n  return this;\n}\n\nfunction node_eachBefore(callback) {\n  var node = this, nodes = [node], children, i;\n  while (node = nodes.pop()) {\n    callback(node), children = node.children;\n    if (children) for (i = children.length - 1; i >= 0; --i) {\n      nodes.push(children[i]);\n    }\n  }\n  return this;\n}\n\nfunction node_eachAfter(callback) {\n  var node = this, nodes = [node], next = [], children, i, n;\n  while (node = nodes.pop()) {\n    next.push(node), children = node.children;\n    if (children) for (i = 0, n = children.length; i < n; ++i) {\n      nodes.push(children[i]);\n    }\n  }\n  while (node = next.pop()) {\n    callback(node);\n  }\n  return this;\n}\n\nfunction node_sum(value) {\n  return this.eachAfter(function(node) {\n    var sum = +value(node.data) || 0,\n        children = node.children,\n        i = children && children.length;\n    while (--i >= 0) sum += children[i].value;\n    node.value = sum;\n  });\n}\n\nfunction node_sort(compare) {\n  return this.eachBefore(function(node) {\n    if (node.children) {\n      node.children.sort(compare);\n    }\n  });\n}\n\nfunction node_path(end) {\n  var start = this,\n      ancestor = leastCommonAncestor(start, end),\n      nodes = [start];\n  while (start !== ancestor) {\n    start = start.parent;\n    nodes.push(start);\n  }\n  var k = nodes.length;\n  while (end !== ancestor) {\n    nodes.splice(k, 0, end);\n    end = end.parent;\n  }\n  return nodes;\n}\n\nfunction leastCommonAncestor(a, b) {\n  if (a === b) return a;\n  var aNodes = a.ancestors(),\n      bNodes = b.ancestors(),\n      c = null;\n  a = aNodes.pop();\n  b = bNodes.pop();\n  while (a === b) {\n    c = a;\n    a = aNodes.pop();\n    b = bNodes.pop();\n  }\n  return c;\n}\n\nfunction node_ancestors() {\n  var node = this, nodes = [node];\n  while (node = node.parent) {\n    nodes.push(node);\n  }\n  return nodes;\n}\n\nfunction node_descendants() {\n  var nodes = [];\n  this.each(function(node) {\n    nodes.push(node);\n  });\n  return nodes;\n}\n\nfunction node_leaves() {\n  var leaves = [];\n  this.eachBefore(function(node) {\n    if (!node.children) {\n      leaves.push(node);\n    }\n  });\n  return leaves;\n}\n\nfunction node_links() {\n  var root = this, links = [];\n  root.each(function(node) {\n    if (node !== root) { // Don’t include the root’s parent, if any.\n      links.push({source: node.parent, target: node});\n    }\n  });\n  return links;\n}\n\nfunction hierarchy(data, children) {\n  var root = new Node(data),\n      valued = +data.value && (root.value = data.value),\n      node,\n      nodes = [root],\n      child,\n      childs,\n      i,\n      n;\n\n  if (children == null) children = defaultChildren;\n\n  while (node = nodes.pop()) {\n    if (valued) node.value = +node.data.value;\n    if ((childs = children(node.data)) && (n = childs.length)) {\n      node.children = new Array(n);\n      for (i = n - 1; i >= 0; --i) {\n        nodes.push(child = node.children[i] = new Node(childs[i]));\n        child.parent = node;\n        child.depth = node.depth + 1;\n      }\n    }\n  }\n\n  return root.eachBefore(computeHeight);\n}\n\nfunction node_copy() {\n  return hierarchy(this).eachBefore(copyData);\n}\n\nfunction defaultChildren(d) {\n  return d.children;\n}\n\nfunction copyData(node) {\n  node.data = node.data.data;\n}\n\nfunction computeHeight(node) {\n  var height = 0;\n  do node.height = height;\n  while ((node = node.parent) && (node.height < ++height));\n}\n\nfunction Node(data) {\n  this.data = data;\n  this.depth =\n  this.height = 0;\n  this.parent = null;\n}\n\nNode.prototype = hierarchy.prototype = {\n  constructor: Node,\n  count: node_count,\n  each: node_each,\n  eachAfter: node_eachAfter,\n  eachBefore: node_eachBefore,\n  sum: node_sum,\n  sort: node_sort,\n  path: node_path,\n  ancestors: node_ancestors,\n  descendants: node_descendants,\n  leaves: node_leaves,\n  links: node_links,\n  copy: node_copy\n};\n\nfunction required(f) {\n  if (typeof f !== \"function\") throw new Error;\n  return f;\n}\n\nvar keyPrefix = \"$\", // Protect against keys like “__proto__”.\n    preroot = {depth: -1},\n    ambiguous = {};\n\nfunction defaultId(d) {\n  return d.id;\n}\n\nfunction defaultParentId(d) {\n  return d.parentId;\n}\n\nfunction stratify() {\n  var id = defaultId,\n      parentId = defaultParentId;\n\n  function stratify(data) {\n    var d,\n        i,\n        n = data.length,\n        root,\n        parent,\n        node,\n        nodes = new Array(n),\n        nodeId,\n        nodeKey,\n        nodeByKey = {};\n\n    for (i = 0; i < n; ++i) {\n      d = data[i], node = nodes[i] = new Node(d);\n      if ((nodeId = id(d, i, data)) != null && (nodeId += \"\")) {\n        nodeKey = keyPrefix + (node.id = nodeId);\n        nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;\n      }\n    }\n\n    for (i = 0; i < n; ++i) {\n      node = nodes[i], nodeId = parentId(data[i], i, data);\n      if (nodeId == null || !(nodeId += \"\")) {\n        if (root) throw new Error(\"multiple roots\");\n        root = node;\n      } else {\n        parent = nodeByKey[keyPrefix + nodeId];\n        if (!parent) throw new Error(\"missing: \" + nodeId);\n        if (parent === ambiguous) throw new Error(\"ambiguous: \" + nodeId);\n        if (parent.children) parent.children.push(node);\n        else parent.children = [node];\n        node.parent = parent;\n      }\n    }\n\n    if (!root) throw new Error(\"no root\");\n    root.parent = preroot;\n    root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);\n    root.parent = null;\n    if (n > 0) throw new Error(\"cycle\");\n\n    return root;\n  }\n\n  stratify.id = function(x) {\n    return arguments.length ? (id = required(x), stratify) : id;\n  };\n\n  stratify.parentId = function(x) {\n    return arguments.length ? (parentId = required(x), stratify) : parentId;\n  };\n\n  return stratify;\n}\n\n/**\n * Resolves the value at the given JSON path\n * @private\n * @param  {String} path [description]\n * @param  {Object} obj  [description]\n * @return {Object}      [description]\n *\n * @example\n * let path = \"/path/to/paradise\";\n * let obj = {\n *   path: {\n *     to: { paradise: \"heaven\"},\n *     from: {...}\n *   }\n * };\n * resolve( path, obj ); // \"heaven\"\n */\nfunction resolve(path, obj) {\n  if (path.charAt(0) === '/') {\n    path = path.substring(1);\n  }\n\n  var arr = path.split('/');\n  var subpath;\n  var container = obj;\n\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i] === '*' && Array.isArray(container)) {\n      var carr = [];\n      subpath = arr.slice(i + 1).join('/');\n\n      for (var c = 0; c < container.length; c++) {\n        var v = resolve(subpath, container[c]); // v.forEach(_ => _._parent = container[c]);\n\n        if (Array.isArray(v)) {\n          carr.push.apply(carr, _toConsumableArray(v));\n        } else {\n          carr.push(v);\n        }\n      }\n\n      return carr; // return container.map(v => resolve(arr.slice(i + 1).join('/'), v));\n    }\n\n    if (!arr[i] && Array.isArray(container)) {\n      var _carr = new Array(container.length);\n\n      subpath = arr.slice(i + 1).join('/');\n\n      for (var _c = 0; _c < container.length; _c++) {\n        _carr[_c] = resolve(subpath, container[_c]);\n      }\n\n      return _carr; // return container.map(v => resolve(arr.slice(i + 1).join('/'), v));\n    }\n\n    if (arr[i] in container) {\n      container = container[arr[i]];\n    }\n  }\n\n  return container;\n}\n\nfunction flattenTree(children, steps, arrIndexAtTargetDepth) {\n  var arr = [];\n\n  if (!children || !children.length) {\n    return arr;\n  }\n\n  if (steps <= 0) {\n    var nodes = arrIndexAtTargetDepth >= 0 ? [children[arrIndexAtTargetDepth]] : children;\n    arr.push.apply(arr, _toConsumableArray(nodes));\n  } else {\n    for (var i = 0; i < children.length; i++) {\n      if (children[i].children && children[i].children.length) {\n        arr.push.apply(arr, _toConsumableArray(flattenTree(children[i].children, steps - 1, arrIndexAtTargetDepth)));\n      }\n    }\n  }\n\n  return arr;\n}\n\nfunction treeAccessor(sourceDepth, targetDepth, arrIndexAtTargetDepth) {\n  if (sourceDepth === targetDepth) {\n    return function (d) {\n      return d;\n    };\n  }\n\n  if (sourceDepth > targetDepth) {\n    // traverse upwards\n    var steps = Math.max(0, Math.min(100, sourceDepth - targetDepth));\n\n    var path = _toConsumableArray(Array(steps)).map(String.prototype.valueOf, 'parent').join('.');\n\n    return Function('node', \"return node.\".concat(path, \";\")); // eslint-disable-line no-new-func\n  }\n\n  if (targetDepth > sourceDepth) {\n    // flatten descendants\n    var _steps = Math.max(0, Math.min(100, targetDepth - sourceDepth));\n\n    return function (node) {\n      return flattenTree(node.children, _steps - 1, arrIndexAtTargetDepth);\n    };\n  }\n\n  return false;\n}\nfunction findField(query, _ref) {\n  var cache = _ref.cache;\n\n  if (typeof query === 'number') {\n    return cache.fields[query];\n  }\n\n  var allFields = cache.allFields;\n\n  if (typeof query === 'function') {\n    for (var i = 0; i < allFields.length; i++) {\n      if (query(allFields[i])) {\n        return allFields[i];\n      }\n    }\n\n    return false;\n  }\n\n  if (typeof query === 'string') {\n    for (var _i = 0; _i < allFields.length; _i++) {\n      if (allFields[_i].key() === query || allFields[_i].title() === query) {\n        return allFields[_i];\n      }\n    }\n  } else if (query && allFields.indexOf(query) !== -1) {\n    // assume 'query' is a field instance\n    return query;\n  }\n\n  throw Error(\"Field not found: \".concat(query));\n}\n\nvar DIM_RX = /^qDimensionInfo(?:\\/(\\d+))?/;\nvar M_RX = /^\\/?qMeasureInfo\\/(\\d+)/;\nvar ATTR_EXPR_RX = /\\/qAttrExprInfo\\/(\\d+)/;\nvar ATTR_DIM_RX = /\\/qAttrDimInfo\\/(\\d+)/;\n\nfunction getColumnOrder(dataset) {\n  var qColumnOrder = dataset.raw().qColumnOrder;\n  var fields = dataset.fields();\n  return qColumnOrder && qColumnOrder.length === fields.length ? qColumnOrder : fields.map(function (f, i) {\n    return i;\n  });\n}\n\nfunction getDimensionColumnOrder(cube) {\n  var order = cube.qColumnOrder && cube.qColumnOrder.length ? cube.qColumnOrder : cube.qDimensionInfo.map(function (d, ii) {\n    return ii;\n  });\n  return order.filter(function (ii) {\n    return ii < cube.qDimensionInfo.length;\n  });\n}\n\nfunction getFieldDepth(field, _ref) {\n  var cube = _ref.cube;\n\n  if (!field) {\n    return -1;\n  }\n\n  var key = field.origin && field.origin() ? field.origin().key() : field.key();\n  var isFieldDimension = false;\n  var fieldIdx = -1; // cache.fields.indexOf(field);\n\n  var attrIdx = -1;\n  var attrDimIdx = -1;\n  var fieldDepth = -1;\n  var pseudoMeasureIndex = -1;\n  var measureIdx = -1;\n  var remainder = key;\n  var treeOrder = cube.qEffectiveInterColumnSortOrder;\n  var columnOrder = getDimensionColumnOrder(cube);\n\n  if (DIM_RX.test(remainder)) {\n    isFieldDimension = true;\n    fieldIdx = +DIM_RX.exec(remainder)[1];\n    remainder = key.replace(DIM_RX, '');\n  }\n\n  if (M_RX.test(remainder)) {\n    if (cube.qMode === 'K') {\n      pseudoMeasureIndex = +M_RX.exec(remainder)[1];\n    } else if (treeOrder && treeOrder.indexOf(-1) !== -1) {\n      pseudoMeasureIndex = +M_RX.exec(remainder)[1];\n      measureIdx = 0;\n    } else {\n      measureIdx = +M_RX.exec(remainder)[1];\n    }\n\n    remainder = remainder.replace(M_RX, '');\n  }\n\n  if (remainder) {\n    if (ATTR_DIM_RX.exec(remainder)) {\n      attrDimIdx = +ATTR_DIM_RX.exec(remainder)[1];\n    } else if (ATTR_EXPR_RX.exec(remainder)) {\n      attrIdx = +ATTR_EXPR_RX.exec(remainder)[1];\n    }\n  }\n\n  if (isFieldDimension) {\n    if (cube.qMode === 'S') {\n      fieldDepth = columnOrder[fieldIdx];\n    } else {\n      fieldDepth = treeOrder ? treeOrder.indexOf(fieldIdx) : fieldIdx;\n    }\n  } else if (treeOrder && treeOrder.indexOf(-1) !== -1) {\n    // if pseudo dimension exists in sort order\n    fieldDepth = treeOrder.indexOf(-1); // depth of pesudodimension\n  } else {\n    // assume measure is at the bottom of the tree\n    fieldDepth = cube.qDimensionInfo.length - (cube.qMode === 'K' ? 0 : 1);\n  }\n\n  return {\n    fieldDepth: fieldDepth + 1,\n    // +1 due to root node\n    pseudoMeasureIndex: pseudoMeasureIndex,\n    measureIdx: measureIdx,\n    attrDimIdx: attrDimIdx,\n    attrIdx: attrIdx\n  };\n}\n\nfunction getFieldAccessor$1(sourceDepthObject, targetDepthObject) {\n  var nodeFn = treeAccessor(sourceDepthObject.fieldDepth, targetDepthObject.fieldDepth, targetDepthObject.pseudoMeasureIndex);\n  var valueFn;\n\n  if (targetDepthObject.measureIdx >= 0) {\n    valueFn = function valueFn(node) {\n      return node.data.qValues[targetDepthObject.measureIdx];\n    };\n  } else {\n    valueFn = function valueFn(node) {\n      return node.data;\n    };\n  }\n\n  var attrFn;\n\n  if (targetDepthObject.attrDimIdx >= 0) {\n    attrFn = function attrFn(data) {\n      return data.qAttrDims.qValues[targetDepthObject.attrDimIdx];\n    };\n  } else if (targetDepthObject.attrIdx >= 0) {\n    attrFn = function attrFn(data) {\n      return data.qAttrExps.qValues[targetDepthObject.attrIdx];\n    };\n  }\n\n  return {\n    nodeFn: nodeFn,\n    attrFn: attrFn,\n    valueFn: valueFn\n  };\n}\n\nfunction datumExtract$1(propCfg, cell, _ref2) {\n  var key = _ref2.key;\n  var datum = {\n    value: typeof propCfg.value === 'function' ? propCfg.value(cell) : typeof propCfg.value !== 'undefined' ? propCfg.value : cell // eslint-disable-line no-nested-ternary\n\n  };\n  datum.label = typeof propCfg.label === 'function' ? propCfg.label(cell) : typeof propCfg.label !== 'undefined' ? String(propCfg.label) : String(datum.value); // eslint-disable-line no-nested-ternary\n\n  if (propCfg.field) {\n    datum.source = {\n      key: key,\n      field: propCfg.field.key()\n    };\n  }\n\n  return datum;\n}\n\nfunction doIt(_ref3) {\n  var propsArr = _ref3.propsArr,\n      props = _ref3.props,\n      item = _ref3.item,\n      itemData = _ref3.itemData,\n      ret = _ref3.ret,\n      sourceKey = _ref3.sourceKey;\n\n  for (var i = 0; i < propsArr.length; i++) {\n    var pCfg = props[propsArr[i]];\n    var arr = pCfg.fields || [pCfg];\n    var coll = void 0;\n    var collStr = void 0;\n\n    if (pCfg.fields) {\n      coll = [];\n      collStr = [];\n    }\n\n    var _loop = function _loop(j) {\n      var p = arr[j];\n      var fn = void 0;\n      var str = void 0;\n      var value = void 0;\n      var nodes = void 0;\n      var cells = void 0;\n      var label = void 0;\n\n      if (p.type === 'primitive') {\n        value = p.value;\n        label = String(p.value);\n      } else {\n        if (typeof p.value === 'function') {\n          fn = function fn(v) {\n            return p.value(v, item);\n          };\n        }\n\n        if (typeof p.label === 'function') {\n          str = function str(v) {\n            return p.label(v, item);\n          };\n        }\n\n        if (p.accessor) {\n          nodes = p.accessor(item);\n\n          if (Array.isArray(nodes)) {\n            // propably descendants\n            cells = nodes.map(p.valueAccessor);\n\n            if (p.attrAccessor) {\n              cells = cells.map(p.attrAccessor);\n            }\n\n            if (fn) {\n              value = cells.map(fn);\n              fn = null;\n            }\n\n            if (str) {\n              label = cells.map(str);\n              str = null;\n            }\n\n            value = p.reduce ? p.reduce(value) : value;\n            label = p.reduceLabel ? p.reduceLabel(label, value) : String(value);\n          } else {\n            value = p.attrAccessor ? p.attrAccessor(p.valueAccessor(nodes)) : p.valueAccessor(nodes);\n            label = value;\n          }\n        } else {\n          value = itemData;\n          label = itemData;\n        }\n      }\n\n      if (pCfg.fields) {\n        var v = fn ? fn(value) : value;\n        coll.push(v);\n        collStr.push(str && label != null ? str(label) : label != null ? label : String(v));\n      } else {\n        var _v = fn ? fn(value) : value;\n\n        ret[propsArr[i]] = {\n          value: _v,\n          label: str ? str(label) : label != null ? label : String(_v)\n        };\n\n        if (p.field) {\n          ret[propsArr[i]].source = {\n            field: p.field.key(),\n            key: sourceKey\n          };\n        }\n      }\n    };\n\n    for (var j = 0; j < arr.length; j++) {\n      _loop(j);\n    }\n\n    if (coll) {\n      ret[propsArr[i]] = {\n        value: typeof pCfg.value === 'function' ? pCfg.value(coll, item) : coll,\n        label: typeof pCfg.label === 'function' ? pCfg.label(collStr, item) : collStr\n      };\n    }\n  }\n}\n\nvar getHierarchy = function getHierarchy(cube, cache, config) {\n  var rootPath = cube.qMode === 'K' ? '/qStackedDataPages/*/qData' : '/qTreeDataPages/*';\n  var childNodes = cube.qMode === 'K' ? 'qSubNodes' : 'qNodes';\n  var root = resolve(rootPath, cube);\n\n  if (!root || !root[0]) {\n    return null;\n  }\n\n  cache.tree = hierarchy(root[0], config.children || function (node) {\n    return node[childNodes];\n  });\n  return cache.tree;\n};\n\nfunction getHierarchyForSMode(dataset) {\n  var matrix = dataset.raw().qDataPages.length ? dataset.raw().qDataPages[0].qMatrix : [];\n  var order = getColumnOrder(dataset);\n  var fields = dataset.fields();\n  var dimensions = dataset.fields().filter(function (f) {\n    return f.type() === 'dimension';\n  }).map(function (f) {\n    return order.indexOf(fields.indexOf(f));\n  });\n  var measures = dataset.fields().filter(function (f) {\n    return f.type() === 'measure';\n  }).map(function (f) {\n    return order.indexOf(fields.indexOf(f));\n  });\n  var root = {\n    __id: '__root',\n    qValues: []\n  };\n  var keys = {\n    __root: root\n  };\n\n  for (var r = 0; r < matrix.length; r++) {\n    var row = matrix[r];\n    var id = '__root'; // let parent = root;\n\n    var isNew = false;\n\n    for (var c = 0; c < dimensions.length; c++) {\n      var cell = row[dimensions[c]];\n      var key = \"\".concat(id, \"__\").concat(cell.qText);\n\n      if (!keys[key]) {\n        keys[key] = _objectSpread2({\n          __id: key,\n          __parent: id,\n          qValues: []\n        }, cell);\n        isNew = true;\n      }\n\n      id = key;\n    }\n\n    if (isNew) {\n      for (var _c = 0; _c < measures.length; _c++) {\n        var _cell = row[measures[_c]];\n        keys[id].qValues.push(_cell);\n      }\n    }\n  }\n\n  var nodes = Object.keys(keys).map(function (key) {\n    return keys[key];\n  });\n  var h = stratify().id(function (d) {\n    return d.__id;\n  }).parentId(function (d) {\n    return d.__parent;\n  })(nodes);\n  return h;\n}\n\nvar attachPropsAccessors = function attachPropsAccessors(_ref4) {\n  var propsArr = _ref4.propsArr,\n      props = _ref4.props,\n      cube = _ref4.cube,\n      cache = _ref4.cache,\n      itemDepthObject = _ref4.itemDepthObject,\n      f = _ref4.f;\n\n  for (var i = 0; i < propsArr.length; i++) {\n    var pCfg = props[propsArr[i]];\n    var arr = pCfg.fields ? pCfg.fields : [pCfg];\n\n    for (var j = 0; j < arr.length; j++) {\n      var p = arr[j];\n\n      if (p.field !== f) {\n        var depthObject = getFieldDepth(p.field, {\n          cube: cube,\n          cache: cache\n        });\n        var accessors = getFieldAccessor$1(itemDepthObject, depthObject);\n        p.accessor = accessors.nodeFn; // nodes accessor\n\n        p.valueAccessor = accessors.valueFn; // cell accessor\n\n        p.attrAccessor = accessors.attrFn; // attr cell accessor\n      }\n    }\n  }\n};\n\nfunction augment() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var dataset = arguments.length > 1 ? arguments[1] : undefined;\n  var cache = arguments.length > 2 ? arguments[2] : undefined;\n  var util = arguments.length > 3 ? arguments[3] : undefined;\n  var cube = dataset.raw();\n  var sourceKey = dataset.key();\n  var h = cube.qMode === 'S' ? getHierarchyForSMode(dataset) : getHierarchy(cube, cache, config);\n\n  if (!h) {\n    return null;\n  }\n\n  var height = h.height;\n  var propDefs = [];\n\n  for (var i = 0; i <= height; i++) {\n    var f = null;\n\n    if (i > 0) {\n      if (cube.qMode === 'S') {\n        var order = getDimensionColumnOrder(cube);\n        var idx = order[i - 1];\n        f = cache.fields[idx];\n      } else {\n        var _idx = cube.qEffectiveInterColumnSortOrder[i - 1]; // if (idx === -1) { // pseudo\n        //   let childIdx = node.parent.children.indexOf(node);\n        //   idx = cube.qDimensionInfo.length + childIdx; // measure field\n        // }\n\n        if (i > cube.qEffectiveInterColumnSortOrder.length) {\n          _idx = cube.qDimensionInfo.length;\n        }\n\n        f = cache.fields[_idx];\n      }\n    }\n\n    var _util$normalizeConfig = util.normalizeConfig(_objectSpread2({}, config, {\n      field: f ? f.key() : undefined\n    }), dataset),\n        props = _util$normalizeConfig.props,\n        main = _util$normalizeConfig.main;\n\n    var propsArr = Object.keys(props);\n    propDefs[i] = {\n      propsArr: propsArr,\n      props: props,\n      main: main\n    };\n    var itemDepthObject = f ? getFieldDepth(f, {\n      cube: cube,\n      cache: cache\n    }) : {\n      fieldDepth: 0\n    };\n    attachPropsAccessors({\n      propsArr: propsArr,\n      props: props,\n      cube: cube,\n      cache: cache,\n      itemDepthObject: itemDepthObject,\n      f: f\n    });\n  }\n\n  var replica = h.copy();\n  var replicaDescendants = replica.descendants();\n  var descendants = h.descendants();\n\n  for (var _i = 0; _i < descendants.length; _i++) {\n    var _propsArr = propDefs[descendants[_i].depth].propsArr;\n    var props = propDefs[descendants[_i].depth].props;\n    var main = propDefs[descendants[_i].depth].main;\n    var item = replicaDescendants[_i];\n    var itemData = item.data; // main.valueAccessor(currentOriginal);\n\n    var ret = datumExtract$1(main, itemData, {\n      key: sourceKey\n    });\n    doIt({\n      propsArr: _propsArr,\n      props: props,\n      item: item,\n      itemData: itemData,\n      ret: ret,\n      sourceKey: sourceKey,\n      isTree: true\n    });\n    descendants[_i].data = ret;\n  }\n\n  return h;\n}\nfunction extract$1(config, dataset, cache, util) {\n  var cfgs = Array.isArray(config) ? config : [config];\n  var dataItems = [];\n\n  for (var g = 0; g < cfgs.length; g++) {\n    if (typeof cfgs[g].field !== 'undefined') {\n      var cube = dataset.raw();\n      var sourceKey = dataset.key();\n      var h = getHierarchy(cube, cache, config);\n\n      if (!h) {\n        continue;\n      }\n\n      var f = _typeof(cfgs[g].field) === 'object' ? cfgs[g].field : dataset.field(cfgs[g].field);\n\n      var _util$normalizeConfig2 = util.normalizeConfig(cfgs[g], dataset),\n          props = _util$normalizeConfig2.props,\n          main = _util$normalizeConfig2.main;\n\n      var propsArr = Object.keys(props);\n      var itemDepthObject = getFieldDepth(f, {\n        cube: cube,\n        cache: cache\n      });\n\n      var _getFieldAccessor = getFieldAccessor$1({\n        fieldDepth: 0\n      }, itemDepthObject),\n          nodeFn = _getFieldAccessor.nodeFn,\n          attrFn = _getFieldAccessor.attrFn,\n          valueFn = _getFieldAccessor.valueFn;\n\n      attachPropsAccessors({\n        propsArr: propsArr,\n        props: props,\n        cube: cube,\n        cache: cache,\n        itemDepthObject: itemDepthObject,\n        f: f\n      });\n      var track = !!cfgs[g].trackBy;\n\n      var trackType = _typeof(cfgs[g].trackBy);\n\n      var tracker = {};\n      var trackedItems = [];\n      var items = nodeFn(cache.tree);\n      var mapped = [];\n\n      for (var i = 0; i < items.length; i++) {\n        var item = items[i];\n        var itemData = attrFn ? attrFn(valueFn(item)) : valueFn(item);\n        var exclude = main.filter && !main.filter(itemData);\n\n        if (exclude) {\n          continue;\n        }\n\n        var ret = datumExtract$1(main, itemData, {\n          key: sourceKey\n        });\n        doIt({\n          propsArr: propsArr,\n          props: props,\n          item: item,\n          itemData: itemData,\n          ret: ret,\n          sourceKey: sourceKey\n        }); // collect items based on the trackBy value\n        // items with the same trackBy value are placed in an array and reduced later\n\n        if (track) {\n          util.track({\n            cfg: cfgs[g],\n            itemData: itemData,\n            obj: ret,\n            target: trackedItems,\n            tracker: tracker,\n            trackType: trackType\n          });\n        }\n\n        mapped.push(ret);\n      } // reduce if items have been grouped\n\n\n      if (track) {\n        dataItems.push.apply(dataItems, _toConsumableArray(util.collect(trackedItems, {\n          main: main,\n          propsArr: propsArr,\n          props: props\n        })));\n      } else {\n        dataItems.push.apply(dataItems, mapped);\n      }\n    }\n  }\n\n  return dataItems;\n}\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar format_min = createCommonjsModule(function (module) {\n/*! javascript-number-formatter - v1.1.11 - http://mottie.github.com/javascript-number-formatter/ * © ecava */\n!function(a,b){module.exports=b();}(commonjsGlobal,function(){return function(a,b){if(!a||isNaN(+b))return b;var c,d,e,f,g,h,i,j,k,l,m=a.length,n=a.search(/[0-9\\-\\+#]/),o=n>0?a.substring(0,n):\"\",p=a.split(\"\").reverse().join(\"\"),q=p.search(/[0-9\\-\\+#]/),r=m-q,s=a.substring(r,r+1),t=r+(\".\"===s||\",\"===s?1:0),u=q>0?a.substring(t,m):\"\";if(a=a.substring(n,t),b=\"-\"===a.charAt(0)?-b:+b,c=b<0?b=-b:0,d=a.match(/[^\\d\\-\\+#]/g),e=d&&d[d.length-1]||\".\",f=d&&d[1]&&d[0]||\",\",a=a.split(e),b=b.toFixed(a[1]&&a[1].length),b=+b+\"\",h=a[1]&&a[1].lastIndexOf(\"0\"),j=b.split(\".\"),(!j[1]||j[1]&&j[1].length<=h)&&(b=(+b).toFixed(h+1)),k=a[0].split(f),a[0]=k.join(\"\"),g=a[0]&&a[0].indexOf(\"0\"),g>-1)for(;j[0].length<a[0].length-g;)j[0]=\"0\"+j[0];else 0===+j[0]&&(j[0]=\"\");if(b=b.split(\".\"),b[0]=j[0],i=k[1]&&k[k.length-1].length){for(l=b[0],p=\"\",r=l.length%i,m=l.length,t=0;t<m;t++)p+=l.charAt(t),!((t-r+1)%i)&&t<m-i&&(p+=f);b[0]=p;}return b[1]=a[1]&&b[1]?e+b[1]:\"\",d=b.join(\"\"),\"0\"!==d&&\"\"!==d||(c=!1),o+((c?\"-\":\"\")+d)+u}});\n});\n\nfunction escapeRegExp(str) {\n  return str.replace(/[-[\\]/{}()*+?.\\\\^$|]/g, '\\\\$&');\n}\n\nvar SIprefixes = {\n  3: 'k',\n  6: 'M',\n  9: 'G',\n  12: 'T',\n  15: 'P',\n  18: 'E',\n  21: 'Z',\n  24: 'Y',\n  '-3': 'm',\n  '-6': 'μ',\n  '-9': 'n',\n  '-12': 'p',\n  '-15': 'f',\n  '-18': 'a',\n  '-21': 'z',\n  '-24': 'y'\n},\n    percentage = /%$/,\n    //    scientific = /e[\\+\\-][0-9]+/,\nradix = /^\\(r(0[2-9]|[12]\\d|3[0-6])\\)/i,\n    oct = /^\\(oct\\)/i,\n    dec = /^\\(dec\\)/i,\n    hex = /^\\(hex\\)/i,\n    bin = /^\\(bin\\)/i,\n    rom = /^\\(rom\\)/i,\n    functional = /^(\\(rom\\)|\\(bin\\)|\\(hex\\)|\\(dec\\)|\\(oct\\)|\\(r(0[2-9]|[12]\\d|3[0-6])\\))/i,\n    prec = /#|0/g;\n\nfunction formatRadix(value, fradix, pattern, decimal) {\n  value = value.toString(fradix);\n\n  if (pattern[1] === pattern[1].toUpperCase()) {\n    value = value.toUpperCase();\n  }\n\n  if (value.length - value.indexOf('.') > 10) {\n    // limit to 10 decimal places\n    value = value.slice(0, value.indexOf('.') + 11);\n  }\n\n  return value.replace('.', decimal || '.');\n} // value must be an integer\n// value must not be in scientific notation\n\n\nfunction formatRoman(value, pattern) {\n  var i,\n      s = '',\n      v = Number(String(value).slice(-3)),\n      nThousands = (value - v) / 1000,\n      decimal = [0, 1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900].reverse(),\n      numeral = ['0', 'I', 'IV', 'V', 'IX', 'X', 'XL', 'L', 'XC', 'C', 'CD', 'D', 'CM'].reverse();\n\n  while (v > 0) {\n    for (i = 0; i < decimal.length; i++) {\n      if (decimal[i] <= v) {\n        s += numeral[i];\n        v -= decimal[i];\n        break;\n      }\n    }\n  }\n\n  for (i = 0; i < nThousands; i++) {\n    s = \"M\".concat(s);\n  }\n\n  if (pattern[1] !== pattern[1].toUpperCase()) {\n    s = s.toLowerCase();\n  }\n\n  return s;\n}\n\nfunction formatFunctional(value, pattern, d) {\n  var temp;\n\n  if (radix.test(pattern)) {\n    value = formatRadix(value, Number(/\\d{2}/.exec(pattern)[0]), pattern, d);\n  } else if (oct.test(pattern)) {\n    value = formatRadix(value, 8, pattern, d);\n  } else if (dec.test(pattern)) {\n    value = formatRadix(value, 10, pattern, d);\n  } else if (hex.test(pattern)) {\n    value = formatRadix(value, 16, pattern, d);\n  } else if (bin.test(pattern)) {\n    value = formatRadix(value, 2, pattern, d);\n  } else if (rom.test(pattern)) {\n    temp = '';\n\n    if (value < 0) {\n      temp = '-';\n      value = -value;\n    }\n\n    value = Math.floor(value);\n\n    if (value === 0) {\n      value = '0';\n    } else if (value <= 500000) {\n      // limit in engine\n      value = formatRoman(value, pattern);\n      value = temp + value;\n    } else {\n      value = pattern + temp + value.toExponential(0); // to return same result as engine\n    }\n  }\n\n  return value;\n}\n\nfunction escape(value, flags, justStr) {\n  var str = escapeRegExp(value);\n\n  if (justStr) {\n    return str;\n  }\n\n  return new RegExp(str || '', flags);\n}\n\nfunction createRegExp(thousand, decimal) {\n  if (decimal) {\n    decimal = escapeRegExp(decimal);\n  }\n\n  if (thousand) {\n    thousand = escapeRegExp(thousand);\n  }\n\n  return new RegExp(\"(?:[#0]+\".concat(thousand, \")?[#0]+(?:\").concat(decimal, \"[#0]+)?\"));\n}\n\nfunction getAbbreviations(localeInfo, listSeparator) {\n  if (!localeInfo || !localeInfo.qNumericalAbbreviation) {\n    return SIprefixes;\n  }\n\n  var abbreviations = {};\n  var abbrs = localeInfo.qNumericalAbbreviation.split(listSeparator);\n  abbrs.forEach(function (abbreviation) {\n    var abbreviationTuple = abbreviation.split(':');\n\n    if (abbreviationTuple.length === 2) {\n      abbreviations[abbreviationTuple[0]] = abbreviationTuple[1];\n    }\n  });\n  return abbreviations;\n}\n\nfunction preparePattern(o, t, d) {\n  var parts,\n      lastPart,\n      pattern = o.pattern,\n      numericPattern,\n      prefix,\n      postfix,\n      groupTemp,\n      decTemp,\n      temp,\n      regex;\n\n  if (pattern.indexOf('A') >= 0) {\n    // abbreviate SI\n    pattern = pattern.replace('A', '');\n    o.abbreviate = true;\n  } // extract the numeric part from the pattern\n\n\n  regex = createRegExp(t, d);\n  numericPattern = pattern.match(regex);\n  numericPattern = numericPattern ? numericPattern[0] : '';\n  prefix = numericPattern ? pattern.substr(0, pattern.indexOf(numericPattern)) : pattern;\n  postfix = numericPattern ? pattern.substring(pattern.indexOf(numericPattern) + numericPattern.length) : '';\n\n  if (!numericPattern) {\n    numericPattern = pattern ? '#' : '##########';\n  }\n\n  if (t && t === d) {\n    // ignore grouping if grouping separator is same as decimal separator\n    // extract decimal part\n    parts = numericPattern.split(d);\n    lastPart = parts.pop();\n    numericPattern = parts.join('') + d + lastPart;\n    t = '';\n  } // formatting library does not support multiple characters as separator (nor +-).\n  // do a temporary replacement\n\n\n  groupTemp = t;\n  t = /,/.test(d) ? '¤' : ',';\n\n  if (groupTemp) {\n    numericPattern = numericPattern.replace(escape(groupTemp, 'g'), t);\n  }\n\n  decTemp = d;\n  d = '.';\n\n  if (decTemp) {\n    numericPattern = numericPattern.replace(escape(decTemp, 'g'), d);\n  }\n\n  temp = numericPattern.match(/#/g);\n  temp = temp ? temp.length : 0;\n  var splitPattern = pattern.split(decTemp);\n  var matchPrecisionResult;\n\n  if (splitPattern[1]) {\n    matchPrecisionResult = splitPattern[1].match(prec);\n  }\n\n  o.prefix = prefix || '';\n  o.postfix = postfix || '';\n  o.pattern = pattern;\n  o.maxPrecision = matchPrecisionResult ? matchPrecisionResult.length : 2;\n  o.percentage = percentage.test(pattern);\n  o.numericPattern = numericPattern || '';\n  o.numericRegex = new RegExp(\"\".concat(escape(t, null, true), \"|\").concat(escape(d, null, true)), 'g');\n  o.groupTemp = groupTemp;\n  o.decTemp = decTemp;\n  o.t = t;\n  o.d = d;\n  o.temp = temp;\n}\n\nvar NumberFormatter =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @name NumberFormatter\n   * @constructs\n   * @param {Object} localeInfo\n   * @param {String} pattern\n   * @param {String} [thousand]\n   * @param {String} [decimal]\n   * @param {String} [type]\n   */\n  function NumberFormatter(localeInfo, pattern, thousand, decimal, type) {\n    _classCallCheck(this, NumberFormatter);\n\n    this.localeInfo = localeInfo;\n    this.pattern = pattern;\n    this.thousandDelimiter = thousand || ',';\n    this.decimalDelimiter = decimal || '.';\n    this.type = type || 'numeric'; // FIXME qListSep?\n    // this.patternSeparator = this.localeInfo && this.localeInfo.qListSep ? this.localeInfo.qListSep : ';';\n\n    this.patternSeparator = ';';\n    this.abbreviations = getAbbreviations(localeInfo, this.patternSeparator);\n    this.prepare();\n  }\n\n  _createClass(NumberFormatter, [{\n    key: \"clone\",\n    value: function clone() {\n      var n = new NumberFormatter(this.localeInfo, this.pattern, this.thousandDelimiter, this.decimalDelimiter, this.type);\n      n.subtype = this.subtype;\n      return n;\n    }\n    /**\n     * Formats a number according to a specific pattern.\n     * Use # for optional numbers and 0 for padding.\n     * @param {Number} value Number to format.\n     * @param {String} [pattern] The pattern to apply.\n     * @param {String} [t] Grouping separator.\n     * @param {String} [d] Decimal delimiter.\n     * @example\n     * format(10, \"0\") // 10;\n     * format(10, \"#\") // 10;\n     * format(10, \"##.#\") // 10;\n     * format(10, \"##.0\") // 10.0;\n     * format(10, \"000\") // 010;\n     * format(10.123, \"0.0\") // 10.1;\n     * format(10.123, \"0.00##\") // 10.123; // at least 2 decimals, never more than 4\n     * format(123456789, \"#,###\") // 123,456,789;\n     * format(123456789, \"####-####\", \"-\") // 1-2345-6789;\n     * format(10000, \"#A\") // 10k,  A -> SI abbreviation\n     * format(1234567, \"#.###A\") // 1.235M;\n     * format(0.0001, \"#.#A\") // 0.1m;\n     *\n     * format(0.257, \"0.0%\") // 25.7%; // will multiply by 100\n     * format(9876, \"$#,###\") // $9,876;\n     * format(-9876, \"$#,###;$(#,###)\") // $(9,876); // use ; for alternative formatting for negative values\n     * format(10, \"(r16)\") // a; // radix 16\n     * format(15, \"(hex)\") // f; // same as (r16)\n     * format(15, \"(HEX)\") // F;\n     * format(10, \"(bin)\") // 1010; // same as (r02)\n     * format(10, \"(oct)\") // 12; // same as (r08)\n     */\n\n  }, {\n    key: \"format\",\n    value: function format(value, pattern, t, d) {\n      this.prepare(pattern, t, d);\n      return this.formatValue(value);\n    }\n  }, {\n    key: \"prepare\",\n    value: function prepare(pattern, t, d) {\n      var prep;\n\n      if (typeof pattern === 'undefined') {\n        pattern = this.pattern;\n      }\n\n      if (typeof t === 'undefined') {\n        t = this.thousandDelimiter;\n      }\n\n      if (typeof d === 'undefined') {\n        d = this.decimalDelimiter;\n      }\n\n      if (!pattern) {\n        this._prepared = {\n          pattern: false\n        };\n        return;\n      }\n\n      this._prepared = {\n        positive: {\n          d: d,\n          t: t,\n          abbreviate: false,\n          isFunctional: false,\n          prefix: '',\n          postfix: ''\n        },\n        negative: {\n          d: d,\n          t: t,\n          abbreviate: false,\n          isFunctional: false,\n          prefix: '',\n          postfix: ''\n        },\n        zero: {\n          d: d,\n          t: t,\n          abbreviate: false,\n          isFunctional: false,\n          prefix: '',\n          postfix: ''\n        }\n      };\n      prep = this._prepared;\n      pattern = pattern.split(this.patternSeparator);\n      prep.positive.pattern = pattern[0];\n      prep.negative.pattern = pattern[1];\n      prep.zero.pattern = pattern[2];\n\n      if (functional.test(pattern[0])) {\n        prep.positive.isFunctional = true;\n      }\n\n      if (!pattern[1]) {\n        prep.negative = false;\n      } else if (functional.test(pattern[1])) {\n        prep.negative.isFunctional = true;\n      }\n\n      if (!pattern[2]) {\n        prep.zero = false;\n      } else if (functional.test(pattern[2])) {\n        prep.zero.isFunctional = true;\n      }\n\n      if (!prep.positive.isFunctional) {\n        preparePattern(prep.positive, t, d);\n      }\n\n      if (prep.negative && !prep.negative.isFunctional) {\n        preparePattern(prep.negative, t, d);\n      }\n\n      if (prep.zero && !prep.zero.isFunctional) {\n        preparePattern(prep.zero, t, d);\n      }\n    }\n  }, {\n    key: \"formatValue\",\n    value: function formatValue(value) {\n      var prep = this._prepared,\n          temp,\n          exponent,\n          abbr = '',\n          absValue,\n          num,\n          sciValue = '',\n          d,\n          t,\n          i,\n          numericPattern,\n          decimalPartPattern,\n          original = value;\n\n      if (isNaN(value)) {\n        return \"\".concat(original);\n      }\n\n      value = +value;\n\n      if (prep.pattern === false) {\n        return value.toString();\n      }\n\n      if (value === 0 && prep.zero) {\n        prep = prep.zero;\n        return prep.pattern;\n      }\n\n      if (value < 0 && prep.negative) {\n        prep = prep.negative;\n        value = -value;\n      } else {\n        prep = prep.positive;\n      }\n\n      d = prep.d;\n      t = prep.t;\n\n      if (prep.isFunctional) {\n        value = formatFunctional(value, prep.pattern, d);\n      } else {\n        if (prep.percentage) {\n          value *= 100;\n        }\n\n        if (prep.abbreviate) {\n          var abbrArray = Object.keys(this.abbreviations).map(function (key) {\n            return parseInt(key, 10);\n          }).sort(function (a, b) {\n            return a - b;\n          });\n          var lowerAbbreviation;\n          var upperAbbreviation = abbrArray[0];\n          i = 0;\n          exponent = Number(Number(value).toExponential().split('e')[1]);\n\n          while (upperAbbreviation <= exponent && i < abbrArray.length) {\n            i++;\n            upperAbbreviation = abbrArray[i];\n          }\n\n          if (i > 0) {\n            lowerAbbreviation = abbrArray[i - 1];\n          }\n\n          var suggestedAbbrExponent; // value and lower abbreviation is for values above 10, use the lower (move to the left <==)\n\n          if (lowerAbbreviation && exponent > 0 && lowerAbbreviation > 0) {\n            suggestedAbbrExponent = lowerAbbreviation; // value and lower abbreviation is for values below 0.1 (move to the right ==>)\n          } else if (exponent < 0 && lowerAbbreviation < 0 || !lowerAbbreviation) {\n            // upper abbreviation is also for values below 0.1 and precision allows for using the upper abbreviation(move to the right ==>)\n            if (upperAbbreviation < 0 && upperAbbreviation - exponent <= prep.maxPrecision) {\n              suggestedAbbrExponent = upperAbbreviation; // lower abbrevaition is smaller than exponent and we can't get away with not abbreviating\n            } else if (lowerAbbreviation <= exponent && !(upperAbbreviation > 0 && -exponent <= prep.maxPrecision)) {\n              // (move to left <==)\n              suggestedAbbrExponent = lowerAbbreviation;\n            }\n          }\n\n          if (suggestedAbbrExponent) {\n            abbr = this.abbreviations[suggestedAbbrExponent];\n            value /= Math.pow(10, suggestedAbbrExponent);\n          }\n        }\n\n        absValue = Math.abs(value);\n        temp = prep.temp;\n        numericPattern = prep.numericPattern;\n        decimalPartPattern = numericPattern.split(d)[1];\n\n        if (this.type === 'I') {\n          value = Math.round(value);\n        }\n\n        num = value;\n\n        if (!decimalPartPattern && numericPattern.slice(-1)[0] === '#') {\n          if (absValue >= Math.pow(10, temp) || absValue < 1 || absValue < 1e-4) {\n            if (value === 0) {\n              value = '0';\n            } else if (absValue < 1e-4 || absValue >= 1e20) {\n              // engine always formats values < 1e-4 in scientific form, values >= 1e20 can only be represented in scientific form\n              value = num.toExponential(Math.max(1, Math.min(14, temp)) - 1);\n              value = value.replace(/\\.?0+(?=e)/, '');\n              sciValue = '';\n            } else {\n              value = value.toPrecision(Math.max(1, Math.min(14, temp)));\n\n              if (value.indexOf('.') >= 0) {\n                value = value.replace(value.indexOf('e') < 0 ? /0+$/ : /\\.?0+(?=e)/, '');\n                value = value.replace('.', d);\n              }\n            }\n          } else {\n            numericPattern += d;\n            temp = Math.max(0, Math.min(20, temp - Math.ceil(Math.log(absValue) / Math.log(10))));\n\n            for (i = 0; i < temp; i++) {\n              numericPattern += '#';\n            }\n\n            value = format_min(numericPattern, value);\n          }\n        } else if (absValue >= 1e15 || absValue > 0 && absValue <= 1e-14) {\n          value = absValue ? absValue.toExponential(15).replace(/\\.?0+(?=e)/, '') : '0';\n        } else {\n          var wholePart = Number(value.toFixed(Math.min(20, decimalPartPattern ? decimalPartPattern.length : 0)).split('.')[0]);\n          var wholePartPattern = numericPattern.split(d)[0];\n          wholePartPattern += d;\n          value = format_min(wholePartPattern, wholePart) || '0';\n\n          if (decimalPartPattern) {\n            var nDecimals = Math.max(0, Math.min(14, decimalPartPattern.length)); // the length of e.g. 0000#####\n\n            var nZeroes = decimalPartPattern.replace(/#+$/, '').length;\n            var decimalPart = (this.type === 'I' ? 0 : absValue % 1).toFixed(nDecimals).slice(2).replace(/0+$/, ''); // remove trailing zeroes\n\n            for (i = decimalPart.length; i < nZeroes; i++) {\n              decimalPart += '0';\n            }\n\n            if (decimalPart) {\n              value += d + decimalPart;\n            }\n          } else if (wholePart === 0) {\n            // to avoid \"-\" being prefixed to value\n            num = 0;\n          }\n        }\n\n        value = value.replace(prep.numericRegex, function (m) {\n          if (m === t) {\n            return prep.groupTemp;\n          }\n\n          if (m === d) {\n            return prep.decTemp;\n          }\n\n          return '';\n        });\n\n        if (num < 0 && !/^-/.test(value)) {\n          value = \"-\".concat(value);\n        }\n      }\n\n      return prep.prefix + value + sciValue + abbr + prep.postfix;\n    }\n  }], [{\n    key: \"getStaticFormatter\",\n    value: function getStaticFormatter() {\n      return {\n        prepare: function prepare() {},\n        formatValue: function formatValue(v) {\n          return \"\".concat(v);\n        }\n      };\n    }\n  }]);\n\n  return NumberFormatter;\n}();\n\nfunction numberFormatFactory() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return _construct(NumberFormatter, args);\n}\n\nfunction memoize(func) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _opts$size = opts.size,\n      size = _opts$size === void 0 ? 5000 : _opts$size,\n      _opts$multipleArgumen = opts.multipleArguments,\n      multipleArguments = _opts$multipleArgumen === void 0 ? false : _opts$multipleArgumen,\n      _opts$toKey = opts.toKey,\n      toKey = _opts$toKey === void 0 ? function (arg) {\n    return arg;\n  } : _opts$toKey;\n  var cache = Object.create(null);\n  var index = Object.create(null);\n  var counter = 0;\n  var fifo = 0; // First-In-First-Out index\n\n  var _cacher2;\n\n  var k;\n\n  if (multipleArguments) {\n    _cacher2 = function cacher() {\n      k = toKey.apply(void 0, arguments);\n\n      if (_cacher2.has(k)) {\n        return _cacher2.get(k);\n      }\n\n      return _cacher2.set(k, func.apply(void 0, arguments));\n    };\n  } else {\n    _cacher2 = function _cacher(arg) {\n      k = toKey(arg);\n\n      if (_cacher2.has(k)) {\n        return _cacher2.get(k);\n      }\n\n      return _cacher2.set(k, func(arg));\n    };\n  }\n\n  _cacher2.set = function (key, val) {\n    if (counter >= size) {\n      delete cache[index[fifo]];\n      delete index[fifo];\n      counter--;\n      fifo++;\n    }\n\n    cache[key] = val;\n    index[counter] = key;\n    counter++;\n    return val;\n  };\n\n  _cacher2.get = function (key) {\n    return cache[key];\n  };\n\n  _cacher2.has = function (key) {\n    return key in cache;\n  };\n\n  _cacher2.clear = function () {\n    cache = Object.create(null);\n    index = Object.create(null);\n    counter = 0;\n    fifo = 0;\n  };\n\n  _cacher2.size = function () {\n    return counter;\n  };\n\n  return _cacher2;\n}\n\nfunction formatter(pattern, thousand, decimal, qType, localeInfo) {\n  var qformat = numberFormatFactory(localeInfo, pattern, thousand, decimal, qType);\n  var memoized = memoize(qformat.formatValue.bind(qformat), {\n    // Handle NaN and cases where toString yields different result than +operator. Ex. a Date.\n    toKey: function toKey(value) {\n      return isNaN(value) ? value : +value;\n    }\n  });\n  /**\n   * Format a value according to the specified pattern created at construct\n   *\n   * @param  {Number} value   The number to be formatted\n   * @return {String}         [description]\n   */\n\n  function format(value) {\n    return memoized(value);\n  }\n  /**\n    * Format a value according to a specific pattern\n    * that is not the one specified in the constructor\n    *\n    * @param  {String} p   Pattern\n    * @param  {Number} v   Value\n    * @param  {String} t   Thousand\n    * @param  {String} d   Decimal\n    * @return {String}     Formatted value\n    */\n\n\n  format.format = function formatFn(p, v, t, d) {\n    memoized.clear();\n    return qformat.format(v, p, t, d);\n  };\n  /**\n    * Change the pattern on existing formatter\n    *\n    * @param  {String} p     Pattern (optional)\n    * @return {String}       Returns the pattern\n    */\n\n\n  format.pattern = function patternFn(p) {\n    if (p) {\n      memoized.clear();\n      qformat.pattern = p;\n      qformat.prepare();\n    }\n\n    return qformat.pattern;\n  };\n  /**\n   * Set the locale for the formatter\n   *\n   * @param  {Object} args   Locale object for formatting\n   * @return {Undefined}      Returns nothing\n   */\n\n  /* format.locale = function( ...args ) {\n    locale = formatLocale( ...args );\n    d3format = locale.format( pattern );\n     return this;\n  }; */\n\n\n  return format;\n}\n\n/* eslint import/prefer-default-export: 0 */\nvar TYPES = {\n  AUTO: 'U',\n  INTEGER: 'I',\n  NUMBER: 'R',\n  FIXED_TO: 'F',\n  MONEY: 'M',\n  DATE: 'D',\n  TIME: 'T',\n  DATE_TIME: 'TS',\n  INTERVAL: 'IV'\n};\n\nvar DAYS = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];\nvar DAYS_ABBR = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];\nvar MONTHS = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\nvar MONTHS_ABBR = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\nvar SECONDS_PER_DAY = 86400;\n\nfunction pad(s, n) {\n  for (var i = s.length; i < n; i++) {\n    s = \"0\".concat(s);\n  }\n\n  return s;\n}\n\nfunction parseDate(d, twelveFormat) {\n  var h = d.getUTCHours();\n  var day = d.getUTCDay() - 1;\n\n  if (twelveFormat) {\n    h %= 12;\n\n    if (!h) {\n      // h == 0 -> 12\n      h = 12;\n    }\n  }\n\n  if (day < 0) {\n    day = 6;\n  }\n\n  return {\n    year: d.getUTCFullYear(),\n    month: d.getUTCMonth(),\n    day: day,\n    date: d.getUTCDate(),\n    h: h,\n    m: d.getUTCMinutes(),\n    s: d.getUTCSeconds(),\n    f: d.getUTCMilliseconds(),\n    t: d.getUTCHours() >= 12 ? 'pm' : 'am'\n  };\n}\n\nfunction getRemainder(value) {\n  var s = value.toString().split('.');\n\n  if (s[1]) {\n    s = Number(\"0.\".concat(s[1]));\n  } else {\n    return 0;\n  }\n\n  return s;\n}\n\nfunction parseIntervalDays(days) {\n  var d = days;\n  var h = 24 * getRemainder(d);\n  var m = 60 * getRemainder(h);\n  var s = 60 * getRemainder(m);\n  var ms = 1000 * getRemainder(s);\n  return {\n    d: Math.floor(d),\n    h: Math.floor(h),\n    m: Math.floor(m),\n    s: Math.floor(s),\n    f: Math.round(ms)\n  };\n}\n\nfunction parseInterval(days, pattern) {\n  var units = parseIntervalDays(days),\n      d = units.d,\n      h = units.h,\n      m = units.m,\n      s = units.s,\n      f = units.f,\n      w = 0,\n      date;\n\n  if (/w+|t+/gi.test(pattern)) {\n    date = new Date(Date.UTC(1899, 11, 30 + Math.floor(days), 0, 0, Math.round(SECONDS_PER_DAY * (days - Math.floor(days)))));\n\n    if (isNaN(date.getTime())) {\n      date = null;\n    }\n  }\n\n  if (!/D+/gi.test(pattern)) {\n    h += d * 24;\n  }\n\n  if (!/h+/gi.test(pattern)) {\n    m += h * 60;\n  }\n\n  if (!/m+/gi.test(pattern)) {\n    s += m * 60;\n  }\n\n  if (/w+/gi.test(pattern)) {\n    w = date ? date.getDay() - 1 : 0;\n\n    if (w < 0) {\n      w = 6;\n    }\n  }\n\n  var someT = '';\n\n  if (date) {\n    someT = date.getUTCHours() >= 12 ? 'pm' : 'am';\n  }\n\n  return {\n    year: 0,\n    month: 0,\n    day: w,\n    date: d,\n    h: h,\n    m: m,\n    s: s,\n    f: f,\n    t: someT\n  };\n}\n\nfunction getMasks(inst, d) {\n  return {\n    'Y+|y+': {\n      Y: \"\".concat(Number(\"\".concat(d.year).slice(-2))),\n      YY: pad(\"\".concat(d.year).slice(-2), 2),\n      YYY: pad(\"\".concat(d.year).slice(-3), 3),\n      def: function def(m) {\n        // default\n        return pad(\"\".concat(d.year), m.length);\n      }\n    },\n    'M+': {\n      M: d.month + 1,\n      MM: pad(\"\".concat(d.month + 1), 2),\n      MMM: inst.locale_months_abbr[d.month],\n      def: inst.locale_months[d.month]\n    },\n    'W+|w+': {\n      W: d.day,\n      WW: pad(\"\".concat(d.day), 2),\n      WWW: inst.locale_days_abbr[d.day],\n      def: inst.locale_days[d.day]\n    },\n    'D+|d+': {\n      D: d.date,\n      def: function def(m) {\n        return pad(\"\".concat(d.date), m.length);\n      }\n    },\n    'h+|H+': {\n      h: d.h,\n      def: function def(m) {\n        return pad(\"\".concat(d.h), m.length);\n      }\n    },\n    'm+': {\n      m: d.m,\n      def: function def(m) {\n        return pad(\"\".concat(d.m), m.length);\n      }\n    },\n    's+|S+': {\n      s: d.s,\n      def: function def(m) {\n        return pad(\"\".concat(d.s), m.length);\n      }\n    },\n    'f+|F+': {\n      def: function def(m) {\n        var f = \"\".concat(d.f),\n            n = m.length - f.length;\n\n        if (n > 0) {\n          for (var i = 0; i < n; i++) {\n            f += '0';\n          }\n        } else if (n < 0) {\n          f = f.slice(0, m.length);\n        }\n\n        return f;\n      }\n    },\n    't{1,2}|T{1,2}': {\n      def: function def(m) {\n        var t = d.t;\n\n        if (m[0].toUpperCase() === m[0]) {\n          t = t.toUpperCase();\n        }\n\n        t = t.slice(0, m.length);\n        return t;\n      }\n    }\n  };\n}\n\nvar DateFormatter =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @name DateFormatter\n   * @constructs\n   * @param {Object} localeInfo\n   * @param {String} pattern\n   */\n  function DateFormatter(localeInfo, pattern, qtype) {\n    _classCallCheck(this, DateFormatter);\n\n    var info = localeInfo || {};\n\n    if (!info.qCalendarStrings) {\n      info.qCalendarStrings = {\n        qLongDayNames: DAYS,\n        qDayNames: DAYS_ABBR,\n        qLongMonthNames: MONTHS,\n        qMonthNames: MONTHS_ABBR\n      };\n    }\n\n    this.localeInfo = info;\n    this.locale_days = info.qCalendarStrings.qLongDayNames.slice();\n    this.locale_days_abbr = info.qCalendarStrings.qDayNames.slice();\n    this.locale_months = info.qCalendarStrings.qLongMonthNames.slice();\n    this.locale_months_abbr = info.qCalendarStrings.qMonthNames.slice();\n\n    if (!pattern) {\n      var _patternMap;\n\n      var patternMap = (_patternMap = {}, _defineProperty(_patternMap, TYPES.TIME, info.qTimeFmt || 'hh:mm:ss'), _defineProperty(_patternMap, TYPES.DATE, info.qDateFmt || 'YYYY-MM-DD'), _defineProperty(_patternMap, TYPES.DATE_TIME, info.qTimestampFmt || 'YYYY-MM-DD hh:mm:ss'), _patternMap);\n      pattern = patternMap[qtype];\n    }\n\n    this.pattern = pattern;\n  }\n\n  _createClass(DateFormatter, [{\n    key: \"clone\",\n    value: function clone() {\n      var n = new DateFormatter(this.localeInfo, this.pattern);\n      n.subtype = this.subtype;\n      return n;\n    }\n    /**\n     * Formats a date according to given pattern\n     * @param {Date} date The date to format.\n     * @param {String} pattern The desired format of the date\n     * var d = new Date(2013, 8, 15, 13, 55, 40, 987);\n     * var n = new DateFormatter();\n     * @example\n     * m.format( d, 'YYYY-MM-DD hh:mm:ss.ffff') // 2013-08-15 13:55:40.9870\n     * m.format( d, 'h:m:s tt') // 1:55:40 pm\n     * m.format( d, 'h:m:s TT') // 1:55:40 PM\n     * m.format( d, 'M/D/YYYY') // 8/15/2013\n     * m.format( d, 'WWWW DD MMM') // Thursday 15 Aug\n     * m.format( d, 'WWW DD MMMM @ hh:mm:ss') // Thu 15 August @ 13:55:40\n     */\n\n  }, {\n    key: \"format\",\n    value: function format(date, pattern) {\n      // Fallback pattern is set in constructor\n      if (!pattern) {\n        pattern = this.pattern ? this.pattern : 'YYYY-MM-DD hh:mm:ss';\n      }\n\n      pattern = pattern.replace(/\\[.+]|\\[|]/g, '');\n      var hasTwelveFlag = /t+/ig.test(pattern);\n      var parsedDate;\n\n      if (date instanceof Date) {\n        parsedDate = parseDate(date, hasTwelveFlag);\n      } else {\n        if (date < 0) {\n          // parseInterval don't support for negative values\n          date = -date;\n          pattern = \"-\".concat(pattern);\n        }\n\n        parsedDate = parseInterval(date, pattern);\n      } // remove [] and everything inside it\n\n\n      var masks = getMasks(this, parsedDate);\n      var masksArr = [];\n\n      for (var mask in masks) {\n        if (Object.prototype.hasOwnProperty.call(masks, mask)) {\n          masksArr.push(mask);\n        }\n      }\n\n      var dateTimeRegex = new RegExp(masksArr.join('|'), 'g');\n      var result = pattern.replace(dateTimeRegex, function (m) {\n        var r;\n        var mask;\n\n        for (mask in masks) {\n          if (Object.prototype.hasOwnProperty.call(masks, mask)) {\n            r = new RegExp(mask);\n\n            if (r.test(m)) {\n              break;\n            }\n          }\n        }\n\n        if (!r) {\n          return '';\n        }\n\n        var value;\n\n        for (var submask in masks[mask]) {\n          if (submask === m || submask.toLowerCase() === m) {\n            value = masks[mask][submask];\n\n            if (typeof value === 'undefined') {\n              value = masks[mask][submask.toLowerCase()];\n            }\n\n            break;\n          }\n        }\n\n        if (typeof value === 'undefined') {\n          value = masks[mask].def;\n        }\n\n        if (typeof value === 'function') {\n          value = value(m);\n        }\n\n        return value;\n      });\n      return result;\n    }\n  }]);\n\n  return DateFormatter;\n}();\n\nfunction dateFormatFactory() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return _construct(DateFormatter, args);\n}\n\nvar MS_PER_DAY = 86400000;\nfunction QlikTimeToDate(value) {\n  return new Date(Date.UTC(1899, 11, 30 + Math.floor(value), 0, 0, 0, Math.round(MS_PER_DAY * (value - Math.floor(value)))));\n}\nfunction formatter$1(pattern) {\n  var qtype = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'TS';\n  var localeInfo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var qformat = dateFormatFactory(localeInfo, pattern, qtype);\n  var memoized = memoize(qformat.format.bind(qformat), {\n    toKey: function toKey(date) {\n      return _typeof(date) === 'object' && typeof date.getTime === 'function' ? date.getTime() : date;\n    }\n  });\n  /**\n   * Prepare a value according to the specified qtype\n   *\n   * @param  {Number} value The value to be formatted\n   * @return {Number}       The converted value (if applied)\n   */\n\n  function prepare(value) {\n    if (qtype !== TYPES.INTERVAL) {\n      return QlikTimeToDate(value);\n    }\n\n    return value;\n  }\n  /**\n   * Format a value according to the specified pattern created at construct\n   *\n   * @param  {Date} value   The number to be formatted\n   * @return {String}         [description]\n   */\n\n\n  function format(value) {\n    value = prepare(value);\n    return memoized(value);\n  }\n  /**\n    * Format a value according to a specific pattern\n    * that is not the one specified in the constructor\n    *\n    * @param  {String} p   Pattern\n    * @param  {Date} v   Value\n    * @return {String}     Formatted value\n    */\n\n\n  format.format = function formatFn(p, v) {\n    memoized.clear();\n    v = prepare(v);\n    return qformat.format(v, p);\n  };\n  /**\n   * Set the locale for the formatter\n   *\n   * @param  {Object} args   Locale object for formatting\n   * @return {Undefined}      Returns nothing\n   */\n\n\n  format.locale = function locale(li) {\n    qformat = dateFormatFactory(li, pattern, qtype);\n    memoized = memoize(qformat.format.bind(qformat), {\n      toKey: function toKey(date) {\n        return _typeof(date) === 'object' ? date.getTime() : date;\n      }\n    });\n    return this;\n  };\n  /**\n   * Get or set the QType\n   *\n   * @param  {String} nqt New qType (optional)\n   * @return {String}     Current qtype\n   */\n\n\n  format.qtype = function qtypeFn(nqt) {\n    if (nqt !== undefined) {\n      qtype = nqt;\n      memoized.clear();\n    }\n\n    return qtype;\n  };\n\n  return format;\n}\n\nfunction createFromMetaInfo(meta, localeInfo) {\n  if (meta && meta.qNumFormat && ['D', 'T', 'TS', 'IV'].indexOf(meta.qNumFormat.qType) !== -1) {\n    return formatter$1(meta.qNumFormat.qFmt, meta.qNumFormat.qType, localeInfo);\n  }\n\n  var pattern = '#';\n  var thousand = localeInfo && typeof localeInfo.qThousandSep !== 'undefined' ? localeInfo.qThousandSep : ',';\n  var decimal = localeInfo && typeof localeInfo.qDecimalSep !== 'undefined' ? localeInfo.qDecimalSep : '.';\n  var type = 'U';\n  var isAuto = meta && !!meta.qIsAutoFormat;\n\n  if (meta && meta.qNumFormat) {\n    pattern = meta.qNumFormat.qFmt || pattern;\n    thousand = meta.qNumFormat.qThou || thousand;\n    decimal = meta.qNumFormat.qDec || decimal;\n    type = meta.qNumFormat.qType || type;\n    isAuto = isAuto && ['M'].indexOf(meta.qNumFormat.qType) === -1;\n  } else {\n    isAuto = true;\n  }\n\n  if (isAuto || type === 'U') {\n    pattern = \"#\".concat(decimal, \"##A\");\n    type = 'U';\n  }\n\n  return formatter(pattern, thousand, decimal, type, localeInfo);\n}\n\nfunction qField() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      meta = _ref.meta,\n      _id = _ref.id,\n      _key = _ref.key,\n      localeInfo = _ref.localeInfo,\n      fieldExtractor = _ref.fieldExtractor,\n      value = _ref.value,\n      _type = _ref.type,\n      sourceField = _ref.sourceField;\n\n  var values;\n  var valueFn = value || (_type === 'dimension' ? function (d) {\n    return d.qElemNo;\n  } : function (d) {\n    return d.qValue;\n  });\n\n  var labelFn = function labelFn(d) {\n    return d.qText || '';\n  };\n\n  var reduce = _type === 'dimension' ? 'first' : 'avg';\n\n  var _formatter = createFromMetaInfo(meta, localeInfo);\n\n  var reduceLabel = _type === 'dimension' ? 'first' : function (labels, v) {\n    return _formatter(v);\n  };\n  var f = {\n    id: function id() {\n      return _id;\n    },\n    key: function key() {\n      return _key;\n    },\n    raw: function raw() {\n      return meta;\n    },\n    title: function title() {\n      return meta.qFallbackTitle || meta.label;\n    },\n    type: function type() {\n      return _type;\n    },\n    origin: function origin() {\n      return sourceField;\n    },\n    items: function items() {\n      if (!values) {\n        values = fieldExtractor(f);\n      }\n\n      return values;\n    },\n    min: function min() {\n      return meta.qMin;\n    },\n    max: function max() {\n      return meta.qMax;\n    },\n    value: valueFn,\n    label: labelFn,\n    reduce: reduce,\n    reduceLabel: reduceLabel,\n    formatter: function formatter() {\n      return _formatter;\n    },\n    tags: function tags() {\n      return meta.qTags;\n    }\n  };\n  return f;\n}\n\nfunction createFields(path, obj, prefix, parentKey, opts) {\n  return (obj[path] || []).map(function (meta, i) {\n    var fieldKey = \"\".concat(parentKey ? \"\".concat(parentKey, \"/\") : '').concat(path, \"/\").concat(i);\n    var f = {\n      instance: qField(extend({\n        id: \"\".concat(prefix ? \"\".concat(prefix, \"/\") : '').concat(fieldKey),\n        key: fieldKey,\n        meta: meta\n      }, opts))\n    };\n    f.attrDims = createFields('qAttrDimInfo', meta, prefix, fieldKey, extend({}, opts, {\n      value: function value(v) {\n        return v.qElemNo;\n      },\n      type: 'dimension'\n    }));\n    f.attrExps = createFields('qAttrExprInfo', meta, prefix, fieldKey, extend({}, opts, {\n      value: function value(v) {\n        return v.qNum;\n      },\n      type: 'measure'\n    }));\n    f.measures = createFields('qMeasureInfo', meta, prefix, fieldKey, extend({}, opts, {\n      value: function value(v) {\n        return v.qValue;\n      },\n      type: 'measure'\n    }));\n    return f;\n  });\n}\n\nfunction q() {\n  var _cache$wrappedFields, _cache$wrappedFields2, _cache$allFields;\n\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _key = _ref.key,\n      data = _ref.data,\n      _ref$config = _ref.config,\n      config = _ref$config === void 0 ? {} : _ref$config;\n\n  var cache = {\n    fields: [],\n    wrappedFields: [],\n    allFields: [],\n    virtualFields: []\n  };\n  var cube = data;\n\n  if (!cube) {\n    throw new Error('Missing \"data\" input');\n  }\n\n  if (!cube.qDimensionInfo) {\n    throw new Error('The \"data\" input is not recognized as a hypercube');\n  }\n\n  var deps = q.util;\n  var opts = {\n    cache: cache,\n    cube: cube,\n    localeInfo: config.localeInfo,\n    fieldExtractor: null,\n    pages: null,\n    hierarchy: function hierarchy() {\n      return null;\n    },\n    virtualFields: config.virtualFields\n  };\n  var dataset = {\n    key: function key() {\n      return _key;\n    },\n    raw: function raw() {\n      return cube;\n    },\n    field: function field(query) {\n      return findField(query, opts);\n    },\n    fields: function fields() {\n      return cache.fields.slice();\n    },\n    extract: function extract(extractionConfig) {\n      return opts.extractor(extractionConfig, dataset, cache, deps);\n    },\n    hierarchy: function hierarchy(hierarchyConfig) {\n      return opts.hierarchy(hierarchyConfig, dataset, cache, deps);\n    },\n    _cache: function _cache() {\n      return cache;\n    }\n  };\n\n  if (cube.qMode === 'K' || cube.qMode === 'T' || !cube.qMode && cube.qNodesOnDim) {\n    opts.extractor = extract$1;\n    opts.hierarchy = augment;\n    opts.pages = cube.qMode === 'K' ? cube.qStackedDataPages : cube.qTreeDataPages;\n  } else if (cube.qMode === 'S') {\n    opts.extractor = extract;\n    opts.pages = cube.qDataPages;\n    opts.hierarchy = augment;\n  } else {\n    opts.extractor = function () {\n      return [];\n    }; // TODO - throw unsupported error?\n\n  }\n\n  opts.fieldExtractor = function (f) {\n    return opts.extractor({\n      field: f\n    }, dataset, cache, deps);\n  };\n\n  var dimAcc = cube.qMode === 'S' ? function (d) {\n    return d.qElemNumber;\n  } : undefined;\n  var measAcc = cube.qMode === 'S' ? function (d) {\n    return d.qNum;\n  } : undefined;\n\n  (_cache$wrappedFields = cache.wrappedFields).push.apply(_cache$wrappedFields, _toConsumableArray(createFields('qDimensionInfo', cube, _key, '', extend({}, opts, {\n    value: dimAcc,\n    type: 'dimension'\n  }))));\n\n  (_cache$wrappedFields2 = cache.wrappedFields).push.apply(_cache$wrappedFields2, _toConsumableArray(createFields('qMeasureInfo', cube, _key, '', extend({}, opts, {\n    value: measAcc,\n    type: 'measure'\n  }))));\n\n  cache.fields = cache.wrappedFields.map(function (f) {\n    return f.instance;\n  });\n\n  var traverse = function traverse(arr) {\n    arr.forEach(function (f) {\n      cache.allFields.push(f.instance);\n      traverse(f.measures);\n      traverse(f.attrDims);\n      traverse(f.attrExps);\n    });\n  };\n\n  traverse(cache.wrappedFields);\n  (config.virtualFields || []).forEach(function (v) {\n    // key: 'temporal',\n    // from: 'qDimensionInfo/0',\n    // override: {\n    //   value: v => v.qNum,\n    // },\n    var sourceField = dataset.field(v.from);\n    var f = qField(_objectSpread2({\n      meta: sourceField.raw(),\n      id: \"\".concat(_key, \"/\").concat(v.key),\n      sourceField: sourceField,\n      fieldExtractor: function fieldExtractor(ff) {\n        return opts.extractor({\n          field: ff\n        }, dataset, cache, deps);\n      },\n      key: v.key,\n      type: sourceField.type(),\n      localeInfo: opts.localeInfo,\n      value: sourceField.value\n    }, v.override || {}));\n    cache.virtualFields.push(f);\n  });\n\n  (_cache$allFields = cache.allFields).push.apply(_cache$allFields, _toConsumableArray(cache.virtualFields));\n\n  return dataset;\n}\n\nvar LAYOUT_TO_PROP = [['qHyperCube', 'qHyperCubeDef'], ['qTreeData', 'qTreeDataDef'], ['qDimensionInfo', 'qDimensions'], ['qMeasureInfo', 'qMeasures'], ['qAttrDimInfo', 'qAttributeDimensions'], ['qAttrExprInfo', 'qAttributeExpressions']];\nvar DIM_RX$1 = /\\/qDimensionInfo(?:\\/(\\d+))?/;\nvar M_RX$1 = /\\/qMeasureInfo\\/(\\d+)/;\nvar ATTR_DIM_RX$1 = /\\/qAttrDimInfo\\/(\\d+)(?:\\/(\\d+))?/;\nvar ATTR_EXPR_RX$1 = /\\/qAttrExprInfo\\/(\\d+)/;\nvar HC_RX = /\\/?qHyperCube/;\nvar TD_RX = /\\/?qTreeData/;\n\nvar SHORTEN_HC = function SHORTEN_HC(path) {\n  return \"\".concat(path.substr(0, path.indexOf('/qHyperCubeDef') + 14));\n}; // 14 = length of '/qHyperCubeDef'\n\n\nvar SHORTEN_TD = function SHORTEN_TD(path) {\n  return \"\".concat(path.substr(0, path.indexOf('/qTreeDataDef') + 13));\n}; // 13 = length of '/qTreeDataDef'\n\n\nfunction extractFieldFromId(id, layout) {\n  var path = id;\n  var dimensionIdx = -1;\n  var measureIdx = -1;\n  var pathToCube = '';\n\n  var shortenizer = function shortenizer(p) {\n    return p;\n  };\n\n  if (HC_RX.test(id)) {\n    pathToCube = \"\".concat(path.substr(0, path.indexOf('qHyperCube') + 10)); // 10 = length of 'qHyperCube'\n\n    shortenizer = SHORTEN_HC;\n  } else if (TD_RX.test(id)) {\n    pathToCube = \"\".concat(path.substr(0, path.indexOf('qTreeData') + 9)); // 9 = length of 'qTreeData'\n\n    shortenizer = SHORTEN_TD;\n  }\n\n  var shortenPath = true;\n\n  if (DIM_RX$1.test(id)) {\n    dimensionIdx = +DIM_RX$1.exec(id)[1];\n  }\n\n  if (M_RX$1.test(id)) {\n    measureIdx = +M_RX$1.exec(id)[1];\n  }\n\n  if (ATTR_DIM_RX$1.test(id)) {\n    measureIdx = -1;\n    dimensionIdx = 0;\n    var attrCol = +ATTR_DIM_RX$1.exec(path)[2];\n\n    if (!isNaN(attrCol)) {\n      dimensionIdx = attrCol;\n      path = path.replace(/\\/\\d+$/, '');\n    }\n\n    shortenPath = false;\n  }\n\n  if (ATTR_EXPR_RX$1.test(id)) {\n    // depends on number of measures + number of attr expressions\n    // in dimensions and measures before this one\n    var offset = measureIdx;\n\n    if (layout) {\n      measureIdx = 0;\n      var hc = resolve(pathToCube, layout); // offset by number of measures\n\n      measureIdx += (hc.qMeasureInfo || []).length; // offset by total number of attr expr in dimensions\n      // (assuming attr expr in dimensions are ordered first)\n\n      if (dimensionIdx > -1) {\n        measureIdx = hc.qDimensionInfo.slice(0, dimensionIdx).reduce(function (v, dim) {\n          return v + dim.qAttrExprInfo.length;\n        }, measureIdx);\n        dimensionIdx = -1;\n      } else {\n        measureIdx = hc.qDimensionInfo.reduce(function (v, dim) {\n          return v + dim.qAttrExprInfo.length;\n        }, measureIdx); // offset by total number of attr expr in measures before 'index'\n\n        measureIdx = hc.qMeasureInfo.slice(0, offset).reduce(function (v, meas) {\n          return v + meas.qAttrExprInfo.length;\n        }, measureIdx);\n      } // offset by the actual column value for the attribute expression itself\n\n\n      measureIdx += +ATTR_EXPR_RX$1.exec(path)[1];\n    } else if (dimensionIdx > -1) {\n      dimensionIdx = -1;\n      measureIdx = +ATTR_EXPR_RX$1.exec(path)[1];\n    } else {\n      measureIdx += +ATTR_EXPR_RX$1.exec(path)[1] + 1;\n    }\n  }\n\n  LAYOUT_TO_PROP.forEach(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        v = _ref2[0],\n        prop = _ref2[1];\n\n    path = path.replace(v, prop);\n  });\n\n  if (shortenPath) {\n    path = shortenizer(path);\n  }\n\n  if (path && path[0] !== '/') {\n    path = \"/\".concat(path);\n  }\n\n  return {\n    measureIdx: measureIdx,\n    dimensionIdx: dimensionIdx,\n    path: path\n  };\n}\n/**\n * Helper method to generate suitable QIX selection methods and parameters based on a brush instance.\n * @alias brush\n * @memberof picasso.q\n * @param {brush} brush A brush instance\n * @param {object} [opts]\n * @param {boolean} [opts.byCells=false] Whether to prefer selection by row index.\n * @param {string} [opts.primarySource] Field source to extract row indices from. If not specified, indices from first source are used.\n * @param {object} [layout] QIX data layout. Needed only when brushing on attribute expressions, to be able to calculate the measure index.\n * @return {object[]} An array of relevant selections\n */\n\nfunction qBrush(brush) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var layout = arguments.length > 2 ? arguments[2] : undefined;\n  var byCells = opts.byCells;\n  var primarySource = opts.primarySource;\n  var selections = [];\n  var methods = {};\n  var isActive = brush.isActive();\n  var hasValues = false;\n  brush.brushes().forEach(function (b) {\n    var info = extractFieldFromId(b.id, layout);\n\n    if (b.type === 'range' && info.measureIdx > -1 && info.dimensionIdx > -1) {\n      var ranges = b.brush.ranges();\n\n      if (ranges.length) {\n        hasValues = true;\n\n        if (!methods.multiRangeSelectTreeDataValues) {\n          methods.multiRangeSelectTreeDataValues = {\n            path: info.path,\n            ranges: []\n          };\n        }\n\n        ranges.forEach(function (range) {\n          return methods.multiRangeSelectTreeDataValues.ranges.push({\n            qMeasureIx: info.measureIdx,\n            qDimensionIx: info.dimensionIdx,\n            qRange: {\n              qMin: range.min,\n              qMax: range.max,\n              qMinInclEq: true,\n              qMaxInclEq: true\n            }\n          });\n        });\n      }\n    } else {\n      if (b.type === 'range' && info.measureIdx > -1) {\n        var _ranges = b.brush.ranges();\n\n        if (_ranges.length) {\n          hasValues = true;\n\n          if (!methods.rangeSelectHyperCubeValues) {\n            methods.rangeSelectHyperCubeValues = {\n              path: info.path,\n              ranges: []\n            };\n          }\n\n          _ranges.forEach(function (range) {\n            return methods.rangeSelectHyperCubeValues.ranges.push({\n              qMeasureIx: info.measureIdx,\n              qRange: {\n                qMin: range.min,\n                qMax: range.max,\n                qMinInclEq: true,\n                qMaxInclEq: true\n              }\n            });\n          });\n        }\n      }\n\n      if (b.type === 'range' && info.dimensionIdx > -1) {\n        var _ranges2 = b.brush.ranges();\n\n        if (_ranges2.length) {\n          hasValues = true;\n\n          if (!methods.selectHyperCubeContinuousRange) {\n            methods.selectHyperCubeContinuousRange = {\n              path: info.path,\n              ranges: []\n            };\n          }\n\n          _ranges2.forEach(function (range) {\n            return methods.selectHyperCubeContinuousRange.ranges.push({\n              qDimIx: info.dimensionIdx,\n              qRange: {\n                qMin: range.min,\n                qMax: range.max,\n                qMinInclEq: true,\n                qMaxInclEq: false\n              }\n            });\n          });\n        }\n      }\n\n      if (b.type === 'value' && info.dimensionIdx > -1) {\n        if (byCells) {\n          if (layout && layout.qHyperCube && (layout.qHyperCube.qMode === 'P' || layout.qHyperCube.qMode === 'T' || layout.qHyperCube.qMode === 'K')) {\n            var hyperCube = layout.qHyperCube;\n            var noOfLeftDims = hyperCube.qNoOfLeftDims;\n            var dimInterColSortIdx = hyperCube.qEffectiveInterColumnSortOrder.indexOf(info.dimensionIdx);\n\n            if (!methods.selectPivotCells) {\n              methods.selectPivotCells = {\n                path: info.path,\n                cells: []\n              };\n            }\n\n            if (b.id === primarySource || !primarySource && methods.selectPivotCells.cells.length === 0) {\n              var validValues = b.brush.values().map(function (s) {\n                return +s;\n              }).filter(function (v) {\n                return !isNaN(v);\n              });\n\n              if ((noOfLeftDims === 0 || dimInterColSortIdx >= noOfLeftDims) && noOfLeftDims > -1) {\n                validValues.forEach(function (val) {\n                  methods.selectPivotCells.cells.push({\n                    qType: 'T',\n                    qCol: val,\n                    qRow: dimInterColSortIdx - noOfLeftDims\n                  });\n                });\n              } else {\n                validValues.forEach(function (val) {\n                  methods.selectPivotCells.cells.push({\n                    qType: 'L',\n                    qCol: info.dimensionIdx,\n                    qRow: val\n                  });\n                });\n              }\n\n              hasValues = !!methods.selectPivotCells.cells.length;\n            }\n          } else {\n            if (!methods.selectHyperCubeCells) {\n              methods.selectHyperCubeCells = {\n                path: info.path,\n                cols: []\n              };\n            }\n\n            methods.selectHyperCubeCells.cols.push(info.dimensionIdx);\n\n            if (b.id === primarySource || !primarySource && !methods.selectHyperCubeCells.values) {\n              methods.selectHyperCubeCells.values = b.brush.values().map(function (s) {\n                return +s;\n              }).filter(function (v) {\n                return !isNaN(v);\n              });\n              hasValues = !!methods.selectHyperCubeCells.values.length;\n            }\n          }\n        } else {\n          var values = b.brush.values().map(function (s) {\n            return +s;\n          }).filter(function (v) {\n            return !isNaN(v);\n          });\n          hasValues = !!values.length;\n          selections.push({\n            params: [info.path, info.dimensionIdx, values, false],\n            method: 'selectHyperCubeValues'\n          });\n        }\n      }\n    }\n  });\n\n  if (!hasValues && isActive) {\n    return [{\n      method: 'resetMadeSelections',\n      params: []\n    }];\n  }\n\n  if (methods.rangeSelectHyperCubeValues) {\n    selections.push({\n      method: 'rangeSelectHyperCubeValues',\n      params: [methods.rangeSelectHyperCubeValues.path, methods.rangeSelectHyperCubeValues.ranges, [], true]\n    });\n  }\n\n  if (methods.selectHyperCubeContinuousRange) {\n    selections.push({\n      method: 'selectHyperCubeContinuousRange',\n      params: [methods.selectHyperCubeContinuousRange.path, methods.selectHyperCubeContinuousRange.ranges]\n    });\n  }\n\n  if (methods.selectHyperCubeCells) {\n    selections.push({\n      method: 'selectHyperCubeCells',\n      params: [methods.selectHyperCubeCells.path, methods.selectHyperCubeCells.values, methods.selectHyperCubeCells.cols]\n    });\n  }\n\n  if (methods.selectPivotCells) {\n    selections.push({\n      method: 'selectPivotCells',\n      params: [methods.selectPivotCells.path, methods.selectPivotCells.cells]\n    });\n  }\n\n  if (methods.multiRangeSelectTreeDataValues) {\n    selections.push({\n      method: 'multiRangeSelectTreeDataValues',\n      params: [methods.multiRangeSelectTreeDataValues.path, methods.multiRangeSelectTreeDataValues.ranges]\n    });\n  }\n\n  return selections;\n}\n\nfunction initialize(picasso) {\n  q.util = picasso.data('matrix').util;\n  picasso.data('q', q);\n  picasso.formatter('q-number', formatter);\n  picasso.formatter('q-time', formatter$1);\n}\ninitialize.qBrushHelper = qBrush; // deprecated\n\ninitialize.selections = qBrush;\n\nexport default initialize;\n//# sourceMappingURL=picasso-q.esm.js.map\n",
        "/*\n* picasso.js v0.27.0\n* Copyright (c) 2019 QlikTech International AB\n* Released under the MIT license.\n*/\n\n\nvar ARG_LENGTH = {\n  a: 7,\n  c: 6,\n  h: 1,\n  l: 2,\n  m: 2,\n  q: 4,\n  s: 4,\n  t: 2,\n  v: 1,\n  z: 0\n};\nvar SEGMENT_PATTERN = /([astvzqmhlc])([^astvzqmhlc]*)/ig;\nvar NUMBER = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/ig;\n\nfunction parseValues(args) {\n  var numbers = args.match(NUMBER);\n  return numbers ? numbers.map(Number) : [];\n}\n/**\n * parse an svg path data string. Generates an Array\n * of commands where each command is an Array of the\n * form `[command, arg1, arg2, ...]`\n *\n * https://www.w3.org/TR/SVG/paths.html#PathDataGeneralInformation\n * @ignore\n *\n * @param {string} path\n * @returns {array}\n */\n\n\nfunction parse(path) {\n  var data = [];\n  var p = String(path).trim(); // A path data segment (if there is one) must begin with a \"moveto\" command\n\n  if (p[0] !== 'M' && p[0] !== 'm') {\n    return data;\n  }\n\n  p.replace(SEGMENT_PATTERN, function (_, command, args) {\n    var type = command.toLowerCase();\n    var theArgs = parseValues(args);\n    var theCommand = command; // overloaded moveTo\n\n    if (type === 'm' && theArgs.length > 2) {\n      data.push([theCommand].concat(theArgs.splice(0, 2)));\n      type = 'l';\n      theCommand = theCommand === 'm' ? 'l' : 'L';\n    } // Ignore invalid commands\n\n\n    if (theArgs.length < ARG_LENGTH[type]) {\n      return '';\n    }\n\n    data.push([theCommand].concat(theArgs.splice(0, ARG_LENGTH[type]))); // The command letter can be eliminated on subsequent commands if the\n    // same command is used multiple times in a row (e.g., you can drop the\n    // second \"L\" in \"M 100 200 L 200 100 L -100 -200\" and use\n    // \"M 100 200 L 200 100 -100 -200\" instead).\n\n    while (theArgs.length >= ARG_LENGTH[type] && theArgs.length && ARG_LENGTH[type]) {\n      data.push([theCommand].concat(theArgs.splice(0, ARG_LENGTH[type])));\n    }\n\n    return '';\n  });\n  return data;\n}\n\nvar parsePath = parse;\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n/**\n * Work around for https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8438884/\n * @ignore\n */\n\n\nfunction supportsSvgPathArgument(window) {\n  var canvas = window.document.createElement('canvas');\n  var g = canvas.getContext('2d');\n  var p = new window.Path2D('M0 0 L1 1');\n  g.strokeStyle = 'red';\n  g.lineWidth = 1;\n  g.stroke(p);\n  var imgData = g.getImageData(0, 0, 1, 1);\n  return imgData.data[0] === 255; // Check if pixel is red\n}\n\nfunction rotatePoint(point, angle) {\n  var nx = point.x * Math.cos(angle) - point.y * Math.sin(angle);\n  var ny = point.y * Math.cos(angle) + point.x * Math.sin(angle);\n  point.x = nx;\n  point.y = ny;\n}\n\nfunction translatePoint(point, dx, dy) {\n  point.x += dx;\n  point.y += dy;\n}\n\nfunction scalePoint(point, s) {\n  point.x *= s;\n  point.y *= s;\n}\n\nfunction polyFillPath2D(window) {\n  if (typeof window === 'undefined' || !window.CanvasRenderingContext2D) {\n    return;\n  }\n\n  if (window.Path2D && supportsSvgPathArgument(window)) {\n    return;\n  }\n  /**\n     * Crates a Path2D polyfill object\n     * @constructor\n     * @ignore\n     * @param {String} path\n     */\n\n\n  var Path2D =\n  /*#__PURE__*/\n  function () {\n    function Path2D(path) {\n      _classCallCheck(this, Path2D);\n\n      this.segments = [];\n\n      if (path && path instanceof Path2D) {\n        var _this$segments;\n\n        (_this$segments = this.segments).push.apply(_this$segments, _toConsumableArray(path.segments));\n      } else if (path) {\n        this.segments = parsePath(path);\n      }\n    }\n\n    _createClass(Path2D, [{\n      key: \"addPath\",\n      value: function addPath(path) {\n        if (path && path instanceof Path2D) {\n          var _this$segments2;\n\n          (_this$segments2 = this.segments).push.apply(_this$segments2, _toConsumableArray(path.segments));\n        }\n      }\n    }, {\n      key: \"moveTo\",\n      value: function moveTo(x, y) {\n        this.segments.push(['M', x, y]);\n      }\n    }, {\n      key: \"lineTo\",\n      value: function lineTo(x, y) {\n        this.segments.push(['L', x, y]);\n      }\n    }, {\n      key: \"arc\",\n      value: function arc(x, y, r, start, end, ccw) {\n        this.segments.push(['AC', x, y, r, start, end, !!ccw]);\n      }\n    }, {\n      key: \"arcTo\",\n      value: function arcTo(x1, y1, x2, y2, r) {\n        this.segments.push(['AT', x1, y1, x2, y2, r]);\n      }\n    }, {\n      key: \"ellipse\",\n      value: function ellipse(x, y, rx, ry, angle, start, end, ccw) {\n        this.segments.push(['E', x, y, rx, ry, angle, start, end, !!ccw]);\n      }\n    }, {\n      key: \"closePath\",\n      value: function closePath() {\n        this.segments.push(['Z']);\n      }\n    }, {\n      key: \"bezierCurveTo\",\n      value: function bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {\n        this.segments.push(['C', cp1x, cp1y, cp2x, cp2y, x, y]);\n      }\n    }, {\n      key: \"quadraticCurveTo\",\n      value: function quadraticCurveTo(cpx, cpy, x, y) {\n        this.segments.push(['Q', cpx, cpy, x, y]);\n      }\n    }, {\n      key: \"rect\",\n      value: function rect(x, y, width, height) {\n        this.segments.push(['R', x, y, width, height]);\n      }\n    }]);\n\n    return Path2D;\n  }();\n\n  var cFill = window.CanvasRenderingContext2D.prototype.fill;\n  var cStroke = window.CanvasRenderingContext2D.prototype.stroke;\n\n  function buildPath(canvas, segments) {\n    var endAngle;\n    var startAngle;\n    var largeArcFlag;\n    var sweepFlag;\n    var endPoint;\n    var midPoint;\n    var angle;\n    var lambda;\n    var t1;\n    var t2;\n    var x;\n    var x1;\n    var y;\n    var y1;\n    var r;\n    var rx;\n    var ry;\n    var w;\n    var h;\n    var pathType;\n    var centerPoint;\n    var cpx;\n    var cpy;\n    var qcpx;\n    var qcpy;\n    var ccw;\n    var startPoint = {\n      x: 0,\n      y: 0\n    };\n    var currentPoint = {\n      x: 0,\n      y: 0\n    };\n    canvas.beginPath();\n\n    for (var i = 0; i < segments.length; ++i) {\n      var s = segments[i];\n      pathType = s[0]; // Reset control point if command is not cubic\n\n      if (pathType !== 'S' && pathType !== 's' && pathType !== 'C' && pathType !== 'c') {\n        cpx = null;\n        cpy = null;\n      }\n\n      if (pathType !== 'T' && pathType !== 't' && pathType !== 'Q' && pathType !== 'q') {\n        qcpx = null;\n        qcpy = null;\n      }\n\n      switch (pathType) {\n        case 'm':\n        case 'M':\n          if (pathType === 'm') {\n            x += s[1];\n            y += s[2];\n          } else {\n            x = s[1];\n            y = s[2];\n          }\n\n          if (pathType === 'M' || !startPoint) {\n            startPoint = {\n              x: x,\n              y: y\n            };\n          }\n\n          canvas.moveTo(x, y);\n          break;\n\n        case 'l':\n          x += s[1];\n          y += s[2];\n          canvas.lineTo(x, y);\n          break;\n\n        case 'L':\n          x = s[1];\n          y = s[2];\n          canvas.lineTo(x, y);\n          break;\n\n        case 'H':\n          x = s[1];\n          canvas.lineTo(x, y);\n          break;\n\n        case 'h':\n          x += s[1];\n          canvas.lineTo(x, y);\n          break;\n\n        case 'V':\n          y = s[1];\n          canvas.lineTo(x, y);\n          break;\n\n        case 'v':\n          y += s[1];\n          canvas.lineTo(x, y);\n          break;\n\n        case 'a':\n        case 'A':\n          if (pathType === 'a') {\n            x += s[6];\n            y += s[7];\n          } else {\n            x = s[6];\n            y = s[7];\n          }\n\n          rx = s[1]; // rx\n\n          ry = s[2]; // ry\n\n          angle = s[3] * Math.PI / 180;\n          largeArcFlag = !!s[4];\n          sweepFlag = !!s[5];\n          endPoint = {\n            x: x,\n            y: y\n          }; // https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n\n          midPoint = {\n            x: (currentPoint.x - endPoint.x) / 2,\n            y: (currentPoint.y - endPoint.y) / 2\n          };\n          rotatePoint(midPoint, -angle); // radius correction\n\n          lambda = midPoint.x * midPoint.x / (rx * rx) + midPoint.y * midPoint.y / (ry * ry);\n\n          if (lambda > 1) {\n            lambda = Math.sqrt(lambda);\n            rx *= lambda;\n            ry *= lambda;\n          }\n\n          centerPoint = {\n            x: rx * midPoint.y / ry,\n            y: -(ry * midPoint.x) / rx\n          };\n          t1 = rx * rx * ry * ry;\n          t2 = rx * rx * midPoint.y * midPoint.y + ry * ry * midPoint.x * midPoint.x;\n\n          if (sweepFlag !== largeArcFlag) {\n            scalePoint(centerPoint, Math.sqrt((t1 - t2) / t2) || 0);\n          } else {\n            scalePoint(centerPoint, -Math.sqrt((t1 - t2) / t2) || 0);\n          }\n\n          startAngle = Math.atan2((midPoint.y - centerPoint.y) / ry, (midPoint.x - centerPoint.x) / rx);\n          endAngle = Math.atan2(-(midPoint.y + centerPoint.y) / ry, -(midPoint.x + centerPoint.x) / rx);\n          rotatePoint(centerPoint, angle);\n          translatePoint(centerPoint, (endPoint.x + currentPoint.x) / 2, (endPoint.y + currentPoint.y) / 2);\n          canvas.save();\n          canvas.translate(centerPoint.x, centerPoint.y);\n          canvas.rotate(angle);\n          canvas.scale(rx, ry);\n          canvas.arc(0, 0, 1, startAngle, endAngle, !sweepFlag);\n          canvas.restore();\n          break;\n\n        case 'C':\n          cpx = s[3]; // Last control point\n\n          cpy = s[4];\n          x = s[5];\n          y = s[6];\n          canvas.bezierCurveTo(s[1], s[2], cpx, cpy, x, y);\n          break;\n\n        case 'c':\n          canvas.bezierCurveTo(s[1] + x, s[2] + y, s[3] + x, s[4] + y, s[5] + x, s[6] + y);\n          cpx = s[3] + x; // Last control point\n\n          cpy = s[4] + y;\n          x += s[5];\n          y += s[6];\n          break;\n\n        case 'S':\n          if (cpx === null || cpx === null) {\n            cpx = x;\n            cpy = y;\n          }\n\n          canvas.bezierCurveTo(2 * x - cpx, 2 * y - cpy, s[1], s[2], s[3], s[4]);\n          cpx = s[1]; // last control point\n\n          cpy = s[2];\n          x = s[3];\n          y = s[4];\n          break;\n\n        case 's':\n          if (cpx === null || cpx === null) {\n            cpx = x;\n            cpy = y;\n          }\n\n          canvas.bezierCurveTo(2 * x - cpx, 2 * y - cpy, s[1] + x, s[2] + y, s[3] + x, s[4] + y);\n          cpx = s[1] + x; // last control point\n\n          cpy = s[2] + y;\n          x += s[3];\n          y += s[4];\n          break;\n\n        case 'Q':\n          qcpx = s[1]; // last control point\n\n          qcpy = s[2];\n          x = s[3];\n          y = s[4];\n          canvas.quadraticCurveTo(qcpx, qcpy, x, y);\n          break;\n\n        case 'q':\n          qcpx = s[1] + x; // last control point\n\n          qcpy = s[2] + y;\n          x += s[3];\n          y += s[4];\n          canvas.quadraticCurveTo(qcpx, qcpy, x, y);\n          break;\n\n        case 'T':\n          if (qcpx === null || qcpx === null) {\n            qcpx = x;\n            qcpy = y;\n          }\n\n          qcpx = 2 * x - qcpx; // last control point\n\n          qcpy = 2 * y - qcpy;\n          x = s[1];\n          y = s[2];\n          canvas.quadraticCurveTo(qcpx, qcpy, x, y);\n          break;\n\n        case 't':\n          if (qcpx === null || qcpx === null) {\n            qcpx = x;\n            qcpy = y;\n          }\n\n          qcpx = 2 * x - qcpx; // last control point\n\n          qcpy = 2 * y - qcpy;\n          x += s[1];\n          y += s[2];\n          canvas.quadraticCurveTo(qcpx, qcpy, x, y);\n          break;\n\n        case 'z':\n        case 'Z':\n          x = startPoint.x;\n          y = startPoint.y;\n          startPoint = undefined;\n          canvas.closePath();\n          break;\n\n        case 'AC':\n          // arc\n          x = s[1];\n          y = s[2];\n          r = s[3];\n          startAngle = s[4];\n          endAngle = s[5];\n          ccw = s[6];\n          canvas.arc(x, y, r, startAngle, endAngle, ccw);\n          break;\n\n        case 'AT':\n          // arcTo\n          x1 = s[1];\n          y1 = s[2];\n          x = s[3];\n          y = s[4];\n          r = s[5];\n          canvas.arcTo(x1, y1, x, y, r);\n          break;\n\n        case 'E':\n          // ellipse\n          x = s[1];\n          y = s[2];\n          rx = s[3];\n          ry = s[4];\n          angle = s[5];\n          startAngle = s[6];\n          endAngle = s[7];\n          ccw = s[8];\n          canvas.save();\n          canvas.translate(x, y);\n          canvas.rotate(angle);\n          canvas.scale(rx, ry);\n          canvas.arc(0, 0, 1, startAngle, endAngle, ccw);\n          canvas.restore();\n          break;\n\n        case 'R':\n          // rect\n          x = s[1];\n          y = s[2];\n          w = s[3];\n          h = s[4];\n          startPoint = {\n            x: x,\n            y: y\n          };\n          canvas.rect(x, y, w, h);\n          break;\n\n        default: // throw new Error(`${pathType} is not implemented`); ?\n\n      }\n\n      currentPoint.x = x;\n      currentPoint.y = y;\n    }\n  }\n\n  window.CanvasRenderingContext2D.prototype.fill = function fill() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var fillRule = 'nonzero';\n\n    if (args.length === 0 || args.length === 1 && typeof args[0] === 'string') {\n      cFill.apply(this, args);\n      return;\n    }\n\n    if (arguments.length === 2) {\n      fillRule = args[1];\n    }\n\n    var path = args[0];\n    buildPath(this, path.segments);\n    cFill.call(this, fillRule);\n  };\n\n  window.CanvasRenderingContext2D.prototype.stroke = function stroke(path) {\n    if (!path) {\n      cStroke.call(this);\n      return;\n    }\n\n    buildPath(this, path.segments);\n    cStroke.call(this);\n  };\n\n  window.Path2D = Path2D;\n}\n\nvar path2dPolyfill = polyFillPath2D;\n\nif (typeof window !== 'undefined') {\n  path2dPolyfill(window);\n}\n\nvar src = {\n  path2dPolyfill: path2dPolyfill,\n  parsePath: parsePath\n};\nvar src_2 = src.parsePath;\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\nvar defineProperty = Object.defineProperty;\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) { /**/ }\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\n// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target\nvar setProperty = function setProperty(target, options) {\n\tif (defineProperty && options.name === '__proto__') {\n\t\tdefineProperty(target, options.name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\tvalue: options.newValue,\n\t\t\twritable: true\n\t\t});\n\t} else {\n\t\ttarget[options.name] = options.newValue;\n\t}\n};\n\n// Return undefined instead of __proto__ if '__proto__' is not an own property\nvar getProperty = function getProperty(obj, name) {\n\tif (name === '__proto__') {\n\t\tif (!hasOwn.call(obj, name)) {\n\t\t\treturn void 0;\n\t\t} else if (gOPD) {\n\t\t\t// In early versions of node, obj['__proto__'] is buggy when obj has\n\t\t\t// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.\n\t\t\treturn gOPD(obj, name).value;\n\t\t}\n\t}\n\n\treturn obj[name];\n};\n\nvar extend = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone;\n\tvar target = arguments[0];\n\tvar i = 1;\n\tvar length = arguments.length;\n\tvar deep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\tif (target == null || (typeof target !== 'object' && typeof target !== 'function')) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = getProperty(target, name);\n\t\t\t\tcopy = getProperty(options, name);\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: extend(deep, clone, copy) });\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: copy });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\nvar about = {\n  version: '0.27.0'\n};\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck$1(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties$1(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass$1(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties$1(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray$1(arr) {\n  return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _nonIterableSpread$1();\n}\n\nfunction _arrayWithoutHoles$1(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray$1(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _nonIterableSpread$1() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\n/**\n * Initilize a new dock configuration\n * @private\n * @param {object} [settings] - Settings object\n * @returns {object} A dock configuration instance\n * @example\n * let instance = dockConfig({\n *  dock: 'left',\n *  displayOrder: 2,\n *  prioOrder: 1,\n *  preferredSize: 33,\n *  minimumLayoutMode: 'L',\n *  show: true\n * });\n */\nfunction dockConfig() {\n  var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var callbackContext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _settings$dock = settings.dock,\n      _dock = _settings$dock === void 0 ? 'center' : _settings$dock,\n      _settings$displayOrde = settings.displayOrder,\n      _displayOrder = _settings$displayOrde === void 0 ? 0 : _settings$displayOrde,\n      _settings$prioOrder = settings.prioOrder,\n      _prioOrder = _settings$prioOrder === void 0 ? 0 : _settings$prioOrder,\n      _settings$preferredSi = settings.preferredSize,\n      preferredSize = _settings$preferredSi === void 0 ? 0 : _settings$preferredSi,\n      _minimumLayoutMode = settings.minimumLayoutMode,\n      _settings$show = settings.show,\n      _show = _settings$show === void 0 ? true : _settings$show; // avoid empty string dock\n\n\n  _dock = _dock || 'center';\n  /**\n   * @private\n   */\n\n  return {\n    /**\n     * Returns the preferred size of a component.\n     * The return value of the function can either be a number representing the required size in the dock direction\n     * or an object with a `size` and `edgeBleed` property.\n     * @param {object} [inner]\n     * @param {object} [outer]\n     * @returns {number|object} Returns the computed preferred size\n     * @example\n     * dockConfig.computePreferredSize(() => 150); // Require a size of 150 in the dock direction\n     *\n     * dockConfig.computePreferredSize(() => ({\n     *  size: 150,\n     *  edgeBleed: {\n     *    left: 50,\n     *    right: 50\n     *  }\n     * })); // Require a size of 150 in the dock direction and a bleed size of 50 to the left and right dock direction\n     */\n    computePreferredSize: function computePreferredSize(_ref) {\n      var inner = _ref.inner,\n          outer = _ref.outer;\n\n      if (typeof preferredSize === 'function') {\n        return preferredSize({\n          inner: inner,\n          outer: outer,\n          dock: this.dock()\n        }, callbackContext);\n      }\n\n      return preferredSize;\n    },\n\n    /**\n     * Set the dock direction, supported values are left | right | top | bottom. Any other value will be interpreted as center dock.\n     * @param {string} [val=''] - Dock direction\n     * @returns {this} The current context\n     * @example\n     * dockConfig.dock('left');\n     */\n    dock: function dock(val) {\n      if (typeof val !== 'undefined') {\n        _dock = val;\n        return this;\n      }\n\n      return typeof _dock === 'function' ? _dock(callbackContext) : _dock;\n    },\n\n    /**\n     * The `displayOrder` property is used by the layout engine to lay out components.\n     * Components are interpreted in the ascending order of the `displayOrder` value. The layout engine apply the value in two ways,\n     * the first is the order in which components are rendererd. The second is the area components are laid out in\n     * when they have a direction, i.e. docked to either top, bottom, left or right.\n     *\n     * If docked at the same area, the component with a higher `displayOrder` will be rendered\n     * on top of the component with a lower `displayOrder`. It can be seen as defining a z-index.\n     * A lower `displayOrder` also means that a component will be laid out first in a given direction,\n     * i.e. laid out closer to the central area (non-directional area) then a component with a higher `displayOrder`.\n     * It can in this case be seen as the x-index or y-index.\n     * @param {number} [val=0] - The display order\n     * @returns {this|number} The current context or display order\n     * @example\n     * dockConfig.displayOrder(99);\n     */\n    displayOrder: function displayOrder(val) {\n      if (typeof val !== 'undefined') {\n        _displayOrder = val;\n        return this;\n      }\n\n      return typeof _displayOrder === 'function' ? _displayOrder(callbackContext) : _displayOrder;\n    },\n\n    /**\n     * The `prioOrder` property is used to define the order in which components are added to the layout engine,\n     * this is done before any components are laid out. When there is not enough space to add any more components\n     * to a given area, all components not all ready added, are then discarded. The `prioOrder` is interpreted\n     * in the ascending order. Such that a lower value is added to the layout engine first.\n     * @param {number} [val=0] - The prio order\n     * @returns {this|number} The current context or prio order\n     * @example\n     * dockConfig.prioOrder(-1);\n     */\n    prioOrder: function prioOrder(val) {\n      if (typeof val !== 'undefined') {\n        _prioOrder = val;\n        return this;\n      }\n\n      return typeof _prioOrder === 'function' ? _prioOrder(callbackContext) : _prioOrder;\n    },\n\n    /**\n     * Ger or set the minimumLayoutMode\n     * @param {string|object} [val] - The minimum layout mode\n     * @returns {string|object|this} If no parameter is passed the current context is returned, else the current layout mode.\n     * @example\n     * dockConfig.minimumLayoutMode('L');\n     * dockConfig.minimumLayoutMode({ width: 'S', height: 'L' });\n     */\n    minimumLayoutMode: function minimumLayoutMode(val) {\n      if (typeof val !== 'undefined') {\n        _minimumLayoutMode = val;\n        return this;\n      }\n\n      return typeof _minimumLayoutMode === 'function' ? _minimumLayoutMode(callbackContext) : _minimumLayoutMode;\n    },\n\n    /**\n     * Set the component visibility. If false the component is not added to the layout engine.\n     * @param {boolean} [val=true] - Toggle visibility\n     * @returns {this|boolean} The current context or show\n     */\n    show: function show(val) {\n      if (typeof val !== 'undefined') {\n        _show = val;\n        return this;\n      }\n\n      return typeof _show === 'function' ? _show(callbackContext) : _show;\n    }\n  };\n}\n\nfunction roundRect(rect) {\n  rect.x = Math.floor(rect.x);\n  rect.y = Math.floor(rect.y);\n  rect.width = Math.floor(rect.width);\n  rect.height = Math.floor(rect.height);\n}\n\nfunction resolveContainerRects(rect, settings) {\n  var containerRect = {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  };\n  var logicalContainerRect = {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  }; // Check input object for size\n\n  containerRect.width = rect.width || 0;\n  containerRect.height = rect.height || 0;\n\n  if (typeof settings.size !== 'undefined') {\n    containerRect.width = isNaN(settings.size.width) ? containerRect.width : settings.size.width;\n    containerRect.height = isNaN(settings.size.height) ? containerRect.height : settings.size.height;\n  }\n\n  if (typeof settings.logicalSize !== 'undefined') {\n    logicalContainerRect.width = isNaN(settings.logicalSize.width) ? containerRect.width : settings.logicalSize.width;\n    logicalContainerRect.height = isNaN(settings.logicalSize.height) ? containerRect.height : settings.logicalSize.height;\n    logicalContainerRect.align = isNaN(settings.logicalSize.align) ? 0.5 : Math.min(Math.max(settings.logicalSize.align, 0), 1);\n    logicalContainerRect.preserveAspectRatio = settings.logicalSize.preserveAspectRatio;\n  } else {\n    logicalContainerRect.width = containerRect.width;\n    logicalContainerRect.height = containerRect.height;\n    logicalContainerRect.preserveAspectRatio = false;\n  }\n\n  roundRect(logicalContainerRect);\n  roundRect(containerRect);\n  return {\n    logicalContainerRect: logicalContainerRect,\n    containerRect: containerRect\n  };\n}\nfunction resolveSettings(s) {\n  var settings = {\n    center: {\n      minWidthRatio: 0.5,\n      minHeightRatio: 0.5,\n      minWidth: 0,\n      minHeight: 0\n    }\n  };\n  extend(true, settings, s);\n  settings.center.minWidthRatio = Math.min(Math.max(settings.center.minWidthRatio, 0), 1); // Only accept value between 0-1\n\n  settings.center.minHeightRatio = Math.min(Math.max(settings.center.minHeightRatio, 0), 1); // Only accept value between 0-1\n\n  settings.center.minWidth = Math.max(settings.center.minWidth, 0); // Consider <= 0 to be falsy and fallback to ratio\n\n  settings.center.minHeight = Math.max(settings.center.minHeight, 0); // Consider <= 0 to be falsy and fallback to ratio\n\n  return settings;\n}\n\nfunction isNumber(v) {\n  return typeof v === 'number' && !isNaN(v);\n}\nfunction notNumber(value) {\n  return typeof value !== 'number' || isNaN(value);\n}\n\nfunction getMinMax(points) {\n  var num = points.length;\n  var xMin = NaN;\n  var xMax = NaN;\n  var yMin = NaN;\n  var yMax = NaN;\n\n  for (var i = 0; i < num; i++) {\n    xMin = isNaN(xMin) ? points[i].x : Math.min(xMin, points[i].x);\n    xMax = isNaN(xMax) ? points[i].x : Math.max(xMax, points[i].x);\n    yMin = isNaN(yMin) ? points[i].y : Math.min(yMin, points[i].y);\n    yMax = isNaN(yMax) ? points[i].y : Math.max(yMax, points[i].y);\n  }\n\n  return [xMin, yMin, xMax, yMax];\n}\n/**\n * @ignore\n * @param {oject} line\n * @returns {point[]} Array of points\n */\n\nfunction lineToPoints(line) {\n  var x1 = line.x1 || 0;\n  var y1 = line.y1 || 0;\n  var x2 = line.x2 || 0;\n  var y2 = line.y2 || 0;\n  return [{\n    x: x1,\n    y: y1\n  }, {\n    x: x2,\n    y: y2\n  }];\n}\n/**\n * @ignore\n * @param {oject} rect\n * @returns {point[]} Array of points\n */\n\nfunction rectToPoints(rect) {\n  return [{\n    x: rect.x,\n    y: rect.y\n  }, {\n    x: rect.x + rect.width,\n    y: rect.y\n  }, {\n    x: rect.x + rect.width,\n    y: rect.y + rect.height\n  }, {\n    x: rect.x,\n    y: rect.y + rect.height\n  }];\n}\nfunction pointsToRect(points) {\n  var _getMinMax = getMinMax(points),\n      _getMinMax2 = _slicedToArray(_getMinMax, 4),\n      xMin = _getMinMax2[0],\n      yMin = _getMinMax2[1],\n      xMax = _getMinMax2[2],\n      yMax = _getMinMax2[3];\n\n  return {\n    x: xMin,\n    y: yMin,\n    width: xMax - xMin,\n    height: yMax - yMin\n  };\n}\nfunction pointsToCircle(points, r) {\n  return {\n    cx: points[0].x,\n    cy: points[0].y,\n    r: r\n  };\n}\nfunction pointsToLine(points) {\n  return {\n    x1: points[0].x,\n    y1: points[0].y,\n    x2: points[1].x,\n    y2: points[1].y\n  };\n}\n/**\n * @ignore\n * @param {oject}\n * @returns {string} Type of geometry\n */\n\nfunction getShapeType(shape) {\n  var _ref = shape || {},\n      x = _ref.x,\n      y = _ref.y,\n      width = _ref.width,\n      height = _ref.height,\n      x1 = _ref.x1,\n      x2 = _ref.x2,\n      y1 = _ref.y1,\n      y2 = _ref.y2,\n      cx = _ref.cx,\n      cy = _ref.cy,\n      r = _ref.r,\n      vertices = _ref.vertices;\n\n  if (isNumber(cx) && isNumber(cy) && isNumber(r)) {\n    return 'circle';\n  }\n\n  if (isNumber(x1) && isNumber(x2) && isNumber(y1) && isNumber(y2)) {\n    return 'line';\n  }\n\n  if (isNumber(x) && isNumber(y) && isNumber(width) && isNumber(height)) {\n    return 'rect';\n  }\n\n  if (isNumber(x) && isNumber(y)) {\n    return 'point';\n  }\n\n  if (Array.isArray(vertices)) {\n    return 'polygon';\n  }\n\n  return null;\n}\nfunction expandRect(size, rect) {\n  return {\n    x: rect.x - size,\n    y: rect.y - size,\n    width: rect.width + size,\n    height: rect.height + size\n  };\n}\n\nfunction createRect(x, y, width, height, margin) {\n  return {\n    x: isNaN(x) ? 0 : x,\n    y: isNaN(x) ? 0 : y,\n    width: isNaN(x) ? 0 : width,\n    height: isNaN(x) ? 0 : height,\n    margin: isNaN(margin) ? 0 : margin\n  };\n}\n\nfunction cacheSize(c, reducedRect, layoutRect) {\n  if (typeof c.cachedSize === 'undefined') {\n    var dock = c.config.dock();\n    var size = c.comp.preferredSize({\n      inner: reducedRect,\n      outer: layoutRect,\n      dock: dock\n    }); // backwards compatibility\n\n    if (!isNaN(size)) {\n      size = {\n        width: size,\n        height: size\n      };\n    } else if (size && !isNaN(size.size)) {\n      size.width = size.size;\n      size.height = size.size;\n    }\n\n    var relevantSize;\n\n    if (dock === 'top' || dock === 'bottom') {\n      relevantSize = size.height;\n    } else if (dock === 'right' || dock === 'left') {\n      relevantSize = size.width;\n    } else {\n      relevantSize = Math.max(size.width, size.height);\n    }\n\n    c.cachedSize = Math.ceil(relevantSize);\n    c.edgeBleed = size.edgeBleed || 0;\n  }\n\n  return c.cachedSize;\n}\n\nfunction validateReduceRect(rect, reducedRect, settings) {\n  // Absolute value for width/height should have predence over relative value\n  var minReduceWidth = Math.min(settings.center.minWidth, rect.width) || Math.max(rect.width * settings.center.minWidthRatio, 1);\n  var minReduceHeight = Math.min(settings.center.minHeight, rect.height) || Math.max(rect.height * settings.center.minHeightRatio, 1);\n  return reducedRect.width >= minReduceWidth && reducedRect.height >= minReduceHeight;\n}\n\nfunction reduceDocRect(reducedRect, c) {\n  switch (c.config.dock()) {\n    case 'top':\n      reducedRect.y += c.cachedSize;\n      reducedRect.height -= c.cachedSize;\n      break;\n\n    case 'bottom':\n      reducedRect.height -= c.cachedSize;\n      break;\n\n    case 'left':\n      reducedRect.x += c.cachedSize;\n      reducedRect.width -= c.cachedSize;\n      break;\n\n    case 'right':\n      reducedRect.width -= c.cachedSize;\n      break;\n\n    default:\n  }\n}\n\nfunction addEdgeBleed(currentEdgeBleed, c) {\n  var edgeBleed = c.edgeBleed;\n\n  if (!edgeBleed) {\n    return;\n  }\n\n  currentEdgeBleed.left = Math.max(currentEdgeBleed.left, edgeBleed.left || 0);\n  currentEdgeBleed.right = Math.max(currentEdgeBleed.right, edgeBleed.right || 0);\n  currentEdgeBleed.top = Math.max(currentEdgeBleed.top, edgeBleed.top || 0);\n  currentEdgeBleed.bottom = Math.max(currentEdgeBleed.bottom, edgeBleed.bottom || 0);\n}\n\nfunction reduceEdgeBleed(layoutRect, reducedRect, edgeBleed) {\n  if (reducedRect.x < edgeBleed.left) {\n    reducedRect.width -= edgeBleed.left - reducedRect.x;\n    reducedRect.x = edgeBleed.left;\n  }\n\n  var reducedRectRightBoundary = layoutRect.width - (reducedRect.x + reducedRect.width);\n\n  if (reducedRectRightBoundary < edgeBleed.right) {\n    reducedRect.width -= edgeBleed.right - reducedRectRightBoundary;\n  }\n\n  if (reducedRect.y < edgeBleed.top) {\n    reducedRect.height -= edgeBleed.top - reducedRect.y;\n    reducedRect.y = edgeBleed.top;\n  }\n\n  var reducedRectBottomBoundary = layoutRect.height - (reducedRect.y + reducedRect.height);\n\n  if (reducedRectBottomBoundary < edgeBleed.bottom) {\n    reducedRect.height -= edgeBleed.bottom - reducedRectBottomBoundary;\n  }\n}\n\nfunction reduceSingleLayoutRect(layoutRect, reducedRect, edgeBleed, c, settings) {\n  var newReduceRect = extend({}, reducedRect);\n  var newEdgeBleed = extend({}, edgeBleed);\n  reduceDocRect(newReduceRect, c);\n  addEdgeBleed(newEdgeBleed, c);\n  reduceEdgeBleed(layoutRect, newReduceRect, newEdgeBleed);\n  var isValid = validateReduceRect(layoutRect, newReduceRect, settings);\n\n  if (!isValid) {\n    return false;\n  }\n\n  reduceDocRect(reducedRect, c);\n  addEdgeBleed(edgeBleed, c);\n  return true;\n}\n/**\n * Updates the visible and hidden components based on components that are docked to other components.\n * For example, assume a component called myRect:\n * {\n *  key: 'myRect',\n *  type: 'rect',\n *  dock: 'bottom'\n * }\n * and a component called myLine:\n * {\n *  key: 'myLine',\n *  type: 'line',\n *  dock: '@myRect'\n * }\n * if the layout engine decides to hide myRect, then myLine should be hidden as well.\n * @param {Array} visible - Components to be decided if they should be hidden or not.\n * @param {Array} hidden - Components that are already hidden.\n * @returns {Object} containing the new visible components and additional components to be hidden.\n * @ignore\n */\n\n\nfunction filterReferencedDocks(visible, hidden) {\n  if (hidden.length === 0) {\n    return;\n  }\n\n  for (var i = 0; i < visible.length; ++i) {\n    var v = visible[i];\n\n    if (v.referencedDocks.length) {\n      var isAllHidden = v.referencedDocks.every(function (refDock) {\n        return hidden.some(function (h) {\n          return h.key === refDock;\n        });\n      });\n\n      if (isAllHidden) {\n        hidden.push(visible.splice(i, 1)[0]);\n      }\n    }\n  }\n}\n\nfunction reduceLayoutRect(_ref) {\n  var layoutRect = _ref.layoutRect,\n      visible = _ref.visible,\n      hidden = _ref.hidden,\n      settings = _ref.settings;\n  var reducedRect = createRect(layoutRect.x, layoutRect.y, layoutRect.width, layoutRect.height);\n  var edgeBleed = {\n    left: 0,\n    right: 0,\n    top: 0,\n    bottom: 0\n  };\n  var sortedComponents = visible.slice();\n  sortedComponents.sort(function (a, b) {\n    return a.config.prioOrder() - b.config.prioOrder();\n  }); // lower prioOrder will have higher prio\n\n  for (var i = 0; i < sortedComponents.length; ++i) {\n    var c = sortedComponents[i];\n    cacheSize(c, reducedRect, layoutRect);\n\n    if (!reduceSingleLayoutRect(layoutRect, reducedRect, edgeBleed, c, settings)) {\n      hidden.push(sortedComponents.splice(i, 1)[0]);\n      --i;\n    }\n  }\n\n  filterReferencedDocks(visible, hidden);\n  var filteredUnsortedComps = visible.filter(function (c) {\n    return sortedComponents.indexOf(c) !== -1;\n  });\n  visible.length = 0;\n  visible.push.apply(visible, _toConsumableArray$1(filteredUnsortedComps));\n  reduceEdgeBleed(layoutRect, reducedRect, edgeBleed);\n  return reducedRect;\n}\n\nfunction computeRect(rect) {\n  return {\n    x: rect.margin.left + rect.x * rect.scaleRatio.x,\n    y: rect.margin.top + rect.y * rect.scaleRatio.y,\n    width: rect.width * rect.scaleRatio.x,\n    height: rect.height * rect.scaleRatio.y\n  };\n}\n\nfunction appendScaleRatio(rect, outerRect, layoutRect, containerRect) {\n  var scaleRatio = {\n    x: containerRect.width / layoutRect.width,\n    y: containerRect.height / layoutRect.height\n  };\n  var margin = {\n    left: 0,\n    top: 0\n  };\n\n  if (layoutRect.preserveAspectRatio) {\n    var xLessThenY = scaleRatio.x < scaleRatio.y; // To preserve the aspect ratio, take the smallest ratio and apply in both directions to \"meet\" the size of the container\n\n    var minRatio = Math.min(scaleRatio.x, scaleRatio.y);\n    scaleRatio.x = minRatio;\n    scaleRatio.y = minRatio;\n    var area = xLessThenY ? 'height' : 'width';\n    var spread = (containerRect[area] - layoutRect[area] * scaleRatio.x) * layoutRect.align;\n    margin.left = xLessThenY ? 0 : spread;\n    margin.top = xLessThenY ? spread : 0;\n  }\n\n  rect.scaleRatio = scaleRatio;\n  rect.margin = margin;\n  outerRect.scaleRatio = scaleRatio;\n  outerRect.margin = margin;\n  layoutRect.scaleRatio = scaleRatio;\n  layoutRect.margin = margin;\n}\n\nfunction boundingBox(rects) {\n  var _ref2;\n\n  var points = (_ref2 = []).concat.apply(_ref2, _toConsumableArray$1(rects.map(rectToPoints)));\n\n  return pointsToRect(points);\n}\n\nfunction positionComponents(_ref3) {\n  var visible = _ref3.visible,\n      layoutRect = _ref3.layoutRect,\n      reducedRect = _ref3.reducedRect,\n      containerRect = _ref3.containerRect,\n      translation = _ref3.translation;\n  var vRect = createRect(reducedRect.x, reducedRect.y, reducedRect.width, reducedRect.height);\n  var hRect = createRect(reducedRect.x, reducedRect.y, reducedRect.width, reducedRect.height);\n  var referencedComponents = {};\n  var referenceArray = visible.slice();\n  var elementOrder = referenceArray.slice().sort(function (a, b) {\n    return a.config.displayOrder() - b.config.displayOrder();\n  });\n  visible.sort(function (a, b) {\n    if (b.referencedDocks.length > 0) {\n      return -1;\n    }\n\n    if (a.referencedDocks.length > 0) {\n      return 1;\n    }\n\n    var diff = a.config.displayOrder() - b.config.displayOrder();\n\n    if (diff === 0) {\n      return referenceArray.indexOf(a) - referenceArray.indexOf(b);\n    }\n\n    return diff;\n  }).forEach(function (c) {\n    var outerRect = {};\n    var rect = {};\n    var d = c.config.dock();\n\n    switch (d) {\n      case 'top':\n        outerRect.height = rect.height = c.cachedSize;\n        outerRect.width = layoutRect.width;\n        rect.width = vRect.width;\n        outerRect.x = layoutRect.x;\n        rect.x = vRect.x;\n        outerRect.y = rect.y = vRect.y - c.cachedSize;\n        vRect.y -= c.cachedSize;\n        vRect.height += c.cachedSize;\n        break;\n\n      case 'bottom':\n        outerRect.x = layoutRect.x;\n        rect.x = vRect.x;\n        outerRect.y = rect.y = vRect.y + vRect.height;\n        outerRect.width = layoutRect.width;\n        rect.width = vRect.width;\n        outerRect.height = rect.height = c.cachedSize;\n        vRect.height += c.cachedSize;\n        break;\n\n      case 'left':\n        outerRect.x = rect.x = hRect.x - c.cachedSize;\n        outerRect.y = layoutRect.y;\n        rect.y = hRect.y;\n        outerRect.width = rect.width = c.cachedSize;\n        outerRect.height = layoutRect.height;\n        rect.height = hRect.height;\n        hRect.x -= c.cachedSize;\n        hRect.width += c.cachedSize;\n        break;\n\n      case 'right':\n        outerRect.x = rect.x = hRect.x + hRect.width;\n        outerRect.y = layoutRect.y;\n        rect.y = hRect.y;\n        outerRect.width = rect.width = c.cachedSize;\n        outerRect.height = layoutRect.height;\n        rect.height = hRect.height;\n        hRect.width += c.cachedSize;\n        break;\n\n      case 'center':\n        outerRect.x = rect.x = reducedRect.x;\n        outerRect.y = rect.y = reducedRect.y;\n        outerRect.width = rect.width = reducedRect.width;\n        outerRect.height = rect.height = reducedRect.height;\n        break;\n\n      default:\n        if (c.referencedDocks.length > 0) {\n          var refs = c.referencedDocks.map(function (ref) {\n            return referencedComponents[ref];\n          }).filter(function (ref) {\n            return !!ref;\n          });\n\n          if (refs.length > 0) {\n            outerRect = boundingBox(refs.map(function (ref) {\n              return ref.outerRect;\n            }));\n            rect = boundingBox(refs.map(function (ref) {\n              return ref.r;\n            }));\n          }\n        }\n\n        break;\n    }\n\n    if (c.key) {\n      referencedComponents[c.key] = {\n        // store the size of this component\n        r: rect,\n        outerRect: outerRect\n      };\n    }\n\n    appendScaleRatio(rect, outerRect, layoutRect, containerRect);\n    rect.edgeBleed = c.edgeBleed;\n    rect.computed = computeRect(rect);\n    outerRect.edgeBleed = c.edgeBleed;\n    outerRect.computed = computeRect(outerRect);\n    rect.x += translation.x;\n    rect.y += translation.y;\n    outerRect.x += translation.x;\n    outerRect.y += translation.y;\n    c.comp.resize(rect, outerRect);\n    c.cachedSize = undefined;\n    c.edgeBleed = undefined;\n  });\n  return visible.map(function (c) {\n    return elementOrder.indexOf(c);\n  });\n}\n\nfunction checkShowSettings(strategySettings, dockSettings, logicalContainerRect) {\n  var layoutModes = strategySettings.layoutModes || {};\n  var minimumLayoutMode = dockSettings.minimumLayoutMode();\n  var show = dockSettings.show();\n\n  if (show && _typeof(minimumLayoutMode) === 'object') {\n    show = layoutModes[minimumLayoutMode.width] && layoutModes[minimumLayoutMode.height] && logicalContainerRect.width >= layoutModes[minimumLayoutMode.width].width && logicalContainerRect.height >= layoutModes[minimumLayoutMode.height].height;\n  } else if (show && minimumLayoutMode !== undefined) {\n    show = layoutModes[minimumLayoutMode] && logicalContainerRect.width >= layoutModes[minimumLayoutMode].width && logicalContainerRect.height >= layoutModes[minimumLayoutMode].height;\n  }\n\n  return show;\n}\n\nfunction validateComponent(component) {\n  if (!component.settings && !component.settings) {\n    throw new Error('Invalid component settings');\n  }\n\n  if (!component.resize || typeof component.resize !== 'function') {\n    throw new Error('Component is missing resize function');\n  }\n\n  if (!component.dockConfig && !component.preferredSize) {\n    throw new Error('Component is missing preferredSize function');\n  }\n}\n\nfunction filterComponents(components, settings, rect) {\n  var visible = [];\n  var hidden = []; // check show settings\n\n  for (var i = 0; i < components.length; ++i) {\n    var comp = components[i];\n    validateComponent(comp); // backwards compatibility\n\n    var config = void 0;\n\n    if (comp.instance) {\n      config = comp.instance.dockConfig();\n    } else {\n      config = dockConfig(comp.settings.layout);\n    }\n\n    var key = comp.settings.key;\n    var d = config.dock();\n    var referencedDocks = /@/.test(d) ? d.split(',').map(function (s) {\n      return s.replace(/^\\s*@/, '');\n    }) : [];\n\n    if (checkShowSettings(settings, config, rect)) {\n      visible.push({\n        comp: comp,\n        key: key,\n        config: config,\n        referencedDocks: referencedDocks\n      });\n    } else {\n      hidden.push({\n        comp: comp,\n        key: key,\n        config: config,\n        referencedDocks: referencedDocks\n      });\n    }\n  }\n\n  return [visible, hidden];\n}\n/**\n * @typedef {object} dock-layout-settings\n * @property {object} [logicalSize] - Logical size\n * @property {number} [logicalSize.width] - Width in pixels\n * @property {number} [logicalSize.height] - Height in pixels\n * @property {boolean} [logicalSize.preserveAspectRatio=false] - If true, takes the smallest ratio of width/height between logical and physical size ( physical / logical )\n * @property {number} [logicalSize.align=0.5] - Normalized value between 0-1. Defines how the space around the scaled axis is spread in the container, with 0.5 meaning the spread is equal on both sides. Only applicable if preserveAspectRatio is set to true\n * @property {object} [center] - Define how much space the center dock area requires\n * @property {number} [center.minWidthRatio=0.5] - Value between 0 and 1\n * @property {number} [center.minHeightRatio=0.5] - Value between 0 and 1\n * @property {number} [center.minWidth] - Width in pixels\n * @property {number} [center.minHeight] - Height in pixels\n * @property {object<string, {width: number, height: number}>} [layoutModes] Dictionary with named sizes\n */\n\n\nfunction dockLayout(initialSettings) {\n  var settings = resolveSettings(initialSettings);\n  var docker = {};\n\n  docker.layout = function layout(rect) {\n    var components = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    if (!rect || isNaN(rect.x) || isNaN(rect.y) || isNaN(rect.width) || isNaN(rect.height)) {\n      throw new Error('Invalid rect');\n    }\n\n    if (!components.length) {\n      return {\n        visible: [],\n        hidden: []\n      };\n    }\n\n    var _resolveContainerRect = resolveContainerRects(rect, settings),\n        logicalContainerRect = _resolveContainerRect.logicalContainerRect,\n        containerRect = _resolveContainerRect.containerRect;\n\n    var _filterComponents = filterComponents(components, settings, logicalContainerRect),\n        _filterComponents2 = _slicedToArray(_filterComponents, 2),\n        visible = _filterComponents2[0],\n        hidden = _filterComponents2[1];\n\n    var reducedRect = reduceLayoutRect({\n      layoutRect: logicalContainerRect,\n      visible: visible,\n      hidden: hidden,\n      settings: settings\n    });\n    var translation = {\n      x: rect.x,\n      y: rect.y\n    };\n    var order = positionComponents({\n      visible: visible,\n      layoutRect: logicalContainerRect,\n      reducedRect: reducedRect,\n      containerRect: containerRect,\n      translation: translation\n    });\n    hidden.forEach(function (c) {\n      c.comp.visible = false; // set empty rects on hidden components\n\n      var r = createRect();\n      c.comp.resize(r, r);\n    });\n    return {\n      visible: visible.map(function (v) {\n        return v.comp;\n      }),\n      hidden: hidden.map(function (h) {\n        return h.comp;\n      }),\n      order: order\n    };\n  };\n\n  docker.settings = function settingsFn(s) {\n    settings = resolveSettings(s);\n  };\n\n  return docker;\n}\n\n/* global navigator */\nfunction detectTouchSupport(e) {\n  if ('ontouchstart' in e && 'ontouchend' in e || navigator.maxTouchPoints > 1) {\n    return true;\n  }\n\n  return false;\n}\nfunction isTouchEvent(e) {\n  return !!e.changedTouches;\n}\nfunction isValidTapEvent(e, eventInfo) {\n  var isTouch = isTouchEvent(e);\n  var ee = isTouch ? e.changedTouches[0] : e;\n  var dt = Date.now() - eventInfo.time;\n  var dx = isNaN(eventInfo.x) ? 0 : Math.abs(ee.clientX - eventInfo.x);\n  var dy = isNaN(eventInfo.y) ? 0 : Math.abs(ee.clientY - eventInfo.y);\n  return (e.button === 0 || isTouch) && !eventInfo.multiTouch && dx <= 12 && dy <= 12 && dt <= 300;\n}\n\n// import types from './types';\n\n/**\n * @ignore\n * @param {Array<data-source>} dataSources\n * @param {any} { logger }\n * @returns {function}\n */\nfunction datasets(dataSources, _ref) {\n  var types = _ref.types,\n      logger = _ref.logger;\n  var data = {};\n  var sets = [];\n\n  if (!Array.isArray(dataSources)) {\n    logger.warn('Deprecated: \"data-source\" configuration\"');\n    sets.push(dataSources);\n  } else {\n    sets.push.apply(sets, _toConsumableArray$1(dataSources));\n  }\n\n  sets.forEach(function (d, i) {\n    var datasetFactory = types(d.type);\n\n    if (datasetFactory) {\n      var key = d.key;\n\n      if (typeof d.key === 'undefined') {\n        logger.warn(\"Missing key for dataset. Using index '\".concat(i, \"' as key.\"));\n        key = i;\n      }\n\n      var dataset = datasetFactory({\n        key: key,\n        data: d.data,\n        config: d.config\n      });\n      data[key] = dataset;\n    }\n  });\n  /**\n   * Returns the `dataset` which has `key` as identifier\n   * @ignore\n   * @param {string} key - The dataset identifier\n   * @returns {dataset}\n   */\n\n  var fn = function fn(key) {\n    if (key) {\n      return data[key];\n    }\n\n    return data[Object.keys(data)[0]];\n  };\n\n  return fn;\n}\n/**\n * @typedef {object} data-source\n * @property {string} key - Unique identifier for this data source\n * @property {string} type - The dataset type\n * @property {any} data\n */\n\nvar pi = Math.PI,\n    tau = 2 * pi,\n    epsilon = 1e-6,\n    tauEpsilon = tau - epsilon;\n\nfunction Path() {\n  this._x0 = this._y0 = // start of current subpath\n  this._x1 = this._y1 = null; // end of current subpath\n  this._ = \"\";\n}\n\nfunction path() {\n  return new Path;\n}\n\nPath.prototype = path.prototype = {\n  constructor: Path,\n  moveTo: function(x, y) {\n    this._ += \"M\" + (this._x0 = this._x1 = +x) + \",\" + (this._y0 = this._y1 = +y);\n  },\n  closePath: function() {\n    if (this._x1 !== null) {\n      this._x1 = this._x0, this._y1 = this._y0;\n      this._ += \"Z\";\n    }\n  },\n  lineTo: function(x, y) {\n    this._ += \"L\" + (this._x1 = +x) + \",\" + (this._y1 = +y);\n  },\n  quadraticCurveTo: function(x1, y1, x, y) {\n    this._ += \"Q\" + (+x1) + \",\" + (+y1) + \",\" + (this._x1 = +x) + \",\" + (this._y1 = +y);\n  },\n  bezierCurveTo: function(x1, y1, x2, y2, x, y) {\n    this._ += \"C\" + (+x1) + \",\" + (+y1) + \",\" + (+x2) + \",\" + (+y2) + \",\" + (this._x1 = +x) + \",\" + (this._y1 = +y);\n  },\n  arcTo: function(x1, y1, x2, y2, r) {\n    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;\n    var x0 = this._x1,\n        y0 = this._y1,\n        x21 = x2 - x1,\n        y21 = y2 - y1,\n        x01 = x0 - x1,\n        y01 = y0 - y1,\n        l01_2 = x01 * x01 + y01 * y01;\n\n    // Is the radius negative? Error.\n    if (r < 0) throw new Error(\"negative radius: \" + r);\n\n    // Is this path empty? Move to (x1,y1).\n    if (this._x1 === null) {\n      this._ += \"M\" + (this._x1 = x1) + \",\" + (this._y1 = y1);\n    }\n\n    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.\n    else if (!(l01_2 > epsilon));\n\n    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?\n    // Equivalently, is (x1,y1) coincident with (x2,y2)?\n    // Or, is the radius zero? Line to (x1,y1).\n    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {\n      this._ += \"L\" + (this._x1 = x1) + \",\" + (this._y1 = y1);\n    }\n\n    // Otherwise, draw an arc!\n    else {\n      var x20 = x2 - x0,\n          y20 = y2 - y0,\n          l21_2 = x21 * x21 + y21 * y21,\n          l20_2 = x20 * x20 + y20 * y20,\n          l21 = Math.sqrt(l21_2),\n          l01 = Math.sqrt(l01_2),\n          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),\n          t01 = l / l01,\n          t21 = l / l21;\n\n      // If the start tangent is not coincident with (x0,y0), line to.\n      if (Math.abs(t01 - 1) > epsilon) {\n        this._ += \"L\" + (x1 + t01 * x01) + \",\" + (y1 + t01 * y01);\n      }\n\n      this._ += \"A\" + r + \",\" + r + \",0,0,\" + (+(y01 * x20 > x01 * y20)) + \",\" + (this._x1 = x1 + t21 * x21) + \",\" + (this._y1 = y1 + t21 * y21);\n    }\n  },\n  arc: function(x, y, r, a0, a1, ccw) {\n    x = +x, y = +y, r = +r;\n    var dx = r * Math.cos(a0),\n        dy = r * Math.sin(a0),\n        x0 = x + dx,\n        y0 = y + dy,\n        cw = 1 ^ ccw,\n        da = ccw ? a0 - a1 : a1 - a0;\n\n    // Is the radius negative? Error.\n    if (r < 0) throw new Error(\"negative radius: \" + r);\n\n    // Is this path empty? Move to (x0,y0).\n    if (this._x1 === null) {\n      this._ += \"M\" + x0 + \",\" + y0;\n    }\n\n    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).\n    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {\n      this._ += \"L\" + x0 + \",\" + y0;\n    }\n\n    // Is this arc empty? We’re done.\n    if (!r) return;\n\n    // Does the angle go the wrong way? Flip the direction.\n    if (da < 0) da = da % tau + tau;\n\n    // Is this a complete circle? Draw two arcs to complete the circle.\n    if (da > tauEpsilon) {\n      this._ += \"A\" + r + \",\" + r + \",0,1,\" + cw + \",\" + (x - dx) + \",\" + (y - dy) + \"A\" + r + \",\" + r + \",0,1,\" + cw + \",\" + (this._x1 = x0) + \",\" + (this._y1 = y0);\n    }\n\n    // Is this arc non-empty? Draw an arc!\n    else if (da > epsilon) {\n      this._ += \"A\" + r + \",\" + r + \",0,\" + (+(da >= pi)) + \",\" + cw + \",\" + (this._x1 = x + r * Math.cos(a1)) + \",\" + (this._y1 = y + r * Math.sin(a1));\n    }\n  },\n  rect: function(x, y, w, h) {\n    this._ += \"M\" + (this._x0 = this._x1 = +x) + \",\" + (this._y0 = this._y1 = +y) + \"h\" + (+w) + \"v\" + (+h) + \"h\" + (-w) + \"Z\";\n  },\n  toString: function() {\n    return this._;\n  }\n};\n\nfunction constant(x) {\n  return function constant() {\n    return x;\n  };\n}\n\nvar abs = Math.abs;\nvar atan2 = Math.atan2;\nvar cos = Math.cos;\nvar max = Math.max;\nvar min = Math.min;\nvar sin = Math.sin;\nvar sqrt = Math.sqrt;\n\nvar epsilon$1 = 1e-12;\nvar pi$1 = Math.PI;\nvar halfPi = pi$1 / 2;\nvar tau$1 = 2 * pi$1;\n\nfunction acos(x) {\n  return x > 1 ? 0 : x < -1 ? pi$1 : Math.acos(x);\n}\n\nfunction asin(x) {\n  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);\n}\n\nfunction arcInnerRadius(d) {\n  return d.innerRadius;\n}\n\nfunction arcOuterRadius(d) {\n  return d.outerRadius;\n}\n\nfunction arcStartAngle(d) {\n  return d.startAngle;\n}\n\nfunction arcEndAngle(d) {\n  return d.endAngle;\n}\n\nfunction arcPadAngle(d) {\n  return d && d.padAngle; // Note: optional!\n}\n\nfunction intersect(x0, y0, x1, y1, x2, y2, x3, y3) {\n  var x10 = x1 - x0, y10 = y1 - y0,\n      x32 = x3 - x2, y32 = y3 - y2,\n      t = y32 * x10 - x32 * y10;\n  if (t * t < epsilon$1) return;\n  t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;\n  return [x0 + t * x10, y0 + t * y10];\n}\n\n// Compute perpendicular offset line of length rc.\n// http://mathworld.wolfram.com/Circle-LineIntersection.html\nfunction cornerTangents(x0, y0, x1, y1, r1, rc, cw) {\n  var x01 = x0 - x1,\n      y01 = y0 - y1,\n      lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01),\n      ox = lo * y01,\n      oy = -lo * x01,\n      x11 = x0 + ox,\n      y11 = y0 + oy,\n      x10 = x1 + ox,\n      y10 = y1 + oy,\n      x00 = (x11 + x10) / 2,\n      y00 = (y11 + y10) / 2,\n      dx = x10 - x11,\n      dy = y10 - y11,\n      d2 = dx * dx + dy * dy,\n      r = r1 - rc,\n      D = x11 * y10 - x10 * y11,\n      d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)),\n      cx0 = (D * dy - dx * d) / d2,\n      cy0 = (-D * dx - dy * d) / d2,\n      cx1 = (D * dy + dx * d) / d2,\n      cy1 = (-D * dx + dy * d) / d2,\n      dx0 = cx0 - x00,\n      dy0 = cy0 - y00,\n      dx1 = cx1 - x00,\n      dy1 = cy1 - y00;\n\n  // Pick the closer of the two intersection points.\n  // TODO Is there a faster way to determine which intersection to use?\n  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;\n\n  return {\n    cx: cx0,\n    cy: cy0,\n    x01: -ox,\n    y01: -oy,\n    x11: cx0 * (r1 / r - 1),\n    y11: cy0 * (r1 / r - 1)\n  };\n}\n\nfunction arc() {\n  var innerRadius = arcInnerRadius,\n      outerRadius = arcOuterRadius,\n      cornerRadius = constant(0),\n      padRadius = null,\n      startAngle = arcStartAngle,\n      endAngle = arcEndAngle,\n      padAngle = arcPadAngle,\n      context = null;\n\n  function arc() {\n    var buffer,\n        r,\n        r0 = +innerRadius.apply(this, arguments),\n        r1 = +outerRadius.apply(this, arguments),\n        a0 = startAngle.apply(this, arguments) - halfPi,\n        a1 = endAngle.apply(this, arguments) - halfPi,\n        da = abs(a1 - a0),\n        cw = a1 > a0;\n\n    if (!context) context = buffer = path();\n\n    // Ensure that the outer radius is always larger than the inner radius.\n    if (r1 < r0) r = r1, r1 = r0, r0 = r;\n\n    // Is it a point?\n    if (!(r1 > epsilon$1)) context.moveTo(0, 0);\n\n    // Or is it a circle or annulus?\n    else if (da > tau$1 - epsilon$1) {\n      context.moveTo(r1 * cos(a0), r1 * sin(a0));\n      context.arc(0, 0, r1, a0, a1, !cw);\n      if (r0 > epsilon$1) {\n        context.moveTo(r0 * cos(a1), r0 * sin(a1));\n        context.arc(0, 0, r0, a1, a0, cw);\n      }\n    }\n\n    // Or is it a circular or annular sector?\n    else {\n      var a01 = a0,\n          a11 = a1,\n          a00 = a0,\n          a10 = a1,\n          da0 = da,\n          da1 = da,\n          ap = padAngle.apply(this, arguments) / 2,\n          rp = (ap > epsilon$1) && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)),\n          rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),\n          rc0 = rc,\n          rc1 = rc,\n          t0,\n          t1;\n\n      // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.\n      if (rp > epsilon$1) {\n        var p0 = asin(rp / r0 * sin(ap)),\n            p1 = asin(rp / r1 * sin(ap));\n        if ((da0 -= p0 * 2) > epsilon$1) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;\n        else da0 = 0, a00 = a10 = (a0 + a1) / 2;\n        if ((da1 -= p1 * 2) > epsilon$1) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;\n        else da1 = 0, a01 = a11 = (a0 + a1) / 2;\n      }\n\n      var x01 = r1 * cos(a01),\n          y01 = r1 * sin(a01),\n          x10 = r0 * cos(a10),\n          y10 = r0 * sin(a10);\n\n      // Apply rounded corners?\n      if (rc > epsilon$1) {\n        var x11 = r1 * cos(a11),\n            y11 = r1 * sin(a11),\n            x00 = r0 * cos(a00),\n            y00 = r0 * sin(a00),\n            oc;\n\n        // Restrict the corner radius according to the sector angle.\n        if (da < pi$1 && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {\n          var ax = x01 - oc[0],\n              ay = y01 - oc[1],\n              bx = x11 - oc[0],\n              by = y11 - oc[1],\n              kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),\n              lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);\n          rc0 = min(rc, (r0 - lc) / (kc - 1));\n          rc1 = min(rc, (r1 - lc) / (kc + 1));\n        }\n      }\n\n      // Is the sector collapsed to a line?\n      if (!(da1 > epsilon$1)) context.moveTo(x01, y01);\n\n      // Does the sector’s outer ring have rounded corners?\n      else if (rc1 > epsilon$1) {\n        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);\n        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);\n\n        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);\n\n        // Have the corners merged?\n        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);\n\n        // Otherwise, draw the two corners and the ring.\n        else {\n          context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);\n          context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);\n          context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);\n        }\n      }\n\n      // Or is the outer ring just a circular arc?\n      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);\n\n      // Is there no inner ring, and it’s a circular sector?\n      // Or perhaps it’s an annular sector collapsed due to padding?\n      if (!(r0 > epsilon$1) || !(da0 > epsilon$1)) context.lineTo(x10, y10);\n\n      // Does the sector’s inner ring (or point) have rounded corners?\n      else if (rc0 > epsilon$1) {\n        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);\n        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);\n\n        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);\n\n        // Have the corners merged?\n        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);\n\n        // Otherwise, draw the two corners and the ring.\n        else {\n          context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);\n          context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);\n          context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);\n        }\n      }\n\n      // Or is the inner ring just a circular arc?\n      else context.arc(0, 0, r0, a10, a00, cw);\n    }\n\n    context.closePath();\n\n    if (buffer) return context = null, buffer + \"\" || null;\n  }\n\n  arc.centroid = function() {\n    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,\n        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$1 / 2;\n    return [cos(a) * r, sin(a) * r];\n  };\n\n  arc.innerRadius = function(_) {\n    return arguments.length ? (innerRadius = typeof _ === \"function\" ? _ : constant(+_), arc) : innerRadius;\n  };\n\n  arc.outerRadius = function(_) {\n    return arguments.length ? (outerRadius = typeof _ === \"function\" ? _ : constant(+_), arc) : outerRadius;\n  };\n\n  arc.cornerRadius = function(_) {\n    return arguments.length ? (cornerRadius = typeof _ === \"function\" ? _ : constant(+_), arc) : cornerRadius;\n  };\n\n  arc.padRadius = function(_) {\n    return arguments.length ? (padRadius = _ == null ? null : typeof _ === \"function\" ? _ : constant(+_), arc) : padRadius;\n  };\n\n  arc.startAngle = function(_) {\n    return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant(+_), arc) : startAngle;\n  };\n\n  arc.endAngle = function(_) {\n    return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant(+_), arc) : endAngle;\n  };\n\n  arc.padAngle = function(_) {\n    return arguments.length ? (padAngle = typeof _ === \"function\" ? _ : constant(+_), arc) : padAngle;\n  };\n\n  arc.context = function(_) {\n    return arguments.length ? ((context = _ == null ? null : _), arc) : context;\n  };\n\n  return arc;\n}\n\nfunction Linear(context) {\n  this._context = context;\n}\n\nLinear.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; // proceed\n      default: this._context.lineTo(x, y); break;\n    }\n  }\n};\n\nfunction curveLinear(context) {\n  return new Linear(context);\n}\n\nfunction x(p) {\n  return p[0];\n}\n\nfunction y(p) {\n  return p[1];\n}\n\nfunction line() {\n  var x$1 = x,\n      y$1 = y,\n      defined = constant(true),\n      context = null,\n      curve = curveLinear,\n      output = null;\n\n  function line(data) {\n    var i,\n        n = data.length,\n        d,\n        defined0 = false,\n        buffer;\n\n    if (context == null) output = curve(buffer = path());\n\n    for (i = 0; i <= n; ++i) {\n      if (!(i < n && defined(d = data[i], i, data)) === defined0) {\n        if (defined0 = !defined0) output.lineStart();\n        else output.lineEnd();\n      }\n      if (defined0) output.point(+x$1(d, i, data), +y$1(d, i, data));\n    }\n\n    if (buffer) return output = null, buffer + \"\" || null;\n  }\n\n  line.x = function(_) {\n    return arguments.length ? (x$1 = typeof _ === \"function\" ? _ : constant(+_), line) : x$1;\n  };\n\n  line.y = function(_) {\n    return arguments.length ? (y$1 = typeof _ === \"function\" ? _ : constant(+_), line) : y$1;\n  };\n\n  line.defined = function(_) {\n    return arguments.length ? (defined = typeof _ === \"function\" ? _ : constant(!!_), line) : defined;\n  };\n\n  line.curve = function(_) {\n    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;\n  };\n\n  line.context = function(_) {\n    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;\n  };\n\n  return line;\n}\n\nfunction area() {\n  var x0 = x,\n      x1 = null,\n      y0 = constant(0),\n      y1 = y,\n      defined = constant(true),\n      context = null,\n      curve = curveLinear,\n      output = null;\n\n  function area(data) {\n    var i,\n        j,\n        k,\n        n = data.length,\n        d,\n        defined0 = false,\n        buffer,\n        x0z = new Array(n),\n        y0z = new Array(n);\n\n    if (context == null) output = curve(buffer = path());\n\n    for (i = 0; i <= n; ++i) {\n      if (!(i < n && defined(d = data[i], i, data)) === defined0) {\n        if (defined0 = !defined0) {\n          j = i;\n          output.areaStart();\n          output.lineStart();\n        } else {\n          output.lineEnd();\n          output.lineStart();\n          for (k = i - 1; k >= j; --k) {\n            output.point(x0z[k], y0z[k]);\n          }\n          output.lineEnd();\n          output.areaEnd();\n        }\n      }\n      if (defined0) {\n        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);\n        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);\n      }\n    }\n\n    if (buffer) return output = null, buffer + \"\" || null;\n  }\n\n  function arealine() {\n    return line().defined(defined).curve(curve).context(context);\n  }\n\n  area.x = function(_) {\n    return arguments.length ? (x0 = typeof _ === \"function\" ? _ : constant(+_), x1 = null, area) : x0;\n  };\n\n  area.x0 = function(_) {\n    return arguments.length ? (x0 = typeof _ === \"function\" ? _ : constant(+_), area) : x0;\n  };\n\n  area.x1 = function(_) {\n    return arguments.length ? (x1 = _ == null ? null : typeof _ === \"function\" ? _ : constant(+_), area) : x1;\n  };\n\n  area.y = function(_) {\n    return arguments.length ? (y0 = typeof _ === \"function\" ? _ : constant(+_), y1 = null, area) : y0;\n  };\n\n  area.y0 = function(_) {\n    return arguments.length ? (y0 = typeof _ === \"function\" ? _ : constant(+_), area) : y0;\n  };\n\n  area.y1 = function(_) {\n    return arguments.length ? (y1 = _ == null ? null : typeof _ === \"function\" ? _ : constant(+_), area) : y1;\n  };\n\n  area.lineX0 =\n  area.lineY0 = function() {\n    return arealine().x(x0).y(y0);\n  };\n\n  area.lineY1 = function() {\n    return arealine().x(x0).y(y1);\n  };\n\n  area.lineX1 = function() {\n    return arealine().x(x1).y(y0);\n  };\n\n  area.defined = function(_) {\n    return arguments.length ? (defined = typeof _ === \"function\" ? _ : constant(!!_), area) : defined;\n  };\n\n  area.curve = function(_) {\n    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;\n  };\n\n  area.context = function(_) {\n    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;\n  };\n\n  return area;\n}\n\nfunction descending(a, b) {\n  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\n}\n\nfunction identity(d) {\n  return d;\n}\n\nfunction pie() {\n  var value = identity,\n      sortValues = descending,\n      sort = null,\n      startAngle = constant(0),\n      endAngle = constant(tau$1),\n      padAngle = constant(0);\n\n  function pie(data) {\n    var i,\n        n = data.length,\n        j,\n        k,\n        sum = 0,\n        index = new Array(n),\n        arcs = new Array(n),\n        a0 = +startAngle.apply(this, arguments),\n        da = Math.min(tau$1, Math.max(-tau$1, endAngle.apply(this, arguments) - a0)),\n        a1,\n        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),\n        pa = p * (da < 0 ? -1 : 1),\n        v;\n\n    for (i = 0; i < n; ++i) {\n      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {\n        sum += v;\n      }\n    }\n\n    // Optionally sort the arcs by previously-computed values or by data.\n    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });\n    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });\n\n    // Compute the arcs! They are stored in the original data's order.\n    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {\n      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {\n        data: data[j],\n        index: i,\n        value: v,\n        startAngle: a0,\n        endAngle: a1,\n        padAngle: p\n      };\n    }\n\n    return arcs;\n  }\n\n  pie.value = function(_) {\n    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant(+_), pie) : value;\n  };\n\n  pie.sortValues = function(_) {\n    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;\n  };\n\n  pie.sort = function(_) {\n    return arguments.length ? (sort = _, sortValues = null, pie) : sort;\n  };\n\n  pie.startAngle = function(_) {\n    return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant(+_), pie) : startAngle;\n  };\n\n  pie.endAngle = function(_) {\n    return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant(+_), pie) : endAngle;\n  };\n\n  pie.padAngle = function(_) {\n    return arguments.length ? (padAngle = typeof _ === \"function\" ? _ : constant(+_), pie) : padAngle;\n  };\n\n  return pie;\n}\n\nvar slice = Array.prototype.slice;\n\nfunction point(that, x, y) {\n  that._context.bezierCurveTo(\n    (2 * that._x0 + that._x1) / 3,\n    (2 * that._y0 + that._y1) / 3,\n    (that._x0 + 2 * that._x1) / 3,\n    (that._y0 + 2 * that._y1) / 3,\n    (that._x0 + 4 * that._x1 + x) / 6,\n    (that._y0 + 4 * that._y1 + y) / 6\n  );\n}\n\nfunction Basis(context) {\n  this._context = context;\n}\n\nBasis.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 =\n    this._y0 = this._y1 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 3: point(this, this._x1, this._y1); // proceed\n      case 2: this._context.lineTo(this._x1, this._y1); break;\n    }\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed\n      default: point(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = x;\n    this._y0 = this._y1, this._y1 = y;\n  }\n};\n\nfunction curveBasis(context) {\n  return new Basis(context);\n}\n\nfunction point$1(that, x, y) {\n  that._context.bezierCurveTo(\n    that._x1 + that._k * (that._x2 - that._x0),\n    that._y1 + that._k * (that._y2 - that._y0),\n    that._x2 + that._k * (that._x1 - x),\n    that._y2 + that._k * (that._y1 - y),\n    that._x2,\n    that._y2\n  );\n}\n\nfunction Cardinal(context, tension) {\n  this._context = context;\n  this._k = (1 - tension) / 6;\n}\n\nCardinal.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 =\n    this._y0 = this._y1 = this._y2 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2: this._context.lineTo(this._x2, this._y2); break;\n      case 3: point$1(this, this._x1, this._y1); break;\n    }\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;\n      case 2: this._point = 3; // proceed\n      default: point$1(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nvar curveCardinal = (function custom(tension) {\n\n  function cardinal(context) {\n    return new Cardinal(context, tension);\n  }\n\n  cardinal.tension = function(tension) {\n    return custom(+tension);\n  };\n\n  return cardinal;\n})(0);\n\nfunction point$2(that, x, y) {\n  var x1 = that._x1,\n      y1 = that._y1,\n      x2 = that._x2,\n      y2 = that._y2;\n\n  if (that._l01_a > epsilon$1) {\n    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,\n        n = 3 * that._l01_a * (that._l01_a + that._l12_a);\n    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;\n    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;\n  }\n\n  if (that._l23_a > epsilon$1) {\n    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,\n        m = 3 * that._l23_a * (that._l23_a + that._l12_a);\n    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;\n    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;\n  }\n\n  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);\n}\n\nfunction CatmullRom(context, alpha) {\n  this._context = context;\n  this._alpha = alpha;\n}\n\nCatmullRom.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 =\n    this._y0 = this._y1 = this._y2 = NaN;\n    this._l01_a = this._l12_a = this._l23_a =\n    this._l01_2a = this._l12_2a = this._l23_2a =\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2: this._context.lineTo(this._x2, this._y2); break;\n      case 3: this.point(this._x2, this._y2); break;\n    }\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n\n    if (this._point) {\n      var x23 = this._x2 - x,\n          y23 = this._y2 - y;\n      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n    }\n\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; // proceed\n      default: point$2(this, x, y); break;\n    }\n\n    this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nvar curveCatmullRom = (function custom(alpha) {\n\n  function catmullRom(context) {\n    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);\n  }\n\n  catmullRom.alpha = function(alpha) {\n    return custom(+alpha);\n  };\n\n  return catmullRom;\n})(0.5);\n\nfunction sign(x) {\n  return x < 0 ? -1 : 1;\n}\n\n// Calculate the slopes of the tangents (Hermite-type interpolation) based on\n// the following paper: Steffen, M. 1990. A Simple Method for Monotonic\n// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.\n// NOV(II), P. 443, 1990.\nfunction slope3(that, x2, y2) {\n  var h0 = that._x1 - that._x0,\n      h1 = x2 - that._x1,\n      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),\n      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),\n      p = (s0 * h1 + s1 * h0) / (h0 + h1);\n  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;\n}\n\n// Calculate a one-sided slope.\nfunction slope2(that, t) {\n  var h = that._x1 - that._x0;\n  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;\n}\n\n// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations\n// \"you can express cubic Hermite interpolation in terms of cubic Bézier curves\n// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1\".\nfunction point$3(that, t0, t1) {\n  var x0 = that._x0,\n      y0 = that._y0,\n      x1 = that._x1,\n      y1 = that._y1,\n      dx = (x1 - x0) / 3;\n  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);\n}\n\nfunction MonotoneX(context) {\n  this._context = context;\n}\n\nMonotoneX.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 =\n    this._y0 = this._y1 =\n    this._t0 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2: this._context.lineTo(this._x1, this._y1); break;\n      case 3: point$3(this, this._t0, slope2(this, this._t0)); break;\n    }\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    var t1 = NaN;\n\n    x = +x, y = +y;\n    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; point$3(this, slope2(this, t1 = slope3(this, x, y)), t1); break;\n      default: point$3(this, this._t0, t1 = slope3(this, x, y)); break;\n    }\n\n    this._x0 = this._x1, this._x1 = x;\n    this._y0 = this._y1, this._y1 = y;\n    this._t0 = t1;\n  }\n};\n\nfunction MonotoneY(context) {\n  this._context = new ReflectContext(context);\n}\n\n(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {\n  MonotoneX.prototype.point.call(this, y, x);\n};\n\nfunction ReflectContext(context) {\n  this._context = context;\n}\n\nReflectContext.prototype = {\n  moveTo: function(x, y) { this._context.moveTo(y, x); },\n  closePath: function() { this._context.closePath(); },\n  lineTo: function(x, y) { this._context.lineTo(y, x); },\n  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }\n};\n\nfunction monotoneX(context) {\n  return new MonotoneX(context);\n}\n\nfunction monotoneY(context) {\n  return new MonotoneY(context);\n}\n\nfunction Natural(context) {\n  this._context = context;\n}\n\nNatural.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x = [];\n    this._y = [];\n  },\n  lineEnd: function() {\n    var x = this._x,\n        y = this._y,\n        n = x.length;\n\n    if (n) {\n      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);\n      if (n === 2) {\n        this._context.lineTo(x[1], y[1]);\n      } else {\n        var px = controlPoints(x),\n            py = controlPoints(y);\n        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {\n          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);\n        }\n      }\n    }\n\n    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n    this._x = this._y = null;\n  },\n  point: function(x, y) {\n    this._x.push(+x);\n    this._y.push(+y);\n  }\n};\n\n// See https://www.particleincell.com/2012/bezier-splines/ for derivation.\nfunction controlPoints(x) {\n  var i,\n      n = x.length - 1,\n      m,\n      a = new Array(n),\n      b = new Array(n),\n      r = new Array(n);\n  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];\n  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];\n  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];\n  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];\n  a[n - 1] = r[n - 1] / b[n - 1];\n  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];\n  b[n - 1] = (x[n] + a[n - 1]) / 2;\n  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];\n  return [a, b];\n}\n\nfunction curveNatural(context) {\n  return new Natural(context);\n}\n\nfunction Step(context, t) {\n  this._context = context;\n  this._t = t;\n}\n\nStep.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x = this._y = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; // proceed\n      default: {\n        if (this._t <= 0) {\n          this._context.lineTo(this._x, y);\n          this._context.lineTo(x, y);\n        } else {\n          var x1 = this._x * (1 - this._t) + x * this._t;\n          this._context.lineTo(x1, this._y);\n          this._context.lineTo(x1, y);\n        }\n        break;\n      }\n    }\n    this._x = x, this._y = y;\n  }\n};\n\nfunction curveStep(context) {\n  return new Step(context, 0.5);\n}\n\nfunction stepBefore(context) {\n  return new Step(context, 0);\n}\n\nfunction stepAfter(context) {\n  return new Step(context, 1);\n}\n\nfunction stackOffsetNone(series, order) {\n  if (!((n = series.length) > 1)) return;\n  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {\n    s0 = s1, s1 = series[order[i]];\n    for (j = 0; j < m; ++j) {\n      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];\n    }\n  }\n}\n\nfunction stackOrderNone(series) {\n  var n = series.length, o = new Array(n);\n  while (--n >= 0) o[n] = n;\n  return o;\n}\n\nfunction stackValue(d, key) {\n  return d[key];\n}\n\nfunction stack() {\n  var keys = constant([]),\n      order = stackOrderNone,\n      offset = stackOffsetNone,\n      value = stackValue;\n\n  function stack(data) {\n    var kz = keys.apply(this, arguments),\n        i,\n        m = data.length,\n        n = kz.length,\n        sz = new Array(n),\n        oz;\n\n    for (i = 0; i < n; ++i) {\n      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {\n        si[j] = sij = [0, +value(data[j], ki, j, data)];\n        sij.data = data[j];\n      }\n      si.key = ki;\n    }\n\n    for (i = 0, oz = order(sz); i < n; ++i) {\n      sz[oz[i]].index = i;\n    }\n\n    offset(sz, oz);\n    return sz;\n  }\n\n  stack.keys = function(_) {\n    return arguments.length ? (keys = typeof _ === \"function\" ? _ : constant(slice.call(_)), stack) : keys;\n  };\n\n  stack.value = function(_) {\n    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant(+_), stack) : value;\n  };\n\n  stack.order = function(_) {\n    return arguments.length ? (order = _ == null ? stackOrderNone : typeof _ === \"function\" ? _ : constant(slice.call(_)), stack) : order;\n  };\n\n  stack.offset = function(_) {\n    return arguments.length ? (offset = _ == null ? stackOffsetNone : _, stack) : offset;\n  };\n\n  return stack;\n}\n\nfunction stackOffsetExpand(series, order) {\n  if (!((n = series.length) > 0)) return;\n  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {\n    for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;\n    if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;\n  }\n  stackOffsetNone(series, order);\n}\n\nfunction stackOffsetDiverging(series, order) {\n  if (!((n = series.length) > 0)) return;\n  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {\n    for (yp = yn = 0, i = 0; i < n; ++i) {\n      if ((dy = (d = series[order[i]][j])[1] - d[0]) >= 0) {\n        d[0] = yp, d[1] = yp += dy;\n      } else if (dy < 0) {\n        d[1] = yn, d[0] = yn += dy;\n      } else {\n        d[0] = yp;\n      }\n    }\n  }\n}\n\nfunction stackOffsetSilhouette(series, order) {\n  if (!((n = series.length) > 0)) return;\n  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {\n    for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;\n    s0[j][1] += s0[j][0] = -y / 2;\n  }\n  stackOffsetNone(series, order);\n}\n\nfunction stackOffsetWiggle(series, order) {\n  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;\n  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {\n    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {\n      var si = series[order[i]],\n          sij0 = si[j][1] || 0,\n          sij1 = si[j - 1][1] || 0,\n          s3 = (sij0 - sij1) / 2;\n      for (var k = 0; k < i; ++k) {\n        var sk = series[order[k]],\n            skj0 = sk[j][1] || 0,\n            skj1 = sk[j - 1][1] || 0;\n        s3 += skj0 - skj1;\n      }\n      s1 += sij0, s2 += s3 * sij0;\n    }\n    s0[j - 1][1] += s0[j - 1][0] = y;\n    if (s1) y -= s2 / s1;\n  }\n  s0[j - 1][1] += s0[j - 1][0] = y;\n  stackOffsetNone(series, order);\n}\n\nfunction appearance(series) {\n  var peaks = series.map(peak);\n  return stackOrderNone(series).sort(function(a, b) { return peaks[a] - peaks[b]; });\n}\n\nfunction peak(series) {\n  var i = -1, j = 0, n = series.length, vi, vj = -Infinity;\n  while (++i < n) if ((vi = +series[i][1]) > vj) vj = vi, j = i;\n  return j;\n}\n\nfunction stackOrderAscending(series) {\n  var sums = series.map(sum);\n  return stackOrderNone(series).sort(function(a, b) { return sums[a] - sums[b]; });\n}\n\nfunction sum(series) {\n  var s = 0, i = -1, n = series.length, v;\n  while (++i < n) if (v = +series[i][1]) s += v;\n  return s;\n}\n\nfunction stackOrderInsideOut(series) {\n  var n = series.length,\n      i,\n      j,\n      sums = series.map(sum),\n      order = appearance(series),\n      top = 0,\n      bottom = 0,\n      tops = [],\n      bottoms = [];\n\n  for (i = 0; i < n; ++i) {\n    j = order[i];\n    if (top < bottom) {\n      top += sums[j];\n      tops.push(j);\n    } else {\n      bottom += sums[j];\n      bottoms.push(j);\n    }\n  }\n\n  return bottoms.reverse().concat(tops);\n}\n\nfunction stackOrderReverse(series) {\n  return stackOrderNone(series).reverse();\n}\n\nfunction registryFactory(parentRegistry) {\n  var registerName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'unspecified';\n  var logger = arguments.length > 2 ? arguments[2] : undefined;\n  var defaultValue;\n  var reg = {};\n  var parent = parentRegistry || {\n    get: function get() {\n      return undefined;\n    },\n    has: function has() {\n      return false;\n    },\n    default: function _default() {\n      return undefined;\n    }\n  };\n  defaultValue = parent.default();\n  /**\n   * @private\n   * @param {string} key\n   * @param {any} value\n   * @throws {TypeError} Key must be a non-empty string\n   * @returns {boolean} False if the given key already exists, true otherwise\n   * @example\n   * var r = registry();\n   * r.add( \"marker\", function(args) {\n   *   return new markers[args.type](args);\n   * });\n   *\n   */\n\n  function add(key, value) {\n    if (!key || typeof key !== 'string') {\n      throw new TypeError('Invalid argument: key must be a non-empty string');\n    }\n\n    if (key in reg) {\n      return false;\n    }\n\n    reg[key] = value;\n    return true;\n  }\n\n  function get(key) {\n    return reg[key] || parent.get(key);\n  }\n\n  function has(key) {\n    return !!reg[key] || parent.has(key);\n  }\n\n  function remove(key) {\n    var d = reg[key];\n    delete reg[key];\n    return d;\n  }\n\n  function getKeys() {\n    return Object.keys(reg);\n  }\n\n  function getValues() {\n    return Object.keys(reg).map(function (key) {\n      return reg[key];\n    });\n  }\n\n  function deflt(d) {\n    if (typeof d !== 'undefined') {\n      defaultValue = d;\n    }\n\n    return defaultValue;\n  }\n  /**\n   * @alias registry\n   * @interface\n   * @param {string} key\n   * @param {any} value\n   */\n\n\n  function registry(key, value) {\n    if (typeof value !== 'undefined') {\n      return add(key, value);\n    }\n\n    var ret = get(key);\n\n    if (logger && typeof ret === 'undefined') {\n      logger.warn(\"\".concat(key, \" does not exist in \").concat(registerName, \" registry\"));\n    }\n\n    return ret || get(defaultValue);\n  }\n\n  registry.add = add;\n  registry.get = get;\n  registry.has = has;\n  registry.remove = remove;\n  registry.getKeys = getKeys;\n  registry.getValues = getValues;\n  registry.default = deflt;\n  registry.register = add; // deprecated\n\n  return registry;\n}\n\n// Computes the decimal coefficient and exponent of the specified number x with\n// significant digits p, where x is positive and p is in [1, 21] or undefined.\n// For example, formatDecimal(1.23) returns [\"123\", 0].\nfunction formatDecimal(x, p) {\n  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf(\"e\")) < 0) return null; // NaN, ±Infinity\n  var i, coefficient = x.slice(0, i);\n\n  // The string returned by toExponential either has the form \\d\\.\\d+e[-+]\\d+\n  // (e.g., 1.2e+3) or the form \\de[-+]\\d+ (e.g., 1e+3).\n  return [\n    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,\n    +x.slice(i + 1)\n  ];\n}\n\nfunction exponent(x) {\n  return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;\n}\n\nfunction formatGroup(grouping, thousands) {\n  return function(value, width) {\n    var i = value.length,\n        t = [],\n        j = 0,\n        g = grouping[0],\n        length = 0;\n\n    while (i > 0 && g > 0) {\n      if (length + g + 1 > width) g = Math.max(1, width - length);\n      t.push(value.substring(i -= g, i + g));\n      if ((length += g + 1) > width) break;\n      g = grouping[j = (j + 1) % grouping.length];\n    }\n\n    return t.reverse().join(thousands);\n  };\n}\n\nfunction formatNumerals(numerals) {\n  return function(value) {\n    return value.replace(/[0-9]/g, function(i) {\n      return numerals[+i];\n    });\n  };\n}\n\n// [[fill]align][sign][symbol][0][width][,][.precision][~][type]\nvar re = /^(?:(.)?([<>=^]))?([+\\-( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?(~)?([a-z%])?$/i;\n\nfunction formatSpecifier(specifier) {\n  if (!(match = re.exec(specifier))) throw new Error(\"invalid format: \" + specifier);\n  var match;\n  return new FormatSpecifier({\n    fill: match[1],\n    align: match[2],\n    sign: match[3],\n    symbol: match[4],\n    zero: match[5],\n    width: match[6],\n    comma: match[7],\n    precision: match[8] && match[8].slice(1),\n    trim: match[9],\n    type: match[10]\n  });\n}\n\nformatSpecifier.prototype = FormatSpecifier.prototype; // instanceof\n\nfunction FormatSpecifier(specifier) {\n  this.fill = specifier.fill === undefined ? \" \" : specifier.fill + \"\";\n  this.align = specifier.align === undefined ? \">\" : specifier.align + \"\";\n  this.sign = specifier.sign === undefined ? \"-\" : specifier.sign + \"\";\n  this.symbol = specifier.symbol === undefined ? \"\" : specifier.symbol + \"\";\n  this.zero = !!specifier.zero;\n  this.width = specifier.width === undefined ? undefined : +specifier.width;\n  this.comma = !!specifier.comma;\n  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;\n  this.trim = !!specifier.trim;\n  this.type = specifier.type === undefined ? \"\" : specifier.type + \"\";\n}\n\nFormatSpecifier.prototype.toString = function() {\n  return this.fill\n      + this.align\n      + this.sign\n      + this.symbol\n      + (this.zero ? \"0\" : \"\")\n      + (this.width === undefined ? \"\" : Math.max(1, this.width | 0))\n      + (this.comma ? \",\" : \"\")\n      + (this.precision === undefined ? \"\" : \".\" + Math.max(0, this.precision | 0))\n      + (this.trim ? \"~\" : \"\")\n      + this.type;\n};\n\n// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.\nfunction formatTrim(s) {\n  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {\n    switch (s[i]) {\n      case \".\": i0 = i1 = i; break;\n      case \"0\": if (i0 === 0) i0 = i; i1 = i; break;\n      default: if (i0 > 0) { if (!+s[i]) break out; i0 = 0; } break;\n    }\n  }\n  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;\n}\n\nvar prefixExponent;\n\nfunction formatPrefixAuto(x, p) {\n  var d = formatDecimal(x, p);\n  if (!d) return x + \"\";\n  var coefficient = d[0],\n      exponent = d[1],\n      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,\n      n = coefficient.length;\n  return i === n ? coefficient\n      : i > n ? coefficient + new Array(i - n + 1).join(\"0\")\n      : i > 0 ? coefficient.slice(0, i) + \".\" + coefficient.slice(i)\n      : \"0.\" + new Array(1 - i).join(\"0\") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!\n}\n\nfunction formatRounded(x, p) {\n  var d = formatDecimal(x, p);\n  if (!d) return x + \"\";\n  var coefficient = d[0],\n      exponent = d[1];\n  return exponent < 0 ? \"0.\" + new Array(-exponent).join(\"0\") + coefficient\n      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + \".\" + coefficient.slice(exponent + 1)\n      : coefficient + new Array(exponent - coefficient.length + 2).join(\"0\");\n}\n\nvar formatTypes = {\n  \"%\": function(x, p) { return (x * 100).toFixed(p); },\n  \"b\": function(x) { return Math.round(x).toString(2); },\n  \"c\": function(x) { return x + \"\"; },\n  \"d\": function(x) { return Math.round(x).toString(10); },\n  \"e\": function(x, p) { return x.toExponential(p); },\n  \"f\": function(x, p) { return x.toFixed(p); },\n  \"g\": function(x, p) { return x.toPrecision(p); },\n  \"o\": function(x) { return Math.round(x).toString(8); },\n  \"p\": function(x, p) { return formatRounded(x * 100, p); },\n  \"r\": formatRounded,\n  \"s\": formatPrefixAuto,\n  \"X\": function(x) { return Math.round(x).toString(16).toUpperCase(); },\n  \"x\": function(x) { return Math.round(x).toString(16); }\n};\n\nfunction identity$1(x) {\n  return x;\n}\n\nvar map = Array.prototype.map,\n    prefixes = [\"y\",\"z\",\"a\",\"f\",\"p\",\"n\",\"µ\",\"m\",\"\",\"k\",\"M\",\"G\",\"T\",\"P\",\"E\",\"Z\",\"Y\"];\n\nfunction formatLocale(locale) {\n  var group = locale.grouping === undefined || locale.thousands === undefined ? identity$1 : formatGroup(map.call(locale.grouping, Number), locale.thousands + \"\"),\n      currencyPrefix = locale.currency === undefined ? \"\" : locale.currency[0] + \"\",\n      currencySuffix = locale.currency === undefined ? \"\" : locale.currency[1] + \"\",\n      decimal = locale.decimal === undefined ? \".\" : locale.decimal + \"\",\n      numerals = locale.numerals === undefined ? identity$1 : formatNumerals(map.call(locale.numerals, String)),\n      percent = locale.percent === undefined ? \"%\" : locale.percent + \"\",\n      minus = locale.minus === undefined ? \"-\" : locale.minus + \"\",\n      nan = locale.nan === undefined ? \"NaN\" : locale.nan + \"\";\n\n  function newFormat(specifier) {\n    specifier = formatSpecifier(specifier);\n\n    var fill = specifier.fill,\n        align = specifier.align,\n        sign = specifier.sign,\n        symbol = specifier.symbol,\n        zero = specifier.zero,\n        width = specifier.width,\n        comma = specifier.comma,\n        precision = specifier.precision,\n        trim = specifier.trim,\n        type = specifier.type;\n\n    // The \"n\" type is an alias for \",g\".\n    if (type === \"n\") comma = true, type = \"g\";\n\n    // The \"\" type, and any invalid type, is an alias for \".12~g\".\n    else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = \"g\";\n\n    // If zero fill is specified, padding goes after sign and before digits.\n    if (zero || (fill === \"0\" && align === \"=\")) zero = true, fill = \"0\", align = \"=\";\n\n    // Compute the prefix and suffix.\n    // For SI-prefix, the suffix is lazily computed.\n    var prefix = symbol === \"$\" ? currencyPrefix : symbol === \"#\" && /[boxX]/.test(type) ? \"0\" + type.toLowerCase() : \"\",\n        suffix = symbol === \"$\" ? currencySuffix : /[%p]/.test(type) ? percent : \"\";\n\n    // What format function should we use?\n    // Is this an integer type?\n    // Can this type generate exponential notation?\n    var formatType = formatTypes[type],\n        maybeSuffix = /[defgprs%]/.test(type);\n\n    // Set the default precision if not specified,\n    // or clamp the specified precision to the supported range.\n    // For significant precision, it must be in [1, 21].\n    // For fixed precision, it must be in [0, 20].\n    precision = precision === undefined ? 6\n        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))\n        : Math.max(0, Math.min(20, precision));\n\n    function format(value) {\n      var valuePrefix = prefix,\n          valueSuffix = suffix,\n          i, n, c;\n\n      if (type === \"c\") {\n        valueSuffix = formatType(value) + valueSuffix;\n        value = \"\";\n      } else {\n        value = +value;\n\n        // Perform the initial formatting.\n        var valueNegative = value < 0;\n        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);\n\n        // Trim insignificant zeros.\n        if (trim) value = formatTrim(value);\n\n        // If a negative value rounds to zero during formatting, treat as positive.\n        if (valueNegative && +value === 0) valueNegative = false;\n\n        // Compute the prefix and suffix.\n        valuePrefix = (valueNegative ? (sign === \"(\" ? sign : minus) : sign === \"-\" || sign === \"(\" ? \"\" : sign) + valuePrefix;\n\n        valueSuffix = (type === \"s\" ? prefixes[8 + prefixExponent / 3] : \"\") + valueSuffix + (valueNegative && sign === \"(\" ? \")\" : \"\");\n\n        // Break the formatted value into the integer “value” part that can be\n        // grouped, and fractional or exponential “suffix” part that is not.\n        if (maybeSuffix) {\n          i = -1, n = value.length;\n          while (++i < n) {\n            if (c = value.charCodeAt(i), 48 > c || c > 57) {\n              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;\n              value = value.slice(0, i);\n              break;\n            }\n          }\n        }\n      }\n\n      // If the fill character is not \"0\", grouping is applied before padding.\n      if (comma && !zero) value = group(value, Infinity);\n\n      // Compute the padding.\n      var length = valuePrefix.length + value.length + valueSuffix.length,\n          padding = length < width ? new Array(width - length + 1).join(fill) : \"\";\n\n      // If the fill character is \"0\", grouping is applied after padding.\n      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = \"\";\n\n      // Reconstruct the final output based on the desired alignment.\n      switch (align) {\n        case \"<\": value = valuePrefix + value + valueSuffix + padding; break;\n        case \"=\": value = valuePrefix + padding + value + valueSuffix; break;\n        case \"^\": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;\n        default: value = padding + valuePrefix + value + valueSuffix; break;\n      }\n\n      return numerals(value);\n    }\n\n    format.toString = function() {\n      return specifier + \"\";\n    };\n\n    return format;\n  }\n\n  function formatPrefix(specifier, value) {\n    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = \"f\", specifier)),\n        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,\n        k = Math.pow(10, -e),\n        prefix = prefixes[8 + e / 3];\n    return function(value) {\n      return f(k * value) + prefix;\n    };\n  }\n\n  return {\n    format: newFormat,\n    formatPrefix: formatPrefix\n  };\n}\n\nvar locale;\nvar format;\nvar formatPrefix;\n\ndefaultLocale({\n  decimal: \".\",\n  thousands: \",\",\n  grouping: [3],\n  currency: [\"$\", \"\"],\n  minus: \"-\"\n});\n\nfunction defaultLocale(definition) {\n  locale = formatLocale(definition);\n  format = locale.format;\n  formatPrefix = locale.formatPrefix;\n  return locale;\n}\n\nfunction formatter(pattern, thousand, decimal) {\n  var locale, d3format;\n  /**\n   * Format a value according to the specified pattern created at construct\n   * @private\n   *\n   * @param  {Number} value   The number to be formatted\n   * @return {String}         [description]\n   */\n\n  function format(value) {\n    return d3format(value);\n  }\n  /**\n    * Set the locale for the formatter\n    *\n    * @param  {Object} args   Locale object for formatting\n    * @return {Undefined}      Returns nothing\n    */\n\n\n  format.locale = function localeFn(settings) {\n    locale = formatLocale(settings);\n    d3format = locale.format(pattern);\n    return this;\n  };\n  /**\n   * Resets the formatter using format.locale\n   * @ignore\n   */\n\n\n  function reset() {\n    format.locale({\n      decimal: decimal || '.',\n      thousands: thousand || ',',\n      grouping: [3],\n      currency: ['$', '']\n    });\n  }\n\n  reset();\n  /**\n    * Format a value according to a specific pattern\n    * that is not the one specified in the constructor\n    *\n    * @param  {String} p   Pattern\n    * @param  {Number} v   Value\n    * @param  {String} t   Thousand\n    * @param  {String} d   Decimal\n    * @return {String}     Formatted value\n    */\n\n  format.format = function formatFn(p, v, t, d) {\n    if (t || d) {\n      thousand = t;\n      decimal = d;\n      reset();\n    }\n\n    return locale.format(p)(v);\n  };\n  /**\n   * Change the pattern on existing formatter\n   *\n   * @param  {String} p     Pattern (optional)\n   * @return {String}       Returns the pattern\n   */\n\n\n  format.pattern = function patternFn(p) {\n    if (p) {\n      pattern = p;\n      d3format = locale.format(p);\n    }\n\n    return pattern;\n  };\n\n  return format;\n}\n\nvar t0 = new Date,\n    t1 = new Date;\n\nfunction newInterval(floori, offseti, count, field) {\n\n  function interval(date) {\n    return floori(date = new Date(+date)), date;\n  }\n\n  interval.floor = interval;\n\n  interval.ceil = function(date) {\n    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;\n  };\n\n  interval.round = function(date) {\n    var d0 = interval(date),\n        d1 = interval.ceil(date);\n    return date - d0 < d1 - date ? d0 : d1;\n  };\n\n  interval.offset = function(date, step) {\n    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n  };\n\n  interval.range = function(start, stop, step) {\n    var range = [], previous;\n    start = interval.ceil(start);\n    step = step == null ? 1 : Math.floor(step);\n    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);\n    while (previous < start && start < stop);\n    return range;\n  };\n\n  interval.filter = function(test) {\n    return newInterval(function(date) {\n      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);\n    }, function(date, step) {\n      if (date >= date) {\n        if (step < 0) while (++step <= 0) {\n          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty\n        } else while (--step >= 0) {\n          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty\n        }\n      }\n    });\n  };\n\n  if (count) {\n    interval.count = function(start, end) {\n      t0.setTime(+start), t1.setTime(+end);\n      floori(t0), floori(t1);\n      return Math.floor(count(t0, t1));\n    };\n\n    interval.every = function(step) {\n      step = Math.floor(step);\n      return !isFinite(step) || !(step > 0) ? null\n          : !(step > 1) ? interval\n          : interval.filter(field\n              ? function(d) { return field(d) % step === 0; }\n              : function(d) { return interval.count(0, d) % step === 0; });\n    };\n  }\n\n  return interval;\n}\n\nvar millisecond = newInterval(function() {\n  // noop\n}, function(date, step) {\n  date.setTime(+date + step);\n}, function(start, end) {\n  return end - start;\n});\n\n// An optimized implementation for this simple case.\nmillisecond.every = function(k) {\n  k = Math.floor(k);\n  if (!isFinite(k) || !(k > 0)) return null;\n  if (!(k > 1)) return millisecond;\n  return newInterval(function(date) {\n    date.setTime(Math.floor(date / k) * k);\n  }, function(date, step) {\n    date.setTime(+date + step * k);\n  }, function(start, end) {\n    return (end - start) / k;\n  });\n};\n\nvar durationSecond = 1e3;\nvar durationMinute = 6e4;\nvar durationHour = 36e5;\nvar durationDay = 864e5;\nvar durationWeek = 6048e5;\n\nvar second = newInterval(function(date) {\n  date.setTime(date - date.getMilliseconds());\n}, function(date, step) {\n  date.setTime(+date + step * durationSecond);\n}, function(start, end) {\n  return (end - start) / durationSecond;\n}, function(date) {\n  return date.getUTCSeconds();\n});\n\nvar minute = newInterval(function(date) {\n  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);\n}, function(date, step) {\n  date.setTime(+date + step * durationMinute);\n}, function(start, end) {\n  return (end - start) / durationMinute;\n}, function(date) {\n  return date.getMinutes();\n});\n\nvar hour = newInterval(function(date) {\n  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);\n}, function(date, step) {\n  date.setTime(+date + step * durationHour);\n}, function(start, end) {\n  return (end - start) / durationHour;\n}, function(date) {\n  return date.getHours();\n});\n\nvar day = newInterval(function(date) {\n  date.setHours(0, 0, 0, 0);\n}, function(date, step) {\n  date.setDate(date.getDate() + step);\n}, function(start, end) {\n  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;\n}, function(date) {\n  return date.getDate() - 1;\n});\n\nfunction weekday(i) {\n  return newInterval(function(date) {\n    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setDate(date.getDate() + step * 7);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;\n  });\n}\n\nvar sunday = weekday(0);\nvar monday = weekday(1);\nvar tuesday = weekday(2);\nvar wednesday = weekday(3);\nvar thursday = weekday(4);\nvar friday = weekday(5);\nvar saturday = weekday(6);\n\nvar month = newInterval(function(date) {\n  date.setDate(1);\n  date.setHours(0, 0, 0, 0);\n}, function(date, step) {\n  date.setMonth(date.getMonth() + step);\n}, function(start, end) {\n  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;\n}, function(date) {\n  return date.getMonth();\n});\n\nvar year = newInterval(function(date) {\n  date.setMonth(0, 1);\n  date.setHours(0, 0, 0, 0);\n}, function(date, step) {\n  date.setFullYear(date.getFullYear() + step);\n}, function(start, end) {\n  return end.getFullYear() - start.getFullYear();\n}, function(date) {\n  return date.getFullYear();\n});\n\n// An optimized implementation for this simple case.\nyear.every = function(k) {\n  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {\n    date.setFullYear(Math.floor(date.getFullYear() / k) * k);\n    date.setMonth(0, 1);\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setFullYear(date.getFullYear() + step * k);\n  });\n};\n\nvar utcMinute = newInterval(function(date) {\n  date.setUTCSeconds(0, 0);\n}, function(date, step) {\n  date.setTime(+date + step * durationMinute);\n}, function(start, end) {\n  return (end - start) / durationMinute;\n}, function(date) {\n  return date.getUTCMinutes();\n});\n\nvar utcHour = newInterval(function(date) {\n  date.setUTCMinutes(0, 0, 0);\n}, function(date, step) {\n  date.setTime(+date + step * durationHour);\n}, function(start, end) {\n  return (end - start) / durationHour;\n}, function(date) {\n  return date.getUTCHours();\n});\n\nvar utcDay = newInterval(function(date) {\n  date.setUTCHours(0, 0, 0, 0);\n}, function(date, step) {\n  date.setUTCDate(date.getUTCDate() + step);\n}, function(start, end) {\n  return (end - start) / durationDay;\n}, function(date) {\n  return date.getUTCDate() - 1;\n});\n\nfunction utcWeekday(i) {\n  return newInterval(function(date) {\n    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCDate(date.getUTCDate() + step * 7);\n  }, function(start, end) {\n    return (end - start) / durationWeek;\n  });\n}\n\nvar utcSunday = utcWeekday(0);\nvar utcMonday = utcWeekday(1);\nvar utcTuesday = utcWeekday(2);\nvar utcWednesday = utcWeekday(3);\nvar utcThursday = utcWeekday(4);\nvar utcFriday = utcWeekday(5);\nvar utcSaturday = utcWeekday(6);\n\nvar utcMonth = newInterval(function(date) {\n  date.setUTCDate(1);\n  date.setUTCHours(0, 0, 0, 0);\n}, function(date, step) {\n  date.setUTCMonth(date.getUTCMonth() + step);\n}, function(start, end) {\n  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;\n}, function(date) {\n  return date.getUTCMonth();\n});\n\nvar utcYear = newInterval(function(date) {\n  date.setUTCMonth(0, 1);\n  date.setUTCHours(0, 0, 0, 0);\n}, function(date, step) {\n  date.setUTCFullYear(date.getUTCFullYear() + step);\n}, function(start, end) {\n  return end.getUTCFullYear() - start.getUTCFullYear();\n}, function(date) {\n  return date.getUTCFullYear();\n});\n\n// An optimized implementation for this simple case.\nutcYear.every = function(k) {\n  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {\n    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);\n    date.setUTCMonth(0, 1);\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step * k);\n  });\n};\n\nfunction localDate(d) {\n  if (0 <= d.y && d.y < 100) {\n    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);\n    date.setFullYear(d.y);\n    return date;\n  }\n  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);\n}\n\nfunction utcDate(d) {\n  if (0 <= d.y && d.y < 100) {\n    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));\n    date.setUTCFullYear(d.y);\n    return date;\n  }\n  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));\n}\n\nfunction newYear(y) {\n  return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};\n}\n\nfunction formatLocale$1(locale) {\n  var locale_dateTime = locale.dateTime,\n      locale_date = locale.date,\n      locale_time = locale.time,\n      locale_periods = locale.periods,\n      locale_weekdays = locale.days,\n      locale_shortWeekdays = locale.shortDays,\n      locale_months = locale.months,\n      locale_shortMonths = locale.shortMonths;\n\n  var periodRe = formatRe(locale_periods),\n      periodLookup = formatLookup(locale_periods),\n      weekdayRe = formatRe(locale_weekdays),\n      weekdayLookup = formatLookup(locale_weekdays),\n      shortWeekdayRe = formatRe(locale_shortWeekdays),\n      shortWeekdayLookup = formatLookup(locale_shortWeekdays),\n      monthRe = formatRe(locale_months),\n      monthLookup = formatLookup(locale_months),\n      shortMonthRe = formatRe(locale_shortMonths),\n      shortMonthLookup = formatLookup(locale_shortMonths);\n\n  var formats = {\n    \"a\": formatShortWeekday,\n    \"A\": formatWeekday,\n    \"b\": formatShortMonth,\n    \"B\": formatMonth,\n    \"c\": null,\n    \"d\": formatDayOfMonth,\n    \"e\": formatDayOfMonth,\n    \"f\": formatMicroseconds,\n    \"H\": formatHour24,\n    \"I\": formatHour12,\n    \"j\": formatDayOfYear,\n    \"L\": formatMilliseconds,\n    \"m\": formatMonthNumber,\n    \"M\": formatMinutes,\n    \"p\": formatPeriod,\n    \"Q\": formatUnixTimestamp,\n    \"s\": formatUnixTimestampSeconds,\n    \"S\": formatSeconds,\n    \"u\": formatWeekdayNumberMonday,\n    \"U\": formatWeekNumberSunday,\n    \"V\": formatWeekNumberISO,\n    \"w\": formatWeekdayNumberSunday,\n    \"W\": formatWeekNumberMonday,\n    \"x\": null,\n    \"X\": null,\n    \"y\": formatYear,\n    \"Y\": formatFullYear,\n    \"Z\": formatZone,\n    \"%\": formatLiteralPercent\n  };\n\n  var utcFormats = {\n    \"a\": formatUTCShortWeekday,\n    \"A\": formatUTCWeekday,\n    \"b\": formatUTCShortMonth,\n    \"B\": formatUTCMonth,\n    \"c\": null,\n    \"d\": formatUTCDayOfMonth,\n    \"e\": formatUTCDayOfMonth,\n    \"f\": formatUTCMicroseconds,\n    \"H\": formatUTCHour24,\n    \"I\": formatUTCHour12,\n    \"j\": formatUTCDayOfYear,\n    \"L\": formatUTCMilliseconds,\n    \"m\": formatUTCMonthNumber,\n    \"M\": formatUTCMinutes,\n    \"p\": formatUTCPeriod,\n    \"Q\": formatUnixTimestamp,\n    \"s\": formatUnixTimestampSeconds,\n    \"S\": formatUTCSeconds,\n    \"u\": formatUTCWeekdayNumberMonday,\n    \"U\": formatUTCWeekNumberSunday,\n    \"V\": formatUTCWeekNumberISO,\n    \"w\": formatUTCWeekdayNumberSunday,\n    \"W\": formatUTCWeekNumberMonday,\n    \"x\": null,\n    \"X\": null,\n    \"y\": formatUTCYear,\n    \"Y\": formatUTCFullYear,\n    \"Z\": formatUTCZone,\n    \"%\": formatLiteralPercent\n  };\n\n  var parses = {\n    \"a\": parseShortWeekday,\n    \"A\": parseWeekday,\n    \"b\": parseShortMonth,\n    \"B\": parseMonth,\n    \"c\": parseLocaleDateTime,\n    \"d\": parseDayOfMonth,\n    \"e\": parseDayOfMonth,\n    \"f\": parseMicroseconds,\n    \"H\": parseHour24,\n    \"I\": parseHour24,\n    \"j\": parseDayOfYear,\n    \"L\": parseMilliseconds,\n    \"m\": parseMonthNumber,\n    \"M\": parseMinutes,\n    \"p\": parsePeriod,\n    \"Q\": parseUnixTimestamp,\n    \"s\": parseUnixTimestampSeconds,\n    \"S\": parseSeconds,\n    \"u\": parseWeekdayNumberMonday,\n    \"U\": parseWeekNumberSunday,\n    \"V\": parseWeekNumberISO,\n    \"w\": parseWeekdayNumberSunday,\n    \"W\": parseWeekNumberMonday,\n    \"x\": parseLocaleDate,\n    \"X\": parseLocaleTime,\n    \"y\": parseYear,\n    \"Y\": parseFullYear,\n    \"Z\": parseZone,\n    \"%\": parseLiteralPercent\n  };\n\n  // These recursive directive definitions must be deferred.\n  formats.x = newFormat(locale_date, formats);\n  formats.X = newFormat(locale_time, formats);\n  formats.c = newFormat(locale_dateTime, formats);\n  utcFormats.x = newFormat(locale_date, utcFormats);\n  utcFormats.X = newFormat(locale_time, utcFormats);\n  utcFormats.c = newFormat(locale_dateTime, utcFormats);\n\n  function newFormat(specifier, formats) {\n    return function(date) {\n      var string = [],\n          i = -1,\n          j = 0,\n          n = specifier.length,\n          c,\n          pad,\n          format;\n\n      if (!(date instanceof Date)) date = new Date(+date);\n\n      while (++i < n) {\n        if (specifier.charCodeAt(i) === 37) {\n          string.push(specifier.slice(j, i));\n          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);\n          else pad = c === \"e\" ? \" \" : \"0\";\n          if (format = formats[c]) c = format(date, pad);\n          string.push(c);\n          j = i + 1;\n        }\n      }\n\n      string.push(specifier.slice(j, i));\n      return string.join(\"\");\n    };\n  }\n\n  function newParse(specifier, newDate) {\n    return function(string) {\n      var d = newYear(1900),\n          i = parseSpecifier(d, specifier, string += \"\", 0),\n          week, day$1;\n      if (i != string.length) return null;\n\n      // If a UNIX timestamp is specified, return it.\n      if (\"Q\" in d) return new Date(d.Q);\n\n      // The am-pm flag is 0 for AM, and 1 for PM.\n      if (\"p\" in d) d.H = d.H % 12 + d.p * 12;\n\n      // Convert day-of-week and week-of-year to day-of-year.\n      if (\"V\" in d) {\n        if (d.V < 1 || d.V > 53) return null;\n        if (!(\"w\" in d)) d.w = 1;\n        if (\"Z\" in d) {\n          week = utcDate(newYear(d.y)), day$1 = week.getUTCDay();\n          week = day$1 > 4 || day$1 === 0 ? utcMonday.ceil(week) : utcMonday(week);\n          week = utcDay.offset(week, (d.V - 1) * 7);\n          d.y = week.getUTCFullYear();\n          d.m = week.getUTCMonth();\n          d.d = week.getUTCDate() + (d.w + 6) % 7;\n        } else {\n          week = newDate(newYear(d.y)), day$1 = week.getDay();\n          week = day$1 > 4 || day$1 === 0 ? monday.ceil(week) : monday(week);\n          week = day.offset(week, (d.V - 1) * 7);\n          d.y = week.getFullYear();\n          d.m = week.getMonth();\n          d.d = week.getDate() + (d.w + 6) % 7;\n        }\n      } else if (\"W\" in d || \"U\" in d) {\n        if (!(\"w\" in d)) d.w = \"u\" in d ? d.u % 7 : \"W\" in d ? 1 : 0;\n        day$1 = \"Z\" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();\n        d.m = 0;\n        d.d = \"W\" in d ? (d.w + 6) % 7 + d.W * 7 - (day$1 + 5) % 7 : d.w + d.U * 7 - (day$1 + 6) % 7;\n      }\n\n      // If a time zone is specified, all fields are interpreted as UTC and then\n      // offset according to the specified time zone.\n      if (\"Z\" in d) {\n        d.H += d.Z / 100 | 0;\n        d.M += d.Z % 100;\n        return utcDate(d);\n      }\n\n      // Otherwise, all fields are in local time.\n      return newDate(d);\n    };\n  }\n\n  function parseSpecifier(d, specifier, string, j) {\n    var i = 0,\n        n = specifier.length,\n        m = string.length,\n        c,\n        parse;\n\n    while (i < n) {\n      if (j >= m) return -1;\n      c = specifier.charCodeAt(i++);\n      if (c === 37) {\n        c = specifier.charAt(i++);\n        parse = parses[c in pads ? specifier.charAt(i++) : c];\n        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;\n      } else if (c != string.charCodeAt(j++)) {\n        return -1;\n      }\n    }\n\n    return j;\n  }\n\n  function parsePeriod(d, string, i) {\n    var n = periodRe.exec(string.slice(i));\n    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n  }\n\n  function parseShortWeekday(d, string, i) {\n    var n = shortWeekdayRe.exec(string.slice(i));\n    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n  }\n\n  function parseWeekday(d, string, i) {\n    var n = weekdayRe.exec(string.slice(i));\n    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n  }\n\n  function parseShortMonth(d, string, i) {\n    var n = shortMonthRe.exec(string.slice(i));\n    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n  }\n\n  function parseMonth(d, string, i) {\n    var n = monthRe.exec(string.slice(i));\n    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n  }\n\n  function parseLocaleDateTime(d, string, i) {\n    return parseSpecifier(d, locale_dateTime, string, i);\n  }\n\n  function parseLocaleDate(d, string, i) {\n    return parseSpecifier(d, locale_date, string, i);\n  }\n\n  function parseLocaleTime(d, string, i) {\n    return parseSpecifier(d, locale_time, string, i);\n  }\n\n  function formatShortWeekday(d) {\n    return locale_shortWeekdays[d.getDay()];\n  }\n\n  function formatWeekday(d) {\n    return locale_weekdays[d.getDay()];\n  }\n\n  function formatShortMonth(d) {\n    return locale_shortMonths[d.getMonth()];\n  }\n\n  function formatMonth(d) {\n    return locale_months[d.getMonth()];\n  }\n\n  function formatPeriod(d) {\n    return locale_periods[+(d.getHours() >= 12)];\n  }\n\n  function formatUTCShortWeekday(d) {\n    return locale_shortWeekdays[d.getUTCDay()];\n  }\n\n  function formatUTCWeekday(d) {\n    return locale_weekdays[d.getUTCDay()];\n  }\n\n  function formatUTCShortMonth(d) {\n    return locale_shortMonths[d.getUTCMonth()];\n  }\n\n  function formatUTCMonth(d) {\n    return locale_months[d.getUTCMonth()];\n  }\n\n  function formatUTCPeriod(d) {\n    return locale_periods[+(d.getUTCHours() >= 12)];\n  }\n\n  return {\n    format: function(specifier) {\n      var f = newFormat(specifier += \"\", formats);\n      f.toString = function() { return specifier; };\n      return f;\n    },\n    parse: function(specifier) {\n      var p = newParse(specifier += \"\", localDate);\n      p.toString = function() { return specifier; };\n      return p;\n    },\n    utcFormat: function(specifier) {\n      var f = newFormat(specifier += \"\", utcFormats);\n      f.toString = function() { return specifier; };\n      return f;\n    },\n    utcParse: function(specifier) {\n      var p = newParse(specifier, utcDate);\n      p.toString = function() { return specifier; };\n      return p;\n    }\n  };\n}\n\nvar pads = {\"-\": \"\", \"_\": \" \", \"0\": \"0\"},\n    numberRe = /^\\s*\\d+/, // note: ignores next directive\n    percentRe = /^%/,\n    requoteRe = /[\\\\^$*+?|[\\]().{}]/g;\n\nfunction pad(value, fill, width) {\n  var sign = value < 0 ? \"-\" : \"\",\n      string = (sign ? -value : value) + \"\",\n      length = string.length;\n  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);\n}\n\nfunction requote(s) {\n  return s.replace(requoteRe, \"\\\\$&\");\n}\n\nfunction formatRe(names) {\n  return new RegExp(\"^(?:\" + names.map(requote).join(\"|\") + \")\", \"i\");\n}\n\nfunction formatLookup(names) {\n  var map = {}, i = -1, n = names.length;\n  while (++i < n) map[names[i].toLowerCase()] = i;\n  return map;\n}\n\nfunction parseWeekdayNumberSunday(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 1));\n  return n ? (d.w = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseWeekdayNumberMonday(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 1));\n  return n ? (d.u = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseWeekNumberSunday(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.U = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseWeekNumberISO(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.V = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseWeekNumberMonday(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.W = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseFullYear(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 4));\n  return n ? (d.y = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseYear(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;\n}\n\nfunction parseZone(d, string, i) {\n  var n = /^(Z)|([+-]\\d\\d)(?::?(\\d\\d))?/.exec(string.slice(i, i + 6));\n  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || \"00\")), i + n[0].length) : -1;\n}\n\nfunction parseMonthNumber(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;\n}\n\nfunction parseDayOfMonth(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.d = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseDayOfYear(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 3));\n  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseHour24(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.H = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseMinutes(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.M = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseSeconds(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.S = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseMilliseconds(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 3));\n  return n ? (d.L = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseMicroseconds(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 6));\n  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;\n}\n\nfunction parseLiteralPercent(d, string, i) {\n  var n = percentRe.exec(string.slice(i, i + 1));\n  return n ? i + n[0].length : -1;\n}\n\nfunction parseUnixTimestamp(d, string, i) {\n  var n = numberRe.exec(string.slice(i));\n  return n ? (d.Q = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseUnixTimestampSeconds(d, string, i) {\n  var n = numberRe.exec(string.slice(i));\n  return n ? (d.Q = (+n[0]) * 1000, i + n[0].length) : -1;\n}\n\nfunction formatDayOfMonth(d, p) {\n  return pad(d.getDate(), p, 2);\n}\n\nfunction formatHour24(d, p) {\n  return pad(d.getHours(), p, 2);\n}\n\nfunction formatHour12(d, p) {\n  return pad(d.getHours() % 12 || 12, p, 2);\n}\n\nfunction formatDayOfYear(d, p) {\n  return pad(1 + day.count(year(d), d), p, 3);\n}\n\nfunction formatMilliseconds(d, p) {\n  return pad(d.getMilliseconds(), p, 3);\n}\n\nfunction formatMicroseconds(d, p) {\n  return formatMilliseconds(d, p) + \"000\";\n}\n\nfunction formatMonthNumber(d, p) {\n  return pad(d.getMonth() + 1, p, 2);\n}\n\nfunction formatMinutes(d, p) {\n  return pad(d.getMinutes(), p, 2);\n}\n\nfunction formatSeconds(d, p) {\n  return pad(d.getSeconds(), p, 2);\n}\n\nfunction formatWeekdayNumberMonday(d) {\n  var day = d.getDay();\n  return day === 0 ? 7 : day;\n}\n\nfunction formatWeekNumberSunday(d, p) {\n  return pad(sunday.count(year(d), d), p, 2);\n}\n\nfunction formatWeekNumberISO(d, p) {\n  var day = d.getDay();\n  d = (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);\n  return pad(thursday.count(year(d), d) + (year(d).getDay() === 4), p, 2);\n}\n\nfunction formatWeekdayNumberSunday(d) {\n  return d.getDay();\n}\n\nfunction formatWeekNumberMonday(d, p) {\n  return pad(monday.count(year(d), d), p, 2);\n}\n\nfunction formatYear(d, p) {\n  return pad(d.getFullYear() % 100, p, 2);\n}\n\nfunction formatFullYear(d, p) {\n  return pad(d.getFullYear() % 10000, p, 4);\n}\n\nfunction formatZone(d) {\n  var z = d.getTimezoneOffset();\n  return (z > 0 ? \"-\" : (z *= -1, \"+\"))\n      + pad(z / 60 | 0, \"0\", 2)\n      + pad(z % 60, \"0\", 2);\n}\n\nfunction formatUTCDayOfMonth(d, p) {\n  return pad(d.getUTCDate(), p, 2);\n}\n\nfunction formatUTCHour24(d, p) {\n  return pad(d.getUTCHours(), p, 2);\n}\n\nfunction formatUTCHour12(d, p) {\n  return pad(d.getUTCHours() % 12 || 12, p, 2);\n}\n\nfunction formatUTCDayOfYear(d, p) {\n  return pad(1 + utcDay.count(utcYear(d), d), p, 3);\n}\n\nfunction formatUTCMilliseconds(d, p) {\n  return pad(d.getUTCMilliseconds(), p, 3);\n}\n\nfunction formatUTCMicroseconds(d, p) {\n  return formatUTCMilliseconds(d, p) + \"000\";\n}\n\nfunction formatUTCMonthNumber(d, p) {\n  return pad(d.getUTCMonth() + 1, p, 2);\n}\n\nfunction formatUTCMinutes(d, p) {\n  return pad(d.getUTCMinutes(), p, 2);\n}\n\nfunction formatUTCSeconds(d, p) {\n  return pad(d.getUTCSeconds(), p, 2);\n}\n\nfunction formatUTCWeekdayNumberMonday(d) {\n  var dow = d.getUTCDay();\n  return dow === 0 ? 7 : dow;\n}\n\nfunction formatUTCWeekNumberSunday(d, p) {\n  return pad(utcSunday.count(utcYear(d), d), p, 2);\n}\n\nfunction formatUTCWeekNumberISO(d, p) {\n  var day = d.getUTCDay();\n  d = (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);\n  return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);\n}\n\nfunction formatUTCWeekdayNumberSunday(d) {\n  return d.getUTCDay();\n}\n\nfunction formatUTCWeekNumberMonday(d, p) {\n  return pad(utcMonday.count(utcYear(d), d), p, 2);\n}\n\nfunction formatUTCYear(d, p) {\n  return pad(d.getUTCFullYear() % 100, p, 2);\n}\n\nfunction formatUTCFullYear(d, p) {\n  return pad(d.getUTCFullYear() % 10000, p, 4);\n}\n\nfunction formatUTCZone() {\n  return \"+0000\";\n}\n\nfunction formatLiteralPercent() {\n  return \"%\";\n}\n\nfunction formatUnixTimestamp(d) {\n  return +d;\n}\n\nfunction formatUnixTimestampSeconds(d) {\n  return Math.floor(+d / 1000);\n}\n\nvar locale$1;\nvar timeFormat;\nvar timeParse;\nvar utcFormat;\nvar utcParse;\n\ndefaultLocale$1({\n  dateTime: \"%x, %X\",\n  date: \"%-m/%-d/%Y\",\n  time: \"%-I:%M:%S %p\",\n  periods: [\"AM\", \"PM\"],\n  days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n  shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n  months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n  shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n});\n\nfunction defaultLocale$1(definition) {\n  locale$1 = formatLocale$1(definition);\n  timeFormat = locale$1.format;\n  timeParse = locale$1.parse;\n  utcFormat = locale$1.utcFormat;\n  utcParse = locale$1.utcParse;\n  return locale$1;\n}\n\nvar isoSpecifier = \"%Y-%m-%dT%H:%M:%S.%LZ\";\n\nfunction formatIsoNative(date) {\n  return date.toISOString();\n}\n\nvar formatIso = Date.prototype.toISOString\n    ? formatIsoNative\n    : utcFormat(isoSpecifier);\n\nfunction parseIsoNative(string) {\n  var date = new Date(string);\n  return isNaN(date) ? null : date;\n}\n\nvar parseIso = +new Date(\"2000-01-01T00:00:00.000Z\")\n    ? parseIsoNative\n    : utcParse(isoSpecifier);\n\nfunction formatter$1(pattern) {\n  // eslint-disable-line import/prefer-default-export\n  var locale = formatLocale$1({\n    dateTime: '%x, %X',\n    date: '%-m/%-d/%Y',\n    time: '%-I:%M:%S %p',\n    periods: ['AM', 'PM'],\n    days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n    shortDays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n    months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n    shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n  });\n  var d3format = locale.format(pattern);\n  /**\n   * Format a value according to the specified pattern created at construct\n   *\n   * @param  {Date} value   The number to be formatted\n   * @return {String}         [description]\n   * @private\n   */\n\n  function format(value) {\n    return d3format(value);\n  }\n  /**\n    * Format a value according to a specific pattern\n    * that is not the one specified in the constructor\n    *\n    * @param  {String} p   Pattern\n    * @param  {Date} v   Value\n    * @return {String}     Formatted value\n    */\n\n\n  format.format = function formatFn(p, v) {\n    return locale.format(p)(v);\n  };\n  /**\n   * Set the locale for the formatter\n   *\n   * @param  {Object} args   Locale object for formatting\n   * @return {Undefined}      Returns nothing\n   */\n\n\n  format.locale = function localeFn() {\n    locale = formatLocale$1.apply(void 0, arguments);\n    d3format = locale.format(pattern);\n    return this;\n  };\n  /**\n   * Parse a string to a date according to a pattern\n   *\n   * @param  {String} p   Pattern\n   * @param  {String} v   Value\n   * @return {Date}     Date\n   */\n\n\n  format.parse = function parse(p, v) {\n    return locale.parse(p)(v);\n  };\n  /**\n   * Returns a parser that parses strings to date according to the pattern\n   *\n   * @param  {String} p   Pattern\n   * @return {Function}   Parser\n   */\n\n\n  format.parsePattern = function parsePattern(p) {\n    return locale.parse(p);\n  };\n\n  return format;\n}\n\nvar formatterRegistry = registryFactory();\nformatterRegistry('d3-number', formatter);\nformatterRegistry('d3-time', formatter$1);\n\n/* eslint no-return-assign: 0 */\n\nvar getFormatter = function getFormatter(data) {\n  if (typeof data.formatter === 'function') {\n    return data.formatter();\n  }\n\n  var f = data.formatter || {};\n  return formatterRegistry(f.type || 'd3-number')(f.format || '');\n};\n\nvar accessors = {\n  id: function id(data) {\n    return \"\".concat(data.source, \"/\").concat(data.key || data.title);\n  },\n  key: function key(data) {\n    return String(data.key || data.title);\n  },\n  tags: function tags(data) {\n    return data.tags;\n  },\n  min: function min(data) {\n    return data.min;\n  },\n  max: function max(data) {\n    return data.max;\n  },\n  type: function type(data) {\n    return data.type;\n  },\n  title: function title(data) {\n    return String(data.title);\n  },\n  values: function values(data) {\n    return data.values;\n  },\n  value: function value(v) {\n    return v;\n  },\n  label: function label(v) {\n    return v;\n  },\n  formatter: function formatter(data) {\n    return getFormatter(data);\n  }\n};\n/**\n * Create a new field with default settings\n * @ignore\n * @return {field} Data field\n */\n\nfunction field(data) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$id = _ref.id,\n      _id = _ref$id === void 0 ? accessors.id : _ref$id,\n      _ref$key = _ref.key,\n      _key = _ref$key === void 0 ? accessors.key : _ref$key,\n      _ref$min = _ref.min,\n      _min = _ref$min === void 0 ? accessors.min : _ref$min,\n      _ref$max = _ref.max,\n      _max = _ref$max === void 0 ? accessors.max : _ref$max,\n      _ref$type = _ref.type,\n      _type = _ref$type === void 0 ? accessors.type : _ref$type,\n      _ref$tags = _ref.tags,\n      _tags = _ref$tags === void 0 ? accessors.tags : _ref$tags,\n      _ref$title = _ref.title,\n      _title = _ref$title === void 0 ? accessors.title : _ref$title,\n      _ref$values = _ref.values,\n      values = _ref$values === void 0 ? accessors.values : _ref$values,\n      _ref$value = _ref.value,\n      value = _ref$value === void 0 ? accessors.value : _ref$value,\n      _ref$label = _ref.label,\n      label = _ref$label === void 0 ? accessors.label : _ref$label,\n      _ref$formatter = _ref.formatter,\n      _formatter = _ref$formatter === void 0 ? accessors.formatter : _ref$formatter;\n\n  /**\n   * @alias field\n   */\n  var f = {\n    /**\n     * Returns this field's id\n     * @returns {string}\n     */\n    id: function id() {\n      return _id(data);\n    },\n\n    /**\n     * Returns this field's key\n     * @returns {string}\n     */\n    key: function key() {\n      return _key(data);\n    },\n\n    /**\n     * Returns the input data\n     * @returns {any}\n     */\n    raw: function raw() {\n      return data;\n    },\n\n    /**\n     * Returns the tags.\n     * @return {Array<string>}\n     */\n    tags: function tags() {\n      return _tags(data);\n    },\n\n    /**\n     * Returns this field's type: 'dimension' or 'measure'.\n     * @return {string}\n     */\n    type: function type() {\n      return _type(data);\n    },\n\n    /**\n     * Returns the min value of this field.\n     * @return {number}\n     */\n    min: function min() {\n      return _min(data);\n    },\n\n    /**\n     * Returns the max value of this field.\n     * @return {number}\n     */\n    max: function max() {\n      return _max(data);\n    },\n\n    /**\n     * Returns this field's title.\n     * @return {string}\n     */\n    title: function title() {\n      return _title(data);\n    },\n\n    /**\n     * Returns the values of this field.\n     * @return {Array<datum-extract>}\n     */\n    items: function items() {\n      return values(data);\n    },\n\n    /**\n     * Returns a formatter adapted to the content of this field.\n     */\n    formatter: function formatter() {\n      return _formatter(data);\n    },\n    value: value,\n    label: label\n  };\n  return f;\n}\n\nvar OFFSETS = {\n  diverging: stackOffsetDiverging,\n  none: stackOffsetNone,\n  silhouette: stackOffsetSilhouette,\n  expand: stackOffsetExpand,\n  wiggle: stackOffsetWiggle\n};\nvar ORDERS = {\n  ascending: stackOrderAscending,\n  insideout: stackOrderInsideOut,\n  none: stackOrderNone,\n  reverse: stackOrderReverse\n};\n\nfunction stacked(data, config, ds) {\n  var stackIds = {};\n  var stackFn = config.stackKey;\n  var valueFn = config.value;\n  var startProp = config.startProp || 'start';\n  var endProp = config.endProp || 'end';\n  var offset = config.offset || 'none';\n  var order = config.order || 'none';\n  var valueRef = config.valueRef || '';\n  var maxStackCount = 0;\n  var valueFields = {};\n\n  for (var i = 0; i < data.items.length; i++) {\n    var p = data.items[i];\n    var sourceField = valueRef ? p[valueRef] : null;\n\n    if (sourceField && sourceField.source) {\n      var ff = \"\".concat(sourceField.source.key || '', \"/\").concat(sourceField.source.field);\n\n      if (!valueFields[ff]) {\n        valueFields[ff] = sourceField.source;\n      }\n    }\n\n    var sid = stackFn(p);\n    stackIds[sid] = stackIds[sid] || {\n      items: []\n    };\n    stackIds[sid].items.push(p);\n    maxStackCount = Math.max(maxStackCount, stackIds[sid].items.length);\n  }\n\n  var keys = Array.apply(null, {\n    length: maxStackCount\n  }).map(Number.call, Number); // eslint-disable-line\n\n  var matrix = Object.keys(stackIds).map(function (sid) {\n    return stackIds[sid].items;\n  });\n  var d3Stack = stack().keys(keys).value(function (s, key) {\n    return s[key] ? valueFn(s[key]) : 0;\n  }).order(ORDERS[order]).offset(OFFSETS[offset]);\n  var series = d3Stack(matrix);\n  var values = [];\n\n  for (var _i = 0; _i < series.length; _i++) {\n    var serie = series[_i];\n\n    for (var s = 0; s < serie.length; s++) {\n      var range = serie[s];\n      var item = serie[s].data[serie.key];\n\n      if (!item) {\n        continue;\n      }\n\n      item[startProp] = {\n        value: range[0]\n      };\n      item[endProp] = {\n        value: range[1]\n      };\n      values.push(range[0], range[1]);\n    }\n  }\n\n  var stackedFields = Object.keys(valueFields).map(function (f) {\n    var dSource = ds(valueFields[f].key);\n    return dSource ? dSource.field(valueFields[f].field) : null;\n  }).filter(function (f) {\n    return !!f;\n  });\n  var field$1 = field({\n    title: stackedFields.map(function (f) {\n      return f.title();\n    }).join(', '),\n    min: Math.min.apply(Math, values),\n    max: Math.max.apply(Math, values),\n    type: 'measure',\n    formatter: stackedFields[0] ? stackedFields[0].formatter : undefined\n  });\n  data.fields.push(field$1);\n}\n\nfunction extract(dataConfig) {\n  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var extracted = {// items: [],\n    // fields: [],\n    // source: null,\n    // value: null,\n    // label: null,\n    // children: null,\n    // root: null,\n    // graph: null\n  };\n  var logger = opts.logger;\n\n  if (Array.isArray(dataConfig)) {\n    // if data is an array, assume it's manual data input -> normalize\n    extracted.items = dataConfig.map(function (v) {\n      return {\n        value: v,\n        label: String(v)\n      };\n    });\n  } else if (dataConfig) {\n    if ('collection' in dataConfig) {\n      extracted = _objectSpread2({}, data.collection(dataConfig.collection));\n    } else {\n      var source = data.dataset ? data.dataset(dataConfig.source) : null;\n\n      var valueFn = dataConfig.value || function (d) {\n        return d;\n      };\n\n      var labelFn = dataConfig.label || function (d) {\n        return d;\n      };\n\n      if (dataConfig.groupBy || dataConfig.mapTo) {\n        // DEPRECATION\n        logger.warn('Deprecated \"data\" configuration', dataConfig);\n        extracted.items = [];\n      } else if (dataConfig.hierarchy) {\n        extracted.root = source.hierarchy ? source.hierarchy(dataConfig.hierarchy) : null;\n        extracted.fields = source.fields();\n      } else if (dataConfig.items) {\n        extracted.items = dataConfig.items.map(function (v) {\n          return {\n            value: valueFn(v),\n            label: String(labelFn(v))\n          };\n        });\n      } else if (dataConfig.extract) {\n        var extractionsConfigs = Array.isArray(dataConfig.extract) ? dataConfig.extract : [dataConfig.extract];\n        extracted.items = [];\n        var sourceFields = [];\n        extractionsConfigs.forEach(function (cfg) {\n          var _extracted$items;\n\n          var s = cfg.source ? data.dataset(cfg.source) : source;\n\n          if (!s) {\n            return;\n          }\n\n          (_extracted$items = extracted.items).push.apply(_extracted$items, _toConsumableArray$1(s.extract(cfg)));\n\n          if (typeof cfg.field !== 'undefined') {\n            sourceFields.push(s.field(cfg.field));\n          }\n        });\n\n        if (sourceFields.length) {\n          extracted.fields = sourceFields;\n        }\n\n        if (dataConfig.amend && Array.isArray(dataConfig.amend)) {\n          var _extracted$items2;\n\n          (_extracted$items2 = extracted.items).push.apply(_extracted$items2, _toConsumableArray$1(dataConfig.amend));\n        }\n      } else if (typeof dataConfig.field !== 'undefined' && source) {\n        var f = source.field(dataConfig.field);\n\n        if (f) {\n          if (!extracted.fields) {\n            extracted.fields = [];\n          }\n\n          extracted.fields.push(f);\n\n          if (!('value' in dataConfig)) {\n            valueFn = f.value || function (v) {\n              return v;\n            };\n\n            labelFn = f.label || function (v) {\n              return v;\n            };\n\n            extracted.value = valueFn;\n          }\n\n          extracted.items = f.items().map(function (v) {\n            return {\n              value: valueFn(v),\n              label: String(labelFn(v)),\n              source: {\n                field: dataConfig.field\n              }\n            };\n          }); // TODO - add source: { key: dataConfig.source, field: dataConfig.field, data: v }\n        }\n      } else if (dataConfig.fields) {\n        dataConfig.fields.forEach(function (obj) {\n          var s = _typeof(obj) === 'object' && obj.source ? data.dataset(obj.source) : source;\n\n          if (!s) {\n            return;\n          }\n\n          var f;\n\n          if (_typeof(obj) === 'object' && typeof obj.field !== 'undefined') {\n            f = s.field(obj.field);\n          } else {\n            f = s.field(obj);\n          }\n\n          if (f) {\n            if (!extracted.fields) {\n              extracted.fields = [];\n            }\n\n            extracted.fields.push(f);\n          }\n        });\n      }\n\n      if (extracted.items && dataConfig.map) {\n        extracted.items = extracted.items.map(dataConfig.map);\n      }\n    }\n\n    if (dataConfig && dataConfig.stack) {\n      stacked(extracted, dataConfig.stack, data.dataset);\n    }\n  }\n\n  if (dataConfig && !Array.isArray(dataConfig) && typeof dataConfig.filter === 'function' && extracted.items) {\n    extracted.items = extracted.items.filter(dataConfig.filter);\n  }\n\n  if (dataConfig && !Array.isArray(dataConfig) && typeof dataConfig.sort === 'function' && extracted.items) {\n    extracted.items = extracted.items.sort(dataConfig.sort);\n  }\n\n  return extracted;\n}\n\nfunction create(config, d, opts) {\n  var extractor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : extract;\n  var collections = {};\n  (config || []).forEach(function (cfg) {\n    if (!cfg.key) {\n      throw new Error('Data collection is missing \"key\" property');\n    }\n\n    if (_typeof(cfg.data) === 'object' && 'collection' in cfg.data) {\n      throw new Error('Data config for collections may not reference other collections');\n    }\n\n    collections[cfg.key] = function () {\n      return extractor(cfg.data, d, opts);\n    };\n  });\n\n  var fn = function fn(key) {\n    var k;\n    var cfg;\n\n    if (typeof key === 'string') {\n      k = key;\n    } else if (_typeof(key) === 'object') {\n      k = key.key;\n      cfg = key;\n    }\n\n    if (!(k in collections)) {\n      throw new Error(\"Unknown data collection: \".concat(k));\n    }\n\n    if (typeof collections[k] === 'function') {\n      collections[k] = collections[k]();\n    }\n\n    var coll = collections[k];\n\n    if (cfg) {\n      if (cfg.fields && cfg.fields.filter) {\n        var filtered = coll.fields.filter(cfg.fields.filter);\n\n        if (coll.fields.length !== filtered.length) {\n          coll = extend(coll, {\n            fields: filtered\n          });\n        }\n      }\n    }\n\n    return coll;\n  };\n\n  return fn;\n}\n\nfunction create$1(options, data, deps) {\n  var extractor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : extract;\n\n  if (options.data) {\n    var d = extractor(options.data, data, deps);\n\n    if (d && d.fields && d.fields[0]) {\n      // TODO Have some magic to handle and merge formatters from multiple sources\n      return d.fields[0].formatter();\n    }\n  }\n\n  var formatterType;\n\n  if (options.formatter) {\n    formatterType = \"\".concat(options.formatter, \"-\").concat(options.type || 'number');\n  } else {\n    formatterType = options.type || 'd3-number';\n  }\n\n  if (deps.formatter.has(formatterType)) {\n    var f = deps.formatter.get(formatterType)(options.format || '');\n    return f;\n  }\n\n  throw new Error(\"Formatter of type '\".concat(formatterType, \"' was not found\"));\n}\nfunction collection(formattersConfig, data, deps) {\n  var fn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : create$1;\n  var formatters = {};\n  return {\n    get: function get(def) {\n      var key;\n\n      if (typeof def === 'string' && formattersConfig[def]) {\n        key = def;\n      } else if (_typeof(def) === 'object' && 'formatter' in def && formattersConfig[def.formatter]) {\n        key = def.formatter;\n      } else if (_typeof(def) === 'object' && 'type' in def && formattersConfig[def.type]) {\n        key = def.type;\n      }\n\n      if (key) {\n        formatters[key] = formatters[key] || fn(formattersConfig[key], data, deps);\n        return formatters[key];\n      }\n\n      return fn(def || {}, data, deps);\n    },\n    all: function all() {\n      Object.keys(formattersConfig).forEach(this.get);\n      return formatters;\n    }\n  };\n}\n\nfunction ascending(a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n\nfunction bisector(compare) {\n  if (compare.length === 1) compare = ascendingComparator(compare);\n  return {\n    left: function(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (compare(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      }\n      return lo;\n    },\n    right: function(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (compare(a[mid], x) > 0) hi = mid;\n        else lo = mid + 1;\n      }\n      return lo;\n    }\n  };\n}\n\nfunction ascendingComparator(f) {\n  return function(d, x) {\n    return ascending(f(d), x);\n  };\n}\n\nvar ascendingBisect = bisector(ascending);\nvar bisectRight = ascendingBisect.right;\n\nfunction sequence(start, stop, step) {\n  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;\n\n  var i = -1,\n      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,\n      range = new Array(n);\n\n  while (++i < n) {\n    range[i] = start + i * step;\n  }\n\n  return range;\n}\n\nvar e10 = Math.sqrt(50),\n    e5 = Math.sqrt(10),\n    e2 = Math.sqrt(2);\n\nfunction ticks(start, stop, count) {\n  var reverse,\n      i = -1,\n      n,\n      ticks,\n      step;\n\n  stop = +stop, start = +start, count = +count;\n  if (start === stop && count > 0) return [start];\n  if (reverse = stop < start) n = start, start = stop, stop = n;\n  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];\n\n  if (step > 0) {\n    start = Math.ceil(start / step);\n    stop = Math.floor(stop / step);\n    ticks = new Array(n = Math.ceil(stop - start + 1));\n    while (++i < n) ticks[i] = (start + i) * step;\n  } else {\n    start = Math.floor(start * step);\n    stop = Math.ceil(stop * step);\n    ticks = new Array(n = Math.ceil(start - stop + 1));\n    while (++i < n) ticks[i] = (start - i) / step;\n  }\n\n  if (reverse) ticks.reverse();\n\n  return ticks;\n}\n\nfunction tickIncrement(start, stop, count) {\n  var step = (stop - start) / Math.max(0, count),\n      power = Math.floor(Math.log(step) / Math.LN10),\n      error = step / Math.pow(10, power);\n  return power >= 0\n      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)\n      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);\n}\n\nfunction tickStep(start, stop, count) {\n  var step0 = Math.abs(stop - start) / Math.max(0, count),\n      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),\n      error = step0 / step1;\n  if (error >= e10) step1 *= 10;\n  else if (error >= e5) step1 *= 5;\n  else if (error >= e2) step1 *= 2;\n  return stop < start ? -step1 : step1;\n}\n\nfunction initRange(domain, range) {\n  switch (arguments.length) {\n    case 0: break;\n    case 1: this.range(domain); break;\n    default: this.range(range).domain(domain); break;\n  }\n  return this;\n}\n\nvar prefix = \"$\";\n\nfunction Map() {}\n\nMap.prototype = map$1.prototype = {\n  constructor: Map,\n  has: function(key) {\n    return (prefix + key) in this;\n  },\n  get: function(key) {\n    return this[prefix + key];\n  },\n  set: function(key, value) {\n    this[prefix + key] = value;\n    return this;\n  },\n  remove: function(key) {\n    var property = prefix + key;\n    return property in this && delete this[property];\n  },\n  clear: function() {\n    for (var property in this) if (property[0] === prefix) delete this[property];\n  },\n  keys: function() {\n    var keys = [];\n    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));\n    return keys;\n  },\n  values: function() {\n    var values = [];\n    for (var property in this) if (property[0] === prefix) values.push(this[property]);\n    return values;\n  },\n  entries: function() {\n    var entries = [];\n    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});\n    return entries;\n  },\n  size: function() {\n    var size = 0;\n    for (var property in this) if (property[0] === prefix) ++size;\n    return size;\n  },\n  empty: function() {\n    for (var property in this) if (property[0] === prefix) return false;\n    return true;\n  },\n  each: function(f) {\n    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);\n  }\n};\n\nfunction map$1(object, f) {\n  var map = new Map;\n\n  // Copy constructor.\n  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });\n\n  // Index array by numeric index or specified key function.\n  else if (Array.isArray(object)) {\n    var i = -1,\n        n = object.length,\n        o;\n\n    if (f == null) while (++i < n) map.set(i, object[i]);\n    else while (++i < n) map.set(f(o = object[i], i, object), o);\n  }\n\n  // Convert object to map.\n  else if (object) for (var key in object) map.set(key, object[key]);\n\n  return map;\n}\n\nfunction Set() {}\n\nvar proto = map$1.prototype;\n\nSet.prototype = set.prototype = {\n  constructor: Set,\n  has: proto.has,\n  add: function(value) {\n    value += \"\";\n    this[prefix + value] = value;\n    return this;\n  },\n  remove: proto.remove,\n  clear: proto.clear,\n  values: proto.keys,\n  size: proto.size,\n  empty: proto.empty,\n  each: proto.each\n};\n\nfunction set(object, f) {\n  var set = new Set;\n\n  // Copy constructor.\n  if (object instanceof Set) object.each(function(value) { set.add(value); });\n\n  // Otherwise, assume it’s an array.\n  else if (object) {\n    var i = -1, n = object.length;\n    if (f == null) while (++i < n) set.add(object[i]);\n    else while (++i < n) set.add(f(object[i], i, object));\n  }\n\n  return set;\n}\n\nvar array = Array.prototype;\n\nvar map$2 = array.map;\nvar slice$1 = array.slice;\n\nvar implicit = {name: \"implicit\"};\n\nfunction ordinal() {\n  var index = map$1(),\n      domain = [],\n      range = [],\n      unknown = implicit;\n\n  function scale(d) {\n    var key = d + \"\", i = index.get(key);\n    if (!i) {\n      if (unknown !== implicit) return unknown;\n      index.set(key, i = domain.push(d));\n    }\n    return range[(i - 1) % range.length];\n  }\n\n  scale.domain = function(_) {\n    if (!arguments.length) return domain.slice();\n    domain = [], index = map$1();\n    var i = -1, n = _.length, d, key;\n    while (++i < n) if (!index.has(key = (d = _[i]) + \"\")) index.set(key, domain.push(d));\n    return scale;\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = slice$1.call(_), scale) : range.slice();\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  scale.copy = function() {\n    return ordinal(domain, range).unknown(unknown);\n  };\n\n  initRange.apply(scale, arguments);\n\n  return scale;\n}\n\nfunction band() {\n  var scale = ordinal().unknown(undefined),\n      domain = scale.domain,\n      ordinalRange = scale.range,\n      range = [0, 1],\n      step,\n      bandwidth,\n      round = false,\n      paddingInner = 0,\n      paddingOuter = 0,\n      align = 0.5;\n\n  delete scale.unknown;\n\n  function rescale() {\n    var n = domain().length,\n        reverse = range[1] < range[0],\n        start = range[reverse - 0],\n        stop = range[1 - reverse];\n    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);\n    if (round) step = Math.floor(step);\n    start += (stop - start - step * (n - paddingInner)) * align;\n    bandwidth = step * (1 - paddingInner);\n    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);\n    var values = sequence(n).map(function(i) { return start + step * i; });\n    return ordinalRange(reverse ? values.reverse() : values);\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain(_), rescale()) : domain();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();\n  };\n\n  scale.rangeRound = function(_) {\n    return range = [+_[0], +_[1]], round = true, rescale();\n  };\n\n  scale.bandwidth = function() {\n    return bandwidth;\n  };\n\n  scale.step = function() {\n    return step;\n  };\n\n  scale.round = function(_) {\n    return arguments.length ? (round = !!_, rescale()) : round;\n  };\n\n  scale.padding = function(_) {\n    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;\n  };\n\n  scale.paddingInner = function(_) {\n    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;\n  };\n\n  scale.paddingOuter = function(_) {\n    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;\n  };\n\n  scale.align = function(_) {\n    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;\n  };\n\n  scale.copy = function() {\n    return band(domain(), range)\n        .round(round)\n        .paddingInner(paddingInner)\n        .paddingOuter(paddingOuter)\n        .align(align);\n  };\n\n  return initRange.apply(rescale(), arguments);\n}\n\nfunction define(constructor, factory, prototype) {\n  constructor.prototype = factory.prototype = prototype;\n  prototype.constructor = constructor;\n}\n\nfunction extend$1(parent, definition) {\n  var prototype = Object.create(parent.prototype);\n  for (var key in definition) prototype[key] = definition[key];\n  return prototype;\n}\n\nfunction Color() {}\n\nvar darker = 0.7;\nvar brighter = 1 / darker;\n\nvar reI = \"\\\\s*([+-]?\\\\d+)\\\\s*\",\n    reN = \"\\\\s*([+-]?\\\\d*\\\\.?\\\\d+(?:[eE][+-]?\\\\d+)?)\\\\s*\",\n    reP = \"\\\\s*([+-]?\\\\d*\\\\.?\\\\d+(?:[eE][+-]?\\\\d+)?)%\\\\s*\",\n    reHex3 = /^#([0-9a-f]{3})$/,\n    reHex6 = /^#([0-9a-f]{6})$/,\n    reRgbInteger = new RegExp(\"^rgb\\\\(\" + [reI, reI, reI] + \"\\\\)$\"),\n    reRgbPercent = new RegExp(\"^rgb\\\\(\" + [reP, reP, reP] + \"\\\\)$\"),\n    reRgbaInteger = new RegExp(\"^rgba\\\\(\" + [reI, reI, reI, reN] + \"\\\\)$\"),\n    reRgbaPercent = new RegExp(\"^rgba\\\\(\" + [reP, reP, reP, reN] + \"\\\\)$\"),\n    reHslPercent = new RegExp(\"^hsl\\\\(\" + [reN, reP, reP] + \"\\\\)$\"),\n    reHslaPercent = new RegExp(\"^hsla\\\\(\" + [reN, reP, reP, reN] + \"\\\\)$\");\n\nvar named = {\n  aliceblue: 0xf0f8ff,\n  antiquewhite: 0xfaebd7,\n  aqua: 0x00ffff,\n  aquamarine: 0x7fffd4,\n  azure: 0xf0ffff,\n  beige: 0xf5f5dc,\n  bisque: 0xffe4c4,\n  black: 0x000000,\n  blanchedalmond: 0xffebcd,\n  blue: 0x0000ff,\n  blueviolet: 0x8a2be2,\n  brown: 0xa52a2a,\n  burlywood: 0xdeb887,\n  cadetblue: 0x5f9ea0,\n  chartreuse: 0x7fff00,\n  chocolate: 0xd2691e,\n  coral: 0xff7f50,\n  cornflowerblue: 0x6495ed,\n  cornsilk: 0xfff8dc,\n  crimson: 0xdc143c,\n  cyan: 0x00ffff,\n  darkblue: 0x00008b,\n  darkcyan: 0x008b8b,\n  darkgoldenrod: 0xb8860b,\n  darkgray: 0xa9a9a9,\n  darkgreen: 0x006400,\n  darkgrey: 0xa9a9a9,\n  darkkhaki: 0xbdb76b,\n  darkmagenta: 0x8b008b,\n  darkolivegreen: 0x556b2f,\n  darkorange: 0xff8c00,\n  darkorchid: 0x9932cc,\n  darkred: 0x8b0000,\n  darksalmon: 0xe9967a,\n  darkseagreen: 0x8fbc8f,\n  darkslateblue: 0x483d8b,\n  darkslategray: 0x2f4f4f,\n  darkslategrey: 0x2f4f4f,\n  darkturquoise: 0x00ced1,\n  darkviolet: 0x9400d3,\n  deeppink: 0xff1493,\n  deepskyblue: 0x00bfff,\n  dimgray: 0x696969,\n  dimgrey: 0x696969,\n  dodgerblue: 0x1e90ff,\n  firebrick: 0xb22222,\n  floralwhite: 0xfffaf0,\n  forestgreen: 0x228b22,\n  fuchsia: 0xff00ff,\n  gainsboro: 0xdcdcdc,\n  ghostwhite: 0xf8f8ff,\n  gold: 0xffd700,\n  goldenrod: 0xdaa520,\n  gray: 0x808080,\n  green: 0x008000,\n  greenyellow: 0xadff2f,\n  grey: 0x808080,\n  honeydew: 0xf0fff0,\n  hotpink: 0xff69b4,\n  indianred: 0xcd5c5c,\n  indigo: 0x4b0082,\n  ivory: 0xfffff0,\n  khaki: 0xf0e68c,\n  lavender: 0xe6e6fa,\n  lavenderblush: 0xfff0f5,\n  lawngreen: 0x7cfc00,\n  lemonchiffon: 0xfffacd,\n  lightblue: 0xadd8e6,\n  lightcoral: 0xf08080,\n  lightcyan: 0xe0ffff,\n  lightgoldenrodyellow: 0xfafad2,\n  lightgray: 0xd3d3d3,\n  lightgreen: 0x90ee90,\n  lightgrey: 0xd3d3d3,\n  lightpink: 0xffb6c1,\n  lightsalmon: 0xffa07a,\n  lightseagreen: 0x20b2aa,\n  lightskyblue: 0x87cefa,\n  lightslategray: 0x778899,\n  lightslategrey: 0x778899,\n  lightsteelblue: 0xb0c4de,\n  lightyellow: 0xffffe0,\n  lime: 0x00ff00,\n  limegreen: 0x32cd32,\n  linen: 0xfaf0e6,\n  magenta: 0xff00ff,\n  maroon: 0x800000,\n  mediumaquamarine: 0x66cdaa,\n  mediumblue: 0x0000cd,\n  mediumorchid: 0xba55d3,\n  mediumpurple: 0x9370db,\n  mediumseagreen: 0x3cb371,\n  mediumslateblue: 0x7b68ee,\n  mediumspringgreen: 0x00fa9a,\n  mediumturquoise: 0x48d1cc,\n  mediumvioletred: 0xc71585,\n  midnightblue: 0x191970,\n  mintcream: 0xf5fffa,\n  mistyrose: 0xffe4e1,\n  moccasin: 0xffe4b5,\n  navajowhite: 0xffdead,\n  navy: 0x000080,\n  oldlace: 0xfdf5e6,\n  olive: 0x808000,\n  olivedrab: 0x6b8e23,\n  orange: 0xffa500,\n  orangered: 0xff4500,\n  orchid: 0xda70d6,\n  palegoldenrod: 0xeee8aa,\n  palegreen: 0x98fb98,\n  paleturquoise: 0xafeeee,\n  palevioletred: 0xdb7093,\n  papayawhip: 0xffefd5,\n  peachpuff: 0xffdab9,\n  peru: 0xcd853f,\n  pink: 0xffc0cb,\n  plum: 0xdda0dd,\n  powderblue: 0xb0e0e6,\n  purple: 0x800080,\n  rebeccapurple: 0x663399,\n  red: 0xff0000,\n  rosybrown: 0xbc8f8f,\n  royalblue: 0x4169e1,\n  saddlebrown: 0x8b4513,\n  salmon: 0xfa8072,\n  sandybrown: 0xf4a460,\n  seagreen: 0x2e8b57,\n  seashell: 0xfff5ee,\n  sienna: 0xa0522d,\n  silver: 0xc0c0c0,\n  skyblue: 0x87ceeb,\n  slateblue: 0x6a5acd,\n  slategray: 0x708090,\n  slategrey: 0x708090,\n  snow: 0xfffafa,\n  springgreen: 0x00ff7f,\n  steelblue: 0x4682b4,\n  tan: 0xd2b48c,\n  teal: 0x008080,\n  thistle: 0xd8bfd8,\n  tomato: 0xff6347,\n  turquoise: 0x40e0d0,\n  violet: 0xee82ee,\n  wheat: 0xf5deb3,\n  white: 0xffffff,\n  whitesmoke: 0xf5f5f5,\n  yellow: 0xffff00,\n  yellowgreen: 0x9acd32\n};\n\ndefine(Color, color, {\n  displayable: function() {\n    return this.rgb().displayable();\n  },\n  hex: function() {\n    return this.rgb().hex();\n  },\n  toString: function() {\n    return this.rgb() + \"\";\n  }\n});\n\nfunction color(format) {\n  var m;\n  format = (format + \"\").trim().toLowerCase();\n  return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1)) // #f00\n      : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000\n      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)\n      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)\n      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)\n      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)\n      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)\n      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)\n      : named.hasOwnProperty(format) ? rgbn(named[format])\n      : format === \"transparent\" ? new Rgb(NaN, NaN, NaN, 0)\n      : null;\n}\n\nfunction rgbn(n) {\n  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);\n}\n\nfunction rgba(r, g, b, a) {\n  if (a <= 0) r = g = b = NaN;\n  return new Rgb(r, g, b, a);\n}\n\nfunction rgbConvert(o) {\n  if (!(o instanceof Color)) o = color(o);\n  if (!o) return new Rgb;\n  o = o.rgb();\n  return new Rgb(o.r, o.g, o.b, o.opacity);\n}\n\nfunction rgb(r, g, b, opacity) {\n  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);\n}\n\nfunction Rgb(r, g, b, opacity) {\n  this.r = +r;\n  this.g = +g;\n  this.b = +b;\n  this.opacity = +opacity;\n}\n\ndefine(Rgb, rgb, extend$1(Color, {\n  brighter: function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);\n  },\n  darker: function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);\n  },\n  rgb: function() {\n    return this;\n  },\n  displayable: function() {\n    return (0 <= this.r && this.r <= 255)\n        && (0 <= this.g && this.g <= 255)\n        && (0 <= this.b && this.b <= 255)\n        && (0 <= this.opacity && this.opacity <= 1);\n  },\n  hex: function() {\n    return \"#\" + hex(this.r) + hex(this.g) + hex(this.b);\n  },\n  toString: function() {\n    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));\n    return (a === 1 ? \"rgb(\" : \"rgba(\")\n        + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + \", \"\n        + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + \", \"\n        + Math.max(0, Math.min(255, Math.round(this.b) || 0))\n        + (a === 1 ? \")\" : \", \" + a + \")\");\n  }\n}));\n\nfunction hex(value) {\n  value = Math.max(0, Math.min(255, Math.round(value) || 0));\n  return (value < 16 ? \"0\" : \"\") + value.toString(16);\n}\n\nfunction hsla(h, s, l, a) {\n  if (a <= 0) h = s = l = NaN;\n  else if (l <= 0 || l >= 1) h = s = NaN;\n  else if (s <= 0) h = NaN;\n  return new Hsl(h, s, l, a);\n}\n\nfunction hslConvert(o) {\n  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);\n  if (!(o instanceof Color)) o = color(o);\n  if (!o) return new Hsl;\n  if (o instanceof Hsl) return o;\n  o = o.rgb();\n  var r = o.r / 255,\n      g = o.g / 255,\n      b = o.b / 255,\n      min = Math.min(r, g, b),\n      max = Math.max(r, g, b),\n      h = NaN,\n      s = max - min,\n      l = (max + min) / 2;\n  if (s) {\n    if (r === max) h = (g - b) / s + (g < b) * 6;\n    else if (g === max) h = (b - r) / s + 2;\n    else h = (r - g) / s + 4;\n    s /= l < 0.5 ? max + min : 2 - max - min;\n    h *= 60;\n  } else {\n    s = l > 0 && l < 1 ? 0 : h;\n  }\n  return new Hsl(h, s, l, o.opacity);\n}\n\nfunction hsl(h, s, l, opacity) {\n  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);\n}\n\nfunction Hsl(h, s, l, opacity) {\n  this.h = +h;\n  this.s = +s;\n  this.l = +l;\n  this.opacity = +opacity;\n}\n\ndefine(Hsl, hsl, extend$1(Color, {\n  brighter: function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Hsl(this.h, this.s, this.l * k, this.opacity);\n  },\n  darker: function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Hsl(this.h, this.s, this.l * k, this.opacity);\n  },\n  rgb: function() {\n    var h = this.h % 360 + (this.h < 0) * 360,\n        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,\n        l = this.l,\n        m2 = l + (l < 0.5 ? l : 1 - l) * s,\n        m1 = 2 * l - m2;\n    return new Rgb(\n      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),\n      hsl2rgb(h, m1, m2),\n      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),\n      this.opacity\n    );\n  },\n  displayable: function() {\n    return (0 <= this.s && this.s <= 1 || isNaN(this.s))\n        && (0 <= this.l && this.l <= 1)\n        && (0 <= this.opacity && this.opacity <= 1);\n  }\n}));\n\n/* From FvD 13.37, CSS Color Module Level 3 */\nfunction hsl2rgb(h, m1, m2) {\n  return (h < 60 ? m1 + (m2 - m1) * h / 60\n      : h < 180 ? m2\n      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60\n      : m1) * 255;\n}\n\nvar deg2rad = Math.PI / 180;\nvar rad2deg = 180 / Math.PI;\n\n// https://beta.observablehq.com/@mbostock/lab-and-rgb\nvar K = 18,\n    Xn = 0.96422,\n    Yn = 1,\n    Zn = 0.82521,\n    t0$1 = 4 / 29,\n    t1$1 = 6 / 29,\n    t2 = 3 * t1$1 * t1$1,\n    t3 = t1$1 * t1$1 * t1$1;\n\nfunction labConvert(o) {\n  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);\n  if (o instanceof Hcl) {\n    if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);\n    var h = o.h * deg2rad;\n    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);\n  }\n  if (!(o instanceof Rgb)) o = rgbConvert(o);\n  var r = rgb2lrgb(o.r),\n      g = rgb2lrgb(o.g),\n      b = rgb2lrgb(o.b),\n      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;\n  if (r === g && g === b) x = z = y; else {\n    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);\n    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);\n  }\n  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);\n}\n\nfunction lab(l, a, b, opacity) {\n  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);\n}\n\nfunction Lab(l, a, b, opacity) {\n  this.l = +l;\n  this.a = +a;\n  this.b = +b;\n  this.opacity = +opacity;\n}\n\ndefine(Lab, lab, extend$1(Color, {\n  brighter: function(k) {\n    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);\n  },\n  darker: function(k) {\n    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);\n  },\n  rgb: function() {\n    var y = (this.l + 16) / 116,\n        x = isNaN(this.a) ? y : y + this.a / 500,\n        z = isNaN(this.b) ? y : y - this.b / 200;\n    x = Xn * lab2xyz(x);\n    y = Yn * lab2xyz(y);\n    z = Zn * lab2xyz(z);\n    return new Rgb(\n      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),\n      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),\n      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),\n      this.opacity\n    );\n  }\n}));\n\nfunction xyz2lab(t) {\n  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0$1;\n}\n\nfunction lab2xyz(t) {\n  return t > t1$1 ? t * t * t : t2 * (t - t0$1);\n}\n\nfunction lrgb2rgb(x) {\n  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);\n}\n\nfunction rgb2lrgb(x) {\n  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);\n}\n\nfunction hclConvert(o) {\n  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);\n  if (!(o instanceof Lab)) o = labConvert(o);\n  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0, o.l, o.opacity);\n  var h = Math.atan2(o.b, o.a) * rad2deg;\n  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);\n}\n\nfunction hcl(h, c, l, opacity) {\n  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);\n}\n\nfunction Hcl(h, c, l, opacity) {\n  this.h = +h;\n  this.c = +c;\n  this.l = +l;\n  this.opacity = +opacity;\n}\n\ndefine(Hcl, hcl, extend$1(Color, {\n  brighter: function(k) {\n    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);\n  },\n  darker: function(k) {\n    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);\n  },\n  rgb: function() {\n    return labConvert(this).rgb();\n  }\n}));\n\nvar A = -0.14861,\n    B = +1.78277,\n    C = -0.29227,\n    D = -0.90649,\n    E = +1.97294,\n    ED = E * D,\n    EB = E * B,\n    BC_DA = B * C - D * A;\n\nfunction cubehelixConvert(o) {\n  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);\n  if (!(o instanceof Rgb)) o = rgbConvert(o);\n  var r = o.r / 255,\n      g = o.g / 255,\n      b = o.b / 255,\n      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),\n      bl = b - l,\n      k = (E * (g - l) - C * bl) / D,\n      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1\n      h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;\n  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);\n}\n\nfunction cubehelix(h, s, l, opacity) {\n  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);\n}\n\nfunction Cubehelix(h, s, l, opacity) {\n  this.h = +h;\n  this.s = +s;\n  this.l = +l;\n  this.opacity = +opacity;\n}\n\ndefine(Cubehelix, cubehelix, extend$1(Color, {\n  brighter: function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);\n  },\n  darker: function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);\n  },\n  rgb: function() {\n    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,\n        l = +this.l,\n        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),\n        cosh = Math.cos(h),\n        sinh = Math.sin(h);\n    return new Rgb(\n      255 * (l + a * (A * cosh + B * sinh)),\n      255 * (l + a * (C * cosh + D * sinh)),\n      255 * (l + a * (E * cosh)),\n      this.opacity\n    );\n  }\n}));\n\nfunction constant$1(x) {\n  return function() {\n    return x;\n  };\n}\n\nfunction linear(a, d) {\n  return function(t) {\n    return a + t * d;\n  };\n}\n\nfunction exponential(a, b, y) {\n  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {\n    return Math.pow(a + t * b, y);\n  };\n}\n\nfunction gamma(y) {\n  return (y = +y) === 1 ? nogamma : function(a, b) {\n    return b - a ? exponential(a, b, y) : constant$1(isNaN(a) ? b : a);\n  };\n}\n\nfunction nogamma(a, b) {\n  var d = b - a;\n  return d ? linear(a, d) : constant$1(isNaN(a) ? b : a);\n}\n\nvar interpolateRgb = (function rgbGamma(y) {\n  var color = gamma(y);\n\n  function rgb$1(start, end) {\n    var r = color((start = rgb(start)).r, (end = rgb(end)).r),\n        g = color(start.g, end.g),\n        b = color(start.b, end.b),\n        opacity = nogamma(start.opacity, end.opacity);\n    return function(t) {\n      start.r = r(t);\n      start.g = g(t);\n      start.b = b(t);\n      start.opacity = opacity(t);\n      return start + \"\";\n    };\n  }\n\n  rgb$1.gamma = rgbGamma;\n\n  return rgb$1;\n})(1);\n\nfunction array$1(a, b) {\n  var nb = b ? b.length : 0,\n      na = a ? Math.min(nb, a.length) : 0,\n      x = new Array(na),\n      c = new Array(nb),\n      i;\n\n  for (i = 0; i < na; ++i) x[i] = interpolateValue(a[i], b[i]);\n  for (; i < nb; ++i) c[i] = b[i];\n\n  return function(t) {\n    for (i = 0; i < na; ++i) c[i] = x[i](t);\n    return c;\n  };\n}\n\nfunction date(a, b) {\n  var d = new Date;\n  return a = +a, b -= a, function(t) {\n    return d.setTime(a + b * t), d;\n  };\n}\n\nfunction interpolateNumber(a, b) {\n  return a = +a, b -= a, function(t) {\n    return a + b * t;\n  };\n}\n\nfunction interpolateObject(a, b) {\n  var i = {},\n      c = {},\n      k;\n\n  if (a === null || typeof a !== \"object\") a = {};\n  if (b === null || typeof b !== \"object\") b = {};\n\n  for (k in b) {\n    if (k in a) {\n      i[k] = interpolateValue(a[k], b[k]);\n    } else {\n      c[k] = b[k];\n    }\n  }\n\n  return function(t) {\n    for (k in i) c[k] = i[k](t);\n    return c;\n  };\n}\n\nvar reA = /[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g,\n    reB = new RegExp(reA.source, \"g\");\n\nfunction zero(b) {\n  return function() {\n    return b;\n  };\n}\n\nfunction one(b) {\n  return function(t) {\n    return b(t) + \"\";\n  };\n}\n\nfunction string(a, b) {\n  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b\n      am, // current match in a\n      bm, // current match in b\n      bs, // string preceding current number in b, if any\n      i = -1, // index in s\n      s = [], // string constants and placeholders\n      q = []; // number interpolators\n\n  // Coerce inputs to strings.\n  a = a + \"\", b = b + \"\";\n\n  // Interpolate pairs of numbers in a & b.\n  while ((am = reA.exec(a))\n      && (bm = reB.exec(b))) {\n    if ((bs = bm.index) > bi) { // a string precedes the next number in b\n      bs = b.slice(bi, bs);\n      if (s[i]) s[i] += bs; // coalesce with previous string\n      else s[++i] = bs;\n    }\n    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match\n      if (s[i]) s[i] += bm; // coalesce with previous string\n      else s[++i] = bm;\n    } else { // interpolate non-matching numbers\n      s[++i] = null;\n      q.push({i: i, x: interpolateNumber(am, bm)});\n    }\n    bi = reB.lastIndex;\n  }\n\n  // Add remains of b.\n  if (bi < b.length) {\n    bs = b.slice(bi);\n    if (s[i]) s[i] += bs; // coalesce with previous string\n    else s[++i] = bs;\n  }\n\n  // Special optimization for only a single match.\n  // Otherwise, interpolate each of the numbers and rejoin the string.\n  return s.length < 2 ? (q[0]\n      ? one(q[0].x)\n      : zero(b))\n      : (b = q.length, function(t) {\n          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);\n          return s.join(\"\");\n        });\n}\n\nfunction interpolateValue(a, b) {\n  var t = typeof b, c;\n  return b == null || t === \"boolean\" ? constant$1(b)\n      : (t === \"number\" ? interpolateNumber\n      : t === \"string\" ? ((c = color(b)) ? (b = c, interpolateRgb) : string)\n      : b instanceof color ? interpolateRgb\n      : b instanceof Date ? date\n      : Array.isArray(b) ? array$1\n      : typeof b.valueOf !== \"function\" && typeof b.toString !== \"function\" || isNaN(b) ? interpolateObject\n      : interpolateNumber)(a, b);\n}\n\nfunction interpolateRound(a, b) {\n  return a = +a, b -= a, function(t) {\n    return Math.round(a + b * t);\n  };\n}\n\nfunction constant$2(x) {\n  return function() {\n    return x;\n  };\n}\n\nfunction number(x) {\n  return +x;\n}\n\nvar unit = [0, 1];\n\nfunction identity$2(x) {\n  return x;\n}\n\nfunction normalize(a, b) {\n  return (b -= (a = +a))\n      ? function(x) { return (x - a) / b; }\n      : constant$2(isNaN(b) ? NaN : 0.5);\n}\n\nfunction clamper(domain) {\n  var a = domain[0], b = domain[domain.length - 1], t;\n  if (a > b) t = a, a = b, b = t;\n  return function(x) { return Math.max(a, Math.min(b, x)); };\n}\n\n// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].\n// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].\nfunction bimap(domain, range, interpolate) {\n  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];\n  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);\n  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);\n  return function(x) { return r0(d0(x)); };\n}\n\nfunction polymap(domain, range, interpolate) {\n  var j = Math.min(domain.length, range.length) - 1,\n      d = new Array(j),\n      r = new Array(j),\n      i = -1;\n\n  // Reverse descending domains.\n  if (domain[j] < domain[0]) {\n    domain = domain.slice().reverse();\n    range = range.slice().reverse();\n  }\n\n  while (++i < j) {\n    d[i] = normalize(domain[i], domain[i + 1]);\n    r[i] = interpolate(range[i], range[i + 1]);\n  }\n\n  return function(x) {\n    var i = bisectRight(domain, x, 1, j) - 1;\n    return r[i](d[i](x));\n  };\n}\n\nfunction copy(source, target) {\n  return target\n      .domain(source.domain())\n      .range(source.range())\n      .interpolate(source.interpolate())\n      .clamp(source.clamp())\n      .unknown(source.unknown());\n}\n\nfunction transformer() {\n  var domain = unit,\n      range = unit,\n      interpolate = interpolateValue,\n      transform,\n      untransform,\n      unknown,\n      clamp = identity$2,\n      piecewise,\n      output,\n      input;\n\n  function rescale() {\n    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;\n    output = input = null;\n    return scale;\n  }\n\n  function scale(x) {\n    return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));\n  }\n\n  scale.invert = function(y) {\n    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain = map$2.call(_, number), clamp === identity$2 || (clamp = clamper(domain)), rescale()) : domain.slice();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = slice$1.call(_), rescale()) : range.slice();\n  };\n\n  scale.rangeRound = function(_) {\n    return range = slice$1.call(_), interpolate = interpolateRound, rescale();\n  };\n\n  scale.clamp = function(_) {\n    return arguments.length ? (clamp = _ ? clamper(domain) : identity$2, scale) : clamp !== identity$2;\n  };\n\n  scale.interpolate = function(_) {\n    return arguments.length ? (interpolate = _, rescale()) : interpolate;\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  return function(t, u) {\n    transform = t, untransform = u;\n    return rescale();\n  };\n}\n\nfunction continuous(transform, untransform) {\n  return transformer()(transform, untransform);\n}\n\n// Computes the decimal coefficient and exponent of the specified number x with\n// significant digits p, where x is positive and p is in [1, 21] or undefined.\n// For example, formatDecimal(1.23) returns [\"123\", 0].\nfunction formatDecimal$1(x, p) {\n  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf(\"e\")) < 0) return null; // NaN, ±Infinity\n  var i, coefficient = x.slice(0, i);\n\n  // The string returned by toExponential either has the form \\d\\.\\d+e[-+]\\d+\n  // (e.g., 1.2e+3) or the form \\de[-+]\\d+ (e.g., 1e+3).\n  return [\n    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,\n    +x.slice(i + 1)\n  ];\n}\n\nfunction exponent$1(x) {\n  return x = formatDecimal$1(Math.abs(x)), x ? x[1] : NaN;\n}\n\nfunction formatGroup$1(grouping, thousands) {\n  return function(value, width) {\n    var i = value.length,\n        t = [],\n        j = 0,\n        g = grouping[0],\n        length = 0;\n\n    while (i > 0 && g > 0) {\n      if (length + g + 1 > width) g = Math.max(1, width - length);\n      t.push(value.substring(i -= g, i + g));\n      if ((length += g + 1) > width) break;\n      g = grouping[j = (j + 1) % grouping.length];\n    }\n\n    return t.reverse().join(thousands);\n  };\n}\n\nfunction formatNumerals$1(numerals) {\n  return function(value) {\n    return value.replace(/[0-9]/g, function(i) {\n      return numerals[+i];\n    });\n  };\n}\n\n// [[fill]align][sign][symbol][0][width][,][.precision][~][type]\nvar re$1 = /^(?:(.)?([<>=^]))?([+\\-( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?(~)?([a-z%])?$/i;\n\nfunction formatSpecifier$1(specifier) {\n  return new FormatSpecifier$1(specifier);\n}\n\nformatSpecifier$1.prototype = FormatSpecifier$1.prototype; // instanceof\n\nfunction FormatSpecifier$1(specifier) {\n  if (!(match = re$1.exec(specifier))) throw new Error(\"invalid format: \" + specifier);\n  var match;\n  this.fill = match[1] || \" \";\n  this.align = match[2] || \">\";\n  this.sign = match[3] || \"-\";\n  this.symbol = match[4] || \"\";\n  this.zero = !!match[5];\n  this.width = match[6] && +match[6];\n  this.comma = !!match[7];\n  this.precision = match[8] && +match[8].slice(1);\n  this.trim = !!match[9];\n  this.type = match[10] || \"\";\n}\n\nFormatSpecifier$1.prototype.toString = function() {\n  return this.fill\n      + this.align\n      + this.sign\n      + this.symbol\n      + (this.zero ? \"0\" : \"\")\n      + (this.width == null ? \"\" : Math.max(1, this.width | 0))\n      + (this.comma ? \",\" : \"\")\n      + (this.precision == null ? \"\" : \".\" + Math.max(0, this.precision | 0))\n      + (this.trim ? \"~\" : \"\")\n      + this.type;\n};\n\n// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.\nfunction formatTrim$1(s) {\n  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {\n    switch (s[i]) {\n      case \".\": i0 = i1 = i; break;\n      case \"0\": if (i0 === 0) i0 = i; i1 = i; break;\n      default: if (i0 > 0) { if (!+s[i]) break out; i0 = 0; } break;\n    }\n  }\n  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;\n}\n\nvar prefixExponent$1;\n\nfunction formatPrefixAuto$1(x, p) {\n  var d = formatDecimal$1(x, p);\n  if (!d) return x + \"\";\n  var coefficient = d[0],\n      exponent = d[1],\n      i = exponent - (prefixExponent$1 = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,\n      n = coefficient.length;\n  return i === n ? coefficient\n      : i > n ? coefficient + new Array(i - n + 1).join(\"0\")\n      : i > 0 ? coefficient.slice(0, i) + \".\" + coefficient.slice(i)\n      : \"0.\" + new Array(1 - i).join(\"0\") + formatDecimal$1(x, Math.max(0, p + i - 1))[0]; // less than 1y!\n}\n\nfunction formatRounded$1(x, p) {\n  var d = formatDecimal$1(x, p);\n  if (!d) return x + \"\";\n  var coefficient = d[0],\n      exponent = d[1];\n  return exponent < 0 ? \"0.\" + new Array(-exponent).join(\"0\") + coefficient\n      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + \".\" + coefficient.slice(exponent + 1)\n      : coefficient + new Array(exponent - coefficient.length + 2).join(\"0\");\n}\n\nvar formatTypes$1 = {\n  \"%\": function(x, p) { return (x * 100).toFixed(p); },\n  \"b\": function(x) { return Math.round(x).toString(2); },\n  \"c\": function(x) { return x + \"\"; },\n  \"d\": function(x) { return Math.round(x).toString(10); },\n  \"e\": function(x, p) { return x.toExponential(p); },\n  \"f\": function(x, p) { return x.toFixed(p); },\n  \"g\": function(x, p) { return x.toPrecision(p); },\n  \"o\": function(x) { return Math.round(x).toString(8); },\n  \"p\": function(x, p) { return formatRounded$1(x * 100, p); },\n  \"r\": formatRounded$1,\n  \"s\": formatPrefixAuto$1,\n  \"X\": function(x) { return Math.round(x).toString(16).toUpperCase(); },\n  \"x\": function(x) { return Math.round(x).toString(16); }\n};\n\nfunction identity$3(x) {\n  return x;\n}\n\nvar prefixes$1 = [\"y\",\"z\",\"a\",\"f\",\"p\",\"n\",\"µ\",\"m\",\"\",\"k\",\"M\",\"G\",\"T\",\"P\",\"E\",\"Z\",\"Y\"];\n\nfunction formatLocale$2(locale) {\n  var group = locale.grouping && locale.thousands ? formatGroup$1(locale.grouping, locale.thousands) : identity$3,\n      currency = locale.currency,\n      decimal = locale.decimal,\n      numerals = locale.numerals ? formatNumerals$1(locale.numerals) : identity$3,\n      percent = locale.percent || \"%\";\n\n  function newFormat(specifier) {\n    specifier = formatSpecifier$1(specifier);\n\n    var fill = specifier.fill,\n        align = specifier.align,\n        sign = specifier.sign,\n        symbol = specifier.symbol,\n        zero = specifier.zero,\n        width = specifier.width,\n        comma = specifier.comma,\n        precision = specifier.precision,\n        trim = specifier.trim,\n        type = specifier.type;\n\n    // The \"n\" type is an alias for \",g\".\n    if (type === \"n\") comma = true, type = \"g\";\n\n    // The \"\" type, and any invalid type, is an alias for \".12~g\".\n    else if (!formatTypes$1[type]) precision == null && (precision = 12), trim = true, type = \"g\";\n\n    // If zero fill is specified, padding goes after sign and before digits.\n    if (zero || (fill === \"0\" && align === \"=\")) zero = true, fill = \"0\", align = \"=\";\n\n    // Compute the prefix and suffix.\n    // For SI-prefix, the suffix is lazily computed.\n    var prefix = symbol === \"$\" ? currency[0] : symbol === \"#\" && /[boxX]/.test(type) ? \"0\" + type.toLowerCase() : \"\",\n        suffix = symbol === \"$\" ? currency[1] : /[%p]/.test(type) ? percent : \"\";\n\n    // What format function should we use?\n    // Is this an integer type?\n    // Can this type generate exponential notation?\n    var formatType = formatTypes$1[type],\n        maybeSuffix = /[defgprs%]/.test(type);\n\n    // Set the default precision if not specified,\n    // or clamp the specified precision to the supported range.\n    // For significant precision, it must be in [1, 21].\n    // For fixed precision, it must be in [0, 20].\n    precision = precision == null ? 6\n        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))\n        : Math.max(0, Math.min(20, precision));\n\n    function format(value) {\n      var valuePrefix = prefix,\n          valueSuffix = suffix,\n          i, n, c;\n\n      if (type === \"c\") {\n        valueSuffix = formatType(value) + valueSuffix;\n        value = \"\";\n      } else {\n        value = +value;\n\n        // Perform the initial formatting.\n        var valueNegative = value < 0;\n        value = formatType(Math.abs(value), precision);\n\n        // Trim insignificant zeros.\n        if (trim) value = formatTrim$1(value);\n\n        // If a negative value rounds to zero during formatting, treat as positive.\n        if (valueNegative && +value === 0) valueNegative = false;\n\n        // Compute the prefix and suffix.\n        valuePrefix = (valueNegative ? (sign === \"(\" ? sign : \"-\") : sign === \"-\" || sign === \"(\" ? \"\" : sign) + valuePrefix;\n        valueSuffix = (type === \"s\" ? prefixes$1[8 + prefixExponent$1 / 3] : \"\") + valueSuffix + (valueNegative && sign === \"(\" ? \")\" : \"\");\n\n        // Break the formatted value into the integer “value” part that can be\n        // grouped, and fractional or exponential “suffix” part that is not.\n        if (maybeSuffix) {\n          i = -1, n = value.length;\n          while (++i < n) {\n            if (c = value.charCodeAt(i), 48 > c || c > 57) {\n              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;\n              value = value.slice(0, i);\n              break;\n            }\n          }\n        }\n      }\n\n      // If the fill character is not \"0\", grouping is applied before padding.\n      if (comma && !zero) value = group(value, Infinity);\n\n      // Compute the padding.\n      var length = valuePrefix.length + value.length + valueSuffix.length,\n          padding = length < width ? new Array(width - length + 1).join(fill) : \"\";\n\n      // If the fill character is \"0\", grouping is applied after padding.\n      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = \"\";\n\n      // Reconstruct the final output based on the desired alignment.\n      switch (align) {\n        case \"<\": value = valuePrefix + value + valueSuffix + padding; break;\n        case \"=\": value = valuePrefix + padding + value + valueSuffix; break;\n        case \"^\": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;\n        default: value = padding + valuePrefix + value + valueSuffix; break;\n      }\n\n      return numerals(value);\n    }\n\n    format.toString = function() {\n      return specifier + \"\";\n    };\n\n    return format;\n  }\n\n  function formatPrefix(specifier, value) {\n    var f = newFormat((specifier = formatSpecifier$1(specifier), specifier.type = \"f\", specifier)),\n        e = Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3,\n        k = Math.pow(10, -e),\n        prefix = prefixes$1[8 + e / 3];\n    return function(value) {\n      return f(k * value) + prefix;\n    };\n  }\n\n  return {\n    format: newFormat,\n    formatPrefix: formatPrefix\n  };\n}\n\nvar locale$2;\nvar format$1;\nvar formatPrefix$1;\n\ndefaultLocale$2({\n  decimal: \".\",\n  thousands: \",\",\n  grouping: [3],\n  currency: [\"$\", \"\"]\n});\n\nfunction defaultLocale$2(definition) {\n  locale$2 = formatLocale$2(definition);\n  format$1 = locale$2.format;\n  formatPrefix$1 = locale$2.formatPrefix;\n  return locale$2;\n}\n\nfunction precisionFixed(step) {\n  return Math.max(0, -exponent$1(Math.abs(step)));\n}\n\nfunction precisionPrefix(step, value) {\n  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3 - exponent$1(Math.abs(step)));\n}\n\nfunction precisionRound(step, max) {\n  step = Math.abs(step), max = Math.abs(max) - step;\n  return Math.max(0, exponent$1(max) - exponent$1(step)) + 1;\n}\n\nfunction tickFormat(start, stop, count, specifier) {\n  var step = tickStep(start, stop, count),\n      precision;\n  specifier = formatSpecifier$1(specifier == null ? \",f\" : specifier);\n  switch (specifier.type) {\n    case \"s\": {\n      var value = Math.max(Math.abs(start), Math.abs(stop));\n      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;\n      return formatPrefix$1(specifier, value);\n    }\n    case \"\":\n    case \"e\":\n    case \"g\":\n    case \"p\":\n    case \"r\": {\n      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === \"e\");\n      break;\n    }\n    case \"f\":\n    case \"%\": {\n      if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === \"%\") * 2;\n      break;\n    }\n  }\n  return format$1(specifier);\n}\n\nfunction linearish(scale) {\n  var domain = scale.domain;\n\n  scale.ticks = function(count) {\n    var d = domain();\n    return ticks(d[0], d[d.length - 1], count == null ? 10 : count);\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    var d = domain();\n    return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);\n  };\n\n  scale.nice = function(count) {\n    if (count == null) count = 10;\n\n    var d = domain(),\n        i0 = 0,\n        i1 = d.length - 1,\n        start = d[i0],\n        stop = d[i1],\n        step;\n\n    if (stop < start) {\n      step = start, start = stop, stop = step;\n      step = i0, i0 = i1, i1 = step;\n    }\n\n    step = tickIncrement(start, stop, count);\n\n    if (step > 0) {\n      start = Math.floor(start / step) * step;\n      stop = Math.ceil(stop / step) * step;\n      step = tickIncrement(start, stop, count);\n    } else if (step < 0) {\n      start = Math.ceil(start * step) / step;\n      stop = Math.floor(stop * step) / step;\n      step = tickIncrement(start, stop, count);\n    }\n\n    if (step > 0) {\n      d[i0] = Math.floor(start / step) * step;\n      d[i1] = Math.ceil(stop / step) * step;\n      domain(d);\n    } else if (step < 0) {\n      d[i0] = Math.ceil(start * step) / step;\n      d[i1] = Math.floor(stop * step) / step;\n      domain(d);\n    }\n\n    return scale;\n  };\n\n  return scale;\n}\n\nfunction linear$1() {\n  var scale = continuous(identity$2, identity$2);\n\n  scale.copy = function() {\n    return copy(scale, linear$1());\n  };\n\n  initRange.apply(scale, arguments);\n\n  return linearish(scale);\n}\n\nfunction threshold() {\n  var domain = [0.5],\n      range = [0, 1],\n      unknown,\n      n = 1;\n\n  function scale(x) {\n    return x <= x ? range[bisectRight(domain, x, 0, n)] : unknown;\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain = slice$1.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = slice$1.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();\n  };\n\n  scale.invertExtent = function(y) {\n    var i = range.indexOf(y);\n    return [domain[i - 1], domain[i]];\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  scale.copy = function() {\n    return threshold()\n        .domain(domain)\n        .range(range)\n        .unknown(unknown);\n  };\n\n  return initRange.apply(scale, arguments);\n}\n\nfunction applyFormat(formatter) {\n  return typeof formatter === 'undefined' ? function (t) {\n    return t;\n  } : function (t) {\n    return formatter(t);\n  };\n}\n\nfunction clamp(val) {\n  return Math.max(0, Math.min(1, val));\n}\n\nfunction isObject(obj) {\n  return _typeof(obj) === 'object';\n}\n\nfunction minorTicksGenerator(count, start, end) {\n  var r = Math.abs(start - end);\n  var interval = r / (count + 1);\n  var ticks = [];\n\n  for (var i = 1; i <= count; i++) {\n    var v = i * interval;\n    ticks.push(start < end ? start + v : start - v);\n  }\n\n  return ticks;\n}\n\nfunction appendMinorTicks(majorTicks, minorCount, scale) {\n  if (majorTicks.length === 1) {\n    return majorTicks;\n  }\n\n  var ticks = majorTicks.concat([]);\n\n  for (var i = 0; i < majorTicks.length; i++) {\n    var start = majorTicks[i];\n    var end = majorTicks[i + 1];\n\n    if (i === 0 && start !== scale.start()) {\n      // Before and after first major tick\n      ticks.push.apply(ticks, _toConsumableArray$1(minorTicksGenerator(minorCount, start, end)));\n      start -= end - start;\n      end = majorTicks[i];\n      ticks.push.apply(ticks, _toConsumableArray$1(minorTicksGenerator(minorCount, start, end)));\n    } else if (i === majorTicks.length - 1 && end !== scale.end()) {\n      // After last major tick\n      end = start + (start - majorTicks[i - 1]);\n      ticks.push.apply(ticks, _toConsumableArray$1(minorTicksGenerator(minorCount, start, end)));\n    } else {\n      ticks.push.apply(ticks, _toConsumableArray$1(minorTicksGenerator(minorCount, start, end)));\n    }\n  }\n\n  return ticks.filter(function (t) {\n    return t >= scale.min() && t <= scale.max();\n  });\n}\n/**\n* Generate ticks based on a distance, for each 100th unit, one additional tick may be added\n* @private\n* @param  {Number} distance       Distance between each tick\n* @param  {Number} scale         The scale instance\n* @param  {Number} [minorCount=0]     Number of tick added between each distance\n* @param  {Number} [unitDivider=100]   Number to divide distance with\n* @return {Array}               Array of ticks\n*/\n\n\nfunction looseDistanceBasedGenerator(_ref) {\n  var distance = _ref.distance,\n      scale = _ref.scale,\n      _ref$minorCount = _ref.minorCount,\n      minorCount = _ref$minorCount === void 0 ? 0 : _ref$minorCount,\n      _ref$unitDivider = _ref.unitDivider,\n      unitDivider = _ref$unitDivider === void 0 ? 100 : _ref$unitDivider,\n      _ref$formatter = _ref.formatter,\n      formatter = _ref$formatter === void 0 ? undefined : _ref$formatter;\n  var step = !notNumber(unitDivider) && !notNumber(distance) ? Math.max(distance / unitDivider, 2) : 2;\n  var count = Math.min(1000, Math.round(step)); // safe guard against huge numbers\n\n  var majorTicks = scale.ticks(count);\n\n  if (majorTicks.length <= 1) {\n    majorTicks = scale.ticks(count + 1);\n  }\n\n  var ticks = minorCount > 0 ? appendMinorTicks(majorTicks, minorCount, scale) : majorTicks;\n  ticks.sort(function (a, b) {\n    return a - b;\n  });\n  var ticksFormatted = ticks.map(applyFormat(formatter));\n  return ticks.map(function (tick, i) {\n    var position = scale(tick);\n    return {\n      position: position,\n      start: position,\n      end: position,\n      label: ticksFormatted[i],\n      value: tick,\n      isMinor: majorTicks.indexOf(tick) === -1\n    };\n  });\n}\n/**\n* Generate ticks based on a distance, for each 100th unit, one additional tick may be added.\n* Will attempt to round the bounds of domain to even values and generate ticks hitting the domain bounds.\n* @private\n* @param  {Number} distance       Distance between each tick\n* @param  {Number} scale         The scale instance\n* @param  {Number} [minorCount=0]     Number of tick added between each distance\n* @param  {Number} [unitDivider=100]   Number to divide distance with\n* @return {Array}               Array of ticks\n*/\n\nfunction tightDistanceBasedGenerator(_ref2) {\n  var distance = _ref2.distance,\n      scale = _ref2.scale,\n      _ref2$minorCount = _ref2.minorCount,\n      minorCount = _ref2$minorCount === void 0 ? 0 : _ref2$minorCount,\n      _ref2$unitDivider = _ref2.unitDivider,\n      unitDivider = _ref2$unitDivider === void 0 ? 100 : _ref2$unitDivider,\n      _ref2$formatter = _ref2.formatter,\n      formatter = _ref2$formatter === void 0 ? undefined : _ref2$formatter;\n  var step = !notNumber(unitDivider) && !notNumber(distance) ? Math.max(distance / unitDivider, 2) : 2;\n  var count = Math.min(1000, Math.round(step)); // safe guard against huge numbers\n\n  var n = count > 10 ? 10 : count;\n  scale.nice(n);\n  var majorTicks = scale.ticks(count);\n  var ticks = minorCount > 0 ? appendMinorTicks(majorTicks, minorCount, scale) : majorTicks;\n  ticks.sort(function (a, b) {\n    return a - b;\n  });\n  var ticksFormatted = ticks.map(applyFormat(formatter));\n  return ticks.map(function (tick, i) {\n    var position = scale(tick);\n    return {\n      position: position,\n      start: position,\n      end: position,\n      label: ticksFormatted[i],\n      value: tick,\n      isMinor: majorTicks.indexOf(tick) === -1\n    };\n  });\n}\n\nfunction ticksByCount(_ref3) {\n  var count = _ref3.count,\n      minorCount = _ref3.minorCount,\n      scale = _ref3.scale,\n      formatter = _ref3.formatter;\n  return scale.ticks((count - 1) * minorCount + count).map(function (tick, i) {\n    var position = scale(tick);\n    return {\n      position: position,\n      start: position,\n      end: position,\n      label: formatter(tick),\n      isMinor: i % (minorCount + 1) !== 0,\n      value: tick\n    };\n  });\n}\n\nfunction ticksByValue(_ref4) {\n  var values = _ref4.values,\n      scale = _ref4.scale,\n      _ref4$formatter = _ref4.formatter,\n      formatter = _ref4$formatter === void 0 ? function (v) {\n    return v;\n  } : _ref4$formatter;\n  return values.sort(function (a, b) {\n    return (isObject(a) ? a.value : a) - (isObject(b) ? b.value : b);\n  }).filter(function (v, i, ary) {\n    var val = isObject(v) ? v.value : v;\n    return val <= scale.max() && val >= scale.min() && ary.indexOf(v) === i;\n  }).map(function (v) {\n    var isObj = isObject(v);\n    var value = isObj ? v.value : v;\n    var position = scale(value);\n    return {\n      position: position,\n      value: value,\n      label: isObj && typeof v.label !== 'undefined' ? v.label : formatter(value),\n      isMinor: isObj ? !!v.isMinor : false,\n      start: isObj && !isNaN(v.start) ? clamp(scale(v.start)) : position,\n      // TODOHandle end < start?\n      end: isObj && !isNaN(v.end) ? clamp(scale(v.end)) : position // TODO Handle start > end?\n\n    };\n  });\n}\n\nfunction forceTicksAtBounds(ticks, scale, formatter) {\n  var ticksP = ticks.map(function (t) {\n    return t.position;\n  });\n  var range = scale.range();\n\n  if (ticksP.indexOf(range[0]) === -1) {\n    ticks.splice(0, 0, {\n      position: range[0],\n      start: range[0],\n      end: range[0],\n      label: formatter(scale.start()),\n      isMinor: false,\n      value: scale.start()\n    });\n  } else if (ticks[0] && ticks[0].isMinor) {\n    ticks[0].isMinor = false; // Convert to major tick\n  }\n\n  var lastTick = ticks[ticks.length - 1];\n\n  if (ticksP.indexOf(range[1]) === -1) {\n    ticks.push({\n      position: range[1],\n      start: range[1],\n      end: range[1],\n      label: formatter(scale.end()),\n      isMinor: false,\n      value: scale.end()\n    });\n  } else if (lastTick && lastTick.isMinor) {\n    lastTick.isMinor = false; // Convert to major tick\n  }\n}\n\nfunction generateContinuousTicks(_ref5) {\n  var settings = _ref5.settings,\n      scale = _ref5.scale,\n      distance = _ref5.distance,\n      _ref5$formatter = _ref5.formatter,\n      formatter = _ref5$formatter === void 0 ? function (val) {\n    return val;\n  } : _ref5$formatter;\n  var ticks;\n  var minorCount = settings.minorTicks && !notNumber(settings.minorTicks.count) ? Math.min(100, settings.minorTicks.count) : 0;\n\n  if (Array.isArray(settings.ticks.values)) {\n    var values = settings.ticks.values.filter(function (v) {\n      return _typeof(v) === 'object' ? !notNumber(v.value) : !notNumber(v);\n    });\n    ticks = ticksByValue({\n      values: values,\n      scale: scale.copy(),\n      formatter: formatter\n    });\n  } else if (!notNumber(settings.ticks.count)) {\n    var count = Math.min(1000, settings.ticks.count);\n    ticks = ticksByCount({\n      count: count,\n      minorCount: minorCount,\n      scale: scale.copy(),\n      formatter: formatter\n    });\n  } else {\n    var tickGen = settings.ticks.tight ? tightDistanceBasedGenerator : looseDistanceBasedGenerator;\n    ticks = tickGen({\n      distance: distance,\n      minorCount: minorCount,\n      unitDivider: settings.ticks.distance,\n      scale: scale,\n      formatter: formatter\n    });\n\n    if (settings.ticks.forceBounds) {\n      forceTicksAtBounds(ticks, scale, formatter);\n    }\n  }\n\n  return ticks;\n}\nfunction generateDiscreteTicks(_ref6) {\n  var scale = _ref6.scale;\n  var domain = scale.domain();\n  var values = domain;\n  var dataItems = scale.data().items;\n  var labels = scale.labels ? scale.labels() : values;\n  var bandwidth = scale.bandwidth();\n  return values.map(function (d, i) {\n    var start = scale(d);\n    return {\n      position: start + bandwidth / 2,\n      label: \"\".concat(labels[i]),\n      data: dataItems ? dataItems[i] : undefined,\n      start: start,\n      end: start + bandwidth\n    };\n  });\n}\n\nfunction resolveSettings$1() {\n  var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var defaultSettings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var stngs = {};\n  Object.keys(defaultSettings).forEach(function (key) {\n    var type = _typeof(settings[key]);\n\n    if (type === 'function') {\n      stngs[key] = settings[key](context);\n    } else if (type === 'undefined') {\n      stngs[key] = defaultSettings[key];\n    } else {\n      stngs[key] = settings[key];\n    }\n  });\n  return stngs;\n}\n\nvar DEFAULT_SETTINGS = {\n  min: NaN,\n  max: NaN,\n  expand: NaN,\n  include: [],\n  invert: false\n};\nvar DEFAULT_TICKS_SETTINGS = {\n  tight: false,\n  forceBounds: false,\n  values: undefined,\n  count: NaN,\n  distance: 100\n};\nvar DEFAULT_MINORTICKS_SETTINGS = {\n  count: NaN\n};\n/**\n * @typedef {object} scale--linear\n * @property {string} [type='linear']\n * @property {number} [expand] - Expand the output range\n * @property {boolean} [invert=false] - Invert the output range\n * @property {number[]} [include] - Include specified numbers in the output range\n * @property {object} [ticks]\n * @property {boolean} [ticks.tight = false]\n * @property {boolean} [ticks.forceBounds = false]\n * @property {number} [ticks.distance = 100]  - Approximate distance between each tick\n * @property {number[]|object[]} [ticks.values] - If set, ticks are no longer generated but instead equal to this set\n * @property {number} [ticks.count]\n * @property {object} [minorTicks]\n * @property {number} [minorTicks.count = 3]\n * @property {number} [min] - Set an explicit minimum value\n * @property {number} [max] - Set an explicit maximum value\n */\n\nfunction getMinMax$1(settings, fields) {\n  var min = +settings.min;\n  var max = +settings.max;\n  var fieldMin = 0;\n  var fieldMax = 1;\n\n  if (fields && fields[0]) {\n    var minValues = fields.map(function (m) {\n      return m.min();\n    }).filter(function (v) {\n      return !isNaN(v);\n    });\n    var maxValues = fields.map(function (m) {\n      return m.max();\n    }).filter(function (v) {\n      return !isNaN(v);\n    });\n    fieldMin = minValues.length ? Math.min.apply(Math, _toConsumableArray$1(minValues)) : Number.NaN;\n    fieldMax = maxValues.length ? Math.max.apply(Math, _toConsumableArray$1(maxValues)) : Number.NaN;\n\n    if (isNaN(fieldMin) || isNaN(fieldMax)) {\n      fieldMin = -1;\n      fieldMax = 1;\n    } else if (fieldMin === fieldMax && fieldMin === 0) {\n      fieldMin = -1;\n      fieldMax = 1;\n    } else if (fieldMin === fieldMax && fieldMin) {\n      fieldMin -= Math.abs(fieldMin * 0.1);\n      fieldMax += Math.abs(fieldMax * 0.1);\n    } else if (!isNaN(settings.expand)) {\n      var range = fieldMax - fieldMin;\n      fieldMin -= range * settings.expand;\n      fieldMax += range * settings.expand;\n    }\n\n    if (Array.isArray(settings.include)) {\n      var i = settings.include.filter(function (n) {\n        return !isNaN(n);\n      });\n      fieldMin = Math.min.apply(Math, _toConsumableArray$1(i).concat([fieldMin]));\n      fieldMax = Math.max.apply(Math, _toConsumableArray$1(i).concat([fieldMax]));\n    }\n  }\n\n  return {\n    mini: !isNaN(min) ? min : fieldMin,\n    maxi: !isNaN(max) ? max : fieldMax\n  };\n}\n\nfunction initNormScale(normScale, scale) {\n  if (normScale.instance) {\n    return;\n  }\n\n  normScale.instance = scale.copy();\n  normScale.instance.domain([scale.start(), scale.end()]);\n  normScale.instance.clamp(true);\n  normScale.instance.range(normScale.invert ? [1, 0] : [0, 1]);\n}\n/**\n * @alias scaleLinear\n * @private\n * @param { object } settings\n * @param { field[] } [fields]\n * @return { linear }\n */\n\n\nfunction scaleLinear() {\n  var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var resources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var d3Scale = linear$1();\n  var normScale = {\n    instance: null,\n    invert: false\n  };\n  var ctx = {\n    data: data,\n    resources: resources\n  };\n  var stgns = resolveSettings$1(settings, DEFAULT_SETTINGS, ctx);\n  stgns.ticks = resolveSettings$1(settings.ticks, DEFAULT_TICKS_SETTINGS, ctx);\n  stgns.minorTicks = resolveSettings$1(settings.minorTicks, DEFAULT_MINORTICKS_SETTINGS, ctx);\n  var tickCache;\n  /**\n   * @alias linear\n   * @private\n   * @param { Object } value\n   * @return { number }\n   */\n\n  function fn(v) {\n    if (notNumber(v)) {\n      return NaN;\n    }\n\n    return d3Scale(v);\n  }\n\n  fn.data = function () {\n    return data;\n  };\n  /**\n   * {@link https://github.com/d3/d3-scale#continuous_invert }\n   * @param { number } value The inverted value\n   * @return { number } The inverted scaled value\n   */\n\n\n  fn.invert = function invert(value) {\n    return d3Scale.invert(value);\n  };\n  /**\n   * {@link https://github.com/d3/d3-scale#continuous_rangeRound }\n   * @param { number[] } values Range values\n   * @return { linear } The instance this method was called on\n   */\n\n\n  fn.rangeRound = function rangeRound(values) {\n    d3Scale.rangeRound(values);\n    return fn;\n  };\n  /**\n   * {@link https://github.com/d3/d3-scale#continuous_clamp }\n   * @param { boolean } [ value=true ] TRUE if clamping should be enabled\n   * @return { linear } The instance this method was called on\n   */\n\n\n  fn.clamp = function clamp() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    d3Scale.clamp(value);\n    return fn;\n  };\n  /**\n   * Get cached ticks (if any)\n   * @return { number | undefined }\n   */\n\n\n  fn.cachedTicks = function fnCachedTicks() {\n    return tickCache;\n  };\n  /**\n   * Clear the tick cache\n   * @return {number | undefined}\n   */\n\n\n  fn.clearTicksCache = function fnClearTicks() {\n    tickCache = undefined;\n    return this;\n  };\n  /**\n   * {@link https://github.com/d3/d3-scale#continuous_ticks }\n   * @param { Object } input Number of ticks to generate or an object passed to tick generator\n   * @return { number[] | Object } Array of ticks or any type the custom tick generator returns\n   */\n\n\n  fn.ticks = function ticks(input) {\n    if (input !== null && _typeof(input) === 'object') {\n      input.settings = input.settings || {}; // TODO Discontinue support for custom ticks settings as argument\n\n      input.settings = extend(true, {}, stgns, input.settings);\n      input.scale = fn;\n      tickCache = generateContinuousTicks(input);\n      return tickCache;\n    }\n\n    tickCache = d3Scale.ticks(input);\n    return tickCache;\n  };\n  /**\n   * {@link https://github.com/d3/d3-scale#continuous_nice }\n   * @param { number } count\n   * @return { linear } The instance this method was called on\n   */\n\n\n  fn.nice = function nice(count) {\n    d3Scale.nice(count);\n    return fn;\n  }; // TODO Support this?\n\n\n  fn.tickFormat = function tickFormat(count, format) {\n    return d3Scale.tickFormat(count, format);\n  }; // TODO Support this?\n\n\n  fn.interpolate = function interpolate(func) {\n    d3Scale.interpolate(func);\n    return fn;\n  };\n  /**\n   * @param { number[] } [values] Set or Get domain values\n   * @return { linear | Number[] } The instance this method was called on if a parameter is provided, otherwise the current domain is returned\n   */\n\n\n  fn.domain = function domain(values) {\n    if (arguments.length) {\n      d3Scale.domain(values);\n\n      if (normScale.instance) {\n        normScale.instance.domain([fn.start(), fn.end()]);\n      }\n\n      return fn;\n    }\n\n    return d3Scale.domain();\n  };\n  /**\n   * @param { number[] } [values] Set or Get range values\n   * @return { linear | number[] } The instance this method was called on if a parameter is provided, otherwise the current range is returned\n   */\n\n\n  fn.range = function range(values) {\n    if (arguments.length) {\n      d3Scale.range(values);\n      return fn;\n    }\n\n    return d3Scale.range();\n  };\n  /**\n   * Get the first value of the domain\n   * @return { number }\n   */\n\n\n  fn.start = function start() {\n    return fn.domain()[0];\n  };\n  /**\n   * Get the last value of the domain\n   * @return { number }\n   */\n\n\n  fn.end = function end() {\n    return fn.domain()[this.domain().length - 1];\n  };\n  /**\n   * Get the minimum value of the domain\n   * @return { number }\n   */\n\n\n  fn.min = function min() {\n    return Math.min(this.start(), this.end());\n  };\n  /**\n   * Get the maximum value of the domain\n   * @return { number }\n   */\n\n\n  fn.max = function max() {\n    return Math.max(this.start(), this.end());\n  };\n  /**\n   * Divides the domain and range into uniform segments, based on start and end value\n   * @param  { number } segments The number of segments\n   * @return { function } The instance this method was called on\n   * @example\n   * let s = linear();\n   * s.domain([0, 10]);\n   * s.range([0, 1]);\n   * s.classify( 2 );\n   * s.domain(); // [10, 5, 5, 0]\n   * s.range(); // [0.75, 0.75, 0.25, 0.25]\n   */\n\n\n  fn.classify = function classify(segments) {\n    var valueRange = (fn.start() - fn.end()) / segments,\n        domain = [fn.end()],\n        range = [],\n        samplePos = valueRange / 2;\n\n    for (var i = 0; i < segments; i++) {\n      var lastVal = domain[domain.length - 1] || 0,\n          calIntervalPos = lastVal + valueRange,\n          calSamplePos = lastVal + samplePos,\n          sampleColValue = fn(calSamplePos);\n      domain.push.apply(domain, [calIntervalPos, calIntervalPos]);\n      range.push.apply(range, [sampleColValue, sampleColValue]);\n    }\n\n    domain.pop();\n    fn.domain(domain);\n    fn.range(range);\n    return fn;\n  };\n\n  fn.copy = function copy() {\n    var cop = scaleLinear(settings, data, resources);\n    cop.domain(fn.domain());\n    cop.range(fn.range());\n    cop.clamp(d3Scale.clamp());\n    return cop;\n  };\n  /**\n   * @param {number} d - A domain value\n   * @return {number} A normalized range output given in range 0-1\n   * @example\n   * const scale = scaleLinear().domain([0, 10]).range([0, 10000]);\n   * scale.norm(5); // Returns 0.5\n   * scale(5); // Returns 5000\n   *\n   * scale.domain([0, 2, 10]);\n   * scale.norm(5); // Returns 0.5\n   */\n\n\n  fn.norm = function norm(d) {\n    initNormScale(normScale, fn);\n    return normScale.instance(d);\n  };\n  /**\n   * @param {number} d - A normalized value in range 0-1\n   * @return {number} A corresponding domain value\n   * @example\n   * const scale = scaleLinear().domain([0, 10]).range([0, 10000]);\n   * scale.normInvert(0.5); // Returns 5\n   * scale.invert(5000); // Returns 5\n   */\n\n\n  fn.normInvert = function norm(t) {\n    initNormScale(normScale, fn);\n    return normScale.instance.invert(t);\n  };\n\n  var _getMinMax = getMinMax$1(stgns, data ? data.fields : []),\n      mini = _getMinMax.mini,\n      maxi = _getMinMax.maxi;\n\n  fn.domain([mini, maxi]);\n  fn.range(stgns.invert ? [1, 0] : [0, 1]);\n  normScale.invert = stgns.invert;\n  return fn;\n}\n\nvar DEFAULT_SETTINGS$1 = {\n  padding: 0,\n  paddingInner: NaN,\n  paddingOuter: NaN,\n  align: 0.5,\n  invert: false,\n  maxPxStep: NaN,\n  range: [0, 1]\n};\n/**\n * @typedef {object} scale--band\n * @property {string} [type='band']\n * @property {number} [padding] - {@link https://github.com/d3/d3-scale#band_padding}\n * @property {number} [paddingInner] - {@link https://github.com/d3/d3-scale#band_paddingInner}\n * @property {number} [paddingOuter] - {@link https://github.com/d3/d3-scale#band_paddingOuter}\n * @property {number} [align] - {@link https://github.com/d3/d3-scale#band_align}\n * @property {boolean} [invert=false] - Invert the output range\n * @property {number} [maxPxStep] - Explicitly limit the bandwidth to a pixel value\n * @property {function} [label] - Callback label function, applied on each datum\n * @property {function} [value] - Callback value function, applied on each datum\n * @property {array<number>|function} [range=[0, 1]] - Set range explicitly (ignored when maxPxStep takes effect)\n */\n\n/**\n * @alias scaleBand\n * @memberof picasso\n * @private\n * @param { Object } settings\n * @param { fields[] } [fields]\n * @param { dataset } [dataset]\n * @return { band }\n */\n\nfunction scaleBand() {\n  var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var resources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  /**\n   * An augmented {@link https://github.com/d3/d3-scale#_band|d3 band scale}\n   * @alias band\n   * @private\n   * @kind function\n   * @param { Object } value\n   * @return { number }\n   */\n  var band$1 = band();\n  var ctx = {\n    data: data,\n    resources: resources\n  };\n  var stgns = resolveSettings$1(settings, DEFAULT_SETTINGS$1, ctx);\n  var items = data.items || [];\n  var domainToDataMapping = {};\n  var values = [];\n  var labels = []; // I would like to define this outside of scaleBand but it cause the documentation to be in the wrong order\n\n  function augmentScaleBand(band, settings) {\n    // eslint-disable-line no-shadow\n    band.data = function () {\n      return data;\n    };\n\n    band.datum = function (domainValue) {\n      return items[domainToDataMapping[domainValue]];\n    };\n    /**\n     * Get the first value of the domain\n     * @return { number }\n     */\n\n\n    band.start = function start() {\n      return band.domain()[0];\n    };\n    /**\n     * Get the last value of the domain\n     * @return { number }\n     */\n\n\n    band.end = function end() {\n      return band.domain()[band.domain().length - 1];\n    };\n\n    band.labels = function () {\n      return labels;\n    };\n    /**\n     * Generate discrete ticks\n     * @return {Object[]} Array of ticks\n     */\n\n\n    band.ticks = function ticks() {\n      var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      input.scale = band;\n      return generateDiscreteTicks(input, settings.trackBy || 'label');\n    };\n  }\n\n  augmentScaleBand(band$1, settings);\n  /**\n   * if required creates a new scale with a restricted range\n   * so that step size is at most maxPxStep\n   * otherwise it returns itself\n   * @param { number } size\n   * @return { band }\n   */\n\n  band$1.pxScale = function pxScale(size) {\n    var max = stgns.maxPxStep;\n\n    if (isNaN(max)) {\n      return band$1;\n    }\n\n    var n = band$1.domain().length;\n    var sizeRelativeToStep = Math.max(1, n - band$1.paddingInner() + 2 * band$1.paddingOuter());\n\n    if (sizeRelativeToStep * max >= size) {\n      return band$1;\n    }\n\n    var newBand = band$1.copy();\n    newBand.type = band$1.type;\n    augmentScaleBand(newBand, settings);\n    var t = sizeRelativeToStep * max / size;\n    var offset = (1 - t) * band$1.align();\n    newBand.range(stgns.invert ? [t + offset, offset] : [offset, t + offset]);\n    return newBand;\n  };\n\n  var valueFn = typeof settings.value === 'function' ? settings.value : function (d) {\n    return d.datum.value;\n  };\n  var labelFn = typeof settings.label === 'function' ? settings.label : function (d) {\n    return d.datum.label;\n  };\n\n  for (var i = 0; i < items.length; i++) {\n    var arg = extend({\n      datum: items[i]\n    }, ctx);\n    var v = valueFn(arg, i);\n\n    if (values.indexOf(v) === -1) {\n      values.push(v);\n      labels.push(labelFn(arg, i));\n      domainToDataMapping[v] = i;\n    }\n  }\n\n  band$1.domain(values);\n  band$1.range(stgns.invert ? stgns.range.slice().reverse() : stgns.range);\n  band$1.padding(isNaN(stgns.padding) ? 0 : stgns.padding);\n\n  if (!isNaN(stgns.paddingInner)) {\n    band$1.paddingInner(stgns.paddingInner);\n  }\n\n  if (!isNaN(stgns.paddingOuter)) {\n    band$1.paddingOuter(stgns.paddingOuter);\n  }\n\n  band$1.align(isNaN(stgns.align) ? 0.5 : stgns.align);\n  return band$1;\n}\n\nvar DEFAULT_TICKS_SETTINGS$1 = {\n  depth: 0\n};\n\nfunction keyGen(node, valueFn, ctx) {\n  return node.ancestors().map(function (a) {\n    return valueFn(extend({\n      datum: a.data\n    }, ctx));\n  }).reverse().slice(1) // Delete root node\n  .toString();\n}\n\nfunction flattenTree(rootNode, settings, ctx) {\n  var ticksDepth = settings.ticks.depth;\n  var valueFn = settings.value;\n  var labelFn = settings.label;\n  var values = [];\n  var labels = [];\n  var items = {};\n  var ticks = [];\n  var expando = 0;\n\n  if (!rootNode) {\n    return {\n      values: values,\n      labels: labels,\n      items: items,\n      ticks: ticks\n    };\n  }\n\n  rootNode.eachAfter(function (node) {\n    if (node.depth > 0) {\n      var key = keyGen(node, valueFn, ctx);\n      var leaves = node.leaves() || [node]; // If leaf node returns itself\n\n      var value = valueFn(extend({\n        datum: node.data\n      }, ctx));\n      var label = labelFn(extend({\n        datum: node.data\n      }, ctx));\n      var isBranch = Array.isArray(node.children);\n      var item = {\n        key: key,\n        count: leaves.length,\n        value: value,\n        label: label,\n        leftEdge: keyGen(leaves[0], valueFn, ctx),\n        rightEdge: keyGen(leaves[Math.max(leaves.length - 1, 0)], valueFn, ctx),\n        node: node // isTick: ticksDepth === null ? !isBranch : node.depth === ticksDepth\n\n      };\n\n      if (isBranch) {\n        values.push(\"SPACER_\".concat(expando, \"_SPACER\"));\n        expando++;\n      } else {\n        values.push(key);\n        labels.push(label);\n      }\n\n      if (ticksDepth <= 0 && !isBranch || node.depth === ticksDepth) {\n        ticks.push(item);\n      }\n\n      items[key] = item;\n    }\n  });\n  var spill = rootNode.height - 1;\n\n  if (spill > 0) {\n    values.splice(-spill);\n  }\n\n  return {\n    values: values,\n    labels: labels,\n    items: items,\n    ticks: ticks\n  };\n}\n/**\n * @typedef {object} scale-hBand.settings\n * @private\n * @property {number} [padding=0] - Exposes {@link https://github.com/d3/d3-scale#band_padding}\n * @property {boolean} [paddingOuter=0] - Exposes {@link https://github.com/d3/d3-scale#band_paddingOuter}\n * @property {number[]} [paddingInner=0] - Exposes {@link https://github.com/d3/d3-scale#band_paddingInner}\n * @property {object} [align=0.5] - Exposes {@link https://github.com/d3/d3-scale#band_align}\n * @property {boolean} [invert=false] - Invert the output range\n */\n\n/**\n  * Hierarchical band scale, that is an augmented band scale, that takes hierarchical data as input\n * @alias scaleHierarchicalBand\n * @private\n * @param { Object } settings\n * @param { fields[] } [fields]\n * @param { dataset } [dataset] - With a root property that is an instance of D3.js Hierarchy\n * @return { h-band }\n */\n\n\nfunction scaleHierarchicalBand() {\n  var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var resources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var ctx = {\n    data: data,\n    resources: resources\n  };\n  var stgns = resolveSettings$1(settings, DEFAULT_SETTINGS$1, ctx);\n  stgns.ticks = resolveSettings$1(settings.ticks, DEFAULT_TICKS_SETTINGS$1, ctx);\n  stgns.value = typeof settings.value === 'function' ? settings.value : function (d) {\n    return d.datum.value;\n  };\n  stgns.label = typeof settings.label === 'function' ? settings.label : function (d) {\n    return d.datum.value;\n  };\n  var bandInstance = scaleBand(stgns);\n\n  var _flattenTree = flattenTree(data.root, stgns, ctx),\n      values = _flattenTree.values,\n      labels = _flattenTree.labels,\n      items = _flattenTree.items,\n      ticks = _flattenTree.ticks;\n  /**\n   * @alias h-band\n   * @private\n   * @kind function\n   * @param { Object[] } value - Array where each value is a reference to a node, going from depth 1 to n.\n   * @return { number }\n   */\n\n\n  var hBand = function fn(val) {\n    var strVal = String(val);\n    var item = items[strVal];\n\n    if (item) {\n      return bandInstance(stgns.invert ? item.rightEdge : item.leftEdge);\n    }\n\n    return bandInstance(strVal);\n  };\n\n  extend(true, hBand, bandInstance);\n  /**\n   * Wrapped {@link https://github.com/d3/d3-scale#band_bandwidth}\n   * @param { Object[] } [val] - Array where each value is a reference to a node, going from depth 1 to n. If omitted, bandwidth for the leaf nodes is return.\n   * @return { number }\n   */\n\n  hBand.bandwidth = function bandwidth(val) {\n    var item = items[String(val)];\n    var bw = bandInstance.bandwidth();\n\n    if (item && !item.isLeaf) {\n      var left = hBand(item.leftEdge);\n      var right = hBand(item.rightEdge);\n      return Math.abs(left - right) + bw;\n    }\n\n    return bw;\n  };\n  /**\n   * Wrapped {@link https://github.com/d3/d3-scale#band_step}\n   * @param { Object[] } [val] - Array where each value is a reference to a node, going from depth 1 to n. If omitted, step size for the leaf nodes is return.\n   * @return { number }\n   */\n\n\n  hBand.step = function step(val) {\n    var item = items[String(val)];\n    var leafCount = item ? item.count : 1;\n    var stepSize = bandInstance.step();\n    stepSize *= leafCount;\n    return stepSize;\n  };\n  /**\n   * @return { dataset }\n   */\n\n\n  hBand.data = function () {\n    return data;\n  };\n  /**\n   * Return datum for a given node\n   * @param { Object[] } val - Array where each value is a reference to a node, going from depth 1 to n.\n   * @return { Object } The datum\n   */\n\n\n  hBand.datum = function (val) {\n    var item = items[String(val)];\n\n    if (item) {\n      return item.node.data;\n    }\n\n    return null;\n  };\n\n  hBand.copy = function () {\n    return scaleHierarchicalBand(settings, data, resources);\n  };\n  /**\n   * @return { Object[] } Labels for each leaf node\n   */\n\n\n  hBand.labels = function () {\n    return labels;\n  };\n  /**\n   * Generate discrete ticks\n   * @return { Object[] } Ticks for each leaf node\n   */\n\n\n  hBand.ticks = function () {\n    // eslint-disable-line arrow-body-style\n    return ticks.map(function (item) {\n      var start = hBand(item.key);\n      var bandwidth = hBand.bandwidth(item.key);\n      return {\n        position: start + bandwidth / 2,\n        label: item.label,\n        data: item.node.data,\n        start: start,\n        end: start + bandwidth\n      };\n    });\n  };\n\n  var orgPxScale = bandInstance.pxScale;\n\n  hBand.pxScale = function pxScale(size) {\n    bandInstance = orgPxScale(size);\n    return hBand;\n  };\n\n  hBand.domain(values);\n  return hBand;\n}\n\nvar minAccessor = function minAccessor(v) {\n  return v.min();\n};\n\nvar maxAccessor = function maxAccessor(v) {\n  return v.max();\n};\n/**\n * Calculate the min/max value based on various inputs.\n *\n * Provided min/max setting takes presedence over all other inputs. If not provided, the respective values are calculated\n * from the given arr input, where each item in the array is expected to have a min/max accessor.\n *\n * @private\n * @param {object} [settings]\n * @param {number} [settings.min] The minimum value. Defaults to 0 if not provided.\n * @param {number} [settings.max] The maximum value. Defaults to 1 if not provided.\n * @param {object} [arr]\n * @returns { object[] } An array containing the min and max values.\n *\n * @example\n * minmax(); // [0, 1]\n *\n * minmax({}, [\n * { min: () => 13, max: () => 15 },\n * { min: () => NaN, max: () => 17 },\n * ]); // [13, 17]\n *\n * minmax({ min: -5, max: 4 }, [\n * { min: () => -20, max: () => 15 },\n * ]); // [-5, 4]\n */\n\n\nfunction minmax(settings, arr) {\n  // const definedMin = settings && typeof settings.min !== 'undefined';\n  // const definedMax = settings && typeof settings.max !== 'undefined';\n  var definedMin = settings && !isNaN(settings.min);\n  var definedMax = settings && !isNaN(settings.max);\n  var min = definedMin ? +settings.min : 0;\n  var max = definedMax ? +settings.max : 1;\n\n  if (arr && arr.length) {\n    if (!definedMin) {\n      var arrMin = arr.map(minAccessor).filter(isNumber);\n      min = arrMin.length ? Math.min.apply(Math, _toConsumableArray$1(arrMin)) : min;\n    }\n\n    if (!definedMax) {\n      var arrMax = arr.map(maxAccessor).filter(isNumber);\n      max = arrMax.length ? Math.max.apply(Math, _toConsumableArray$1(arrMax)) : max;\n    }\n  }\n\n  return [min, max];\n}\n\nvar DEFAULT_SETTINGS$2 = {\n  domain: [],\n  range: [],\n  invert: false,\n  min: NaN,\n  max: NaN\n};\n\nfunction generateDomain(range, min, max) {\n  var len = range.length;\n\n  if (len === 2) {\n    return [min, max];\n  }\n\n  var domain = [];\n  var part = (max - min) / (len - 1);\n  domain.push(min);\n\n  for (var i = 1; i < len - 1; i++) {\n    domain.push(min + part * i);\n  }\n\n  domain.push(max);\n  return domain;\n}\n/**\n * @typedef {object} scale--sequential-color\n * @property {string} [type='sequential-color']\n * @property {string[]} [range] - CSS color values of the output range\n * @property {boolean} [invert=false] - Invert range\n * @property {number} [min] - Set an explicit minimum value\n * @property {number} [max] - Set an explicit maximum value\n */\n\n/**\n * @alias scaleSequentialColor\n * @private\n * @param { Object } [settings] Settings for this scale. If both range and domain are specified, they have to fulfill range.length === domain.length, otherwise they will be overriden.\n * @param { number[] } [settings.domain] Numeric values indicating stop limits between start and end values.\n * @param { color[] } [settings.range] CSS color values indicating stop colors between start and end values.\n * @param { field[] } [fields] Fields to dynamically calculate the domain extent.\n * @return { sequentialColor }\n *\n * @example\n * picasso.scaleSequentialColor({\n *  range: ['red', '#fc6', 'green'],\n *  domain: [-40, 0, 100]\n * });\n */\n\n\nfunction scaleSequentialColor() {\n  var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var resources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var s = scaleLinear(settings, data, resources).clamp(true).interpolate(interpolateRgb);\n  var stgns = resolveSettings$1(settings, DEFAULT_SETTINGS$2, {\n    data: data,\n    resources: resources\n  });\n  var isDomain = Array.isArray(stgns.domain) && stgns.domain.length;\n  var isRange = Array.isArray(stgns.range) && stgns.range.length;\n  /**\n   * @alias sequentialColor\n   * @private\n   * @kind function\n   * @param { Object } v Object containing a 'value' property\n   * @return { string } The blended color\n   */\n\n  var fn = s;\n  extend(true, fn, s);\n\n  var _minmax = minmax(stgns, data ? data.fields : []),\n      _minmax2 = _slicedToArray(_minmax, 2),\n      min = _minmax2[0],\n      max = _minmax2[1];\n\n  var num = isDomain ? stgns.domain.length : -1;\n  var DEFAULT_COLORS = resources.theme ? resources.theme.palette('sequential', num > 0 ? num : 2) : [];\n  var range = isRange ? stgns.range : DEFAULT_COLORS;\n  fn.range(stgns.invert ? range.slice().reverse() : range.slice());\n  fn.domain(isDomain ? stgns.domain : generateDomain(fn.range(), min, max));\n  return fn;\n}\n\nvar DEFAULT_SETTINGS$3 = {\n  domain: [],\n  range: [],\n  invert: false,\n  min: NaN,\n  max: NaN,\n  nice: false\n};\n\nfunction generateDomain$1(range, min, max) {\n  var len = range.length;\n\n  if (len === 2) {\n    return [min + (max - min) / 2];\n  }\n\n  var domain = [];\n  var part = (max - min) / len;\n\n  for (var i = 1; i < len; i++) {\n    domain.push(min + part * i);\n  }\n\n  return domain;\n}\n\nfunction getBreaks(domain) {\n  var ret = [];\n\n  for (var i = 0; i < domain.length - 1; i++) {\n    ret.push((domain[i] + domain[i + 1]) / 2);\n  }\n\n  return ret;\n}\n\nfunction generateRange(domain, colors, min, max) {\n  min = domain[0];\n  max = domain && domain.length >= 2 ? domain[domain.length - 1] : max;\n  var seq = scaleSequentialColor().domain([min, max]).range(colors);\n  var values = [min].concat(_toConsumableArray$1(getBreaks(domain)), [max]);\n  return values.map(function (v) {\n    return seq(v);\n  });\n}\n\nfunction generateNiceDomain(range, min, max) {\n  var numPoints = range.length === 2 ? 10 : Math.max(1, range.length);\n  var lin = linear$1().domain([min, max]).nice(numPoints);\n  var domain = lin.ticks(numPoints);\n\n  if (!range || !range.length) {\n    return domain;\n  } // remove values from endpoints\n\n\n  var num = Math.max(0, range.length - 1);\n\n  while (domain.length > num) {\n    if (domain[0] - min <= max - domain[domain.length - 1]) {\n      domain.shift();\n    } else {\n      domain.pop();\n    }\n  }\n\n  return domain;\n}\n/**\n * @typedef {object} scale--threshold-color\n * @property {string} [type='threshold-color']\n * @property {number[]} [domain] Values defining the thresholds\n * @property {string[]} [range] - CSS color values of the output range\n * @property {boolean} [invert=false] - Invert range\n * @property {number} [min] - Set an explicit minimum value\n * @property {number} [max] - Set an explicit maximum value\n * @property {boolean} [nice=false] If set to true, will generate 'nice' domain values. Ignored if domain is set.\n */\n\n/**\n * @alias scaleThresholdColor\n * @private\n * @param { object } [settings] Settings for this scale. If both domain and range are specified, they have to fulfill domain.length === range.length + 1,  otherwise they will be overriden.\n * @param { number[] } [settings.domain] Values defining the thresholds.\n * @param { color[] } [settings.range] CSS color values of the output range.\n * @param { boolean } [settings.nice=false] If set to true, will generate 'nice' domain values. Ignored if domain is set.\n * @param { number } [settings.min] Minimum value to generate domain extent from. Ignored if domain is set.\n * @param { number } [settings.max] Maximum value to generate domain extend from. Ignored if domain is set.\n * @param { field[] } [fields] Fields to dynamically calculate the domain extent from. Ignored if min/max are set.\n * @return { thresholdColor }\n *\n * @example\n * let t = threshold({\n *   range: ['black', 'white'],\n *   domain: [25,50,75],\n *   max: 100,\n *   min: 0\n * });\n * t.domain(); // [25,50,75]\n * t.range(); // Generates from colors and domain: ['rgb(0,0,0)','rgb(85,85,85)','rgb(170,170,170)','rgb(255,255,255)']\n */\n\n\nfunction scaleThresholdColor() {\n  var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var resources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var d3Scale = threshold();\n  var stgns = resolveSettings$1(settings, DEFAULT_SETTINGS$3, {\n    data: data,\n    resources: resources\n  });\n  var isDomain = Array.isArray(stgns.domain) && stgns.domain.length;\n  var isRange = Array.isArray(stgns.range) && stgns.range.length;\n  /**\n   * @alias thresholdColor\n   * @private\n   * @param { object } v Object literal containing a 'value' property.\n   * @return { string } A CSS color from the scale's range.\n   */\n\n  function fn(v) {\n    if (notNumber(v)) {\n      return NaN;\n    }\n\n    return d3Scale(v);\n  }\n\n  Object.keys(d3Scale).forEach(function (key) {\n    return fn[key] = d3Scale[key];\n  });\n  var fields = data.fields;\n\n  var _minmax = minmax(stgns, fields),\n      _minmax2 = _slicedToArray(_minmax, 2),\n      min = _minmax2[0],\n      max = _minmax2[1];\n\n  var num = isDomain ? stgns.domain.length : -1;\n  var DEFAULT_COLORS = resources.theme ? resources.theme.palette('sequential', num > 0 ? num : 2) : [];\n  var range = isRange ? stgns.range : DEFAULT_COLORS;\n  var domain = [];\n\n  if (isDomain) {\n    domain = stgns.domain;\n  } else if (stgns.nice) {\n    domain = generateNiceDomain(range, min, max);\n  } else {\n    domain = [min + (max - min) / 2];\n  }\n\n  if (range.length > domain.length + 1) {\n    // Generate limits from range\n    domain = generateDomain$1(range, min, max);\n  } else if (range.length < domain.length + 1) {\n    // Generate additional colors\n    range = generateRange(domain, range, min, max);\n  }\n\n  fn.data = function () {\n    return data;\n  };\n\n  fn.range(stgns.invert ? range.slice().reverse() : range);\n  fn.domain(domain);\n  return fn;\n}\n\nvar DEFAULT_SETTINGS$4 = {\n  domain: [],\n  range: []\n};\n/**\n * @alias scaleOrdinal\n * @private\n * @param { Object } settings\n * @param { field[] } [fields]\n * @param { dataset } data\n * @return { ordinal }\n */\n\nfunction ordinal$1() {\n  var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var resources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  /**\n   * An augmented {@link https://github.com/d3/d3-scale#_ordinal|d3 ordinal scale}\n   * @private\n   * @alias ordinal\n   * @param { Object }\n   * @return { number }\n   */\n  var fn = ordinal();\n  var ctx = {\n    data: data,\n    resources: resources\n  };\n  var stgns = resolveSettings$1(settings, DEFAULT_SETTINGS$4, ctx);\n  var valueFn = typeof settings.value === 'function' ? settings.value : function (d) {\n    return d.datum.value;\n  };\n  var labelFn = typeof settings.label === 'function' ? settings.label : function (d) {\n    return d.datum.label;\n  };\n  var items = data.items || [];\n  var domainToDataMapping = {};\n  var values = [];\n  var labels = [];\n\n  for (var i = 0; i < items.length; i++) {\n    var arg = extend({\n      datum: items[i]\n    }, ctx);\n    var v = valueFn(arg, i);\n\n    if (values.indexOf(v) === -1) {\n      values.push(v);\n      labels.push(labelFn(arg, i));\n      domainToDataMapping[v] = i;\n    }\n  }\n\n  fn.data = function () {\n    return data;\n  };\n\n  fn.labels = function () {\n    return labels;\n  };\n\n  fn.label = function (domainValue) {\n    return labels[values.indexOf(domainValue)];\n  };\n\n  fn.datum = function (domainValue) {\n    return items[domainToDataMapping[domainValue]];\n  };\n\n  fn.range(stgns.range);\n\n  if (Array.isArray(stgns.domain) && stgns.domain.length) {\n    fn.domain(stgns.domain);\n  } else {\n    fn.domain(values);\n  }\n\n  return fn;\n}\n\nvar DEFAULT_SETTINGS$5 = {\n  domain: [],\n  range: [],\n  unknown: undefined\n};\nvar DEFAULT_EXPLICIT_SETTINGS = {\n  domain: [],\n  range: [],\n  override: false\n};\n/**\n * @typedef {object} scale--categorical-color\n * @property {string} [type='categorical-color']\n * @property {string[]} [range=false] - CSS color values of the output range\n * @property {string} [unknown] - {@link https://github.com/d3/d3-scale#ordinal_unknown}\n * @property {object} [explicit] - Explicitly bind values to an output\n * @property {object[]} [explicit.domain[]] - Values to bind\n * @property {string[]} [explicit.range[]] - Output range\n */\n\n/**\n * An ordinal scale with the output range set to default colors, as defined by *scaleCategorical.range*\n * @alias scaleCategorical\n * @private\n * @param { Object } settings\n * @param { field[] } [fields]\n * @param { dataset } [dataset]\n * @return { ordinal }\n */\n\nfunction scaleCategorical() {\n  var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var resources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var s = ordinal$1(settings, data, resources);\n  var theme = resources.theme;\n  var stgns = resolveSettings$1(settings, DEFAULT_SETTINGS$5, {\n    data: data,\n    resources: resources\n  });\n  stgns.explicit = resolveSettings$1(settings.explicit, DEFAULT_EXPLICIT_SETTINGS, {\n    data: data,\n    resources: resources\n  });\n  var range;\n\n  if (!Array.isArray(stgns.range) || stgns.range.length === 0) {\n    range = theme ? theme.palette('categorical', s.domain().length).slice() : [];\n  } else {\n    range = stgns.range.slice();\n  }\n\n  if (stgns.unknown) {\n    s.unknown(stgns.unknown);\n  } else if (theme && theme.palette('unknown')) {\n    var un = theme.palette('unknown');\n    s.unknown(un[0]);\n  }\n\n  if (Array.isArray(stgns.explicit.domain) && stgns.explicit.domain.length) {\n    var domain = s.domain().slice();\n    var explicitDomain = stgns.explicit.domain;\n    var explicitRange = Array.isArray(stgns.explicit.range) ? stgns.explicit.range : []; // duplicate range values to cover entire domain\n\n    var numCopies = Math.floor(domain.length / range.length);\n\n    for (var i = 1; i < numCopies + 1; i *= 2) {\n      range = range.concat(range);\n    }\n\n    if (stgns.explicit.override) {\n      for (var _i = 0; _i < explicitDomain.length; _i++) {\n        var index = domain.indexOf(explicitDomain[_i]);\n\n        if (index > -1) {\n          range[index] = explicitRange[_i];\n        }\n      }\n    } else {\n      // inject explicit colors\n      var order = explicitDomain.map(function (d, i) {\n        return [domain.indexOf(d), d, explicitRange[i]];\n      }).sort(function (a, b) {\n        return a[0] - b[0];\n      });\n      order.forEach(function (v) {\n        var idx = domain.indexOf(v[1]);\n\n        if (idx !== -1) {\n          range.splice(idx, 0, v[2]);\n        }\n      });\n    } // cutoff excess range values\n\n\n    range.length = domain.length;\n  }\n\n  s.range(range);\n  return s;\n}\n\nvar scaleRegistry = registryFactory();\nscaleRegistry('linear', scaleLinear);\nscaleRegistry('band', scaleBand);\nscaleRegistry('h-band', scaleHierarchicalBand);\nscaleRegistry('sequential-color', scaleSequentialColor);\nscaleRegistry('threshold-color', scaleThresholdColor);\nscaleRegistry('categorical-color', scaleCategorical);\n\nfunction getTypeFromMeta(fields) {\n  var types = fields.map(function (field) {\n    return field.type() === 'dimension' ? 'band' : 'linear';\n  });\n  return types.indexOf('linear') !== -1 ? 'linear' : 'band';\n}\n\nfunction deduceScaleTypeFromData(data) {\n  if (data.root) {\n    return 'h-band';\n  }\n\n  if (data.fields && data.fields[0]) {\n    return getTypeFromMeta(data.fields);\n  }\n\n  return 'linear';\n}\n\nfunction create$2(options, d, deps) {\n  var dataSourceConfig = options.data;\n\n  if (options.source) {\n    // DEPRECATION\n    deps.logger.warn('Deprecated: Scale data source configuration');\n    dataSourceConfig = {\n      extract: []\n    };\n    (Array.isArray(options.source) ? options.source : [options.source]).forEach(function (source) {\n      dataSourceConfig.extract.push({\n        field: source\n      });\n    });\n  }\n\n  var data = extract(dataSourceConfig, d, deps);\n  var type = options.type || deduceScaleTypeFromData(data);\n  var s;\n\n  if (type === 'color') {\n    if (data.fields && data.fields[0] && data.fields[0].type() === 'dimension') {\n      type = 'categorical-color';\n    } else {\n      type = 'sequential-color';\n    }\n  }\n\n  if (deps.scale.has(type)) {\n    s = deps.scale.get(type);\n    s = s(options, data, {\n      theme: deps.theme,\n      logger: deps.logger\n    });\n    s.type = type;\n  }\n\n  return s;\n}\nfunction collection$1(scalesConfig, data, deps) {\n  var fn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : create$2;\n  var scales = {};\n  return {\n    get: function get(def) {\n      var key;\n\n      if (typeof def === 'string' && scalesConfig[def]) {\n        key = def;\n      } else if (_typeof(def) === 'object' && 'scale' in def && scalesConfig[def.scale]) {\n        key = def.scale;\n      }\n\n      if (key) {\n        scales[key] = scales[key] || fn(scalesConfig[key], data, deps);\n        return scales[key];\n      }\n\n      return fn(def, data, deps);\n    },\n    all: function all() {\n      Object.keys(scalesConfig).forEach(this.get);\n      return scales;\n    }\n  };\n}\n\n/**\n * Utility functions\n */\n\nvar util = {};\n\nutil.isObject = function isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n};\n\nutil.isNumber = function isNumber(arg) {\n  return typeof arg === 'number';\n};\n\nutil.isUndefined = function isUndefined(arg) {\n  return arg === void 0;\n};\n\nutil.isFunction = function isFunction(arg){\n  return typeof arg === 'function';\n};\n\n\n/**\n * EventEmitter class\n */\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nvar nodeEventEmitter = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\nEventEmitter.init = function() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!util.isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error' && !this._events.error) {\n    er = arguments[1];\n    if (er instanceof Error) {\n      throw er; // Unhandled 'error' event\n    } else {\n      throw Error('Uncaught, unspecified \"error\" event.');\n    }\n    return false;\n  }\n\n  handler = this._events[type];\n\n  if (util.isUndefined(handler))\n    return false;\n\n  if (util.isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        len = arguments.length;\n        args = new Array(len - 1);\n        for (i = 1; i < len; i++)\n          args[i - 1] = arguments[i];\n        handler.apply(this, args);\n    }\n  } else if (util.isObject(handler)) {\n    len = arguments.length;\n    args = new Array(len - 1);\n    for (i = 1; i < len; i++)\n      args[i - 1] = arguments[i];\n\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!util.isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              util.isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (util.isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (util.isObject(this._events[type]) && !this._events[type].warned) {\n    var m;\n    if (!util.isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n\n      if (util.isFunction(console.error)) {\n        console.error('(node) warning: possible EventEmitter memory ' +\n                      'leak detected. %d listeners added. ' +\n                      'Use emitter.setMaxListeners() to increase limit.',\n                      this._events[type].length);\n      }\n      if (util.isFunction(console.trace))\n        console.trace();\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!util.isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!util.isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (util.isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (util.isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (util.isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (Array.isArray(listeners)) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (util.isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  var ret;\n  if (!emitter._events || !emitter._events[type])\n    ret = 0;\n  else if (util.isFunction(emitter._events[type]))\n    ret = 1;\n  else\n    ret = emitter._events[type].length;\n  return ret;\n};\n\nvar EventEmitter$1 = {\n  /**\n   * Function used to add event handling to objects passed in.\n   * @private\n   * @param {Object} obj Object instance that will get event handling.\n   */\n  mixin: function mixin(obj) {\n    Object.keys(nodeEventEmitter.prototype).forEach(function (key) {\n      obj[key] = nodeEventEmitter.prototype[key];\n    });\n    nodeEventEmitter.init(obj);\n    return obj;\n  }\n};\n\nfunction scrollApi() {\n  var min = 0;\n  var max = 0;\n  var start = 0;\n  var viewSize = 0;\n  start = start || min;\n  /**\n   * The scroll api\n   * @private\n   * @alias scroll\n   */\n\n  var s = {\n    /**\n     * Move the current scroll\n     * @param {number} value\n     * @emits update\n     */\n    move: function move(value) {\n      this.moveTo(start + value);\n    },\n\n    /**\n     * Change the current scroll to a specific value\n     * @param {number} value\n     * @emits update\n     */\n    moveTo: function moveTo(value) {\n      var newStart = Math.max(min, Math.min(max - viewSize, value));\n\n      if (start !== newStart) {\n        start = newStart;\n        s.emit('update');\n      }\n    },\n\n    /**\n     * Update scroll settings\n     * @param {number} [settings.min]\n     * @param {number} [settings.max]\n     * @param {number} [settings.viewSize]\n     * @emits update\n     */\n    update: function update(settings) {\n      var triggerUpdate = false;\n      var _settings$min = settings.min;\n      min = _settings$min === void 0 ? min : _settings$min;\n      var _settings$max = settings.max;\n      max = _settings$max === void 0 ? max : _settings$max;\n\n      if (settings.viewSize !== undefined && settings.viewSize !== viewSize) {\n        viewSize = settings.viewSize;\n        triggerUpdate = true;\n      } // update scroll to be within the new bounds\n\n\n      var newStart = Math.max(min, Math.min(max - viewSize, start));\n\n      if (start !== newStart) {\n        start = newStart;\n        triggerUpdate = true;\n      }\n\n      if (triggerUpdate) {\n        s.emit('update');\n      }\n    },\n\n    /**\n     * Get the current scroll state\n     * @return {object} with min, max, start & viewSize\n     */\n    getState: function getState() {\n      return {\n        min: min,\n        max: max,\n        start: start,\n        viewSize: viewSize\n      };\n    }\n  };\n  EventEmitter$1.mixin(s);\n  return s;\n}\n\nfunction createOrUpdate(options, oldApi) {\n  var min = options.min || 0;\n  var max = options.max || 0;\n  var viewSize = options.viewSize || 0;\n  var s = oldApi || scrollApi();\n  s.update({\n    min: min,\n    max: max,\n    viewSize: viewSize\n  });\n  return s;\n}\nfunction builder(obj, oldScrollApis) {\n  var scrollApis = {};\n\n  for (var n in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, n)) {\n      scrollApis[n] = createOrUpdate(obj[n], oldScrollApis ? oldScrollApis[n] : null);\n    }\n  }\n\n  return scrollApis;\n}\nfunction getOrCreateScrollApi(v, scrollApis) {\n  if (!scrollApis[v]) {\n    scrollApis[v] = scrollApi();\n  }\n\n  return scrollApis[v];\n}\n\nfunction lessThanOrEqual(value, limit) {\n  return value <= limit;\n}\n\nfunction lessThan(value, limit) {\n  return value < limit;\n}\n\nfunction index(boundaries, point, after) {\n  var i = 0;\n\n  while (i < boundaries.length && point > boundaries[i]) {\n    ++i;\n  }\n\n  if (boundaries[i] === point && after) {\n    ++i;\n  }\n\n  return i;\n}\n\nfunction contains(boundaries, point, minCondition, maxCondition) {\n  var len = boundaries.length;\n\n  for (var i = 1; i < len; i += 2) {\n    if (minCondition(boundaries[i - 1], point) && maxCondition(point, boundaries[i])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction rangeCollection() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var maxCondition;\n  var minCondition;\n  var boundaries = [];\n\n  function fn() {}\n\n  fn.configure = function () {\n    var c = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var _c$includeMax = c.includeMax,\n        includeMax = _c$includeMax === void 0 ? true : _c$includeMax,\n        _c$includeMin = c.includeMin,\n        includeMin = _c$includeMin === void 0 ? true : _c$includeMin;\n    maxCondition = includeMax ? lessThanOrEqual : lessThan;\n    minCondition = includeMin ? lessThanOrEqual : lessThan;\n  };\n\n  fn.add = function (_ref) {\n    var _boundaries;\n\n    var min = _ref.min,\n        max = _ref.max;\n    var i0 = index(boundaries, min);\n    var i1 = index(boundaries, max, true);\n    var args = [i0, i1 - i0];\n\n    if (i0 % 2 === 0) {\n      args.push(min);\n    }\n\n    if (i1 % 2 === 0) {\n      args.push(max);\n    }\n\n    var before = boundaries.join(',');\n\n    (_boundaries = boundaries).splice.apply(_boundaries, args);\n\n    var after = boundaries.join(',');\n    return before !== after;\n  };\n\n  fn.remove = function (_ref2) {\n    var _boundaries2;\n\n    var min = _ref2.min,\n        max = _ref2.max;\n    var i0 = index(boundaries, min);\n    var i1 = index(boundaries, max, true);\n    var args = [i0, i1 - i0];\n\n    if (i0 % 2 === 1) {\n      args.push(min);\n    }\n\n    if (i1 % 2 === 1) {\n      args.push(max);\n    }\n\n    var before = boundaries.join(',');\n\n    (_boundaries2 = boundaries).splice.apply(_boundaries2, args);\n\n    var after = boundaries.join(',');\n    return before !== after;\n  };\n\n  fn.set = function (range) {\n    var before = boundaries.join(',');\n    boundaries = [];\n\n    if (Array.isArray(range)) {\n      range.forEach(fn.add);\n    } else {\n      fn.add(range);\n    }\n\n    var after = boundaries.join(',');\n    return before !== after;\n  };\n\n  fn.clear = function () {\n    var before = boundaries.length > 0;\n    boundaries = [];\n    return before;\n  };\n\n  fn.containsValue = function (value) {\n    return contains(boundaries, value, minCondition, maxCondition);\n  };\n\n  fn.containsRange = function (_ref3) {\n    var min = _ref3.min,\n        max = _ref3.max;\n    var i0 = index(boundaries, min, true);\n    var i1 = index(boundaries, max);\n    return i0 === i1 && i1 % 2 === 1;\n  };\n\n  fn.toggle = function (range) {\n    if (fn.containsRange(range)) {\n      return fn.remove(range);\n    }\n\n    return fn.add(range);\n  };\n\n  fn.ranges = function () {\n    var collection = [];\n\n    for (var i = 1; i < boundaries.length; i += 2) {\n      collection.push({\n        min: boundaries[i - 1],\n        max: boundaries[i]\n      });\n    }\n\n    return collection;\n  };\n\n  fn.configure(config);\n  return fn;\n}\n\nfunction valueCollection() {\n  var values = [];\n\n  function vc() {}\n\n  vc.add = function (value) {\n    if (values.indexOf(value) === -1) {\n      values.push(value);\n      return true;\n    }\n\n    return false;\n  };\n\n  vc.remove = function (value) {\n    var idx = values.indexOf(value);\n\n    if (idx !== -1) {\n      values.splice(idx, 1);\n      return true;\n    }\n\n    return false;\n  };\n\n  vc.contains = function (value) {\n    return values.indexOf(value) !== -1;\n  };\n\n  vc.values = function () {\n    return values.slice();\n  };\n\n  vc.clear = function () {\n    return values = [];\n  };\n\n  vc.toString = function () {\n    return values.join(';');\n  };\n\n  return vc;\n}\n\n/**\n * @typedef {object} brush-config\n * @property {Array<brush-config--ranges>} [ranges] - Range configurations\n */\n\n/**\n * @typedef {object}\n * @alias brush-config--ranges\n */\n\nvar DEFAULT_RANGE_CONFIG = {\n  /**\n   * An identifier that represents the data source of the value\n   * @type {string=}\n   */\n  key: undefined,\n\n  /**\n   * Whether or not the minimum value of a range should be included when determening if a value is brushed.\n   * @type {boolean=} */\n  includeMin: true,\n\n  /**\n   * Whether or not the maximum value of a range should be included when determening if a value is brushed.\n   * @type {boolean=} */\n  includeMax: true\n};\n\nfunction add(_ref) {\n  var items = _ref.items,\n      collection = _ref.collection,\n      vc = _ref.vc;\n  var changedMap = {};\n  var changed = [];\n  var key;\n  var values;\n\n  for (var i = 0, num = items.length; i < num; i++) {\n    key = items[i].key;\n\n    if (!collection[key]) {\n      collection[key] = vc();\n    }\n\n    values = items[i].values || [items[i].value];\n\n    for (var vi = 0; vi < values.length; vi++) {\n      if (collection[key].add(values[vi])) {\n        changedMap[key] = changedMap[key] || [];\n        changedMap[key].push(values[vi]);\n      }\n    }\n  }\n\n  var keys = Object.keys(changedMap);\n\n  for (var _i = 0, _num = keys.length; _i < _num; _i++) {\n    key = keys[_i];\n    changed.push({\n      id: key,\n      values: changedMap[key]\n    });\n  }\n\n  return changed;\n}\n\nfunction remove(_ref2) {\n  var items = _ref2.items,\n      collection = _ref2.collection;\n  var changedMap = {};\n  var changed = [];\n  var key;\n  var values;\n\n  for (var i = 0, num = items.length; i < num; i++) {\n    key = items[i].key;\n\n    if (!collection[key]) {\n      continue;\n    }\n\n    values = items[i].values || [items[i].value];\n\n    for (var vi = 0; vi < values.length; vi++) {\n      if (collection[key].remove(values[vi])) {\n        changedMap[key] = changedMap[key] || [];\n        changedMap[key].push(values[vi]);\n      }\n    }\n  }\n\n  var keys = Object.keys(changedMap);\n\n  for (var _i2 = 0, _num2 = keys.length; _i2 < _num2; _i2++) {\n    key = keys[_i2];\n    changed.push({\n      id: key,\n      values: changedMap[key]\n    });\n  }\n\n  return changed;\n}\n\nfunction collectUnique(items) {\n  var filteredSet = {};\n  var key;\n  var values;\n\n  for (var i = 0, num = items.length; i < num; i++) {\n    key = items[i].key;\n    values = items[i].values || [items[i].value];\n\n    if (!filteredSet[key]) {\n      filteredSet[key] = [];\n    }\n\n    for (var vi = 0; vi < values.length; vi++) {\n      var idx = filteredSet[key].indexOf(values[vi]);\n\n      if (idx === -1) {\n        filteredSet[key].push(values[vi]);\n      }\n    }\n  }\n\n  return filteredSet;\n}\n\nfunction createValueCollection(_ref3) {\n  var key = _ref3.key,\n      collection = _ref3.collection,\n      obj = _ref3.obj,\n      fn = _ref3.fn,\n      value = _ref3.value;\n\n  if (!collection[key]) {\n    collection[key] = fn();\n  }\n\n  obj[key] = obj[key] || [];\n  obj[key].push(value);\n  collection[key].add(value);\n}\n\nfunction toggle(_ref4) {\n  var items = _ref4.items,\n      values = _ref4.values,\n      vc = _ref4.vc;\n  var addedMap = {};\n  var removedMap = {};\n  var added = [];\n  var removed = [];\n  var filteredSet = collectUnique(items);\n  var key;\n  var value;\n  var fs;\n  var setKeys = Object.keys(filteredSet);\n\n  for (var i = 0, num = setKeys.length; i < num; i++) {\n    key = setKeys[i];\n    fs = filteredSet[key];\n\n    for (var k = 0, len = fs.length; k < len; k++) {\n      value = fs[k];\n\n      if (!values[key] || !values[key].contains(value)) {\n        createValueCollection({\n          key: key,\n          value: value,\n          collection: values,\n          obj: addedMap,\n          fn: vc\n        });\n      } else if (values[key] && values[key].contains(value)) {\n        removedMap[key] = removedMap[key] || [];\n        removedMap[key].push(value);\n        values[key].remove(value);\n      }\n    }\n  }\n\n  var addedKeys = Object.keys(addedMap);\n\n  for (var _i3 = 0, _num3 = addedKeys.length; _i3 < _num3; _i3++) {\n    key = addedKeys[_i3];\n    added.push({\n      id: key,\n      values: addedMap[key]\n    });\n  }\n\n  var removedKeys = Object.keys(removedMap);\n\n  for (var _i4 = 0, _num4 = removedKeys.length; _i4 < _num4; _i4++) {\n    key = removedKeys[_i4];\n    removed.push({\n      id: key,\n      values: removedMap[key]\n    });\n  }\n\n  return [added, removed];\n}\n\nfunction diff(old, current) {\n  var changed = [];\n  var keys = Object.keys(old);\n  var key;\n  var changedValues;\n\n  var filterFn = function filterFn(v) {\n    return current[key].indexOf(v) === -1;\n  };\n\n  for (var i = 0, num = keys.length; i < num; i++) {\n    key = keys[i];\n\n    if (!current[key]) {\n      changed.push({\n        id: key,\n        values: old[key]\n      });\n    } else {\n      changedValues = old[key].filter(filterFn);\n\n      if (changedValues.length) {\n        changed.push({\n          id: key,\n          values: changedValues\n        });\n      }\n    }\n  }\n\n  return changed;\n}\n\nfunction set$1(_ref5) {\n  var items = _ref5.items,\n      vCollection = _ref5.vCollection,\n      vc = _ref5.vc;\n  var addedMap = {};\n  var filteredSet = collectUnique(items);\n  var added = [];\n  var removed = [];\n  var key;\n  var oldMap = {};\n  var vcKeys = Object.keys(vCollection);\n\n  for (var i = 0, num = vcKeys.length; i < num; i++) {\n    key = vcKeys[i];\n    oldMap[key] = vCollection[key].values().slice();\n    delete vCollection[key];\n  }\n\n  var createValueCollectionFn = function createValueCollectionFn(value) {\n    if (!vCollection[key] || !vCollection[key].contains(value)) {\n      createValueCollection({\n        key: key,\n        value: value,\n        collection: vCollection,\n        obj: addedMap,\n        fn: vc\n      });\n    }\n  };\n\n  var fsKeys = Object.keys(filteredSet);\n\n  for (var _i5 = 0, _num5 = fsKeys.length; _i5 < _num5; _i5++) {\n    key = fsKeys[_i5];\n    filteredSet[key].forEach(createValueCollectionFn);\n  }\n\n  removed = diff(oldMap, addedMap);\n  added = diff(addedMap, oldMap);\n  return [added, removed];\n}\n\nfunction applyAliases(items, aliases) {\n  if (!Object.keys(aliases).length) {\n    return items;\n  }\n\n  var len = items.length;\n  var its = Array(len);\n\n  for (var i = 0; i < len; i++) {\n    its[i] = items[i].key in aliases ? extend({}, items[i], {\n      key: aliases[items[i].key]\n    }) : items[i];\n  }\n\n  return its;\n}\n\nfunction intercept(handlers, items, aliases) {\n  var its = applyAliases(items, aliases);\n  return handlers && handlers.length ? handlers.reduce(function (value, interceptor) {\n    return interceptor(value);\n  }, its) : its;\n}\n\nfunction toCamelCase(s) {\n  return s.replace(/(-[a-z])/g, function ($1) {\n    return $1.toUpperCase().replace('-', '');\n  });\n}\n\nfunction toSnakeCase(s) {\n  return s.replace(/([A-Z])/g, function ($1) {\n    return \"-\".concat($1.toLowerCase());\n  });\n}\n\nfunction updateRange(items, action, _ref6) {\n  var ranges = _ref6.ranges,\n      interceptors = _ref6.interceptors,\n      rc = _ref6.rc,\n      aliases = _ref6.aliases,\n      rangeConfig = _ref6.rangeConfig;\n  var inter = \"\".concat(action, \"Ranges\");\n  var its = intercept(interceptors[inter], items, aliases);\n  var changed = false;\n  its.forEach(function (item) {\n    var key = item.key;\n\n    if (!ranges[key]) {\n      ranges[key] = rc(rangeConfig.sources[key] || rangeConfig.default);\n    }\n\n    if (action === 'set') {\n      changed = ranges[key][action](item.ranges || item.range) || changed;\n    } else {\n      var rangeValues = item.ranges || [item.range];\n\n      for (var i = 0; i < rangeValues.length; i++) {\n        changed = ranges[key][action](rangeValues[i]) || changed;\n      }\n    }\n  });\n  return changed;\n}\n\nfunction brush() {\n  var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref7$vc = _ref7.vc,\n      vc = _ref7$vc === void 0 ? valueCollection : _ref7$vc,\n      _ref7$rc = _ref7.rc,\n      rc = _ref7$rc === void 0 ? rangeCollection : _ref7$rc;\n\n  var activated = false;\n  var ranges = {};\n  var values = {};\n  var aliases = {};\n  var rangeConfig = {\n    sources: {},\n    default: extend({}, DEFAULT_RANGE_CONFIG)\n  };\n  var interceptors = {\n    addValues: [],\n    removeValues: [],\n    toggleValues: [],\n    setValues: [],\n    addRanges: [],\n    setRanges: [],\n    removeRanges: [],\n    toggleRanges: []\n  };\n\n  var getState = function getState() {\n    var state = {\n      values: {},\n      ranges: {}\n    };\n    Object.keys(values).forEach(function (key) {\n      state.values[key] = values[key].values();\n    });\n    Object.keys(ranges).forEach(function (key) {\n      state.ranges[key] = ranges[key].ranges();\n    });\n    return state;\n  };\n\n  var links = {\n    ls: [],\n    clear: function clear() {\n      this.ls.forEach(function (b) {\n        return b.clear();\n      });\n    },\n    start: function start() {\n      this.ls.forEach(function (b) {\n        return b.start();\n      });\n    },\n    end: function end() {\n      this.ls.forEach(function (b) {\n        return b.end();\n      });\n    },\n    update: function update() {\n      var s = getState();\n      this.ls.forEach(function (b) {\n        return b._state(s);\n      });\n    },\n    updateValues: function updateValues() {\n      var s = getState();\n      this.ls.forEach(function (b) {\n        return b._state({\n          values: s.values\n        });\n      });\n    },\n    updateRanges: function updateRanges() {\n      var s = getState();\n      this.ls.forEach(function (b) {\n        return b._state({\n          ranges: s.ranges\n        });\n      });\n    }\n  };\n  /**\n   * A brush context\n   * @alias brush\n   * @interface\n   */\n\n  var fn = {};\n  /**\n   * Triggered when this brush is activated\n   * @event brush#start\n   * @type {string}\n   */\n\n  /**\n   * Triggered when this brush is updated\n   * @event brush#update\n   * @type {string}\n   * @param {Array<object>} added - The added items\n   * @param {Array<object>} removed - The removed items\n   */\n\n  /**\n   * Triggered when this brush is deactivated\n   * @event brush#end\n   * @type {string}\n   */\n\n  /**\n    * Configure the brush instance.\n    *\n    * @param {brush-config} config\n    * @example\n    * brushInstance.configure({\n    *   ranges: [\n    *     { key: 'some key', includeMax: false },\n    *     { includeMax: true, includeMin: true },\n    *   ]\n    * })\n    */\n\n  fn.configure = function () {\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (Array.isArray(config.ranges) && config.ranges.length) {\n      rangeConfig = {\n        sources: {},\n        default: extend({}, DEFAULT_RANGE_CONFIG)\n      };\n      config.ranges.forEach(function (cfg) {\n        var c = {};\n        Object.keys(DEFAULT_RANGE_CONFIG).filter(function (attr) {\n          return attr !== 'key';\n        }).forEach(function (attr) {\n          c[attr] = typeof cfg[attr] !== 'undefined' ? cfg[attr] : DEFAULT_RANGE_CONFIG[attr];\n        });\n\n        if (typeof cfg.key !== 'undefined') {\n          rangeConfig.sources[cfg.key] = c;\n        } else {\n          rangeConfig.default = c;\n        }\n      });\n      Object.keys(ranges).forEach(function (key) {\n        return ranges[key].configure(rangeConfig.sources[key] || rangeConfig.default);\n      }); // TODO only emit update if config has changed\n\n      fn.emit('update', [], []);\n    }\n  };\n  /**\n   * Link this brush to another brush instance.\n   *\n   * When linked, the `target` will receive updates whenever this brush changes.\n   * @param {brush} target - The brush instance to link to\n   */\n\n\n  fn.link = function (target) {\n    if (fn === target) {\n      throw new Error('Can\\'t link to self');\n    }\n\n    links.ls.push(target);\n\n    target._state(getState());\n  };\n\n  fn._state = function (s) {\n    if (!s) {\n      return getState();\n    }\n\n    if (s.values) {\n      var arr = [];\n      Object.keys(s.values).forEach(function (key) {\n        if (!values[key] || s.values[key].join(';') !== values[key].toString()) {\n          arr.push({\n            key: key,\n            values: s.values[key]\n          });\n        }\n      });\n      Object.keys(values).forEach(function (key) {\n        if (!s.values[key]) {\n          arr.push({\n            key: key,\n            values: []\n          });\n        }\n      });\n\n      if (arr.length) {\n        fn.setValues(arr);\n      }\n    }\n\n    if (s.ranges) {\n      var _arr = [];\n      Object.keys(s.ranges).forEach(function (key) {\n        if (!ranges[key] || s.ranges[key].join(';') !== ranges[key].toString()) {\n          _arr.push({\n            key: key,\n            ranges: s.ranges[key]\n          });\n        }\n      });\n      Object.keys(ranges).forEach(function (key) {\n        if (!s.ranges[key]) {\n          _arr.push({\n            key: key,\n            ranges: []\n          });\n        }\n      });\n\n      if (_arr.length) {\n        fn.setRanges(_arr);\n      }\n    }\n\n    return undefined;\n  };\n  /**\n   * Starts this brush context\n   *\n   * Starts this brush context and emits a 'start' event if it is not already started.\n   * @emits brush#start\n   */\n\n\n  fn.start = function () {\n    if (!activated) {\n      activated = true;\n      fn.emit('start');\n      links.start();\n    }\n  };\n  /**\n   * Ends this brush context\n   *\n   * Ends this brush context and emits an 'end' event if it is not already ended.\n   * @emits brush#end\n   */\n\n\n  fn.end = function () {\n    if (!activated) {\n      return;\n    }\n\n    activated = false;\n    ranges = {};\n    values = {};\n    fn.emit('end');\n    links.end();\n  };\n  /**\n   * Checks if this brush is activated\n   *\n   * Returns true if started, false otherwise\n   * @return {boolean}\n   */\n\n\n  fn.isActive = function () {\n    return activated;\n  };\n  /**\n   * Clears this brush context\n   */\n\n\n  fn.clear = function () {\n    var removed = fn.brushes().filter(function (b) {\n      return b.type === 'value' && b.brush.values().length;\n    }).map(function (b) {\n      return {\n        id: b.id,\n        values: b.brush.values()\n      };\n    });\n    var hasChanged = Object.keys(ranges).length > 0 || removed.length;\n    ranges = {};\n    values = {};\n\n    if (hasChanged) {\n      fn.emit('update', [], removed); // TODO - do not emit update if state hasn't changed\n\n      links.clear();\n    }\n  };\n  /**\n   * Returns all brushes within this context\n   * @return {object}\n   */\n\n\n  fn.brushes = function () {\n    var result = [];\n    result = result.concat(Object.keys(ranges).map(function (key) {\n      return {\n        type: 'range',\n        id: key,\n        brush: ranges[key]\n      };\n    }));\n    result = result.concat(Object.keys(values).map(function (key) {\n      return {\n        type: 'value',\n        id: key,\n        brush: values[key]\n      };\n    }));\n    return result;\n  };\n  /**\n   * Adds a primitive value to this brush context\n   *\n   * If this brush context is not started, a 'start' event is emitted.\n   * If the state of the brush changes, ie. if the added value does not already exist, an 'update' event is emitted.\n   *\n   * @param {string} key  An identifier that represents the data source of the value\n   * @param {string|number} value The value to add\n   * @emits brush#start\n   * @emits brush#update\n   * @example\n   * brush.addValue('countries', 'Sweden');\n   * brush.addValue('/qHyperCube/qDimensionInfo/0', 3);\n   */\n\n\n  fn.addValue = function (key, value) {\n    fn.addValues([{\n      key: key,\n      value: value\n    }]);\n  };\n  /**\n   * @param {object[]} items Items to add\n   */\n\n\n  fn.addValues = function (items) {\n    var its = intercept(interceptors.addValues, items, aliases);\n    var added = add({\n      vc: vc,\n      collection: values,\n      items: its\n    });\n    fn.emit('add-values', its);\n\n    if (added.length) {\n      if (!activated) {\n        activated = true;\n        fn.emit('start');\n      }\n\n      fn.emit('update', added, []);\n      links.updateValues();\n    }\n  };\n  /**\n   * @param {object[]} items Items to set\n   */\n\n\n  fn.setValues = function (items) {\n    var its = intercept(interceptors.setValues, items, aliases);\n    var changed = set$1({\n      items: its,\n      vCollection: values,\n      vc: vc\n    });\n    fn.emit('set-values', its);\n\n    if (changed[0].length > 0 || changed[1].length > 0) {\n      if (!activated) {\n        activated = true;\n        fn.emit('start');\n      }\n\n      fn.emit('update', changed[0], changed[1]);\n      links.updateValues();\n    }\n  };\n  /**\n   * Removes a primitive values from this brush context\n   *\n   * If the state of the brush changes, ie. if the removed value does exist, an 'update' event is emitted.\n   *\n   * @param  {string} key  An identifier that represents the data source of the value\n   * @param  {string|number} value The value to remove\n   * @example\n   * brush.removeValue('countries', 'Sweden');\n   */\n\n\n  fn.removeValue = function (key, value) {\n    fn.removeValues([{\n      key: key,\n      value: value\n    }]);\n  };\n  /**\n   * @param {object[]} items Items to remove\n   */\n\n\n  fn.removeValues = function (items) {\n    var its = intercept(interceptors.removeValues, items, aliases);\n    var removed = remove({\n      collection: values,\n      items: its\n    });\n    fn.emit('remove-values', its);\n\n    if (removed.length) {\n      fn.emit('update', [], removed);\n      links.updateValues(); // TODO - emit 'end' event if there are no remaining active brushes\n    }\n  };\n  /**\n   * Add and remove values in a single operation\n   * almost the same as calling addValues and removeValues but only triggers one 'update' event\n   *\n   * If the state of the brush changes, an 'update' event is emitted.\n   *\n   * @param {object[]} addItems Items to add\n   * @param {object[]} removeItems Items to remove\n   */\n\n\n  fn.addAndRemoveValues = function (addItems, removeItems) {\n    var addIts = intercept(interceptors.addValues, addItems, aliases);\n    var removeIts = intercept(interceptors.removeValues, removeItems, aliases);\n    var added = add({\n      vc: vc,\n      collection: values,\n      items: addIts\n    });\n    var removed = remove({\n      collection: values,\n      items: removeIts\n    });\n    fn.emit('add-values', addIts);\n    fn.emit('remove-values', removeIts);\n\n    if (added.length || removed.length) {\n      if (!activated) {\n        activated = true;\n        fn.emit('start');\n      }\n\n      fn.emit('update', added, removed);\n      links.updateValues();\n    }\n  };\n  /**\n   * Toggles a primitive value in this brush context\n   *\n   * If the given value exist in this brush context, it will be removed. If it does not exist it will be added.\n   *\n   * @param  {string} key  An identifier that represents the data source of the value\n   * @param  {string|number} value The value to toggle\n   * @example\n   * brush.toggleValue('countries', 'Sweden');\n   */\n\n\n  fn.toggleValue = function (key, value) {\n    fn.toggleValues([{\n      key: key,\n      value: value\n    }]);\n  };\n  /**\n   * @param {object[]} items Items to toggle\n   */\n\n\n  fn.toggleValues = function (items) {\n    var its = intercept(interceptors.toggleValues, items, aliases);\n    var toggled = toggle({\n      items: its,\n      values: values,\n      vc: vc\n    });\n    fn.emit('toggle-values', its);\n\n    if (toggled[0].length > 0 || toggled[1].length > 0) {\n      if (!activated) {\n        activated = true;\n        fn.emit('start');\n      }\n\n      fn.emit('update', toggled[0], toggled[1]);\n      links.updateValues();\n    }\n  };\n  /**\n   * Checks if a certain value exists in this brush context\n   *\n   * Returns true if the values exists for the provided key, returns false otherwise.\n   *\n   * @param  {string} key  An identifier that represents the data source of the value\n   * @param  {string|number} value The value to check for\n   * @return {boolean}\n   * @example\n   * brush.addValue('countries', 'Sweden');\n   * brush.containsValue('countries', 'Sweden'); // true\n   * brush.toggleValue('countries', 'Sweden'); // remove 'Sweden'\n   * brush.containsValue('countries', 'Sweden'); // false\n   */\n\n\n  fn.containsValue = function (key, value) {\n    var k = aliases[key] || key;\n\n    if (!values[k]) {\n      return false;\n    }\n\n    return values[k].contains(value);\n  };\n  /**\n   * Adds a numeric range to this brush context\n   *\n   * @param {string} key - An identifier that represents the data source of the range\n   * @param {object} range - The range to add to this brush\n   * @param {number} range.min - Min value of the range\n   * @param {number} range.max - Max value of the range\n   * @example\n   * brush.addRange('Sales', { min: 20, max: 50 });\n   */\n\n\n  fn.addRange = function (key, range) {\n    fn.addRanges([{\n      key: key,\n      range: range\n    }]);\n  };\n  /**\n   * @see {brush.addRange}\n   * @param {object[]} items - Items containing the ranges to remove\n   * @param {string} items[].key\n   * @param {object} items[].range\n   */\n\n\n  fn.addRanges = function (items) {\n    var changed = updateRange(items, 'add', {\n      ranges: ranges,\n      rc: rc,\n      interceptors: interceptors,\n      aliases: aliases,\n      rangeConfig: rangeConfig\n    });\n\n    if (!changed) {\n      return;\n    }\n\n    if (!activated) {\n      activated = true;\n      fn.emit('start');\n    }\n\n    fn.emit('update', [], []);\n    links.updateRanges();\n  };\n  /**\n   * Removes a numeric range from this brush context\n   *\n   * @param {string} key - An identifier that represents the data source of the range\n   * @param {object} range - The range to remove from this brush\n   * @param {number} range.min - Min value of the range\n   * @param {number} range.max - Max value of the range\n   */\n\n\n  fn.removeRange = function (key, range) {\n    fn.removeRanges([{\n      key: key,\n      range: range\n    }]);\n  };\n  /**\n   * @see {brush.removeRange}\n   * @param {object[]} items - Items containing the ranges to remove\n   */\n\n\n  fn.removeRanges = function (items) {\n    var changed = updateRange(items, 'remove', {\n      ranges: ranges,\n      rc: rc,\n      interceptors: interceptors,\n      aliases: aliases,\n      rangeConfig: rangeConfig\n    });\n\n    if (!changed) {\n      return;\n    }\n\n    if (!activated) {\n      activated = true;\n      fn.emit('start');\n    }\n\n    fn.emit('update', [], []);\n    links.updateRanges();\n  };\n  /**\n   * Sets a numeric range to this brush context\n   *\n   * Overwrites any active ranges identified by `key`\n   *\n   * @param {string} key - An identifier that represents the data source of the range\n   * @param {object} range - The range to set on this brush\n   * @param {number} range.min - Min value of the range\n   * @param {number} range.max - Max value of the range\n   */\n\n\n  fn.setRange = function (key, range) {\n    fn.setRanges([{\n      key: key,\n      range: range\n    }]);\n  };\n  /**\n   * @see {brush.setRange}\n   * @param {object[]} items - Items containing the ranges to set\n   */\n\n\n  fn.setRanges = function (items) {\n    var changed = updateRange(items, 'set', {\n      ranges: ranges,\n      rc: rc,\n      interceptors: interceptors,\n      aliases: aliases,\n      rangeConfig: rangeConfig\n    });\n\n    if (!changed) {\n      return;\n    }\n\n    if (!activated) {\n      activated = true;\n      fn.emit('start');\n    }\n\n    fn.emit('update', [], []);\n    links.updateRanges();\n  };\n  /**\n   * Toggles a numeric range in this brush context\n   *\n   * Removes the range if it's already contained within the given identifier,\n   * otherwise the given range is added to the brush.\n   *\n   * @param {string} key - An identifier that represents the data source of the range\n   * @param {object} range - The range to toggle in this brush\n   * @param {number} range.min - Min value of the range\n   * @param {number} range.max - Max value of the range\n   */\n\n\n  fn.toggleRange = function (key, range) {\n    fn.toggleRanges([{\n      key: key,\n      range: range\n    }]);\n  };\n  /**\n   * @see {brush.toggleRange}\n   * @param {object[]} items - Items containing the ranges to toggle\n   */\n\n\n  fn.toggleRanges = function (items) {\n    var changed = updateRange(items, 'toggle', {\n      ranges: ranges,\n      rc: rc,\n      interceptors: interceptors,\n      aliases: aliases,\n      rangeConfig: rangeConfig\n    });\n\n    if (!changed) {\n      return;\n    }\n\n    if (!activated) {\n      activated = true;\n      fn.emit('start');\n    }\n\n    fn.emit('update', [], []);\n    links.updateRanges();\n  };\n  /**\n   * Checks if a value is contained within a range in this brush context\n   *\n   * Returns true if the values exists for the provided key, returns false otherwise.\n   *\n   * @param  {string} key - An identifier that represents the data source of the value\n   * @param  {number} value - The value to check for\n   * @return {boolean}\n   * @example\n   * brush.addRange('Sales', { min: 10, max: 50 });\n   * brush.containsRangeValue('Sales', 30); // true\n   * brush.containsRangeValue('Sales', 5); // false\n   */\n\n\n  fn.containsRangeValue = function (key, value) {\n    var k = aliases[key] || key;\n\n    if (!ranges[k]) {\n      return false;\n    }\n\n    return ranges[k].containsValue(value);\n  };\n  /**\n   * Checks if a range segment is contained within this brush context\n   *\n   * Returns true if the range segment exists for the provided key, returns false otherwise.\n   *\n   * @param {string} key - An identifier that represents the data source of the value\n   * @param {object} range - The range to check for\n   * @param {number} range.min - Min value of the range\n   * @param {number} range.max - Max value of the range\n   * @return {boolean}\n   * @example\n   * brush.addRange('Sales', { min: 10, max: 50 });\n   * brush.containsRange('Sales', { min: 15, max: 20 }); // true - the range segment is fully contained within [10, 50]\n   * brush.containsRange('Sales', { min: 5, max: 20 }); // false - part of the range segment is outside [10, 50]\n   * brush.containsRange('Sales', { min: 30, max: 80 }); // false - part of the range segment is outside [10, 50]\n   */\n\n\n  fn.containsRange = function (key, range) {\n    var k = aliases[key] || key;\n\n    if (!ranges[k]) {\n      return false;\n    }\n\n    return ranges[k].containsRange(range);\n  };\n\n  fn.containsMappedData = function (d, props, mode) {\n    var status = [];\n    var keys = Object.keys(d);\n    var key;\n    var item;\n    var source;\n    var value;\n\n    for (var i = 0, num = keys.length; i < num; i++) {\n      key = keys[i];\n\n      if (key === 'value') {\n        item = d;\n        status[i] = {\n          key: '',\n          i: i,\n          bool: false\n        };\n      } else if (key === 'source') {\n        continue;\n      } else {\n        item = d[key];\n        status[i] = {\n          key: key,\n          i: i,\n          bool: false\n        };\n      }\n\n      source = item.source && item.source.field;\n\n      if (typeof source === 'undefined') {\n        continue;\n      }\n\n      if (typeof item.source.key !== 'undefined') {\n        source = \"\".concat(item.source.key, \"/\").concat(source);\n      }\n\n      if (source in aliases) {\n        source = aliases[source];\n      }\n\n      value = item.value;\n\n      if (ranges[source]) {\n        status[i].bool = Array.isArray(value) ? ranges[source].containsRange({\n          min: value[0],\n          max: value[1]\n        }) : ranges[source].containsValue(value);\n      } else if (values[source] && values[source].contains(value)) {\n        status[i].bool = true;\n      }\n    }\n\n    if (props) {\n      status = status.filter(function (b) {\n        return props.indexOf(b.key) !== -1;\n      });\n\n      if (mode === 'and') {\n        return !!status.length && !status.some(function (s) {\n          return s.bool === false;\n        });\n      }\n\n      if (mode === 'xor') {\n        return !!status.length && status.some(function (s) {\n          return s.bool;\n        }) && status.some(function (s) {\n          return s.bool === false;\n        });\n      } // !mode || mode === 'or'\n\n\n      return status.some(function (s) {\n        return s.bool;\n      });\n    }\n\n    return status.some(function (s) {\n      return s.bool;\n    });\n  };\n  /**\n   * Adds an event interceptor\n   *\n   * @param {string} name Name of the event to intercept\n   * @param {function} ic Handler to call before event is triggered\n   * @example\n   * brush.intercept('add-values', items => {\n   *  console.log('about to add the following items', items);\n   *  return items;\n   * });\n   */\n\n\n  fn.intercept = function (name, ic) {\n    var s = toCamelCase(name);\n\n    if (!interceptors[s]) {\n      return;\n    }\n\n    interceptors[s].push(ic);\n  };\n  /**\n   * Removes an interceptor\n   *\n   * @param {string} name Name of the event to intercept\n   * @param {function} ic Handler to remove\n   */\n\n\n  fn.removeInterceptor = function (name, ic) {\n    var s = toCamelCase(name);\n\n    if (!interceptors[s]) {\n      return;\n    }\n\n    var idx = interceptors[s].indexOf(ic);\n\n    if (idx !== -1) {\n      interceptors[s].splice(idx, 1);\n    }\n  };\n  /**\n   * Removes all interceptors\n   *\n   * @param {string} [name] Name of the event to remove interceptors for. If not provided, removes all interceptors.\n   */\n\n\n  fn.removeAllInterceptors = function (name) {\n    var toRemove = [];\n\n    if (name) {\n      var s = toCamelCase(name);\n\n      if (interceptors[s] && interceptors[s].length) {\n        toRemove.push({\n          name: name,\n          handlers: interceptors[s]\n        });\n      }\n    } else {\n      Object.keys(interceptors).forEach(function (n) {\n        if (interceptors[n].length) {\n          toRemove.push({\n            name: toSnakeCase(n),\n            handlers: interceptors[n]\n          });\n        }\n      });\n    }\n\n    toRemove.forEach(function (ic) {\n      var interceptorHandlers = ic.handlers.slice();\n      interceptorHandlers.forEach(function (handler) {\n        return fn.removeInterceptor(ic.name, handler);\n      });\n    });\n  };\n  /**\n   * Adds an alias to the given key\n   *\n   * @param {string} key - Value to be replaced\n   * @param {string} alias - Value to replace key with\n   * @example\n   * brush.addKeyAlias('BadFieldName', 'Region');\n   * brush.addValue('BadFieldName', 'Sweden'); // 'BadFieldName' will be stored as 'Region'\n   * brush.containsValue('Region', 'Sweden'); // true\n   * brush.containsValue('BadFieldName', 'Sweden'); // true\n   */\n\n\n  fn.addKeyAlias = function (key, alias) {\n    aliases[key] = alias;\n  };\n  /**\n   * Removes an alias\n   *\n   * This will only remove the key to alias mapping for new manipulations of the brush,\n   * no changes will be made to the current state of this brush.\n   *\n   * @param {string} key - Value to remove as alias\n   * @example\n   * brush.removeKeyAlias('BadFieldName');\n   */\n\n\n  fn.removeKeyAlias = function (key) {\n    delete aliases[key];\n  };\n\n  EventEmitter$1.mixin(fn);\n  return fn;\n}\n\nvar reg = registryFactory();\n\nfunction cubicInOut(t) {\n  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;\n}\n\nvar tau$2 = 2 * Math.PI,\n    amplitude = 1,\n    period = 0.3;\n\nvar elasticOut = (function custom(a, p) {\n  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau$2);\n\n  function elasticOut(t) {\n    return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);\n  }\n\n  elasticOut.amplitude = function(a) { return custom(a, p * tau$2); };\n  elasticOut.period = function(p) { return custom(a, p); };\n\n  return elasticOut;\n})(amplitude, period);\n\n/* globals window */\n\nfunction nodeId(node, i) {\n  if (node.data) {\n    return node.data.value;\n  }\n\n  if (node.type === 'text') {\n    return node.text;\n  }\n\n  return i;\n}\n\nfunction tween(_ref, _ref2, config) {\n  var old = _ref.old,\n      current = _ref.current;\n  var renderer = _ref2.renderer;\n  var ticker; // let staticNodes = [];\n\n  var toBeUpdated = [];\n  var entered = {\n    nodes: [],\n    ips: []\n  };\n  var exited = {\n    nodes: [],\n    ips: []\n  };\n  var updated = {\n    nodes: [],\n    ips: []\n  };\n  var stages = [];\n  var trackBy = config.trackBy || nodeId;\n  var tweener = {\n    start: function start() {\n      var ids = {};\n      old.forEach(function (node, i) {\n        var id = trackBy(node, i);\n        ids[id] = node;\n      });\n      current.forEach(function (node, i) {\n        var id = trackBy(node, i);\n\n        if (ids[id]) {\n          updated.ips.push(interpolateObject(ids[id], node));\n          updated.nodes.push(node);\n          toBeUpdated.push(ids[id]);\n          ids[id] = false;\n        } else {\n          entered.nodes.push(node);\n          entered.ips.push(interpolateObject({\n            r: 0.001,\n            opacity: 0\n          }, node));\n        }\n      });\n      Object.keys(ids).forEach(function (key) {\n        if (ids[key]) {\n          exited.nodes.push(ids[key]);\n          exited.ips.push(interpolateObject(ids[key], extend({}, ids[key], {\n            r: 0.0001,\n            opacity: 0\n          })));\n        }\n      });\n\n      if (exited.ips.length) {\n        stages.push({\n          easing: cubicInOut,\n          duration: 200,\n          tweens: exited.ips,\n          nodes: [].concat(toBeUpdated)\n        });\n      }\n\n      if (updated.ips.length) {\n        stages.push({\n          easing: cubicInOut,\n          duration: 400,\n          tweens: updated.ips,\n          nodes: []\n        });\n      }\n\n      if (entered.ips.length) {\n        stages.push({\n          easing: elasticOut,\n          duration: 1200,\n          tweens: entered.ips,\n          nodes: _toConsumableArray$1(updated.nodes)\n        });\n      } // console.log(stages);\n\n\n      if (stages.length) {\n        stages[0].started = Date.now();\n\n        if (typeof window !== 'undefined') {\n          ticker = window.requestAnimationFrame(tweener.tick);\n        }\n      }\n    },\n    tick: function tick() {\n      var currentStage = stages[0];\n\n      if (!currentStage) {\n        tweener.stop();\n      }\n\n      if (!currentStage.started) {\n        currentStage.started = Date.now();\n      }\n\n      var t = (Date.now() - currentStage.started) / currentStage.duration;\n      var currentNodes = [];\n      var tweenedNodes = currentStage.tweens.map(function (ip) {\n        return ip(currentStage.easing(Math.min(1, t)));\n      });\n      currentNodes.push.apply(currentNodes, _toConsumableArray$1(tweenedNodes));\n      currentNodes.push.apply(currentNodes, _toConsumableArray$1(currentStage.nodes)); // currentNodes.push(...staticNodes);\n      // stages.slice(1).forEach(stage => currentNodes.push(...stage.nodes));\n\n      renderer.render(currentNodes);\n\n      if (t >= 1) {\n        // staticNodes.push(...currentStage.nodes);\n        stages.shift();\n\n        if (!stages.length) {\n          tweener.stop();\n        }\n      }\n\n      if (ticker) {\n        ticker = window.requestAnimationFrame(tweener.tick);\n      }\n    },\n    stop: function stop() {\n      if (ticker) {\n        window.cancelAnimationFrame(ticker);\n        ticker = false;\n      }\n    }\n  };\n  return tweener;\n}\n\nvar GLOBAL_DEFAULTS = {\n  fontFamily: 'Arial',\n  fontSize: '13px',\n  color: '#595959',\n  backgroundColor: '#ffffff',\n  stroke: '#000000',\n  strokeWidth: 0,\n  $fill: '#333333'\n};\nvar REF_RX = /^\\$/;\n\nfunction isPrimitive(x) {\n  var type = _typeof(x);\n\n  return type !== 'object' && type !== 'function' && type !== 'undefined';\n}\n/**\n * @callback datum-accessor\n * @param {datum-extract} d\n */\n\n/**\n * @typedef {object} datum-config\n * @property {string} [scale]\n * @property {datum-accessor} fn\n * @property {string} ref - A reference to a datum-extract property\n */\n\n/**\n * @typedef {string|datum-config|datum-accessor} datum-string\n */\n\n/**\n * @typedef {number|datum-config|datum-accessor} datum-number\n */\n\n/**\n * @typedef {boolean|datum-config|datum-accessor} datum-boolean\n */\n\n/**\n * Normalizes property settings\n *\n * @ignore\n * @export\n * @param {any} settings\n * @param {any} defaults\n * @param {any} chart\n * @returns {any}\n */\n\n\nfunction normalizeSettings(settings, defaults, chart) {\n  var composition = extend({}, settings);\n  var defs = extend({}, defaults);\n  Object.keys(composition).forEach(function (key) {\n    defs[key] = {};\n    var v = composition[key];\n\n    var vType = _typeof(v);\n\n    if (typeof v === 'function') {\n      defs[key].fn = v;\n    } else if (isPrimitive(v)) {\n      var defaultValue = defaults[key];\n\n      if (typeof defaultValue === 'string' && REF_RX.test(defaultValue)) {\n        defaultValue = GLOBAL_DEFAULTS[defaultValue];\n      }\n\n      var defaultType = _typeof(defaultValue);\n\n      if (defaultType === 'undefined') {\n        // if property has no default, assign provided value\n        defs[key] = v;\n      } else {\n        // assign provided value if it's of same type as default, otherwise use default\n        defs[key] = defaultType === vType ? v : defaultValue;\n      }\n    } else if (v && _typeof(v) === 'object') {\n      if (typeof v.fn === 'function') {\n        defs[key].fn = v.fn;\n      }\n\n      if (typeof v.scale !== 'undefined') {\n        defs[key].scale = chart.scale(v.scale);\n      }\n\n      if (typeof v.ref === 'string') {\n        defs[key].ref = v.ref;\n      }\n    }\n  });\n  Object.keys(defaults).forEach(function (key) {\n    if (key in composition) {\n      // don't process same props again\n      return;\n    }\n\n    var v = defaults[key];\n\n    var defaultType = _typeof(v);\n\n    if (defaultType === 'string' && REF_RX.test(v)) {\n      defs[key] = GLOBAL_DEFAULTS[v];\n    } else {\n      defs[key] = v;\n    }\n  });\n  return defs;\n}\nfunction resolveForItem(context, normalized, idx) {\n  var ret = {};\n  var keys = Object.keys(normalized);\n  var len = keys.length;\n  var fallbackData = context.datum;\n  var datum = context.datum;\n\n  for (var i = 0; i < len; i++) {\n    var key = keys[i];\n    var normalizedProp = normalized[key];\n    var exists = _typeof(datum) === 'object' && typeof normalizedProp !== 'undefined';\n    var hasExplicitDataProp = exists && typeof normalizedProp.ref === 'string';\n    var hasImplicitDataProp = exists && key in datum;\n    var propData = hasExplicitDataProp ? datum[normalizedProp.ref] : hasImplicitDataProp ? datum[key] : fallbackData; // eslint-disable-line\n\n    if (isPrimitive(normalizedProp)) {\n      ret[key] = normalizedProp;\n    } else if (exists && normalizedProp.fn) {\n      // callback function\n      if (normalizedProp.scale) {\n        context.scale = normalizedProp.scale;\n      }\n\n      ret[key] = normalizedProp.fn.call(null, context, idx);\n    } else if (exists && normalizedProp.scale && propData) {\n      ret[key] = normalizedProp.scale(propData.value);\n\n      if (normalizedProp.scale.bandwidth) {\n        ret[key] += normalizedProp.scale.bandwidth() / 2;\n      }\n    } else if (hasExplicitDataProp && propData) {\n      ret[key] = propData.value;\n    } else if (normalizedProp.fn) {\n      ret[key] = normalizedProp.fn.call(null, context, idx);\n    } else {\n      ret[key] = normalizedProp;\n    }\n  }\n\n  return ret;\n}\n\nfunction updateScaleSize(object, path, size) {\n  var o = object[path];\n\n  if (o && o.scale && o.scale.pxScale) {\n    o.scale = o.scale.pxScale(size);\n  } else if (o && o.pxScale) {\n    object[path] = o.pxScale(size);\n  }\n}\nfunction scaleWithSize(scale, size) {\n  return scale.pxScale ? scale.pxScale(size) : scale;\n}\n\nvar externals = {\n  normalizeSettings: normalizeSettings,\n  resolveForItem: resolveForItem,\n  updateScaleSize: updateScaleSize\n};\nfunction settingsResolver (resources) {\n  var deps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : externals;\n  var cache = {};\n\n  function resolve(_ref) {\n    var data = _ref.data,\n        settings = _ref.settings,\n        _ref$defaults = _ref.defaults,\n        defaults = _ref$defaults === void 0 ? {} : _ref$defaults,\n        scaled = _ref.scaled;\n    var norm = cache.norm = deps.normalizeSettings(settings, defaults, resources.chart);\n    var res = {\n      scale: resources.chart.scale,\n      formatter: resources.chart.formatter\n    };\n\n    if (scaled) {\n      Object.keys(scaled).forEach(function (key) {\n        if (norm[key]) {\n          deps.updateScaleSize(norm, key, scaled[key]);\n        }\n      });\n    }\n\n    var resolved = [];\n\n    if (data && Array.isArray(data.items)) {\n      var context;\n\n      for (var i = 0, len = data.items.length; i < len; i++) {\n        context = {\n          datum: data.items[i],\n          data: data,\n          resources: res\n        };\n        var obj = deps.resolveForItem(context, cache.norm, i);\n        obj.data = data.items[i];\n        resolved.push(obj);\n      }\n    } else {\n      var _context = {\n        data: data,\n        resources: res\n      };\n\n      var _obj = deps.resolveForItem(_context, cache.norm, -1);\n\n      return {\n        settings: cache.norm,\n        item: _obj\n      };\n    }\n\n    return {\n      settings: cache.norm,\n      items: resolved\n    };\n  }\n\n  return {\n    resolve: resolve\n  };\n}\n\n/**\n * Flatten the array of nodes by removing any containers as they do not support styling, thus unable to brush them.\n * @param {array} nodes\n * @ignore\n */\n\nfunction reduceToLeafNodes() {\n  var nodes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return nodes.reduce(function (ary, node) {\n    if (Array.isArray(node.children)) {\n      ary.push.apply(ary, _toConsumableArray$1(reduceToLeafNodes(node.children)));\n      return ary;\n    }\n\n    ary.push(node);\n    return ary;\n  }, []);\n}\nfunction styler(obj, _ref) {\n  var context = _ref.context,\n      data = _ref.data,\n      style = _ref.style,\n      filter = _ref.filter,\n      mode = _ref.mode;\n  var brusher = obj.chart.brush(context);\n  var dataProps = data;\n  var active = style.active || {};\n  var inactive = style.inactive || {};\n  var styleProps = [];\n  Object.keys(active).forEach(function (key) {\n    styleProps.push(key);\n  });\n  Object.keys(inactive).forEach(function (key) {\n    if (styleProps.indexOf(key) === -1) {\n      styleProps.push(key);\n    }\n  });\n  var activeNodes = [];\n  var globalActivation = false; // track when we need to loop through all nodes, not just the active ones\n\n  var getNodes = function getNodes() {\n    var nodes = reduceToLeafNodes(obj.nodes);\n\n    if (typeof filter === 'function') {\n      nodes = nodes.filter(filter);\n    }\n\n    return nodes;\n  };\n\n  var update = function update() {\n    // TODO - render nodes only once, i.e. don't render for each brush, update nodes for all brushes and then render\n    var nodes = getNodes();\n    var len = nodes.length;\n    var nodeData;\n    var globalChanged = false;\n\n    var _loop = function _loop(i) {\n      // TODO - update only added and removed nodes\n      nodeData = nodes[i].data;\n\n      if (!nodeData) {\n        return \"continue\";\n      }\n\n      if (!nodes[i].__style) {\n        nodes[i].__style = {};\n        styleProps.forEach(function (s) {\n          nodes[i].__style[s] = nodes[i][s]; // store original value\n        });\n      }\n\n      var isActive = brusher.containsMappedData(nodeData, dataProps, mode);\n      var activeIdx = activeNodes.indexOf(nodes[i]);\n      var changed = false;\n\n      if (isActive && activeIdx === -1) {\n        // activated\n        activeNodes.push(nodes[i]);\n        changed = true;\n      } else if (!isActive && activeIdx !== -1) {\n        // was active\n        activeNodes.splice(activeIdx, 1);\n        changed = true;\n      }\n\n      if (changed || globalActivation) {\n        var original = extend({}, nodes[i], nodes[i].__style);\n        styleProps.forEach(function (s) {\n          if (isActive && s in active) {\n            nodes[i][s] = typeof active[s] === 'function' ? active[s].call(null, original) : active[s];\n          } else if (!isActive && s in inactive) {\n            nodes[i][s] = typeof inactive[s] === 'function' ? inactive[s].call(null, original) : inactive[s];\n          } else {\n            nodes[i][s] = nodes[i].__style[s];\n          }\n        });\n        globalChanged = true;\n      }\n    };\n\n    for (var i = 0; i < len; i++) {\n      var _ret = _loop(i);\n\n      if (_ret === \"continue\") continue;\n    }\n\n    globalActivation = false;\n    return globalChanged;\n  };\n\n  var onStart = function onStart() {\n    var nodes = getNodes();\n    var len = nodes.length;\n\n    var _loop2 = function _loop2(i) {\n      if (!nodes[i].data) {\n        return \"continue\";\n      }\n\n      nodes[i].__style = nodes[i].__style || {};\n      styleProps.forEach(function (s) {\n        nodes[i].__style[s] = nodes[i][s]; // store original value\n\n        if (s in inactive) {\n          nodes[i][s] = typeof inactive[s] === 'function' ? inactive[s].call(null, nodes[i]) : inactive[s];\n        }\n      });\n    };\n\n    for (var i = 0; i < len; i++) {\n      var _ret2 = _loop2(i);\n\n      if (_ret2 === \"continue\") continue;\n    }\n\n    globalActivation = true;\n    activeNodes.length = 0;\n    obj.renderer.render(obj.nodes);\n  };\n\n  var onEnd = function onEnd() {\n    var nodes = getNodes();\n    var len = nodes.length;\n\n    var _loop3 = function _loop3(i) {\n      if (nodes[i].__style) {\n        Object.keys(nodes[i].__style).forEach(function (s) {\n          nodes[i][s] = nodes[i].__style[s];\n        });\n        nodes[i].__style = undefined;\n      }\n    };\n\n    for (var i = 0; i < len; i++) {\n      _loop3(i);\n    }\n\n    activeNodes.length = 0;\n    obj.renderer.render(obj.nodes);\n  };\n\n  var onUpdate = function onUpdate()\n  /* added, removed */\n  {\n    var changed = update();\n\n    if (changed) {\n      obj.renderer.render(obj.nodes);\n    }\n  };\n\n  var externalUpdate = function externalUpdate() {\n    activeNodes.length = 0;\n    globalActivation = true;\n    update();\n  };\n\n  brusher.on('start', onStart);\n  brusher.on('end', onEnd);\n  brusher.on('update', onUpdate);\n\n  function cleanUp() {\n    brusher.removeListener('start', onStart);\n    brusher.removeListener('end', onEnd);\n    brusher.removeListener('update', onUpdate);\n  }\n\n  return {\n    isActive: function isActive() {\n      return brusher.isActive();\n    },\n    update: externalUpdate,\n    cleanUp: cleanUp\n  };\n}\nfunction brushDataPoints(_ref2) {\n  var dataPoints = _ref2.dataPoints,\n      action = _ref2.action,\n      chart = _ref2.chart,\n      trigger = _ref2.trigger;\n\n  if (!trigger) {\n    return;\n  }\n\n  var dataProps = trigger.data || [''];\n  var rangeBrush = {\n    items: [],\n    actionFn: 'toggleRanges'\n  };\n  var valueBrush = {\n    items: [],\n    actionFn: 'toggleValues'\n  };\n\n  if (['add', 'remove', 'set', 'toggle'].indexOf(action) !== -1) {\n    rangeBrush.actionFn = \"\".concat(action, \"Ranges\");\n    valueBrush.actionFn = \"\".concat(action, \"Values\");\n  }\n\n  var _loop4 = function _loop4(i) {\n    var dataPoint = dataPoints[i];\n\n    if (!dataPoint) {\n      return \"continue\";\n    }\n\n    dataProps.forEach(function (p) {\n      var d = dataPoint && !p ? dataPoint : dataPoint[p];\n\n      if (d) {\n        var it = {\n          key: d.source.field\n        };\n\n        if (typeof d.source.key !== 'undefined') {\n          it.key = \"\".concat(d.source.key, \"/\").concat(d.source.field);\n        }\n\n        if (Array.isArray(d.value)) {\n          it.range = {\n            min: d.value[0],\n            max: d.value[1]\n          };\n          rangeBrush.items.push(it);\n        } else {\n          it.value = d.value;\n          valueBrush.items.push(it);\n        }\n      }\n    });\n  };\n\n  for (var i = 0; i < dataPoints.length; i++) {\n    var _ret3 = _loop4(i);\n\n    if (_ret3 === \"continue\") continue;\n  }\n\n  trigger.contexts.forEach(function (c) {\n    if (rangeBrush.items.length) {\n      chart.brush(c)[rangeBrush.actionFn](rangeBrush.items);\n    } else {\n      chart.brush(c)[valueBrush.actionFn](valueBrush.items); // call action even if there are items to potentially clear what is currently in the brush\n    }\n  });\n}\nfunction brushFromSceneNodes(_ref3) {\n  var nodes = _ref3.nodes,\n      action = _ref3.action,\n      chart = _ref3.chart,\n      trigger = _ref3.trigger;\n  var dataPoints = [];\n\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    var nodeData = node.data;\n\n    if (nodeData !== null) {\n      dataPoints.push(nodeData);\n    }\n  }\n\n  brushDataPoints({\n    dataPoints: dataPoints,\n    action: action,\n    chart: chart,\n    trigger: trigger\n  });\n}\nfunction resolveEvent(_ref4) {\n  var collisions = _ref4.collisions,\n      t = _ref4.t,\n      config = _ref4.config,\n      action = _ref4.action;\n  var brushCollisions = [];\n  var resolved = false;\n\n  if (collisions.length > 0) {\n    brushCollisions = collisions;\n    resolved = true;\n\n    if (t.propagation === 'stop') {\n      brushCollisions = [collisions[collisions.length - 1]];\n    }\n  }\n\n  var nodes = brushCollisions.map(function (c) {\n    return c.node;\n  });\n  brushFromSceneNodes({\n    nodes: nodes,\n    action: action,\n    chart: config.chart,\n    data: config.data,\n    trigger: t\n  });\n  return resolved;\n}\n\nfunction touchSingleContactPoint(e, rect) {\n  if (e.changedTouches.length !== 1) {\n    return null;\n  }\n\n  return {\n    x: e.changedTouches[0].clientX - rect.left,\n    y: e.changedTouches[0].clientY - rect.top\n  };\n}\n\nfunction singleContactPoint(e, rect) {\n  return {\n    x: e.clientX - rect.left,\n    y: e.clientY - rect.top\n  };\n}\n\nfunction resolveCollisions(e, t, renderer) {\n  var rect = renderer.element().getBoundingClientRect();\n  var p = isTouchEvent(e) ? touchSingleContactPoint(e, rect) : singleContactPoint(e, rect);\n\n  if (p === null || p.x < 0 || p.y < 0 || p.x > rect.width || p.y > rect.height) {\n    // TODO include radius in this check?\n    return [];\n  }\n\n  if (t.touchRadius > 0 && isTouchEvent(e)) {\n    p = {\n      cx: p.x,\n      cy: p.y,\n      r: t.touchRadius // TODO Use touch event radius/width value (Need to handle dpi scaling as well)\n\n    };\n  }\n\n  return renderer.itemsAt(p);\n}\n\nfunction resolveAction(action, e, def) {\n  if (action) {\n    if (typeof action === 'function') {\n      return action(e);\n    }\n\n    return action;\n  }\n\n  return def;\n}\n\nfunction resolveTapEvent(_ref5) {\n  var e = _ref5.e,\n      t = _ref5.t,\n      config = _ref5.config;\n  var collisions = resolveCollisions(e, t, config.renderer);\n  return resolveEvent({\n    collisions: collisions,\n    t: t,\n    config: config,\n    action: resolveAction(t.action, e, 'toggle')\n  });\n}\nfunction resolveOverEvent(_ref6) {\n  var e = _ref6.e,\n      t = _ref6.t,\n      config = _ref6.config;\n  var collisions = resolveCollisions(e, t, config.renderer);\n  return resolveEvent({\n    collisions: collisions,\n    t: t,\n    config: config,\n    action: resolveAction(t.action, e, 'set')\n  });\n}\n\n/**\n * A list of supported attributes in lower camelCase notation mapped to corresponding kebab-case notation.\n * The kebab-case notations are a sub-set of SVG attributes (https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute).\n * @ignore\n */\nvar mappedAttributes = {\n  fill: 'fill',\n  stroke: 'stroke',\n  opacity: 'opacity',\n  strokeWidth: 'stroke-width',\n  strokeLinejoin: 'stroke-linejoin',\n  fontFamily: 'font-family',\n  fontSize: 'font-size',\n  baseline: 'dominant-baseline',\n  // Special case where we have defined our own attribute name\n  dominantBaseline: 'dominant-baseline',\n  anchor: 'text-anchor',\n  // Special case where we have defined our own attribute name\n  textAnchor: 'text-anchor',\n  maxWidth: 'maxWidth',\n  transform: 'transform',\n  strokeDasharray: 'stroke-dasharray',\n  id: 'id'\n};\n/**\n * Takes a target object and assign each supported attribute from a source object to that target.\n * Each supported attributes is converted to a mapped kebab-case notation.\n * @ignore\n *\n * @param {object} target - Target object on which to assign mapped attribute values\n * @param {object} source - Source object\n */\n\nfunction assignMappedAttribute(target, source) {\n  Object.keys(mappedAttributes).forEach(function (key) {\n    var sourceValue = source[key];\n\n    if (typeof sourceValue !== 'undefined') {\n      var mappedKey = mappedAttributes[key];\n      target[mappedKey] = sourceValue;\n    }\n  });\n}\n\n/**\n * @extends symbol-config\n * @typedef {object} symbol--circle\n */\nfunction circle(options) {\n  return {\n    type: 'circle',\n    fill: 'black',\n    cx: options.x,\n    cy: options.y,\n    r: options.size / 2\n  };\n}\n\nfunction pointsToPath(points) {\n  var close = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var d = '';\n\n  for (var i = 0; i < points.length; i++) {\n    var p = points[i];\n\n    if (i === 0) {\n      d += \"M\".concat(p.x, \" \").concat(p.y);\n    } else {\n      d += \"L\".concat(p.x, \" \").concat(p.y);\n    }\n\n    d += ' ';\n  }\n\n  if (close) {\n    d += 'Z';\n  }\n\n  return d;\n}\n\n/**\n * @extends symbol-config\n * @typedef {object} symbol--diamond\n */\n\nfunction diamond(options) {\n  var size = options.size;\n  var left = options.x - size / 2;\n  var top = options.y - size / 2;\n  var points = [{\n    x: left,\n    y: top + size / 2\n  }, {\n    x: left + size / 2,\n    y: top\n  }, {\n    x: left + size,\n    y: top + size / 2\n  }, {\n    x: left + size / 2,\n    y: top + size\n  }, {\n    x: left,\n    y: top + size / 2\n  }];\n  return {\n    type: 'path',\n    fill: 'black',\n    d: pointsToPath(points)\n  };\n}\n\nfunction generateCrossPoints(x, y, size, barWidth) {\n  var r = size / 2;\n  var innerLeft = x - barWidth / 2;\n  var innerTop = y - barWidth / 2;\n  var left = x - r;\n  var top = y - r;\n  return [{\n    x: innerLeft,\n    y: innerTop\n  }, // Top\n  {\n    x: innerLeft,\n    y: top\n  }, {\n    x: innerLeft + barWidth,\n    y: top\n  }, {\n    x: innerLeft + barWidth,\n    y: innerTop\n  }, // Right\n  {\n    x: left + size,\n    y: innerTop\n  }, {\n    x: left + size,\n    y: innerTop + barWidth\n  }, {\n    x: innerLeft + barWidth,\n    y: innerTop + barWidth\n  }, // Bottom\n  {\n    x: innerLeft + barWidth,\n    y: top + size\n  }, {\n    x: innerLeft,\n    y: top + size\n  }, {\n    x: innerLeft,\n    y: innerTop + barWidth\n  }, // Left\n  {\n    x: left,\n    y: innerTop + barWidth\n  }, {\n    x: left,\n    y: innerTop\n  }];\n}\n/**\n * @extends symbol-config\n * @typedef {object} symbol--cross\n * @property {number} [width] - Width of the diagonals\n */\n\nfunction cross(options) {\n  var x = options.x;\n  var y = options.y;\n  var r = options.size / 2;\n  var width = isNaN(options.width) ? r / 2 : options.width;\n  var barWidth = Math.min(width, r);\n  var points = generateCrossPoints(x, y, options.size, barWidth);\n  return {\n    type: 'path',\n    fill: 'black',\n    d: pointsToPath(points)\n  };\n}\n\n/**\n * Get x1, y1, x2, y2 point from angle\n * Source: {@link https://codepen.io/NV/pen/jcnmK}\n * @private\n *\n * @param  {number} angle Radians\n * @return {object}       Point with x1, y2, x2, y2.\n */\nfunction angleToPoints(angle) {\n  var segment = Math.floor(angle / Math.PI * 2) + 2;\n  var diagonal = (0.5 * segment + 0.25) * Math.PI;\n  var op = Math.cos(Math.abs(diagonal - angle)) * Math.sqrt(2);\n  var x = op * Math.cos(angle);\n  var y = op * Math.sin(angle);\n  return {\n    x1: x < 0 ? 1 : 0,\n    y1: y < 0 ? 1 : 0,\n    x2: x >= 0 ? x : x + 1,\n    y2: y >= 0 ? y : y + 1\n  };\n}\n/**\n * Turns degrees into radians\n * @private\n *\n * @param  {number} degrees Degrees\n * @return {number}         Radians\n */\n\nfunction toRadians(d) {\n  return -d / 180 * Math.PI;\n}\n/**\n * Get x1, y1, x2, y2 point from degree\n * @private\n *\n * @param  {number} d Degree\n * @return {object}   Point with x1, y2, x2, y2.\n */\n\nfunction degreesToPoints(d) {\n  return angleToPoints(toRadians(d));\n}\n\nfunction add$1(v1, v2) {\n  return {\n    x: v1.x + v2.x,\n    y: v1.y + v2.y\n  };\n}\nfunction sub(v1, v2) {\n  return {\n    x: v1.x - v2.x,\n    y: v1.y - v2.y\n  };\n}\nfunction scalarMultiply(v, s) {\n  return {\n    x: v.x * s,\n    y: v.y * s\n  };\n}\nfunction distanceX(v1, v2) {\n  return v1.x - v2.x;\n}\nfunction distanceY(v1, v2) {\n  return v1.y - v2.y;\n}\nfunction sqrDistance(v1, v2) {\n  return Math.pow(distanceX(v1, v2), 2) + Math.pow(distanceY(v1, v2), 2);\n}\nfunction distance(v1, v2) {\n  return Math.sqrt(sqrDistance(v1, v2));\n}\nfunction dot(v1, v2) {\n  return v1.x * v2.x + v1.y * v2.y;\n}\nfunction projectOnto(v1, v2) {\n  var m = dot(v1, v2) / dot(v2, v2) || 1;\n  return {\n    x: v2.x * m,\n    y: v2.y * m\n  };\n}\nfunction rotate(v, radians) {\n  var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    x: 0,\n    y: 0\n  };\n  var cos = Math.cos(radians);\n  var sin = Math.sin(radians);\n  var t1 = sub(v, origin);\n  var t2 = {\n    x: cos * t1.x - sin * t1.y,\n    y: sin * t1.x + cos * t1.y\n  };\n  return add$1(t2, origin);\n}\n\n/**\n * @extends symbol-config\n * @typedef {object} symbol--saltire\n * @property {number} [width] - Width of the diagonals\n */\n\nfunction saltire(options) {\n  var radians = toRadians(45);\n  var r = options.size / 2;\n  var width = isNaN(options.width) ? r / 2 : options.width;\n  var barWidth = Math.min(width, r);\n  var adjustedSize = options.size; // Adjust for the barwidth and rotation angle, so that the visual part is always inside the symbol area\n\n  var h = Math.sin(Math.asin(-radians)) * (barWidth / 2);\n  var c = r / Math.sin(-radians);\n  adjustedSize += (c - r) * 2;\n  adjustedSize -= h * 2;\n  var centroid = {\n    x: options.x,\n    y: options.y\n  };\n  var points = generateCrossPoints(options.x, options.y, adjustedSize, barWidth).map(function (p) {\n    return rotate(p, radians, centroid);\n  });\n  return {\n    type: 'path',\n    fill: 'black',\n    d: pointsToPath(points)\n  };\n}\n\n/**\n * @extends symbol-config\n * @typedef {object} symbol--square\n */\nfunction square(options) {\n  var size = options.size;\n  return {\n    type: 'rect',\n    fill: 'black',\n    x: options.x - size / 2,\n    y: options.y - size / 2,\n    width: size,\n    height: size\n  };\n}\n\nvar DIRECTION_TO_ANGLE = {\n  up: 0,\n  down: 180,\n  left: 90,\n  right: -90\n};\n/**\n * @extends symbol-config\n * @typedef {object} symbol--triangle\n * @property {string} [direction='up'] - Direction of the triangle ('up'|'down'|'left'|'right')\n */\n\nfunction triangle(options) {\n  var size = options.size;\n  var p = {\n    x: options.x,\n    y: options.y\n  };\n  var directionAngle = DIRECTION_TO_ANGLE[options.direction] || 0;\n  var halfSize = size / 2;\n  var left = options.x - halfSize;\n  var top = options.y - halfSize;\n  var points = [{\n    x: left,\n    y: top + size\n  }, {\n    x: left + halfSize,\n    y: top\n  }, {\n    x: left + size,\n    y: top + size\n  }, {\n    x: left,\n    y: top + size\n  }];\n  var radians = toRadians(directionAngle);\n  points = points.map(function (pp) {\n    return rotate(pp, radians, p);\n  });\n  return {\n    type: 'path',\n    fill: 'black',\n    d: pointsToPath(points)\n  };\n}\n\nfunction createRectCollider(_ref) {\n  var x = _ref.x,\n      y = _ref.y,\n      size = _ref.size;\n  var r = size / 2;\n  return {\n    type: 'rect',\n    x: x - r,\n    y: y - r,\n    width: size,\n    height: size\n  };\n}\n/**\n * @extends symbol-config\n * @typedef {object} symbol--line\n * @property {string} [direction='horizontal'] - Direction of line ('horizontal'|'vertical').\n */\n\n\nfunction line$1(options) {\n  var isVertical = options.direction === 'vertical';\n  var r = options.size / 2;\n  var x = options.x;\n  var y = options.y;\n  return {\n    type: 'line',\n    stroke: 'black',\n    strokeWidth: 1,\n    x1: x - (isVertical ? 0 : r),\n    y1: y - (isVertical ? r : 0),\n    x2: x + (isVertical ? 0 : r),\n    y2: y + (isVertical ? r : 0),\n    collider: createRectCollider(options) // TODO Use visual collider?\n\n  };\n}\n\n/**\n * @extends symbol-config\n * @typedef {object} symbol--star\n * @property {number} [points=5] - Number of points on the star\n * @property {number} [startAngle=90] - Start drawing angle\n * @property {number} [innerRadius=size/2] - Size of the star core. My not exceed size of symbol.\n */\n\nfunction star(options) {\n  var size = options.size;\n  var points = [];\n  var outerRadius = size / 2;\n  var drawPoints = options.points || 5;\n  var innerRadius = Math.min(options.innerRadius || size / 2, size) / 2;\n  var startAngle = isNaN(options.startAngle) ? 90 : options.startAngle;\n  var angle = 360 / drawPoints;\n\n  for (var i = 1; i <= drawPoints; i++) {\n    var pAngle = angle * i + startAngle;\n    var radians = toRadians(pAngle);\n    var innerRadians = toRadians(pAngle + angle / 2);\n    var y = Math.sin(radians);\n    var x = Math.cos(radians);\n    var iy = Math.sin(innerRadians);\n    var ix = Math.cos(innerRadians);\n    points.push({\n      x: options.x + x * outerRadius,\n      y: options.y + y * outerRadius\n    });\n    points.push({\n      x: options.x + ix * innerRadius,\n      y: options.y + iy * innerRadius\n    });\n  }\n\n  return {\n    type: 'path',\n    fill: 'black',\n    d: pointsToPath(points)\n  };\n}\n\n/**\n * @extends symbol-config\n * @typedef {object} symbol--n-polygon\n * @property {object} [sides=6] - Number of sides on the regular polygon\n * @property {object} [startAngle=0] - Start drawing angle\n */\n\nfunction nPolygon(options) {\n  var points = [];\n  var radius = options.size / 2;\n  var drawPoints = Math.max(isNaN(options.sides) ? 6 : options.sides, 3);\n  var angle = 360 / drawPoints;\n  var startAngle = isNaN(options.startAngle) ? 0 : options.startAngle;\n\n  for (var i = 1; i <= drawPoints; i++) {\n    var radians = toRadians(angle * i + startAngle);\n    var y = Math.sin(radians);\n    var x = Math.cos(radians);\n    points.push({\n      x: options.x + x * radius,\n      y: options.y + y * radius\n    });\n  }\n\n  return {\n    type: 'path',\n    fill: 'black',\n    d: pointsToPath(points)\n  };\n}\n\n/**\n * @extends symbol-config\n * @typedef {object} symbol--bar\n * @property {string} [direction='horizontal'] - Direction of bar ('horizontal'|'vertical').\n */\n\nfunction bar(options) {\n  var p = {\n    x: options.x,\n    y: options.y\n  };\n  var isVertical = options.direction === 'vertical';\n  var r = options.size / 2;\n  var width = r / 2;\n  var halfWidth = width / 2;\n  var points = [{\n    x: p.x - r,\n    y: p.y + halfWidth\n  }, {\n    x: p.x - r,\n    y: p.y - halfWidth\n  }, {\n    x: p.x + r,\n    y: p.y - halfWidth\n  }, {\n    x: p.x + r,\n    y: p.y + halfWidth\n  }];\n\n  if (isVertical) {\n    var radians = toRadians(90);\n    points = points.map(function (pp) {\n      return rotate(pp, radians, p);\n    });\n  }\n\n  var rect = pointsToRect(points);\n  rect.type = 'rect';\n  rect.fill = 'black';\n  return rect;\n}\n\nvar reg$1 = registryFactory();\nreg$1.add('circle', circle);\nreg$1.add('diamond', diamond);\nreg$1.add('saltire', saltire);\nreg$1.add('square', square);\nreg$1.add('triangle', triangle);\nreg$1.add('line', line$1);\nreg$1.add('star', star);\nreg$1.add('n-polygon', nPolygon);\nreg$1.add('cross', cross);\nreg$1.add('bar', bar);\n\nfunction applyOpts(obj) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Object.keys(opts).forEach(function (key) {\n    if (typeof mappedAttributes[key] !== 'undefined' && key !== 'transform') {\n      obj[key] = opts[key];\n    }\n  });\n}\n/**\n * Factory function for symbols.\n * Options object is passed to symbols function.\n * @private\n * @param {symbol--bar|symbol--circle|symbol--cross|symbol--diamond|symbol--line|symbol--n-polygon|symbol--saltire|symbol--square|symbol--star|symbol--triangle} options - Options definition may contain any of the supported display-object attributes\n * @returns {object} A node definition\n */\n\n\nfunction create$3() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  // TODO handle reserverd properties x, y, size, data, etc..\n  var fn = reg$1.get(options.type);\n\n  if (fn) {\n    var s = fn(options);\n    applyOpts(s, options);\n\n    if (typeof options.data !== 'undefined') {\n      s.data = options.data;\n    }\n\n    return s;\n  }\n\n  return fn;\n}\n/**\n * Mandatory symbol config\n * @typedef {object} symbol-config\n * @property {object} options - Options definition may contain any of the supported display-object attributes\n * @property {string} options.type - Type of symbol\n * @property {number} options.x - x-coordinate\n * @property {number} options.y - y-coordinate\n * @property {number} options.size\n * @property {object} [options.data]\n */\n\nvar isReservedProperty = function isReservedProperty(prop) {\n  return ['on', 'preferredSize', 'created', 'beforeMount', 'mounted', 'resize', 'beforeUpdate', 'updated', 'beforeRender', 'render', 'beforeUnmount', 'beforeDestroy', 'destroyed', 'defaultSettings', 'data', 'settings', 'formatter', 'scale', 'chart', 'dockConfig', 'mediator', 'style', 'resolver', 'registries', '_DO_NOT_USE_getInfo', 'symbol', 'isVisible'].some(function (name) {\n    return name === prop;\n  });\n};\n\nfunction prepareContext(ctx, definition, opts) {\n  var _definition$require = definition.require,\n      require = _definition$require === void 0 ? [] : _definition$require;\n\n  var mediatorSettings = definition.mediator || {};\n  var settings = opts.settings,\n      formatter = opts.formatter,\n      scale = opts.scale,\n      data = opts.data,\n      renderer = opts.renderer,\n      chart = opts.chart,\n      dockConfig = opts.dockConfig,\n      mediator = opts.mediator,\n      instance = opts.instance,\n      rect = opts.rect,\n      style = opts.style,\n      registries = opts.registries,\n      resolver = opts.resolver,\n      update = opts.update,\n      _DO_NOT_USE_getInfo = opts._DO_NOT_USE_getInfo,\n      symbol = opts.symbol,\n      isVisible = opts.isVisible;\n\n  ctx.emit = function () {};\n\n  if (isVisible) {\n    ctx.isVisible = isVisible;\n  } // TODO add setters and log warnings / errors to console\n\n\n  Object.defineProperty(ctx, 'settings', {\n    get: settings\n  });\n  Object.defineProperty(ctx, 'data', {\n    get: data\n  });\n  Object.defineProperty(ctx, 'formatter', {\n    get: formatter\n  });\n  Object.defineProperty(ctx, 'scale', {\n    get: scale\n  });\n  Object.defineProperty(ctx, 'mediator', {\n    get: mediator\n  });\n  Object.defineProperty(ctx, 'style', {\n    get: style\n  });\n  Object.defineProperty(ctx, 'registries', {\n    get: registries\n  });\n\n  if (rect) {\n    Object.defineProperty(ctx, 'rect', {\n      get: rect\n    });\n  } // TODO _DO_NOT_USE_getInfo is a temporary solution to expose info from a component\n  // It should replace ASAP with a proper solution.\n  // The only component activaly in need of it is the legend-cat\n\n\n  if (_DO_NOT_USE_getInfo) {\n    ctx._DO_NOT_USE_getInfo = _DO_NOT_USE_getInfo;\n  }\n\n  Object.keys(definition).forEach(function (key) {\n    if (!isReservedProperty(key)) {\n      // Add non-lifecycle methods to the context\n      if (typeof definition[key] === 'function') {\n        ctx[key] = definition[key].bind(ctx);\n      } else {\n        ctx[key] = definition[key];\n      }\n    }\n  }); // Add properties to context\n\n  require.forEach(function (req) {\n    if (req === 'renderer') {\n      Object.defineProperty(ctx, 'renderer', {\n        get: renderer\n      });\n    } else if (req === 'chart') {\n      Object.defineProperty(ctx, 'chart', {\n        get: chart\n      });\n    } else if (req === 'dockConfig') {\n      Object.defineProperty(ctx, 'dockConfig', {\n        get: dockConfig\n      });\n    } else if (req === 'instance') {\n      Object.defineProperty(ctx, 'instance', {\n        get: instance\n      });\n    } else if (req === 'update' && update) {\n      Object.defineProperty(ctx, 'update', {\n        get: update\n      });\n    } else if (req === 'resolver') {\n      Object.defineProperty(ctx, 'resolver', {\n        get: resolver\n      });\n    } else if (req === 'symbol') {\n      Object.defineProperty(ctx, 'symbol', {\n        get: symbol\n      });\n    }\n  });\n\n  Object.keys(mediatorSettings).forEach(function (eventName) {\n    ctx.mediator.on(eventName, mediatorSettings[eventName].bind(ctx));\n  });\n}\n\nfunction createDockDefinition(settings, preferredSize, logger) {\n  var getLayoutProperty = function getLayoutProperty(propName) {\n    if (settings[propName]) {\n      logger.warn(\"Deprecation Warning the \".concat(propName, \" property should be moved into layout: {} property\")); // eslint-disable-line no-console\n\n      return settings[propName];\n    }\n\n    return settings.layout ? settings.layout[propName] : undefined;\n  };\n\n  var def = {};\n  def.displayOrder = getLayoutProperty('displayOrder');\n  def.dock = getLayoutProperty('dock');\n  def.prioOrder = getLayoutProperty('prioOrder');\n  def.minimumLayoutMode = getLayoutProperty('minimumLayoutMode'); // move layout properties to layout object\n\n  settings.layout = settings.layout || {};\n  settings.layout.displayOrder = typeof def.displayOrder !== 'undefined' ? def.displayOrder : settings.layout.displayOrder;\n  settings.layout.prioOrder = typeof def.prioOrder !== 'undefined' ? def.prioOrder : settings.layout.prioOrder;\n  settings.layout.dock = def.dock || settings.layout.dock;\n  settings.layout.minimumLayoutMode = def.minimumLayoutMode || settings.layout.minimumLayoutMode; // not directly a dock layout property\n\n  def.show = settings.show;\n  def.preferredSize = preferredSize;\n  return def;\n}\n\nfunction setUpEmitter(ctx, emitter, settings) {\n  // Object.defineProperty(ctx, 'emitter', )\n  Object.keys(settings.on || {}).forEach(function (event) {\n    ctx.eventListeners = ctx.eventListeners || [];\n    var listener = settings.on[event].bind(ctx);\n    ctx.eventListeners.push({\n      event: event,\n      listener: listener\n    });\n    emitter.on(event, listener);\n  });\n\n  ctx.emit = function (name) {\n    for (var _len = arguments.length, event = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      event[_key - 1] = arguments[_key];\n    }\n\n    return emitter.emit.apply(emitter, [name].concat(event));\n  };\n}\n\nfunction tearDownEmitter(ctx, emitter) {\n  if (ctx.eventListeners) {\n    ctx.eventListeners.forEach(function (_ref) {\n      var event = _ref.event,\n          listener = _ref.listener;\n      emitter.removeListener(event, listener);\n    });\n    ctx.eventListeners.length = 0;\n  }\n\n  ctx.emit = function () {};\n} // First render\n// preferredSize -> resize -> beforeRender -> render -> mounted\n// Normal update\n// beforeUpdate -> preferredSize -> resize -> beforeRender -> render -> updated\n// Update without relayout\n// beforeUpdate -> beforeRender -> render -> updated\n// TODO support es6 classes\n\n\nfunction componentFactory(definition) {\n  var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _definition$defaultSe = definition.defaultSettings,\n      defaultSettings = _definition$defaultSe === void 0 ? {} : _definition$defaultSe,\n      _definition$_DO_NOT_U = definition._DO_NOT_USE_getInfo,\n      _DO_NOT_USE_getInfo = _definition$_DO_NOT_U === void 0 ? function () {\n    return {};\n  } : _definition$_DO_NOT_U;\n\n  var _chart = context.chart,\n      container = context.container,\n      _mediator = context.mediator,\n      _registries = context.registries,\n      theme = context.theme,\n      renderer = context.renderer;\n  var emitter = EventEmitter$1.mixin({});\n  var config = context.settings || {};\n\n  var _settings = extend(true, {}, defaultSettings, config);\n\n  var _data = [];\n\n  var _scale;\n\n  var _formatter;\n\n  var element;\n  var size;\n\n  var _style;\n\n  var _resolver = settingsResolver({\n    chart: _chart\n  });\n\n  var _isVisible = false;\n  var brushArgs = {\n    nodes: [],\n    chart: _chart,\n    config: _settings.brush || {},\n    renderer: null\n  };\n  var brushTriggers = {\n    tap: [],\n    over: []\n  };\n  var brushStylers = [];\n  var definitionContext = {};\n  var instanceContext = extend({}, config); // Create a callback that calls lifecycle functions in the definition and config (if they exist).\n\n  function createCallback(method) {\n    var defaultMethod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n    var canBeValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    return function cb() {\n      var inDefinition = typeof definition[method] !== 'undefined';\n      var inConfig = typeof config[method] !== 'undefined';\n      var returnValue;\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      if (inDefinition) {\n        if (typeof definition[method] === 'function') {\n          var _definition$method;\n\n          returnValue = (_definition$method = definition[method]).call.apply(_definition$method, [definitionContext].concat(args));\n        } else if (canBeValue) {\n          returnValue = definition[method];\n        }\n      }\n\n      if (inConfig) {\n        if (typeof config[method] === 'function') {\n          var _config$method;\n\n          returnValue = (_config$method = config[method]).call.apply(_config$method, [instanceContext].concat(args));\n        } else if (canBeValue) {\n          returnValue = config[method];\n        }\n      }\n\n      if (!inDefinition && !inConfig) {\n        returnValue = defaultMethod.call.apply(defaultMethod, [definitionContext].concat(args));\n      }\n\n      return returnValue;\n    };\n  }\n\n  var preferredSize = createCallback('preferredSize', function () {\n    return 0;\n  }, true);\n  var resize = createCallback('resize', function (_ref2) {\n    var inner = _ref2.inner;\n    return inner;\n  });\n  var created = createCallback('created');\n  var beforeMount = createCallback('beforeMount');\n  var mounted = createCallback('mounted');\n  var beforeUnmount = createCallback('beforeUnmount');\n  var beforeUpdate = createCallback('beforeUpdate');\n  var updated = createCallback('updated');\n  var beforeRender = createCallback('beforeRender');\n  var beforeDestroy = createCallback('beforeDestroy');\n  var destroyed = createCallback('destroyed');\n  var render = definition.render; // Do not allow overriding of this function\n\n  var addBrushStylers = function addBrushStylers() {\n    if (_settings.brush) {\n      (_settings.brush.consume || []).forEach(function (b) {\n        if (b.context && b.style) {\n          brushStylers.push(styler(brushArgs, b));\n        }\n      });\n    }\n  };\n\n  var addBrushTriggers = function addBrushTriggers() {\n    if (_settings.brush) {\n      (_settings.brush.trigger || []).forEach(function (t) {\n        if (t.on === 'over') {\n          brushTriggers.over.push(t);\n        } else {\n          brushTriggers.tap.push(t);\n        }\n      });\n    }\n  };\n\n  Object.defineProperty(brushArgs, 'data', {\n    get: function get() {\n      return _data;\n    }\n  });\n  var rendString = _settings.renderer || definition.renderer;\n  var rend = rendString ? renderer || _registries.renderer(rendString)() : renderer || _registries.renderer()();\n  brushArgs.renderer = rend;\n  var dockConfigCallbackContext = {\n    resources: _chart.logger ? {\n      logger: _chart.logger()\n    } : {}\n  };\n\n  var _dockConfig = dockConfig(createDockDefinition(_settings, preferredSize, _chart.logger()), dockConfigCallbackContext);\n\n  var appendComponentMeta = function appendComponentMeta(node) {\n    node.key = _settings.key;\n    node.element = rend.element();\n  };\n\n  var fn = function fn() {};\n\n  fn.dockConfig = function () {\n    return _dockConfig;\n  }; // Set new settings - will trigger mapping of data and creation of scale / formatter.\n\n\n  fn.set = function () {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (opts.settings) {\n      config = opts.settings;\n      _settings = extend(true, {}, defaultSettings, opts.settings);\n      _dockConfig = dockConfig(createDockDefinition(_settings, preferredSize, _chart.logger()), dockConfigCallbackContext);\n    }\n\n    if (_settings.scale) {\n      _scale = _chart.scale(_settings.scale);\n    }\n\n    if (_settings.data) {\n      _data = extract(_settings.data, {\n        dataset: _chart.dataset,\n        collection: _chart.dataCollection\n      }, {\n        logger: _chart.logger()\n      }, _chart.dataCollection);\n    } else if (_scale) {\n      _data = _scale.data();\n    } else {\n      _data = [];\n    }\n\n    if (typeof _settings.formatter === 'string') {\n      _formatter = _chart.formatter(_settings.formatter);\n    } else if (_typeof(_settings.formatter) === 'object') {\n      _formatter = _chart.formatter(_settings.formatter);\n    } else if (_scale && _scale.data().fields) {\n      _formatter = _scale.data().fields[0].formatter();\n    }\n\n    _style = theme.style(_settings.style || {});\n  };\n\n  fn.resize = function () {\n    var inner = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var outer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var newSize = resize({\n      inner: inner,\n      outer: outer\n    });\n\n    if (newSize) {\n      size = rend.size(newSize);\n    } else {\n      size = rend.size(inner);\n    }\n\n    instanceContext.rect = extend(true, {\n      computedPhysical: size.computedPhysical,\n      computedOuter: outer.computed || outer,\n      computedInner: inner.computed || inner\n    }, inner);\n    size = extend(true, {\n      computedOuter: outer.computed || outer,\n      computedInner: inner.computed || inner\n    }, size);\n  };\n\n  fn.getRect = function () {\n    return instanceContext.rect;\n  };\n\n  var getRenderArgs = function getRenderArgs() {\n    var renderArgs = rend.renderArgs ? rend.renderArgs.slice(0) : [];\n    renderArgs.push({\n      data: _data\n    });\n    return renderArgs;\n  };\n\n  fn.beforeMount = beforeMount;\n\n  fn.beforeRender = function () {\n    beforeRender({\n      size: size\n    });\n  };\n\n  var currentNodes;\n\n  fn.render = function () {\n    var nodes = brushArgs.nodes = render.call.apply(render, [definitionContext].concat(_toConsumableArray$1(getRenderArgs())));\n    rend.render(nodes);\n    currentNodes = nodes;\n  };\n\n  fn.hide = function () {\n    fn.unmount();\n    rend.size({\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    });\n    rend.clear();\n  };\n\n  fn.beforeUpdate = function () {\n    beforeUpdate({\n      settings: _settings,\n      data: _data\n    });\n  };\n\n  var currentTween;\n\n  fn.update = function () {\n    if (currentTween) {\n      currentTween.stop();\n    }\n\n    var nodes = brushArgs.nodes = render.call.apply(render, [definitionContext].concat(_toConsumableArray$1(getRenderArgs()))); // Reset brush stylers and triggers\n\n    brushStylers.forEach(function (b) {\n      return b.cleanUp();\n    });\n    brushStylers.length = 0;\n    brushTriggers.tap = [];\n    brushTriggers.over = [];\n\n    if (_settings.brush) {\n      addBrushStylers();\n      addBrushTriggers();\n    }\n\n    brushStylers.forEach(function (bs) {\n      if (bs.isActive()) {\n        bs.update();\n      }\n    });\n\n    if (currentNodes && _settings.animations && _settings.animations.enabled) {\n      currentTween = tween({\n        old: currentNodes,\n        current: nodes\n      }, {\n        renderer: rend\n      }, _settings.animations);\n      currentTween.start();\n    } else {\n      rend.render(nodes);\n    }\n\n    currentNodes = nodes;\n\n    if (rend.setKey && typeof config.key === 'string') {\n      rend.setKey(config.key);\n    }\n  };\n\n  fn.updated = updated;\n\n  fn.destroy = function () {\n    fn.unmount();\n    beforeDestroy(element);\n    rend.destroy();\n    destroyed();\n    element = null;\n  };\n  /**\n   * Update active nodes. For now this can be used as a way update and apply brushing on nodes.\n   * Ex: if a component have changed the nodes since its initial render.\n   * @param {Nodes[]} nodes\n   * @deprecated\n   * @ignore\n   */\n\n\n  var updateNodes = function updateNodes(nodes) {\n    brushArgs.nodes = nodes;\n    brushStylers.forEach(function (bs) {\n      if (bs.isActive()) {\n        bs.update();\n      }\n    });\n    rend.render(nodes);\n  }; // Set contexts, note that the definition and instance need different contexts (for example if they have different 'require' props)\n\n\n  prepareContext(definitionContext, definition, {\n    settings: function settings() {\n      return _settings;\n    },\n    data: function data() {\n      return _data;\n    },\n    scale: function scale() {\n      return _scale;\n    },\n    formatter: function formatter() {\n      return _formatter;\n    },\n    renderer: function renderer() {\n      return rend;\n    },\n    chart: function chart() {\n      return _chart;\n    },\n    dockConfig: function dockConfig() {\n      return _dockConfig;\n    },\n    mediator: function mediator() {\n      return _mediator;\n    },\n    instance: function instance() {\n      return instanceContext;\n    },\n    rect: function rect() {\n      return instanceContext.rect;\n    },\n    style: function style() {\n      return _style;\n    },\n    update: function update() {\n      return updateNodes;\n    },\n    registries: function registries() {\n      return _registries;\n    },\n    resolver: function resolver() {\n      return _resolver;\n    },\n    symbol: function symbol() {\n      return create$3;\n    }\n  });\n  prepareContext(instanceContext, config, {\n    settings: function settings() {\n      return _settings;\n    },\n    data: function data() {\n      return _data;\n    },\n    scale: function scale() {\n      return _scale;\n    },\n    formatter: function formatter() {\n      return _formatter;\n    },\n    renderer: function renderer() {\n      return rend;\n    },\n    chart: function chart() {\n      return _chart;\n    },\n    dockConfig: function dockConfig() {\n      return _dockConfig;\n    },\n    mediator: function mediator() {\n      return _mediator;\n    },\n    style: function style() {\n      return _style;\n    },\n    _DO_NOT_USE_getInfo: _DO_NOT_USE_getInfo.bind(definitionContext),\n    isVisible: function isVisible() {\n      return _isVisible;\n    }\n  });\n\n  fn.getBrushedShapes = function getBrushedShapes(brushCtx, mode, props) {\n    var shapes = [];\n\n    if (_settings.brush && _settings.brush.consume) {\n      var brusher = _chart.brush(brushCtx);\n\n      var sceneNodes = rend.findShapes('*');\n\n      _settings.brush.consume.filter(function (t) {\n        return t.context === brushCtx;\n      }).forEach(function (consume) {\n        for (var i = 0; i < sceneNodes.length; i++) {\n          var node = sceneNodes[i];\n\n          if (node.data && brusher.containsMappedData(node.data, props || consume.data, mode)) {\n            appendComponentMeta(node);\n            shapes.push(node);\n            sceneNodes.splice(i, 1);\n            i--;\n          }\n        }\n      });\n    }\n\n    return shapes;\n  };\n\n  fn.findShapes = function (selector) {\n    var shapes = rend.findShapes(selector);\n\n    for (var i = 0, num = shapes.length; i < num; i++) {\n      appendComponentMeta(shapes[i]);\n    }\n\n    return shapes;\n  };\n\n  fn.shapesAt = function (shape) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var items = rend.itemsAt(shape);\n    var shapes;\n\n    if (opts && opts.propagation === 'stop' && items.length > 0) {\n      shapes = [items.pop().node];\n    } else {\n      shapes = items.map(function (i) {\n        return i.node;\n      });\n    }\n\n    for (var i = 0, num = shapes.length; i < num; i++) {\n      appendComponentMeta(shapes[i]);\n    }\n\n    return shapes;\n  };\n\n  fn.brushFromShapes = function (shapes) {\n    var trigger = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    trigger.contexts = Array.isArray(trigger.contexts) ? trigger.contexts : [];\n    var action = trigger.action || 'toggle';\n    brushFromSceneNodes({\n      nodes: shapes,\n      action: action,\n      trigger: trigger,\n      chart: _chart,\n      data: brushArgs.data\n    });\n  };\n\n  fn.mount = function () {\n    element = rend.element && rend.element() ? element : rend.appendTo(container);\n\n    if (rend.setKey && typeof config.key === 'string') {\n      rend.setKey(config.key);\n    }\n\n    if (_settings.brush) {\n      addBrushStylers();\n      addBrushTriggers();\n    }\n\n    setUpEmitter(instanceContext, emitter, config);\n    setUpEmitter(definitionContext, emitter, definition);\n    _isVisible = true;\n  };\n\n  fn.mounted = function () {\n    return mounted(element);\n  };\n\n  fn.unmount = function () {\n    [instanceContext, definitionContext].forEach(function (ctx) {\n      tearDownEmitter(ctx, emitter);\n    });\n    brushTriggers.tap = [];\n    brushTriggers.over = [];\n    brushStylers.forEach(function (bs) {\n      bs.cleanUp();\n    });\n    brushStylers.length = 0;\n    beforeUnmount();\n    _isVisible = false;\n  };\n\n  fn.onBrushTap = function (e) {\n    brushTriggers.tap.forEach(function (t) {\n      if (resolveTapEvent({\n        e: e,\n        t: t,\n        config: brushArgs\n      }) && t.globalPropagation === 'stop') {\n        _chart.toggleBrushing(true);\n      }\n    });\n  };\n\n  fn.onBrushOver = function (e) {\n    brushTriggers.over.forEach(function (t) {\n      if (resolveOverEvent({\n        e: e,\n        t: t,\n        config: brushArgs\n      }) && t.globalPropagation === 'stop') {\n        _chart.toggleBrushing(true);\n      }\n    });\n  };\n  /**\n   * Expose definition on instance\n   * @private\n   * @experimental\n   */\n\n\n  fn.def = definitionContext;\n  /**\n   * Expose instanceCtx on \"instance\"\n   * @private\n   * @experimental\n   */\n\n  fn.ctx = instanceContext;\n\n  fn.renderer = function () {\n    return rend;\n  };\n\n  fn.set({\n    settings: config\n  });\n  created();\n  return fn;\n}\n\nfunction mediator() {\n  var instance = {};\n  EventEmitter$1.mixin(instance);\n  return instance;\n}\n\nvar EPSILON = 1e-12;\nfunction closestPointToLine(start, end, p) {\n  var startToPoint = sub(p, start);\n  var startToEnd = sub(end, start);\n  var pointOnLine = add$1(projectOnto(startToPoint, startToEnd), start);\n  return pointOnLine;\n}\nfunction isPointOnLine(start, end, p) {\n  return distance(start, p) + distance(end, p) - distance(start, end) < EPSILON;\n}\n/**\n * Check if rectangle a is located inside rectangle b or if they are the same rectangle.\n * @param {rect} a - An rect containing (x,y) coordinates, width and height. The origin is assumed to be top left.\n * @param {rect} b - An rect containing (x,y) coordinates, width and height. The origin is assumed to be top left.\n * @ignore\n */\n\nfunction rectContainsRect(a, b) {\n  return a.x >= b.x && a.x + a.width <= b.x + b.width && a.y >= b.y && a.y + a.height <= b.y + b.height;\n}\n\nfunction lineHasNoLength(line) {\n  return line.x1 === line.x2 && line.y1 === line.y2;\n}\n\nfunction rectHasNoSize(rect) {\n  return rect.width <= 0 || rect.height <= 0;\n}\n\nfunction circleHasNoSize(circle) {\n  return circle.r <= 0;\n}\n\nfunction toFewEdges(polygon) {\n  return polygon.edges.length <= 2;\n}\n/**\n   * Test if a Circle contains a point. If so, returns true and false otherwise.\n   * Circle muse have a radius greater then 0.\n   * @private\n   * @param {object} circle\n   * @param {number} circle.cx - center x-coordinate\n   * @param {number} circle.cy - center y-coordinate\n   * @param {number} circle.r - circle radius\n   * @param {object} point\n   * @param {number} point.x - x-coordinate\n   * @param {number} point.y - y-coordinate\n   * @return {boolean} true if circle contains point\n   */\n\n\nfunction testCirclePoint(circle, point) {\n  if (circleHasNoSize(circle)) {\n    return false;\n  }\n\n  var center = {\n    x: circle.cx,\n    y: circle.cy\n  };\n  var sqrDist = sqrDistance(center, point);\n\n  if (sqrDist <= Math.pow(circle.r, 2)) {\n    return true;\n  }\n\n  return false;\n}\n/**\n   * Test if a Circle collide with a rectangle. If so, returns true and false otherwise.\n   * Circle muse have a radius greater then 0.\n   * Rectangle must have a width and height greather then 0.\n   * @private\n   * @param {object} circle\n   * @param {number} circle.cx - center x-coordinate\n   * @param {number} circle.cy - center y-coordinate\n   * @param {number} circle.r - circle radius\n   * @param {object} rect\n   * @param {number} rect.x - x-coordinate\n   * @param {number} rect.y - y-coordinate\n   * @param {number} rect.width - width\n   * @param {number} rect.height - height\n   * @return {boolean} true if circle collide with rectangle\n  */\n\nfunction testCircleRect(circle, rect) {\n  if (rectHasNoSize(rect) || circleHasNoSize(circle)) {\n    return false;\n  }\n\n  var rX = rect.width / 2;\n  var rY = rect.height / 2;\n  var rcX = rect.x + rX;\n  var rcY = rect.y + rY;\n  var r = circle.r;\n  var cx = circle.cx;\n  var cy = circle.cy;\n  var dX = Math.abs(cx - rcX);\n  var dY = Math.abs(cy - rcY);\n\n  if (dX > rX + r || dY > rY + r) {\n    return false;\n  }\n\n  if (dX <= rX || dY <= rY) {\n    return true;\n  }\n\n  var sqrDist = Math.pow(dX - rX, 2) + Math.pow(dY - rY, 2);\n  return sqrDist <= Math.pow(r, 2);\n}\n/**\n   * Test if a Circle collide with a line segment. If so, returns true and false otherwise.\n   * Circle muse have a radius greater then 0.\n   * Line must have a length greater then 0.\n   * @private\n   * @param {object} circle\n   * @param {number} circle.cx - center x-coordinate\n   * @param {number} circle.cy - center y-coordinate\n   * @param {number} circle.r - circle radius\n   * @param {object} line\n   * @param {number} line.x1 - x-coordinate\n   * @param {number} line.y1 - y-coordinate\n   * @param {number} line.x1 - x-coordinate\n   * @param {number} line.y1 - y-coordinate\n   * @return {boolean} true if circle collide with line\n  */\n\nfunction testCircleLine(circle, line) {\n  if (circleHasNoSize(circle) || lineHasNoLength(line)) {\n    return false;\n  }\n\n  var _lineToPoints = lineToPoints(line),\n      _lineToPoints2 = _slicedToArray(_lineToPoints, 2),\n      p1 = _lineToPoints2[0],\n      p2 = _lineToPoints2[1];\n\n  if (testCirclePoint(circle, p1) || testCirclePoint(circle, p2)) {\n    return true;\n  }\n\n  var center = {\n    x: circle.cx,\n    y: circle.cy\n  };\n  var pointOnLine = closestPointToLine(p1, p2, center);\n  var dist = sqrDistance(pointOnLine, center);\n  return dist <= Math.pow(circle.r, 2) && isPointOnLine(p1, p2, pointOnLine);\n}\n/**\n   * Test if a Circle collide with another Circle. If so, returns true and false otherwise.\n   * Both circles muse have a radius greater then 0.\n   * @private\n   * @param {object} circle\n   * @param {number} circle.cx - center x-coordinate\n   * @param {number} circle.cy - center y-coordinate\n   * @param {number} circle.r - circle radius\n   * @param {object} circle\n   * @param {number} circle.cx - center x-coordinate\n   * @param {number} circle.cy - center y-coordinate\n   * @param {number} circle.r - circle radius\n   * @return {boolean} true if circle collide with circle\n  */\n\nfunction testCircleCircle(circle1, circle2) {\n  if (circleHasNoSize(circle1) || circleHasNoSize(circle2)) {\n    return false;\n  }\n\n  var dx = circle1.cx - circle2.cx;\n  var dy = circle1.cy - circle2.cy;\n  var sqrDist = Math.pow(dx, 2) + Math.pow(dy, 2);\n\n  if (sqrDist <= Math.pow(circle1.r + circle2.r, 2)) {\n    return true;\n  }\n\n  return false;\n}\n/**\n   * Test if a Circle collide with Polygon. If so, returns true and false otherwise.\n   * Circle muse have a radius greater then 0.\n   * Polygon must contain at least 2 vertices\n   * @private\n   * @param {object} circle\n   * @param {number} circle.cx - center x-coordinate\n   * @param {number} circle.cy - center y-coordinate\n   * @param {number} circle.r - circle radius\n   * @param {object} polygon\n   * @param {Array} polygon.vertices - Array of vertices\n   * @param {object} polygon.vertices.vertex\n   * @param {number} polygon.vertices.vertex.x - x-coordinate\n   * @param {number} polygon.vertices.vertex.y - y-coordinate\n   * @param {Array} polygon.edges - Array of edges\n   * @param {Array} polygon.edges.edge - Array of points\n   * @param {object} polygon.edges.edge.point\n   * @param {number} polygon.edges.edge.point.x - x-coordinate\n   * @param {number} polygon.edges.edge.point.y - y-coordinate\n   * @return {boolean} true if circle collide with polygon\n  */\n\nfunction testCirclePolygon(circle, polygon) {\n  // TODO handle polygon that is a straight line, current impl will interrept it is a true, if radius is extended onto any of the edges\n  if (toFewEdges(polygon) || circleHasNoSize(circle)) {\n    return false;\n  }\n\n  var center = {\n    x: circle.cx,\n    y: circle.cy\n  };\n\n  if (testPolygonPoint(polygon, center)) {\n    return true;\n  }\n\n  var num = polygon.edges.length;\n\n  for (var i = 0; i < num; i++) {\n    var edge = pointsToLine(polygon.edges[i]);\n\n    if (testCircleLine(circle, edge)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n   * Test if a Polygon contains a Point. If so, returns true and false otherwise.\n   * Polygon must contain at least 2 vertices\n   * @private\n   * @param {object} polygon\n   * @param {Array} polygon.vertices - Array of vertices\n   * @param {object} polygon.vertices.vertex\n   * @param {number} polygon.vertices.vertex.x - x-coordinate\n   * @param {number} polygon.vertices.vertex.y - y-coordinate\n   * @param {Array} polygon.edges - Array of edges\n   * @param {Array} polygon.edges.edge - Array of points\n   * @param {object} polygon.edges.edge.point\n   * @param {number} polygon.edges.edge.point.x - x-coordinate\n   * @param {number} polygon.edges.edge.point.y - y-coordinate\n   * @param {object} point\n   * @param {number} point.x - x-coordinate\n   * @param {number} point.y - y-coordinate\n   * @return {boolean} true if polygon conatins point\n  */\n\nfunction testPolygonPoint(polygon, point) {\n  // TODO handle polygon that is a straight line, current impl gives a non-deterministic output, that is depending on number of vertices\n  if (toFewEdges(polygon) || !testRectPoint(polygon.boundingRect(), point)) {\n    return false;\n  }\n\n  var even = true;\n  var num = polygon.vertices.length;\n  var rayStart = {\n    x: polygon.xMin - 1,\n    y: point.y\n  };\n\n  for (var i = 0; i < num - 1; i++) {\n    var edge = pointsToLine(polygon.edges[i]);\n\n    if (!(edge.y1 < point.y && edge.y2 < point.y) && !(edge.y1 > point.y && edge.y2 > point.y)) {\n      // filterout any edges that does not cross the ray\n      even = testLineLine(edge, pointsToLine([rayStart, point])) ? !even : even;\n    }\n  }\n\n  return !even;\n}\n/**\n   * Test if a Polygon collider with a line. If so, returns true and false otherwise.\n   * Polygon must contain at least 3 edges.\n   * Line must have length greater then 0.\n   * @private\n   * @param {object} polygon\n   * @param {Array} polygon.vertices - Array of vertices\n   * @param {object} polygon.vertices.vertex\n   * @param {number} polygon.vertices.vertex.x - x-coordinate\n   * @param {number} polygon.vertices.vertex.y - y-coordinate\n   * @param {Array} polygon.edges - Array of edges\n   * @param {Array} polygon.edges.edge - Array of points\n   * @param {object} polygon.edges.edge.point\n   * @param {number} polygon.edges.edge.point.x - x-coordinate\n   * @param {number} polygon.edges.edge.point.y - y-coordinate\n   * @param {object} line\n   * @param {number} line.x1 - x-coordinate\n   * @param {number} line.y1 - y-coordinate\n   * @param {number} line.x1 - x-coordinate\n   * @param {number} line.y1 - y-coordinate\n   * @return {boolean} true if polygon collider with line\n  */\n\nfunction testPolygonLine(polygon, line) {\n  // TODO handle polygon that is a straight line, current impl gives a non-deterministic output, that is depending on number of vertices\n  if (toFewEdges(polygon)) {\n    return false;\n  }\n\n  for (var i = 0, num = polygon.edges.length; i < num; i++) {\n    var edge = pointsToLine(polygon.edges[i]);\n\n    if (testLineLine(line, edge)) {\n      return true;\n    }\n  }\n\n  var _lineToPoints3 = lineToPoints(line),\n      _lineToPoints4 = _slicedToArray(_lineToPoints3, 2),\n      p1 = _lineToPoints4[0],\n      p2 = _lineToPoints4[1];\n\n  return testPolygonPoint(polygon, p1) || testPolygonPoint(polygon, p2);\n}\n/**\n   * Test if a Polygon collider with a rectangle. If so, returns true and false otherwise.\n   * Polygon must contain at least 3 edges.\n   * Rectangle must width and height greater then 0.\n   * @private\n   * @param {object} polygon\n   * @param {Array} polygon.vertices - Array of vertices\n   * @param {object} polygon.vertices.vertex\n   * @param {number} polygon.vertices.vertex.x - x-coordinate\n   * @param {number} polygon.vertices.vertex.y - y-coordinate\n   * @param {Array} polygon.edges - Array of edges\n   * @param {Array} polygon.edges.edge - Array of points\n   * @param {object} polygon.edges.edge.point\n   * @param {number} polygon.edges.edge.point.x - x-coordinate\n   * @param {number} polygon.edges.edge.point.y - y-coordinate\n   * @param {object} rect\n   * @param {number} rect.x - x-coordinate\n   * @param {number} rect.y - y-coordinate\n   * @param {number} rect.width - width\n   * @param {number} rect.height - height\n   * @return {boolean} true if polygon collider with rect\n  */\n\nfunction testPolygonRect(polygon, rect) {\n  // TODO handle polygon that is a straight line, current impl gives a non-deterministic output, that is depending on number of vertices\n  if (toFewEdges(polygon)) {\n    return false;\n  }\n\n  for (var i = 0, num = polygon.edges.length; i < num; i++) {\n    var edge = pointsToLine(polygon.edges[i]);\n\n    if (testRectLine(rect, edge)) {\n      return true;\n    }\n  }\n\n  var _rectToPoints = rectToPoints(rect),\n      _rectToPoints2 = _slicedToArray(_rectToPoints, 4),\n      p1 = _rectToPoints2[0],\n      p2 = _rectToPoints2[1],\n      p3 = _rectToPoints2[2],\n      p4 = _rectToPoints2[3];\n\n  return testPolygonPoint(polygon, p1) || testPolygonPoint(polygon, p2) || testPolygonPoint(polygon, p3) || testPolygonPoint(polygon, p4);\n}\n/**\n   * Test if a Rectangle collide with another rectangle. If so, returns true and false otherwise.\n   * Both rectangles must have a width and height greather then 0.\n   * @private\n   * @param {object} rect\n   * @param {number} rect.x - x-coordinate\n   * @param {number} rect.y - y-coordinate\n   * @param {number} rect.width - width\n   * @param {number} rect.height - height\n   * @param {object} rect\n   * @param {number} rect.x - x-coordinate\n   * @param {number} rect.y - y-coordinate\n   * @param {number} rect.width - width\n   * @param {number} rect.height - height\n   * @return {boolean} true if rectangle collide with rectangle\n  */\n\nfunction testRectRect(rect1, rect2) {\n  if (rectHasNoSize(rect1) || rectHasNoSize(rect2)) {\n    return false;\n  }\n\n  return rect1.x <= rect2.x + rect2.width && rect2.x <= rect1.x + rect1.width && rect1.y <= rect2.y + rect2.height && rect2.y <= rect1.y + rect1.height;\n}\n/**\n   * Test if a Rectangle contains a Point. If so, returns true and false otherwise.\n   * Rectangle must have a width and height greather then 0.\n   * @private\n   * @param {object} rect\n   * @param {number} rect.x - x-coordinate\n   * @param {number} rect.y - y-coordinate\n   * @param {number} rect.width - width\n   * @param {number} rect.height - height\n   * @param {object} point\n   * @param {number} point.x - x-coordinate\n   * @param {number} point.y - y-coordinate\n   * @return {boolean} true if rectangle contains point\n  */\n\nfunction testRectPoint(rect, point) {\n  if (rectHasNoSize(rect)) {\n    return false;\n  }\n\n  return point.x >= rect.x && point.x <= rect.x + rect.width && point.y >= rect.y && point.y <= rect.y + rect.height;\n}\n/**\n   * Test if a Rectangle collider with a line. If so, returns true and false otherwise.\n   * Rectangle must have a width and height greather then 0.\n   * Line must have length greater then 0.\n   * @private\n   * @param {object} rect\n   * @param {number} rect.x - x-coordinate\n   * @param {number} rect.y - y-coordinate\n   * @param {number} rect.width - width\n   * @param {number} rect.height - height\n   * @param {object} line\n   * @param {number} line.x1 - x-coordinate\n   * @param {number} line.y1 - y-coordinate\n   * @param {number} line.x1 - x-coordinate\n   * @param {number} line.y1 - y-coordinate\n   * @return {boolean} true if rectangle collide with line\n  */\n\nfunction testRectLine(rect, line) {\n  if (lineHasNoLength(line) || rectHasNoSize(rect)) {\n    return false;\n  }\n\n  var _lineToPoints5 = lineToPoints(line),\n      _lineToPoints6 = _slicedToArray(_lineToPoints5, 2),\n      p1 = _lineToPoints6[0],\n      p2 = _lineToPoints6[1];\n\n  if (testRectPoint(rect, p1) || testRectPoint(rect, p2)) {\n    return true;\n  }\n\n  var rectEdges = rectToPoints(rect);\n  var num = rectEdges.length;\n\n  for (var i = 0; i < num; i++) {\n    var edge = pointsToLine([rectEdges[i], rectEdges[i !== 3 ? i + 1 : 0]]);\n\n    if (testLineLine(edge, line)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n   * Test if a Line collider with another line. If so, returns true and false otherwise.\n   * Both lines must have length greater then 0.\n   * @private\n   * @param {object} line\n   * @param {number} line.x1 - x-coordinate\n   * @param {number} line.y1 - y-coordinate\n   * @param {number} line.x1 - x-coordinate\n   * @param {number} line.y1 - y-coordinate\n   * @param {object} line\n   * @param {number} line.x1 - x-coordinate\n   * @param {number} line.y1 - y-coordinate\n   * @param {number} line.x1 - x-coordinate\n   * @param {number} line.y1 - y-coordinate\n   * @return {boolean} true if line collide with line\n  */\n\nfunction testLineLine(line1, line2) {\n  var _lineToPoints7 = lineToPoints(line1),\n      _lineToPoints8 = _slicedToArray(_lineToPoints7, 2),\n      p1 = _lineToPoints8[0],\n      p2 = _lineToPoints8[1];\n\n  var _lineToPoints9 = lineToPoints(line2),\n      _lineToPoints10 = _slicedToArray(_lineToPoints9, 2),\n      p3 = _lineToPoints10[0],\n      p4 = _lineToPoints10[1];\n\n  var dx1 = distanceX(p2, p1);\n  var dy1 = distanceY(p2, p1);\n  var dx2 = distanceX(p4, p3);\n  var dy2 = distanceY(p4, p3);\n  var dx3 = distanceX(p1, p3);\n  var dy3 = distanceY(p1, p3);\n  var ub = dy2 * dx1 - dx2 * dy1;\n  var uat = dx2 * dy3 - dy2 * dx3;\n  var ubt = dx1 * dy3 - dy1 * dx3;\n  var t1;\n  var t2;\n\n  if (dx1 === 0 && dy1 === 0) {\n    // Line segment has no length\n    return false;\n  }\n\n  if (dx2 === 0 && dy2 === 0) {\n    // Line segment has no length\n    return false;\n  }\n\n  if (ub === 0) {\n    if (uat === 0 && ubt === 0) {\n      // COINCIDENT;\n      if (dx1 === 0) {\n        if (dy1 === 0) {\n          // p1 = p2\n          return p1.x === p2.x && p1.y === p2.y;\n        }\n\n        t1 = distanceY(p3, p1) / dy1;\n        t2 = distanceY(p4, p1) / dy1;\n      } else {\n        t1 = (p3.x - p1.x) / dx1;\n        t2 = (p4.x - p1.x) / dx1;\n      }\n\n      if (t1 < 0 && t2 < 0 || t1 > 1 && t2 > 1) {\n        return false;\n      }\n\n      return true;\n    }\n\n    return false; // PARALLEL;\n  }\n\n  var ua = uat / ub;\n  ub = ubt / ub;\n\n  if (ua >= 0.0 && ua <= 1.0 && ub >= 0.0 && ub <= 1.0) {\n    return true;\n  }\n\n  return false;\n}\n/**\n   * Test if a Line contains a Point. If so, returns true and false otherwise.\n   * Line must have length greater then 0.\n   * @private\n   * @param {object} line\n   * @param {number} line.x1 - x-coordinate\n   * @param {number} line.y1 - y-coordinate\n   * @param {number} line.x1 - x-coordinate\n   * @param {number} line.y1 - y-coordinate\n   * @param {object} point\n   * @param {number} point.x - x-coordinate\n   * @param {number} point.y - y-coordinate\n   * @return {boolean} true if line contains point\n  */\n\nfunction testLinePoint(line, point) {\n  if (lineHasNoLength(line)) {\n    return false;\n  }\n\n  var _lineToPoints11 = lineToPoints(line),\n      _lineToPoints12 = _slicedToArray(_lineToPoints11, 2),\n      p1 = _lineToPoints12[0],\n      p2 = _lineToPoints12[1];\n\n  return isPointOnLine(p1, p2, point);\n}\n\nvar VARIABLE_RX = /^\\$/;\nvar EXTEND = '@extend';\n\nfunction throwCyclical(s) {\n  throw new Error(\"Cyclical reference for \\\"\".concat(s, \"\\\"\"));\n}\n\nfunction res(style, references, path) {\n  if (typeof style === 'string') {\n    var value = references[style];\n\n    if (path.indexOf(style) !== -1) {\n      throwCyclical(style);\n    }\n\n    if (VARIABLE_RX.test(value)) {\n      path.push(style);\n      return res(value, references, path);\n    }\n\n    return value;\n  }\n\n  var computed = style;\n  var refs = extend(true, {}, references, style);\n  var s = {};\n\n  if (style[EXTEND]) {\n    var extendFrom = style[EXTEND];\n\n    if (path.indexOf(extendFrom) !== -1) {\n      throwCyclical(extendFrom);\n    }\n\n    var pext = path.slice();\n    pext.push(extendFrom);\n    computed = extend(true, {}, res(refs[extendFrom], references, pext), style);\n  }\n\n  Object.keys(computed).forEach(function (key) {\n    var p = path.slice();\n\n    if (key === EXTEND || VARIABLE_RX.test(key)) {\n      return;\n    }\n\n    s[key] = computed[key];\n    var value = s[key];\n\n    if (VARIABLE_RX.test(value) && value in refs) {\n      if (path.indexOf(value) !== -1) {\n        throwCyclical(value);\n      }\n\n      p.push(value);\n      value = refs[value];\n\n      if (_typeof(value) === 'object') {\n        s[key] = res(value, refs, p);\n      } else if (VARIABLE_RX.test(value) && value in refs) {\n        s[key] = res(value, refs, p);\n      } else {\n        s[key] = value;\n      }\n    } else if (_typeof(value) === 'object') {\n      s[key] = res(value, refs, p);\n    }\n  });\n  return s;\n}\n/**\n * Resolve style references\n * @private\n * @param {style-object} style\n * @param {style-object} references\n * @returns {object} The resolved style\n * @example\n * resolve({\n *   label: '$label--big'\n * }, {\n *   '$size--m': '12px',\n *   '$label--big': {\n *     fontFamily: 'Arial',\n *     fontSize: '$size--m'\n *   }\n * }); // { label: { fontFamily: 'Arial', fontSize: '12px' } }\n */\n\n\nfunction resolve(style, references) {\n  return res(style, references, []);\n}\n\nfunction themeFn() {\n  var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var palettes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var pals = {};\n  var internalStyle = style;\n\n  var setPalettes = function setPalettes(p) {\n    p.forEach(function (palette) {\n      var pal = Array.isArray(palette.colors[0]) ? palette.colors : [palette.colors];\n      pals[palette.key] = {\n        colors: pal,\n        sizes: pal.map(function (colors) {\n          return colors ? colors.length : 0;\n        })\n      };\n    });\n  };\n\n  var getPalette = function getPalette(key, num) {\n    var palette = pals[key];\n\n    if (!palette) {\n      return [];\n    }\n\n    var sizes = palette.sizes; // find the first color set containing at least 'num' colors\n\n    for (var i = 0; i < sizes.length; i++) {\n      if (num <= sizes[i]) {\n        return palette.colors[i];\n      }\n    }\n\n    return palette.colors[sizes.length - 1];\n  };\n  /**\n   * Theme API\n   * @private\n   * @experimental\n   */\n\n\n  var theme = {\n    /**\n     * Get an array of colors\n     * @param {string} name - Name of the color palette\n     * @param {number} [num] - The minimum number of colors to get from the palette\n     */\n    palette: function palette(name, num) {\n      return getPalette(name, num);\n    },\n    setPalettes: setPalettes,\n\n    /**\n     * Resolve style references\n     * @param {style-object} s - Object containing style\n     */\n    style: function style(s) {\n      return resolve(s, internalStyle);\n    },\n\n    /**\n     * Set custom style\n     * @param {style-object} s - Object containing style\n     */\n    setStyle: function setStyle(s) {\n      internalStyle = extend({}, style, s);\n    }\n  };\n  setPalettes(palettes);\n  return theme;\n}\n\n/**\n * @typedef {object} component-settings\n * @property {string} type - Component type (ex: axis, point, ...)\n * @property {function} [preferredSize] - Function returning the preferred size\n * @property {function} [created]\n * @property {function} [beforeMount]\n * @property {function} [mounted]\n * @property {function} [beforeUpdate]\n * @property {function} [updated]\n * @property {function} [beforeRender]\n * @property {function} [beforeDestroy]\n * @property {function} [destroyed]\n * @property {brush-setting} [brush] see [brushing](./brushing.md)\n * @property {object} [layout] Layout settings\n * @property {number} [layout.displayOrder = 0]\n * @property {number} [layout.prioOrder = 0]\n * @property {string | {width: string, height: string}} [layout.minimumLayoutMode] Refer to layout sizes defined by layoutModes in `strategy`\n * @property {string} [layout.dock] left, right, top or bottom\n * @property {boolean} [show = true] If the component should be rendered\n * @property {string} [scale] Named scale. Will be provided to the component if it ask for it.\n * @property {string} [formatter] Named formatter. Fallback to create formatter from scale. Will be provided to the component if it ask for it.\n */\n\nfunction addComponentDelta(shape, containerBounds, componentBounds) {\n  var dx = containerBounds.left - componentBounds.left;\n  var dy = containerBounds.top - componentBounds.top;\n  var type = getShapeType(shape);\n  var deltaShape = extend(true, {}, shape);\n\n  switch (type) {\n    case 'circle':\n      deltaShape.cx += dx;\n      deltaShape.cy += dy;\n      break;\n\n    case 'polygon':\n      for (var i = 0, num = deltaShape.vertices.length; i < num; i++) {\n        var v = deltaShape.vertices[i];\n        v.x += dx;\n        v.y += dy;\n      }\n\n      break;\n\n    case 'line':\n      deltaShape.x1 += dx;\n      deltaShape.y1 += dy;\n      deltaShape.x2 += dx;\n      deltaShape.y2 += dy;\n      break;\n\n    case 'point':\n    case 'rect':\n      deltaShape.x += dx;\n      deltaShape.y += dy;\n      break;\n\n    default:\n      break;\n  }\n\n  return deltaShape;\n}\n\nvar moveToPosition = function moveToPosition(element, comp, index) {\n  var el = comp.instance.renderer().element();\n\n  if (isNaN(index) || !el || !element || !element.children) {\n    return;\n  }\n\n  var nodes = element.children;\n  var i = Math.max(0, index);\n  var node = nodes[i];\n\n  if (el === node) {\n    return;\n  }\n\n  var additionalEl = comp.instance.def.additionalElements && comp.instance.def.additionalElements().filter(Boolean);\n\n  if (element.insertBefore && typeof node !== 'undefined') {\n    element.insertBefore(el, node);\n\n    if (additionalEl) {\n      additionalEl.forEach(function (ae) {\n        element.insertBefore(ae, el);\n      });\n    }\n  } else {\n    if (additionalEl) {\n      additionalEl.forEach(function (ae) {\n        element.appendChild(ae, el);\n      });\n    }\n\n    element.appendChild(el);\n  }\n};\n\nfunction orderComponents(element, visibleComponents, order) {\n  var elToIdx = [];\n  var numElements = 0;\n  var ordered = order ? visibleComponents.slice().sort(function (a, b) {\n    return order[visibleComponents.indexOf(a)] - order[visibleComponents.indexOf(b)];\n  }) : visibleComponents;\n  ordered.forEach(function (comp) {\n    elToIdx.push(numElements); // assume each component has at least one element\n\n    numElements++; // check additional elements\n\n    var additionalEl = comp.instance.def.additionalElements && comp.instance.def.additionalElements();\n\n    if (additionalEl) {\n      numElements += additionalEl.length;\n    }\n  });\n  ordered.forEach(function (comp, i) {\n    return moveToPosition(element, comp, elToIdx[i]);\n  });\n}\n\nfunction chartFn(definition, context) {\n  /**\n   * @typedef {object} chart-definition\n   */\n  var element = definition.element,\n      _definition$data = definition.data,\n      data = _definition$data === void 0 ? [] : _definition$data,\n      _definition$settings = definition.settings,\n      settings = _definition$settings === void 0 ? {} : _definition$settings,\n      _definition$on = definition.on,\n      on = _definition$on === void 0 ? {} : _definition$on;\n  var registries = context.registries;\n  var logger = context.logger;\n  var theme = themeFn(context.style, context.palettes);\n  var listeners = [];\n  /**\n   * @alias chart\n   * @interface\n   */\n\n  var instance = extend({}, definition);\n  var mediator$1 = mediator();\n  var currentComponents = []; // Augmented components\n\n  var visibleComponents = [];\n  var currentScales = null; // Built scales\n\n  var currentFormatters = null; // Built formatters\n\n  var currentScrollApis = null; // Build scroll apis\n\n  var currentInteractions = [];\n\n  var dataset = function dataset() {};\n\n  var dataCollection = function dataCollection() {};\n\n  var brushes = {};\n  var stopBrushing = false;\n\n  var createComponent = function createComponent(compSettings, container) {\n    if (!registries.component.has(compSettings.type)) {\n      logger.warn(\"Unknown component: \".concat(compSettings.type));\n      return false;\n    }\n\n    var componentDefinition = registries.component(compSettings.type);\n    var compInstance = componentFactory(componentDefinition, {\n      settings: compSettings,\n      chart: instance,\n      mediator: mediator$1,\n      registries: registries,\n      theme: theme,\n      container: container\n    });\n    return {\n      instance: compInstance,\n      settings: extend(true, {}, compSettings),\n      key: compSettings.key,\n      hasKey: typeof compSettings.key !== 'undefined'\n    };\n  }; // Create a callback that calls lifecycle functions in the definition and config (if they exist).\n\n\n  function createCallback(method) {\n    var defaultMethod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n    return function cb() {\n      var inDefinition = typeof definition[method] === 'function';\n      var returnValue;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      if (inDefinition) {\n        var _definition$method;\n\n        returnValue = (_definition$method = definition[method]).call.apply(_definition$method, [instance].concat(args));\n      } else {\n        returnValue = defaultMethod.call.apply(defaultMethod, [instance].concat(args));\n      }\n\n      return returnValue;\n    };\n  }\n\n  var findComponent = function findComponent(componentInstance) {\n    for (var i = 0; i < currentComponents.length; i++) {\n      if (currentComponents[i].instance === componentInstance) {\n        return currentComponents[i];\n      }\n    }\n\n    return null;\n  };\n\n  var findComponentIndexByKey = function findComponentIndexByKey(key) {\n    for (var i = 0; i < currentComponents.length; i++) {\n      var currComp = currentComponents[i];\n\n      if (currComp.hasKey && currComp.key === key) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  function getElementRect(el) {\n    if (typeof el.getBoundingClientRect === 'function') {\n      var _el$getBoundingClient = el.getBoundingClientRect(),\n          width = _el$getBoundingClient.width,\n          height = _el$getBoundingClient.height;\n\n      return {\n        x: 0,\n        y: 0,\n        width: width,\n        height: height\n      };\n    }\n\n    return {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n  }\n\n  var layout = function layout(components) {\n    var vcomponents = components.map(function (c) {\n      var dockConfig = c.instance.dockConfig();\n      return {\n        instance: c.instance,\n        resize: c.instance.resize,\n        preferredSize: dockConfig.computePreferredSize.bind(dockConfig),\n        settings: c.settings,\n        layoutComponents: function layoutComponents() {}\n      };\n    });\n    var layoutSettings;\n\n    if (settings.dockLayout) {\n      logger.warn('Deprecation Warning: \"dockLayout\" property should be renamed to \"strategy\"');\n      layoutSettings = settings.dockLayout;\n    } else {\n      layoutSettings = settings.strategy;\n    }\n\n    var dockLayout$1 = dockLayout(layoutSettings);\n    var rect = getElementRect(element);\n\n    var _dockLayout$layout = dockLayout$1.layout(rect, vcomponents),\n        visible = _dockLayout$layout.visible,\n        hidden = _dockLayout$layout.hidden,\n        order = _dockLayout$layout.order;\n\n    return {\n      visible: visible.map(function (v) {\n        return findComponent(v.instance);\n      }),\n      hidden: hidden.map(function (h) {\n        return findComponent(h.instance);\n      }),\n      order: order\n    };\n  };\n\n  var created = createCallback('created');\n  var beforeMount = createCallback('beforeMount');\n  var mounted = createCallback('mounted');\n  var beforeUpdate = createCallback('beforeUpdate');\n  var updated = createCallback('updated');\n  var beforeRender = createCallback('beforeRender');\n  var beforeDestroy = createCallback('beforeDestroy');\n  var destroyed = createCallback('destroyed');\n\n  var set = function set(_data, _settings) {\n    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        partialData = _ref.partialData;\n\n    var _settings$formatters = _settings.formatters,\n        formatters = _settings$formatters === void 0 ? {} : _settings$formatters,\n        _settings$scales = _settings.scales,\n        scales = _settings$scales === void 0 ? {} : _settings$scales,\n        _settings$scroll = _settings.scroll,\n        scroll = _settings$scroll === void 0 ? {} : _settings$scroll;\n    dataset = datasets(_data, {\n      logger: logger,\n      types: registries.data\n    });\n\n    if (!partialData) {\n      Object.keys(brushes).forEach(function (b) {\n        return brushes[b].clear();\n      });\n    }\n\n    if (_settings.palettes) {\n      theme.setPalettes(_settings.palettes);\n    }\n\n    if (_settings.style) {\n      theme.setStyle(_settings.style);\n    }\n\n    dataCollection = create(_settings.collections, {\n      dataset: dataset\n    }, {\n      logger: logger\n    });\n    var deps = {\n      theme: theme,\n      logger: logger\n    };\n    currentScales = collection$1(scales, {\n      dataset: dataset,\n      collection: dataCollection\n    }, _objectSpread2({}, deps, {\n      scale: registries.scale\n    }));\n    currentFormatters = collection(formatters, {\n      dataset: dataset,\n      collection: dataCollection\n    }, _objectSpread2({}, deps, {\n      formatter: registries.formatter\n    }));\n    currentScrollApis = builder(scroll, currentScrollApis);\n  };\n\n  var render = function render() {\n    var _settings2 = settings,\n        _settings2$components = _settings2.components,\n        components = _settings2$components === void 0 ? [] : _settings2$components;\n    beforeRender();\n    set(data, settings);\n    currentComponents = components.map(function (compSettings) {\n      return createComponent(compSettings, element);\n    }).filter(function (c) {\n      return !!c;\n    });\n\n    var _layout = layout(currentComponents),\n        visible = _layout.visible,\n        hidden = _layout.hidden,\n        order = _layout.order;\n\n    visibleComponents = visible;\n    hidden.forEach(function (comp) {\n      comp.instance.hide();\n      comp.visible = false;\n    });\n    visible.forEach(function (comp) {\n      return comp.instance.beforeMount();\n    });\n    visible.forEach(function (comp) {\n      return comp.instance.mount();\n    });\n    visible.forEach(function (comp) {\n      return comp.instance.beforeRender();\n    });\n    visible.forEach(function (comp) {\n      return comp.instance.render();\n    });\n    visible.forEach(function (comp) {\n      return comp.instance.mounted();\n    });\n    visible.forEach(function (comp) {\n      comp.visible = true;\n    });\n    orderComponents(element, visibleComponents, order);\n  };\n\n  function setInteractions() {\n    var interactions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var current = {};\n    var newKeys = interactions.filter(function (it) {\n      return !!it.key;\n    }).map(function (it) {\n      return it.key;\n    });\n    currentInteractions.forEach(function (cit) {\n      if (cit.key && newKeys.indexOf(cit.key) !== -1) {\n        // keep old instance\n        current[cit.key] = cit;\n      } else {\n        cit.destroy();\n      }\n    });\n    currentInteractions = interactions.map(function (intSettings) {\n      var intDefinition = intSettings.key && current[intSettings.key] ? current[intSettings.key] : registries.interaction(intSettings.type)(instance, mediator$1, element);\n      intDefinition.set(intSettings);\n      return intDefinition;\n    });\n  }\n\n  var componentsFromPoint = function componentsFromPoint(p) {\n    var br = element.getBoundingClientRect();\n    var x = 'clientX' in p ? p.clientX : p.x;\n    var y = 'clientY' in p ? p.clientY : p.y;\n    var tp = {\n      x: x - br.left,\n      y: y - br.top\n    };\n    var ret = [];\n    visibleComponents.forEach(function (c) {\n      var r = c.instance.getRect(); // Do test on physical rect and use computed rect if available, otherwise fallback to computing a new rect for legacy support\n\n      if (testRectPoint(r.computedPhysical ? r.computedPhysical : {\n        x: r.margin.left + r.x * r.scaleRatio.x,\n        y: r.margin.top + r.y * r.scaleRatio.y,\n        width: r.width * r.scaleRatio.x,\n        height: r.height * r.scaleRatio.y\n      }, tp)) {\n        ret.push(c);\n      }\n    });\n    return ret;\n  };\n\n  var addDefaultEventListeners = function addDefaultEventListeners() {\n    if (listeners.length || !element) {\n      return;\n    }\n\n    Object.keys(on).forEach(function (key) {\n      var listener = on[key].bind(instance);\n      element.addEventListener(key, listener);\n      listeners.push({\n        key: key,\n        listener: listener\n      });\n    });\n    var eventInfo = {};\n\n    var onTapDown = function onTapDown(e) {\n      if (e.touches) {\n        eventInfo.x = e.touches[0].clientX;\n        eventInfo.y = e.touches[0].clientY;\n        eventInfo.multiTouch = e.touches.length > 1;\n      } else {\n        eventInfo.x = e.clientX;\n        eventInfo.y = e.clientY;\n        eventInfo.multiTouch = false;\n      }\n\n      eventInfo.time = Date.now();\n      eventInfo.comps = componentsFromPoint(eventInfo);\n    };\n\n    var onBrushTap = function onBrushTap(e) {\n      var comps = eventInfo.comps || componentsFromPoint(e);\n\n      if (comps.every(function (c) {\n        return c.instance.def.disableTriggers;\n      })) {\n        return;\n      }\n\n      if (e.type === 'touchend') {\n        e.preventDefault();\n      }\n\n      if (!isValidTapEvent(e, eventInfo)) {\n        return;\n      }\n\n      for (var i = comps.length - 1; i >= 0; i--) {\n        var comp = comps[i];\n        comp.instance.onBrushTap(e);\n\n        if (stopBrushing) {\n          stopBrushing = false;\n          break;\n        }\n      }\n    };\n\n    var onBrushOver = function onBrushOver(e) {\n      var comps = componentsFromPoint(e);\n\n      for (var i = comps.length - 1; i >= 0; i--) {\n        var comp = comps[i];\n        comp.instance.onBrushOver(e);\n\n        if (stopBrushing) {\n          stopBrushing = false;\n          break;\n        }\n      }\n    };\n\n    var brushEventList = [];\n    brushEventList.push({\n      key: 'mousedown',\n      listener: onTapDown\n    });\n    brushEventList.push({\n      key: 'mouseup',\n      listener: onBrushTap\n    });\n\n    if (detectTouchSupport(element)) {\n      brushEventList.push({\n        key: 'touchstart',\n        listener: onTapDown\n      });\n      brushEventList.push({\n        key: 'touchend',\n        listener: onBrushTap\n      });\n    }\n\n    brushEventList.push({\n      key: 'mousemove',\n      listener: onBrushOver\n    });\n    brushEventList.forEach(function (event) {\n      element.addEventListener(event.key, event.listener);\n      listeners.push(event);\n    });\n  };\n\n  var removeDefaultEventListeners = function removeDefaultEventListeners() {\n    listeners.forEach(function (_ref2) {\n      var key = _ref2.key,\n          listener = _ref2.listener;\n      return element.removeEventListener(key, listener);\n    });\n    listeners.length = 0;\n  }; // Browser only\n\n\n  var mount = function mount() {\n    element.innerHTML = '';\n    render();\n    addDefaultEventListeners();\n    setInteractions(settings.interactions);\n  };\n\n  var unmount = function unmount() {\n    removeDefaultEventListeners();\n    setInteractions();\n  };\n  /**\n   * Update the chart with new settings and / or data\n   * @param {chart-definition} [chart] - Chart definition\n   */\n\n\n  instance.update = function () {\n    var newProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var partialData = newProps.partialData,\n        _newProps$excludeFrom = newProps.excludeFromUpdate,\n        excludeFromUpdate = _newProps$excludeFrom === void 0 ? [] : _newProps$excludeFrom;\n    var visibleOrder;\n\n    if (newProps.data) {\n      data = newProps.data;\n    }\n\n    if (newProps.settings) {\n      settings = newProps.settings;\n      setInteractions(newProps.settings.interactions);\n    }\n\n    beforeUpdate();\n    set(data, settings, {\n      partialData: partialData\n    });\n    var _settings3 = settings,\n        formatters = _settings3.formatters,\n        scales = _settings3.scales,\n        _settings3$components = _settings3.components,\n        components = _settings3$components === void 0 ? [] : _settings3$components;\n\n    var _loop = function _loop(i) {\n      var currComp = currentComponents[i]; // TODO warn when there is no key\n\n      if (!components.some(function (c) {\n        return currComp.hasKey && currComp.key === c.key;\n      })) {\n        // Component is removed\n        currentComponents.splice(i, 1);\n        currComp.instance.destroy();\n      }\n    };\n\n    for (var i = currentComponents.length - 1; i >= 0; i--) {\n      _loop(i);\n    } // Let the \"components\" array determine order of components\n\n\n    currentComponents = components.map(function (comp) {\n      var idx = findComponentIndexByKey(comp.key); // Component should not be updated\n\n      if (excludeFromUpdate.indexOf(comp.key) > -1) {\n        return currentComponents[idx];\n      }\n\n      if (idx === -1) {\n        // Component is added\n        return createComponent(comp, element);\n      } // Component is (potentially) updated\n\n\n      currentComponents[idx].updateWith = {\n        formatters: formatters,\n        scales: scales,\n        data: data,\n        settings: comp\n      };\n      return currentComponents[idx];\n    }).filter(function (c) {\n      return !!c;\n    });\n    currentComponents.forEach(function (comp) {\n      if (comp.updateWith) {\n        comp.instance.set(comp.updateWith);\n      }\n    });\n    currentComponents.forEach(function (comp) {\n      if (comp.updateWith) {\n        comp.instance.beforeUpdate();\n      }\n    });\n    var toUpdate = [];\n    var toRender = [];\n    var toRenderOrUpdate;\n\n    if (partialData) {\n      currentComponents.forEach(function (comp) {\n        if (comp.updateWith && comp.visible) {\n          toUpdate.push(comp);\n        }\n      });\n      toRenderOrUpdate = toUpdate;\n    } else {\n      var _layout2 = layout(currentComponents),\n          visible = _layout2.visible,\n          hidden = _layout2.hidden,\n          order = _layout2.order; // Relayout\n\n\n      visibleComponents = visible;\n      toRenderOrUpdate = visible;\n      visibleOrder = order;\n      visible.forEach(function (comp) {\n        if (comp.updateWith && comp.visible) {\n          toUpdate.push(comp);\n        } else {\n          toRender.push(comp);\n        }\n      });\n      hidden.forEach(function (comp) {\n        comp.instance.hide();\n        comp.visible = false;\n        delete comp.updateWith;\n      });\n    }\n\n    toRender.forEach(function (comp) {\n      return comp.instance.beforeMount();\n    });\n    toRender.forEach(function (comp) {\n      return comp.instance.mount();\n    });\n    toRenderOrUpdate.forEach(function (comp) {\n      return comp.instance.beforeRender();\n    });\n    toRenderOrUpdate.forEach(function (comp) {\n      if (comp.updateWith && comp.visible) {\n        comp.instance.update();\n      } else {\n        comp.instance.render();\n      }\n    }); // Ensure that displayOrder is keept, only do so on re-layout update.\n    // Which is only the case if partialData is false.\n\n    if (!partialData) {\n      orderComponents(element, visibleComponents, visibleOrder);\n    }\n\n    toRender.forEach(function (comp) {\n      return comp.instance.mounted();\n    });\n    toUpdate.forEach(function (comp) {\n      return comp.instance.updated();\n    });\n    visibleComponents.forEach(function (comp) {\n      delete comp.updateWith;\n      comp.visible = true;\n    });\n    updated();\n  };\n  /**\n   * Destroy the chart instance.\n   */\n\n\n  instance.destroy = function () {\n    beforeDestroy();\n    currentComponents.forEach(function (comp) {\n      return comp.instance.destroy();\n    });\n    currentComponents = [];\n    unmount();\n    delete instance.update;\n    delete instance.destroy;\n    destroyed();\n  };\n  /**\n   * Get all shapes associated with the provided context\n   * @param {string} context The brush context\n   * @param {string} mode Property comparasion mode.\n   * @param {Array<string>} props Which specific data properties to compare\n   * @param {string} key Which component to get shapes from. Default gives shapes from all components.\n   * @return {Array<object>} Array of objects containing shape and parent element\n   */\n\n\n  instance.getAffectedShapes = function (ctx) {\n    var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'and';\n    var props = arguments.length > 2 ? arguments[2] : undefined;\n    var key = arguments.length > 3 ? arguments[3] : undefined;\n    var shapes = [];\n    currentComponents.filter(function (comp) {\n      return key === undefined || key === null || comp.key === key;\n    }).forEach(function (comp) {\n      shapes.push.apply(shapes, _toConsumableArray$1(comp.instance.getBrushedShapes(ctx, mode, props)));\n    });\n    return shapes;\n  };\n  /**\n   * Get all nodes matching the provided selector\n   * @param {string} selector CSS selector [type, attribute, universal, class]\n   * @returns {Array<SceneNode>} Array of objects containing matching nodes\n   *\n   * @example\n   * chart.findShapes('Circle') // [<CircleNode>, <CircleNode>]\n   * chart.findShapes('Circle[fill=\"red\"][stroke!=\"black\"]') // [CircleNode, CircleNode]\n   * chart.findShapes('Container Rect') // [Rect, Rect]\n   */\n\n\n  instance.findShapes = function (selector) {\n    var shapes = [];\n    visibleComponents.forEach(function (c) {\n      shapes.push.apply(shapes, _toConsumableArray$1(c.instance.findShapes(selector)));\n    });\n    return shapes;\n  };\n  /**\n   * Get components overlapping a point.\n   * @param {point} p - Point with x- and y-cooridnate. The coordinate is relative to the browser viewport.\n   * @returns {Array<component-context>} Array of component contexts\n   */\n\n\n  instance.componentsFromPoint = function (p) {\n    return componentsFromPoint(p).map(function (comp) {\n      return comp.instance.ctx;\n    });\n  };\n  /**\n   * Get all nodes colliding with a geometrical shape (circle, line, rectangle, point, polygon).\n   *\n   * The input shape is identified based on the geometrical attributes in the following order: circle => line => rectangle => point => polygon.\n   * Note that not all nodes on a scene have collision detection enabled.\n   * @param {line|rect|point|circle} shape - A geometrical shape. Coordinates are relative to the top-left corner of the chart instance container.\n   * @param {object} opts - Options\n   * @param {object[]} [opts.components] - Array of components to include in the lookup. If no components are specified, all components will be included.\n   * @param {string} [opts.components[].component.key] - Component key\n   * @param {string} [opts.components[].component.propagation] - if set to `stop`, will start lookup on top visible shape and propagate downwards until a shape is found.\n   * @param {string} [opts.propagation] - if set to `stop`, will start lookup on top visible component and propagate downwards until a component has at least a match.\n   * @returns {Array<SceneNode>} Array of objects containing colliding nodes\n   *\n   * @example\n   * chart.shapesAt(\n   *  {\n   *    x: 0,\n   *    y: 0,\n   *    width: 100,\n   *    height: 100\n   *  },\n   *  {\n   *    components: [\n   *      { key: 'key1', propagation: 'stop' },\n   *      { key: 'key2' }\n   *    ],\n   *    propagation: 'stop'\n   *  }\n   * );\n   */\n\n\n  instance.shapesAt = function (shape) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var result = [];\n    var containerBounds = element.getBoundingClientRect();\n    var comps = visibleComponents; // Assume that visibleComponents is ordererd according to displayOrder\n\n    if (Array.isArray(opts.components) && opts.components.length > 0) {\n      var compKeys = opts.components.map(function (c) {\n        return c.key;\n      });\n      comps = visibleComponents.filter(function (c) {\n        return compKeys.indexOf(c.key) !== -1;\n      }).map(function (c) {\n        return {\n          instance: c.instance,\n          opts: opts.components[compKeys.indexOf(c.key)]\n        };\n      });\n    }\n\n    for (var i = comps.length - 1; i >= 0; i--) {\n      var c = comps[i];\n      var componentBounds = c.instance.renderer().element().getBoundingClientRect();\n      var deltaShape = addComponentDelta(shape, containerBounds, componentBounds);\n      var shapes = c.instance.shapesAt(deltaShape, c.opts);\n      var stopPropagation = shapes.length > 0 && opts.propagation === 'stop';\n      result.push.apply(result, _toConsumableArray$1(shapes));\n\n      if (result.length > 0 && stopPropagation) {\n        return result;\n      }\n    }\n\n    return result;\n  };\n  /**\n   * Brush data by providing a collection of data bound shapes.\n   * @param {SceneNode[]} shapes - An array of data bound shapes.\n   * @param {object} config - Options\n   * @param {Array<object>} opts.components - Array of components to include in the lookup.\n   * @param {string} [opts.components.component.key] - Component key\n   * @param {Array<string>} [opts.components.component.contexts] - Name of the brushing contexts to affect\n   * @param {Array<string>} [opts.components.component.data] - The mapped data properties to add to the brush\n   * @param {string} [opts.components.component.action] - Type of action to respond with\n   *\n   * @example\n   * const shapes = chartInstance.shapesAt(...);\n   * const config = {\n   *  components:[\n   *    {\n   *      key: 'key1',\n   *      contexts: ['myContext'],\n   *      data: [''],\n   *      action: 'add'\n   *    }\n   *  ]\n   * };\n   * chartInstance.brushFromShapes(shapes, config);\n   */\n\n\n  instance.brushFromShapes = function (shapes) {\n    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      components: []\n    };\n\n    var _loop2 = function _loop2(i) {\n      var iKey = config.components[i].key;\n      visibleComponents.filter(function (c) {\n        return iKey === c.key;\n      }).forEach(function (c) {\n        var compShapes = shapes.filter(function (shape) {\n          return shape.key === c.key;\n        });\n        c.instance.brushFromShapes(compShapes, config.components[i]);\n      });\n    };\n\n    for (var i = 0; i < config.components.length; i++) {\n      _loop2(i);\n    }\n  };\n  /**\n   * @param {string} name - Name of scroll api\n   * @returns {scroll}\n   */\n\n\n  instance.scroll = function scroll() {\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';\n    return getOrCreateScrollApi(name, currentScrollApis);\n  };\n  /**\n   * Get\n   * @param {string} key - Get the dataset identified by `key`\n   * @returns {dataset}\n   */\n\n\n  instance.dataset = function (key) {\n    return dataset(key);\n  };\n\n  instance.dataCollection = function (key) {\n    return dataCollection(key);\n  };\n  /**\n   * Get all registered scales\n   * @returns {Object<string,scale>}\n   */\n\n\n  instance.scales = function scales() {\n    return currentScales.all();\n  };\n  /**\n   * Get all registered formatters\n   * @returns {Object<string,formatter>}\n   */\n\n\n  instance.formatters = function formatters() {\n    return currentFormatters.all();\n  };\n  /**\n   * Get or create brush context for this chart\n   * @param {string} name - Name of the brush context. If no match is found, a new brush context is created and returned.\n   * @returns {brush}\n   */\n\n\n  instance.brush = function brushFn() {\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';\n\n    if (!brushes[name]) {\n      brushes[name] = brush();\n    }\n\n    return brushes[name];\n  };\n  /**\n   * Get or create a scale for this chart\n   * @param {string|object} v - Scale reference or scale options\n   * @returns {scale}\n   * @example\n   * instance.scale('nameOfMyScale'); // Fetch an existing scale by name\n   * instance.scale({ scale: 'nameOfMyScale' }); // Fetch an existing scale by name\n   * instance.scale({ source: '0/1', type: 'linear' }); // Create a new scale\n   */\n\n\n  instance.scale = function scale(v) {\n    return currentScales.get(v);\n  };\n  /**\n   * Get or create a formatter for this chart\n   * @param {string|object} v - Formatter reference or formatter options\n   * @returns {formatter}\n   * @example\n   * instance.formatter('nameOfMyFormatter'); // Fetch an existing formatter by name\n   * instance.formatter({ formatter: 'nameOfMyFormatter' }); // Fetch an existing formatter by name\n   * instance.formatter({ type: 'q' }); // Fetch an existing formatter by type\n   * instance.formatter({\n   *  formatter: 'd3',\n   *  type: 'number',\n   *  format: '1.0.%'\n   * }); // Create a new formatter\n   */\n\n\n  instance.formatter = function formatter(v) {\n    return currentFormatters.get(v);\n  };\n  /**\n   * @param {boolean} [val] - Toggle brushing on or off. If value is omitted, a toggle action is applied to the current state.\n   */\n\n\n  instance.toggleBrushing = function toggleBrushing(val) {\n    if (typeof val !== 'undefined') {\n      stopBrushing = val;\n    } else {\n      stopBrushing = !stopBrushing;\n    }\n  };\n  /**\n   * Get a component context\n   * @param {string} key - Component key\n   * @returns {component-context} Component context\n   */\n\n\n  instance.component = function (key) {\n    var idx = findComponentIndexByKey(key);\n\n    if (idx !== -1) {\n      return currentComponents[idx].instance.ctx;\n    }\n\n    return undefined;\n  };\n\n  instance.logger = function () {\n    return logger;\n  };\n\n  instance.theme = function () {\n    return theme;\n  };\n  /**\n   * Get the all interactions instances\n   * @name chart.interactions\n   * @type {object}\n   * @example\n   * chart.interactions.instances; // Array of all interaction instances\n   * chart.interactions.on(); // Toggle on all interactions instances\n   * chart.interactions.off(); // Toggle off all interactions instances\n   */\n\n\n  Object.defineProperty(instance, 'interactions', {\n    get: function get() {\n      return (\n        /** @lends chart.interactions */\n        {\n          /** @type Array<interaction> */\n          instances: currentInteractions,\n\n          /** Enable all interaction instances */\n          on: function on() {\n            addDefaultEventListeners();\n            currentInteractions.forEach(function (i) {\n              return i.on();\n            });\n          },\n\n          /** Disable all interaction instances */\n          off: function off() {\n            removeDefaultEventListeners();\n            currentInteractions.forEach(function (i) {\n              return i.off();\n            });\n          }\n        }\n      );\n    }\n  });\n  created();\n\n  if (element) {\n    beforeMount();\n    mount();\n    mounted(element);\n    instance.element = element;\n  }\n\n  return instance;\n}\n\nvar rendererRegistry = function rendererRegistry(reg) {\n  var f = registryFactory(reg);\n\n  f.prio = function (p) {\n    return p ? f.default(p[0]) : [f.default()];\n  };\n\n  f.types = function () {\n    return f.getKeys();\n  };\n\n  return f;\n};\n\nvar componentRegistry = registryFactory();\n\nfunction findField(query, _ref) {\n  var cache = _ref.cache;\n\n  if (typeof query === 'number') {\n    return cache.fields[query];\n  } // Find by key first\n\n\n  for (var i = 0; i < cache.fields.length; i++) {\n    if (cache.fields[i].key() === query) {\n      return cache.fields[i];\n    }\n  } // find by title\n\n\n  for (var _i = 0; _i < cache.fields.length; _i++) {\n    if (cache.fields[_i].title() === query) {\n      return cache.fields[_i];\n    }\n  }\n\n  return null;\n}\nvar filters = {\n  numeric: function numeric(values) {\n    return values.filter(function (v) {\n      return typeof v === 'number' && !isNaN(v);\n    });\n  }\n};\nvar unfilteredReducers = {\n  sum: function sum(values) {\n    return values.reduce(function (a, b) {\n      return a + b;\n    }, 0);\n  }\n}; // function isPrimitive(x) {\n//   const type = typeof x;\n//   return (type !== 'object' && type !== 'function');\n// }\n\n/**\n * [reducers description]\n * @type {Object}\n * @private\n */\n\nvar reducers = {\n  first: function first(values) {\n    return values[0];\n  },\n  last: function last(values) {\n    return values[values.length - 1];\n  },\n  min: function min(values) {\n    var filtered = filters.numeric(values);\n    return !filtered.length ? NaN : Math.min.apply(null, filtered);\n  },\n  max: function max(values) {\n    var filtered = filters.numeric(values);\n    return !filtered.length ? NaN : Math.max.apply(null, filtered);\n  },\n  sum: function sum(values) {\n    var filtered = filters.numeric(values);\n    return !filtered.length ? NaN : filtered.reduce(function (a, b) {\n      return a + b;\n    }, 0);\n  },\n  avg: function avg(values) {\n    var filtered = filters.numeric(values);\n    var len = filtered.length;\n    return !len ? NaN : unfilteredReducers.sum(filtered) / len;\n  }\n};\n\nfunction normalizeProperties(cfg, dataset, dataProperties, main) {\n  // console.log('======', cfg, main, dataset);\n  var props = {};\n  var mainField = main.field || (typeof cfg.field !== 'undefined' ? dataset.field(cfg.field) : null);\n  Object.keys(dataProperties).forEach(function (key) {\n    var pConfig = dataProperties[key];\n    var prop = props[key] = {};\n\n    if (['number', 'string', 'boolean'].indexOf(_typeof(pConfig)) !== -1) {\n      prop.type = 'primitive';\n      prop.value = pConfig;\n    } else if (typeof pConfig === 'function') {\n      prop.type = 'function';\n      prop.value = pConfig;\n      prop.label = pConfig;\n      prop.field = mainField;\n    } else if (_typeof(pConfig) === 'object') {\n      if (pConfig.fields) {\n        prop.fields = pConfig.fields.map(function (ff) {\n          return normalizeProperties(cfg, dataset, {\n            main: ff\n          }, main).main;\n        });\n      } else if (typeof pConfig.field !== 'undefined') {\n        prop.type = 'field';\n        prop.field = dataset.field(pConfig.field);\n        prop.value = prop.field.value;\n        prop.label = prop.field.label;\n      } else if (mainField) {\n        prop.value = mainField.value;\n        prop.label = mainField.label;\n        prop.field = mainField;\n      }\n\n      if (typeof pConfig.filter === 'function') {\n        prop.filter = pConfig.filter;\n      }\n\n      if (typeof pConfig.value !== 'undefined') {\n        prop.value = pConfig.value;\n      }\n\n      if (typeof pConfig.label !== 'undefined') {\n        prop.label = pConfig.label;\n      }\n\n      if (typeof pConfig.reduce === 'function') {\n        prop.reduce = pConfig.reduce;\n      } else if (pConfig.reduce) {\n        prop.reduce = reducers[pConfig.reduce];\n      } else if (prop.field && prop.field.reduce) {\n        prop.reduce = typeof prop.field.reduce === 'string' ? reducers[prop.field.reduce] : prop.field.reduce;\n      }\n\n      if (typeof pConfig.reduceLabel === 'function') {\n        prop.reduceLabel = pConfig.reduceLabel;\n      } else if (pConfig.reduceLabel) {\n        prop.reduceLabel = reducers[pConfig.reduceLabel];\n      } else if (prop.field && prop.field.reduceLabel) {\n        prop.reduceLabel = typeof prop.field.reduceLabel === 'string' ? reducers[prop.field.reduceLabel] : prop.field.reduceLabel;\n      }\n    }\n  });\n  return props;\n}\n/*\nexample of configuration input\ncfg = {\n  field: 'State', // the 'top level' values are extracted from field state\n  value: d => d.qText, // the value of the output\n  props: { // additional data properties ammended to each item\n    a: 3, // constant value\n    b: d => d.qElemNumber, // function will receive the original field value\n    c: {\n      field: 'Country', // reference to another field\n      value: d => d.qText // extract the qText value from the referenced field\n    },\n    d: {\n      value: d => d.qRow //  extract qRow from field 'State'\n    }\n  }\n}\n\n// output\n[{\n  value: 'CA', source: { field: 'State' },\n  a: { value: 3 },\n  b: { value: 26, source: 'State' },\n  c: { value: 'USA', source: 'Country' },\n  d: { value: 131, source: 'State' }\n},\n...]\n*/\n\n\nfunction getPropsInfo(cfg, dataset) {\n  // console.log('222', cfg);\n  var _normalizeProperties = normalizeProperties(cfg, dataset, {\n    main: {\n      value: cfg.value,\n      label: cfg.label,\n      reduce: cfg.reduce,\n      filter: cfg.filter\n    }\n  }, {}),\n      main = _normalizeProperties.main;\n\n  var props = normalizeProperties(cfg, dataset, cfg.props || {}, main);\n  return {\n    props: props,\n    main: main\n  };\n}\n\nfunction collectItems(items, cfg, formatter, prop) {\n  var values = Array(items.length);\n  var labels = Array(items.length);\n  var it;\n\n  for (var i = 0; i < items.length; i++) {\n    it = prop ? items[i][prop] : items[i];\n    values[i] = it.value;\n    labels[i] = it.label;\n  }\n\n  var reduce = cfg.reduce;\n  var reduceLabel = cfg.reduceLabel;\n  var v = reduce ? reduce(values) : values;\n  var b = reduceLabel ? reduceLabel(labels, v) : formatter ? formatter(v) : String(v); // eslint-disable-line no-nested-ternary\n  // // ret[prop].label = String(propsFormatters[prop](ret[prop].value));\n\n  var ret = {\n    value: v,\n    label: b\n  };\n\n  if (prop && items[0][prop].source) {\n    ret.source = items[0][prop].source;\n    return ret;\n  }\n\n  if (!prop && items[0].source) {\n    ret.source = items[0].source;\n    return ret;\n  }\n\n  return ret;\n} // collect items that have been grouped and reduce per group and property\n\n\nfunction collect(trackedItems, _ref2) {\n  var main = _ref2.main,\n      propsArr = _ref2.propsArr,\n      props = _ref2.props;\n  var dataItems = [];\n  var mainFormatter = main.field.formatter(); // || (v => v);\n\n  var propsFormatters = {};\n  propsArr.forEach(function (prop) {\n    propsFormatters[prop] = props[prop].field ? props[prop].field.formatter() : function (v) {\n      return v;\n    };\n  });\n  dataItems.push.apply(dataItems, _toConsumableArray$1(trackedItems.map(function (t) {\n    var ret = collectItems(t.items, main, mainFormatter);\n    propsArr.forEach(function (prop) {\n      ret[prop] = collectItems(t.items, props[prop], propsFormatters[prop], prop);\n    });\n    return ret;\n  })));\n  return dataItems;\n}\nfunction track(_ref3) {\n  var cfg = _ref3.cfg,\n      itemData = _ref3.itemData,\n      obj = _ref3.obj,\n      target = _ref3.target,\n      tracker = _ref3.tracker,\n      trackType = _ref3.trackType;\n  var trackId = trackType === 'function' ? cfg.trackBy(itemData) : itemData[cfg.trackBy];\n  var trackedItem = tracker[trackId];\n\n  if (!trackedItem) {\n    trackedItem = tracker[trackId] = {\n      items: [],\n      id: trackId\n    };\n    target.push(trackedItem);\n  }\n\n  trackedItem.items.push(obj);\n}\n\nfunction datumExtract(propCfg, cell, _ref) {\n  var key = _ref.key;\n  var datum = {\n    value: typeof propCfg.value === 'function' ? propCfg.value(cell) : typeof propCfg.value !== 'undefined' ? propCfg.value : cell // eslint-disable-line no-nested-ternary\n\n  };\n  datum.label = typeof propCfg.label === 'function' ? propCfg.label(cell) : typeof propCfg.label !== 'undefined' ? String(propCfg.label) : String(datum.value); // eslint-disable-line no-nested-ternary\n\n  if (propCfg.field) {\n    datum.source = {\n      key: key,\n      field: propCfg.field.key()\n    };\n  }\n\n  return datum;\n}\n\nfunction extract$1(config, dataset) {\n  var cfgs = Array.isArray(config) ? config : [config];\n  var dataItems = [];\n  cfgs.forEach(function (cfg) {\n    if (typeof cfg.field !== 'undefined') {\n      (function () {\n        var f = dataset.field(cfg.field);\n        var sourceKey = dataset.key();\n\n        if (!f) {\n          throw Error(\"Field '\".concat(cfg.field, \"' not found\"));\n        }\n\n        var _getPropsInfo = getPropsInfo(cfg, dataset),\n            props = _getPropsInfo.props,\n            main = _getPropsInfo.main;\n\n        var propsArr = Object.keys(props);\n        var track$1 = !!cfg.trackBy;\n\n        var trackType = _typeof(cfg.trackBy);\n\n        var tracker = {};\n        var trackedItems = [];\n        var items = f.items();\n        var mapped = [];\n\n        var _loop = function _loop(idx) {\n          var mainCell = items[idx];\n          var exclude = main.filter && !main.filter(mainCell);\n\n          if (exclude) {\n            return \"continue\";\n          }\n\n          var ret = datumExtract(main, mainCell, {\n            key: sourceKey\n          }); // loop through all props that need to be mapped and\n          // assign 'value' and 'source' to each property\n\n          propsArr.forEach(function (prop) {\n            var p = props[prop];\n            var propCell = p.field ? p.field.items()[idx] : mainCell;\n            ret[prop] = datumExtract(p, propCell, {\n              key: sourceKey\n            });\n          }); // collect items based on the trackBy value\n          // items with the same trackBy value are placed in an array and reduced later\n\n          if (track$1) {\n            track({\n              cfg: cfg,\n              itemData: mainCell,\n              obj: ret,\n              target: trackedItems,\n              tracker: tracker,\n              trackType: trackType\n            });\n          }\n\n          mapped.push(ret);\n        };\n\n        for (var idx = 0; idx < items.length; idx++) {\n          var _ret = _loop(idx);\n\n          if (_ret === \"continue\") continue;\n        } // reduce if items have been grouped\n\n\n        if (track$1) {\n          dataItems.push.apply(dataItems, _toConsumableArray$1(collect(trackedItems, {\n            main: main,\n            propsArr: propsArr,\n            props: props\n          })));\n        } else {\n          dataItems.push.apply(dataItems, mapped);\n        }\n      })();\n    }\n  });\n  return dataItems;\n}\n\nvar filters$1 = {\n  numeric: function numeric(values) {\n    return values.filter(function (v) {\n      return typeof v === 'number' && !isNaN(v);\n    });\n  }\n};\n\nfunction createFields(_ref) {\n  var source = _ref.source,\n      data = _ref.data,\n      cache = _ref.cache,\n      config = _ref.config;\n  var headers;\n  var content = data;\n  var parse = config && config.parse;\n\n  if (Array.isArray(data[0])) {\n    // assume 2d matrix of data\n    if (parse && parse.headers === false) {\n      headers = data[0].map(function (v, i) {\n        return i;\n      });\n    } else {\n      headers = data[0];\n      content = data.slice(1);\n    }\n  } else {\n    headers = Object.keys(data[0]);\n  }\n\n  var rowFn = !!parse && typeof parse.row === 'function' && parse.row;\n  var flds = headers;\n\n  if (parse && typeof parse.fields === 'function') {\n    flds = parse.fields(flds.slice());\n  } else {\n    flds = headers.map(function (h) {\n      return {\n        key: h,\n        title: h\n      };\n    });\n  }\n\n  var fieldValues;\n\n  if (Array.isArray(data[0])) {\n    fieldValues = flds.map(function () {\n      return [];\n    });\n  } else {\n    fieldValues = {};\n    flds.forEach(function (f) {\n      fieldValues[f.key] = [];\n    });\n  }\n\n  for (var r = 0; r < content.length; r++) {\n    var row = rowFn ? rowFn(content[r], r, flds) : content[r];\n\n    if (!row) {\n      continue;\n    }\n\n    if (Array.isArray(row)) {\n      for (var c = 0; c < flds.length; c++) {\n        fieldValues[c].push(row[c]);\n      }\n    } else {\n      for (var _c = 0; _c < flds.length; _c++) {\n        fieldValues[flds[_c].key].push(row[flds[_c].key]);\n      }\n    }\n  }\n\n  var fv = Array.isArray(fieldValues) ? function (i) {\n    return fieldValues[i];\n  } : function (i) {\n    return fieldValues[flds[i].key];\n  };\n\n  for (var _c2 = 0; _c2 < flds.length; _c2++) {\n    var values = fv(_c2);\n    var numericValues = filters$1.numeric(values);\n    var isMeasure = numericValues.length > 0;\n    var type = isMeasure ? 'measure' : 'dimension';\n    var min = isMeasure ? Math.min.apply(Math, _toConsumableArray$1(numericValues)) : NaN;\n    var max = isMeasure ? Math.max.apply(Math, _toConsumableArray$1(numericValues)) : NaN;\n    cache.fields.push(field(extend({\n      source: source,\n      key: _c2,\n      title: flds[_c2].title,\n      values: values,\n      min: min,\n      max: max,\n      type: type\n    }, flds[_c2]), {\n      value: flds[_c2].value,\n      label: flds[_c2].label\n    }));\n  }\n}\n\nvar dsv = function dsv(_ref2) {\n  var data = _ref2.data,\n      config = _ref2.config;\n  var rows = data.split('\\n');\n  var row0 = rows[0];\n  var row1 = rows[1];\n  var delimiter = ',';\n\n  if (config && config.parse && config.parse.delimiter) {\n    delimiter = config.parse.delimiter;\n  } else if (row0) {\n    // guess delimiter\n    var guesses = [/,/, /\\t/, /;/];\n\n    for (var i = 0; i < guesses.length; i++) {\n      var d = guesses[i];\n\n      if (row0 && row1) {\n        if (d.test(row0) && d.test(row1) && row0.split(d).length === row1.split(d).length) {\n          delimiter = d;\n          break;\n        }\n      } else if (d.test(row0)) {\n        delimiter = d;\n      }\n    }\n  }\n\n  return rows.map(function (row) {\n    return row.split(delimiter);\n  });\n};\n\nvar parseData = function parseData(_ref3) {\n  var key = _ref3.key,\n      data = _ref3.data,\n      cache = _ref3.cache,\n      config = _ref3.config;\n\n  if (!data) {\n    return;\n  }\n\n  var dd = data;\n\n  if (typeof dd === 'string') {\n    // assume dsv\n    dd = dsv({\n      data: data,\n      config: config\n    });\n  }\n\n  if (!Array.isArray(dd)) {\n    return; // warn?\n  }\n\n  createFields({\n    data: dd,\n    cache: cache,\n    source: key,\n    config: config\n  });\n};\n/**\n * Create a new dataset with default settings\n * @private\n * @return {dataset}\n */\n\n\nfunction ds() {\n  var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _key = _ref4.key,\n      data = _ref4.data,\n      config = _ref4.config;\n\n  var cache = {\n    fields: []\n  };\n  /**\n   * @alias dataset\n   * @interface\n   */\n\n  var dataset = {\n    /**\n     * Get the key identifying this dataset\n     * @returns {string}\n     */\n    key: function key() {\n      return _key;\n    },\n\n    /**\n     * Get the raw data\n     * @returns {any}\n     */\n    raw: function raw() {\n      return data;\n    },\n\n    /**\n     * Find a field within this dataset\n     * @param {string} query - The field to find\n     * @returns {field}\n     */\n    field: function field(query) {\n      return findField(query, {\n        cache: cache,\n        matrix: data\n      });\n    },\n\n    /**\n     * Get all fields within this dataset\n     * @returns {Array<field>}\n     */\n    fields: function fields() {\n      return cache.fields.slice();\n    },\n\n    /**\n     * Extract data items from this dataset\n     * @param {data-extract-config} config\n     * @returns {Array<datum-extract>}\n     */\n    extract: function extract(cfg) {\n      return extract$1(cfg, dataset);\n    },\n\n    /**\n     * @returns {null}\n     */\n    hierarchy: function hierarchy() {\n      return null;\n    }\n  };\n  parseData({\n    key: _key,\n    data: data,\n    config: config,\n    cache: cache\n  });\n  return dataset;\n}\n\nds.util = {\n  normalizeConfig: getPropsInfo,\n  collect: collect,\n  track: track\n};\n/**\n * @typedef {object} data-extract-config\n * @property {string} field - The field to extract data from\n * @property {data-extract-config~valueFn} [value] - The field value accessor\n * @property {data-extract-config~labelFn} [label] - The field label accessor\n * @property {data-extract-config~trackByFn} [trackBy] - Track by value accessor\n * @property {data-extract-config~reduceFn} [reduce] - Reducer function\n * @property {data-extract-config~reduceLabelFn} [reduceLabel] - Label reducer function\n * @property {data-extract-config~filterFn} [filter] - Filter function\n * @property {object} [props] - Additional properties to add to the extracted item\n */\n\n/**\n * @callback data-extract-config~valueFn\n * @param {any} cell The field cell\n * @returns {any}\n */\n\n/**\n * @callback data-extract-config~labelFn\n * @param {any} cell The field cell\n * @returns {string}\n */\n\n/**\n * @callback data-extract-config~filterFn\n * @param {any} cell The field cell\n * @returns {boolean}\n */\n\n/**\n * @callback data-extract-config~trackByFn\n * @param {any} cell The field cell\n * @returns {any}\n */\n\n/**\n * @callback data-extract-config~reduceFn\n * @param {any[]} values The collected values to reduce\n * @returns {any}\n */\n\n/**\n * @callback data-extract-config~reduceLabelFn\n * @param {any[]} labels The collected labels to reduce\n * @param {any} value Reduced value\n * @returns {string}\n */\n\n/**\n * @typedef {object} datum-extract\n * @property {any} value - The extracted value\n * @property {string} label - The extracted value as a string\n * @property {object} source - The data source of the extracted data\n * @property {string} source.key - The data-source key\n * @property {string} source.field - The source field\n */\n\nvar dataRegistry = registryFactory();\ndataRegistry.default('matrix');\ndataRegistry('matrix', ds);\ndataRegistry('default', ds); // deprecated\n\n/**\n * Manages event handlers for native events\n * @private\n */\nfunction native(chart, mediator, element) {\n  var instance = {\n    chart: chart,\n    mediator: mediator,\n    element: element\n  };\n  var nativeEvents = [];\n  var settings;\n  var itKey;\n  var isOn = true;\n  /**\n   * Set default settings\n   * @private\n   */\n\n  function setDefaultSettings(newSettings) {\n    itKey = newSettings.key;\n    settings = newSettings;\n    settings.events = settings.events || [];\n\n    if (settings.enable === undefined) {\n      settings.enable = true;\n    }\n  }\n  /**\n   * Add native events based on settings\n   * @private\n   */\n\n\n  function addEvents() {\n    if (typeof settings.enable === 'function') {\n      settings.enable = settings.enable.bind(instance)();\n    }\n\n    if (!settings.enable) {\n      return; // interaction is disabled\n    }\n\n    Object.keys(settings.events).forEach(function (key) {\n      var listener = settings.events[key].bind(instance);\n      element.addEventListener(key, listener);\n      nativeEvents.push({\n        key: key,\n        listener: listener\n      });\n    });\n  }\n  /**\n   * Removes all added native events\n   * @private\n   */\n\n\n  function removeAddedEvents() {\n    // remove added native events\n    nativeEvents.forEach(function (_ref) {\n      var key = _ref.key,\n          listener = _ref.listener;\n      element.removeEventListener(key, listener);\n    });\n    nativeEvents = [];\n  }\n\n  return {\n    /**\n     * Getter for the key.\n     * @private\n     */\n    get key() {\n      return itKey;\n    },\n\n    /**\n     * Updates this with new settings\n     * @private\n     * @param {object} newSettings\n     * @param {string} [newSettings.type] - The interaction type. Is 'native' for this component\n     * @param {boolean|function} [newSettings.enable=true] - Should the interactions defined here be enabled or not.\n     * This is only run when adding event handlers. In effect at startup, update or during on/off.\n     * It does not run during every event loop.\n     * @param {array} [newSettings.gestures] - The keys in this object is the names of native events\n     * that should be added to the chart element and they should all point to function which\n     * will be the corresponding event handler.\n     */\n    set: function set(newSettings) {\n      setDefaultSettings(newSettings);\n      removeAddedEvents();\n\n      if (isOn) {\n        addEvents();\n      }\n    },\n\n    /**\n     * Turns off interactions\n     * @private\n     */\n    off: function off() {\n      isOn = false;\n      removeAddedEvents();\n    },\n\n    /**\n     * Turns off interactions\n     * @private\n     */\n    on: function on() {\n      isOn = true;\n\n      if (nativeEvents.length === 0) {\n        addEvents();\n      }\n    },\n\n    /**\n     * Destroys and unbinds all event handlers\n     * @private\n     */\n    destroy: function destroy() {\n      removeAddedEvents();\n      instance = null;\n      settings = null;\n    }\n  };\n}\n\nvar reg$2 = registryFactory();\nreg$2('native', native);\n\n/**\n * Short-hand for max(min())\n *\n * @param {number} min Minimum allowed value\n * @param {number} max Maximum allowed value\n * @param {number} value The actual value to cap\n * @ignore\n */\nfunction cap(min, max, value) {\n  return Math.max(min, Math.min(max, value));\n}\n/**\n * Resolve a diff, i.e. resolveDiff(0.2, 0.6, 1, 100) = 20\n *\n * @param {object} params parameters\n * @param {number} params.start Normalized start value\n * @param {number} params.end Normalized end value\n * @param {number} params.minPx The minimum number of pixels\n * @param {number} params.maxPx Maximum number of pixels, i.e. the width or height\n * @ignore\n */\n\nfunction resolveDiff(_ref) {\n  var start = _ref.start,\n      end = _ref.end,\n      _ref$minPx = _ref.minPx,\n      minPx = _ref$minPx === void 0 ? 0.1 : _ref$minPx,\n      _ref$maxPx = _ref.maxPx,\n      maxPx = _ref$maxPx === void 0 ? 1 : _ref$maxPx;\n  var high = Math.max(start, end);\n  var low = Math.min(start, end);\n  var highModified = cap(-0.1, 1.2, high);\n  var lowModified = cap(-0.1, 1.2, low);\n  var wantedDiff = highModified * maxPx - lowModified * maxPx;\n  var actualDiff = Math.max(minPx, wantedDiff);\n  var startModifier = (actualDiff - wantedDiff) / 2;\n  var actualLow = lowModified * maxPx - startModifier;\n  return {\n    actualDiff: actualDiff,\n    startModifier: startModifier,\n    actualLow: actualLow\n  };\n}\n\n/**\n * Out of bounds shape\n * @param {object} params parameters\n * @param {object} params.item Resolved styling item from box component with item.major\n * @param {number} params.value 0 or 1 depending on where to render the oob shape\n * @param {number} params.boxWidth Un-calculated box width in relative/normalized format\n * @param {number} params.boxPadding Un-calculated box padding in relative/normalized format\n * @param {number} params.rendWidth The pixel width of the area to render upon\n * @param {number} params.rendHeight The pixel height of the area to render upon\n * @param {boolean} params.flipXY Wether or not to flip X and Y coordinates together with Width and Height\n * @param {function} params.symbol Symbol library function from component\n * @ignore\n */\n\nfunction oob(_ref) {\n  var _extend;\n\n  var item = _ref.item,\n      value = _ref.value,\n      boxCenter = _ref.boxCenter,\n      rendWidth = _ref.rendWidth,\n      rendHeight = _ref.rendHeight,\n      flipXY = _ref.flipXY,\n      symbol = _ref.symbol;\n  var x = 'x';\n  var y = 'y';\n  var calcwidth = rendWidth;\n  var calcheight = rendHeight;\n  var startAngle = value < 0.5 ? 90 : -90;\n\n  if (flipXY) {\n    x = 'y';\n    y = 'x';\n    calcwidth = rendHeight;\n    calcheight = rendWidth;\n    startAngle = value < 0.5 ? 180 : 0;\n  }\n\n  return symbol(extend({}, item.oob, (_extend = {}, _defineProperty(_extend, x, boxCenter * calcwidth), _defineProperty(_extend, y, Math.max(item.oob.size / 2, Math.min(value * calcheight, calcheight - item.oob.size / 2))), _defineProperty(_extend, \"startAngle\", startAngle), _extend)));\n}\n/**\n * Box shape calculation function\n * @param {object} params parameters\n * @param {object} params.item Resolved styling item from box component with item.major\n * @param {number} params.boxWidth Un-calculated box width in relative/normalized format\n * @param {number} params.boxPadding Un-calculated box padding in relative/normalized format\n * @param {number} params.rendWidth The pixel width of the area to render upon\n * @param {number} params.rendHeight The pixel height of the area to render upon\n * @param {boolean} params.flipXY wether or not to flip X and Y coordinates together with Width and Height\n * @ignore\n */\n\nfunction box(_ref2) {\n  var _extend2;\n\n  var item = _ref2.item,\n      boxWidth = _ref2.boxWidth,\n      boxPadding = _ref2.boxPadding,\n      rendWidth = _ref2.rendWidth,\n      rendHeight = _ref2.rendHeight,\n      flipXY = _ref2.flipXY;\n  var x = 'x';\n  var y = 'y';\n  var width = 'width';\n  var height = 'height';\n  var calcwidth = rendWidth;\n  var calcheight = rendHeight;\n\n  if (flipXY) {\n    x = 'y';\n    y = 'x';\n    width = 'height';\n    height = 'width';\n    calcwidth = rendHeight;\n    calcheight = rendWidth;\n  }\n\n  var _resolveDiff = resolveDiff({\n    start: item.start,\n    end: item.end,\n    minPx: item.box.minHeightPx,\n    maxPx: calcheight\n  }),\n      actualDiff = _resolveDiff.actualDiff,\n      actualLow = _resolveDiff.actualLow;\n\n  return extend({}, item.box, (_extend2 = {\n    type: 'rect'\n  }, _defineProperty(_extend2, x, (boxPadding + item.major) * calcwidth), _defineProperty(_extend2, y, actualLow), _defineProperty(_extend2, height, actualDiff), _defineProperty(_extend2, width, boxWidth * calcwidth), _defineProperty(_extend2, \"data\", item.data || {}), _defineProperty(_extend2, \"collider\", {\n    type: null\n  }), _extend2));\n}\n/**\n * A vertical line shape (for start - min, end - max values)\n * @param {object} params parameters\n * @param {object} params.item Resolved styling item from box component with item.major\n * @param {number} params.from Normalized from value\n * @param {number} params.to Normalized to value\n * @param {number} params.boxCenter Center coordinate for the box\n * @param {number} params.rendWidth The pixel width of the area to render upon\n * @param {number} params.rendHeight The pixel height of the area to render upon\n * @param {boolean} params.flipXY wether or not to flip X and Y coordinates together with Width and Height\n * @ignore\n */\n\nfunction verticalLine(_ref3) {\n  var _extend3;\n\n  var item = _ref3.item,\n      from = _ref3.from,\n      to = _ref3.to,\n      boxCenter = _ref3.boxCenter,\n      rendWidth = _ref3.rendWidth,\n      rendHeight = _ref3.rendHeight,\n      flipXY = _ref3.flipXY;\n  var x1 = 'x1';\n  var y1 = 'y1';\n  var x2 = 'x2';\n  var y2 = 'y2';\n  var calcwidth = rendWidth;\n  var calcheight = rendHeight;\n\n  if (flipXY) {\n    x1 = 'y1';\n    y1 = 'x1';\n    x2 = 'y2';\n    y2 = 'x2';\n    calcwidth = rendHeight;\n    calcheight = rendWidth;\n  }\n\n  return extend({}, item.line, (_extend3 = {\n    type: 'line'\n  }, _defineProperty(_extend3, y2, Math.floor(from * calcheight)), _defineProperty(_extend3, x1, boxCenter * calcwidth), _defineProperty(_extend3, y1, Math.floor(to * calcheight)), _defineProperty(_extend3, x2, boxCenter * calcwidth), _defineProperty(_extend3, \"data\", item.data || {}), _defineProperty(_extend3, \"collider\", {\n    type: null\n  }), _extend3));\n}\n/**\n * A horizontal line shape (for median and whiskers)\n * @param {object} params parameters\n * @param {object} params.item Resolved styling item from box component with item.major\n * @param {string} params.key Which key to use as style base in the item object\n * @param {number} params.position At which \"height\" (X) to position the horizontal line\n * @param {number} params.width Width of the horizontal line (i.e. box width or a multiple of it)\n * @param {number} params.boxCenter Center coordinate for the box\n * @param {number} params.rendWidth The pixel width of the area to render upon\n * @param {number} params.rendHeight The pixel height of the area to render upon\n * @param {boolean} params.flipXY wether or not to flip X and Y coordinates together with Width and Height\n * @ignore\n */\n\nfunction horizontalLine(_ref4) {\n  var _extend4;\n\n  var item = _ref4.item,\n      key = _ref4.key,\n      position = _ref4.position,\n      width = _ref4.width,\n      boxCenter = _ref4.boxCenter,\n      rendWidth = _ref4.rendWidth,\n      rendHeight = _ref4.rendHeight,\n      flipXY = _ref4.flipXY;\n  var x1 = 'x1';\n  var y1 = 'y1';\n  var x2 = 'x2';\n  var y2 = 'y2';\n  var calcwidth = rendWidth;\n  var calcheight = rendHeight;\n\n  if (flipXY) {\n    x1 = 'y1';\n    y1 = 'x1';\n    x2 = 'y2';\n    y2 = 'x2';\n    calcwidth = rendHeight;\n    calcheight = rendWidth;\n  }\n\n  var halfWidth = width / 2;\n  return extend({\n    type: 'line'\n  }, item[key], (_extend4 = {}, _defineProperty(_extend4, y1, Math.floor(position * calcheight)), _defineProperty(_extend4, x1, (boxCenter - halfWidth) * calcwidth), _defineProperty(_extend4, y2, Math.floor(position * calcheight)), _defineProperty(_extend4, x2, (boxCenter + halfWidth) * calcwidth), _defineProperty(_extend4, \"r\", halfWidth * calcwidth), _defineProperty(_extend4, \"cx\", boxCenter * calcwidth), _defineProperty(_extend4, \"cy\", position * calcheight), _defineProperty(_extend4, \"width\", width * calcwidth), _defineProperty(_extend4, \"data\", item.data || {}), _defineProperty(_extend4, \"collider\", {\n    type: null\n  }), _extend4));\n}\n/**\n * A horizontal line shape (for median and whiskers)\n * @param {number} bandwidth The current bandwidth for this item\n * @param {object} item A resolved style item to render with major and box width variables, minWidthPx and maxWidthPx\n * @param {number} maxMajorWidth The actual maximum major width\n * @ignore\n */\n\nfunction getBoxWidth(bandwidth, item, maxMajorWidth) {\n  var _item$box = item.box,\n      width = _item$box.width,\n      maxWidthPx = _item$box.maxWidthPx,\n      minWidthPx = _item$box.minWidthPx;\n  var sign = bandwidth >= 0 ? 1 : -1;\n  var boxWidth = Math.min(sign * bandwidth * width, isNaN(maxWidthPx) ? maxMajorWidth : maxWidthPx / maxMajorWidth);\n  boxWidth = isNaN(minWidthPx) ? boxWidth : Math.max(minWidthPx / maxMajorWidth, boxWidth);\n  return boxWidth * sign;\n}\n\nfunction buildShapes(_ref) {\n  var width = _ref.width,\n      height = _ref.height,\n      flipXY = _ref.flipXY,\n      resolved = _ref.resolved,\n      keys = _ref.keys,\n      symbol = _ref.symbol;\n  // if (!settings || !settings.major || !settings.major.scale || !settings.minor || !settings.minor.scale) {\n  //   return [];\n  // }\n  var output = [];\n  var majorItems = resolved.major.items;\n\n  if (!majorItems.length) {\n    return output;\n  }\n\n  var rendWidth = width;\n  var rendHeight = height;\n  var maxMajorWidth = flipXY ? height : width;\n  var majorSettings = resolved.major.settings;\n  var minorProps = ['start', 'end', 'min', 'max', 'med'].filter(function (prop) {\n    return typeof resolved.minor.settings[prop] !== 'undefined';\n  });\n  var numMinorProps = minorProps.length;\n  var nonOobKeys = keys.filter(function (key) {\n    return key !== 'oob';\n  });\n  var children;\n  var major;\n  var minorItem;\n  var boxWidth;\n  var boxPadding;\n  var boxCenter;\n  var isLowerOutOfBounds;\n  var isHigherOutOfBounds;\n  var isOutOfBounds;\n  var numKeys = keys ? keys.length : 0;\n  var numNonOobKeys = nonOobKeys ? nonOobKeys.length : 0;\n\n  function addBox() {\n    /* THE BOX */\n    if (minorItem.box && isNumber(minorItem.start) && isNumber(minorItem.end)) {\n      children.push(box({\n        item: minorItem,\n        boxWidth: boxWidth,\n        boxPadding: boxPadding,\n        rendWidth: rendWidth,\n        rendHeight: rendHeight,\n        flipXY: flipXY\n      }));\n    }\n  }\n\n  function addLine() {\n    /* LINES MIN - START, END - MAX */\n    if (isNumber(minorItem.min) && isNumber(minorItem.start)) {\n      children.push(verticalLine({\n        item: minorItem,\n        from: minorItem.min,\n        to: minorItem.start,\n        boxCenter: boxCenter,\n        rendWidth: rendWidth,\n        rendHeight: rendHeight,\n        flipXY: flipXY\n      }));\n    }\n\n    if (isNumber(minorItem.max) && isNumber(minorItem.end)) {\n      children.push(verticalLine({\n        item: minorItem,\n        from: minorItem.max,\n        to: minorItem.end,\n        boxCenter: boxCenter,\n        rendWidth: rendWidth,\n        rendHeight: rendHeight,\n        flipXY: flipXY\n      }));\n    }\n  }\n\n  function addMedian() {\n    /* MEDIAN */\n    if (minorItem.median && isNumber(minorItem.med)) {\n      children.push(horizontalLine({\n        item: minorItem,\n        key: 'median',\n        position: minorItem.med,\n        width: boxWidth,\n        boxCenter: boxCenter,\n        rendWidth: rendWidth,\n        rendHeight: rendHeight,\n        flipXY: flipXY\n      }));\n    }\n  }\n\n  function addWhisker() {\n    /* WHISKERS */\n    if (minorItem.whisker) {\n      var whiskerWidth = boxWidth * minorItem.whisker.width;\n\n      if (isNumber(minorItem.min)) {\n        children.push(horizontalLine({\n          item: minorItem,\n          key: 'whisker',\n          position: minorItem.min,\n          width: whiskerWidth,\n          boxCenter: boxCenter,\n          rendWidth: rendWidth,\n          rendHeight: rendHeight,\n          flipXY: flipXY\n        }));\n      }\n\n      if (isNumber(minorItem.max)) {\n        children.push(horizontalLine({\n          item: minorItem,\n          key: 'whisker',\n          position: minorItem.max,\n          width: whiskerWidth,\n          boxCenter: boxCenter,\n          rendWidth: rendWidth,\n          rendHeight: rendHeight,\n          flipXY: flipXY\n        }));\n      }\n    }\n  }\n\n  function addOutOfBounds() {\n    /* OUT OF BOUNDS */\n    if (isLowerOutOfBounds) {\n      children.push(oob({\n        item: minorItem,\n        value: 0,\n        boxCenter: boxCenter,\n        rendWidth: rendWidth,\n        rendHeight: rendHeight,\n        flipXY: flipXY,\n        symbol: symbol\n      }));\n    } else if (isHigherOutOfBounds) {\n      children.push(oob({\n        item: minorItem,\n        value: 1,\n        boxCenter: boxCenter,\n        rendWidth: rendWidth,\n        rendHeight: rendHeight,\n        flipXY: flipXY,\n        symbol: symbol\n      }));\n    }\n  }\n\n  var addMarkerList = {\n    box: addBox,\n    line: addLine,\n    median: addMedian,\n    whisker: addWhisker\n  };\n\n  function checkOutOfBounds() {\n    var value;\n    var max = -Number.MAX_VALUE;\n    var min = Number.MAX_VALUE;\n\n    for (var n = 0; n < numMinorProps; n++) {\n      value = minorItem[minorProps[n]];\n\n      if (isNumber(value)) {\n        if (max < value) {\n          max = value;\n        }\n\n        if (min > value) {\n          min = value;\n        }\n      }\n    }\n\n    isLowerOutOfBounds = max < 0 && max !== -Number.MAX_VALUE;\n    isHigherOutOfBounds = min > 1 && min !== Number.MAX_VALUE;\n    isOutOfBounds = isLowerOutOfBounds || isHigherOutOfBounds;\n  }\n\n  for (var i = 0, len = majorItems.length; i < len; i++) {\n    children = [];\n    major = null;\n    var majorItem = majorItems[i];\n    var d = majorItem.data;\n    var majorVal = null;\n    var majorEndVal = null;\n\n    if (typeof majorSettings.binStart !== 'undefined') {\n      // if start and end is defined\n      majorVal = majorItem.binStart;\n      majorEndVal = majorItem.binEnd;\n      major = majorSettings.binStart.scale;\n    } else {\n      major = majorSettings.major.scale;\n      majorVal = major ? majorItem.major : 0;\n    }\n\n    var bandwidth = 0;\n\n    if (!major) {\n      bandwidth = 1;\n    } else if (major.bandwidth) {\n      bandwidth = major.bandwidth();\n      majorVal -= bandwidth / 2;\n    } else {\n      bandwidth = majorEndVal - majorVal;\n    }\n\n    minorItem = extend({}, {\n      major: majorVal,\n      majorEnd: majorEndVal\n    }, resolved.minor.items[i]);\n\n    for (var j = 0; j < numKeys; j++) {\n      minorItem[keys[j]] = resolved[keys[j]].items[i];\n    }\n\n    boxWidth = getBoxWidth(bandwidth, minorItem, maxMajorWidth);\n    boxPadding = (bandwidth - boxWidth) / 2;\n    boxCenter = boxPadding + minorItem.major + boxWidth / 2;\n    checkOutOfBounds();\n\n    if (!isOutOfBounds) {\n      for (var k = 0; k < numNonOobKeys; k++) {\n        if (minorItem[nonOobKeys[k]] && minorItem[nonOobKeys[k]].show === false) {\n          continue;\n        }\n\n        addMarkerList[nonOobKeys[k]]();\n      }\n    } else if (minorItem.oob) {\n      addOutOfBounds();\n    }\n\n    var container = {\n      type: 'container',\n      data: d,\n      collider: {\n        type: 'bounds'\n      },\n      children: children\n    };\n    output.push(container);\n  }\n\n  return output;\n}\n\n/**\n * Resolve a complex object using the built-in resolver from this.resolver in component\n * @ignore\n */\n\nfunction complexResolver(_ref) {\n  var keys = _ref.keys,\n      data = _ref.data,\n      defaultSettings = _ref.defaultSettings,\n      style = _ref.style,\n      settings = _ref.settings,\n      width = _ref.width,\n      height = _ref.height,\n      resolver = _ref.resolver;\n  var defaults = extend(true, {}, defaultSettings || {}, style || {});\n  var scaled = {\n    major: settings.orientation === 'horizontal' ? height : width,\n    minor: settings.orientation === 'horizontal' ? width : height\n  };\n  var majorSettings = settings.major;\n  var majorResolved;\n\n  if (_typeof(majorSettings) === 'object' && _typeof(majorSettings.ref) === 'object' && typeof majorSettings.ref.start !== 'undefined' && typeof majorSettings.ref.end !== 'undefined') {\n    // temporary backwards compatibility\n    majorResolved = resolver.resolve({\n      data: data,\n      defaults: {\n        start: 0,\n        end: 1\n      },\n      scaled: scaled,\n      settings: extend(true, {}, {\n        binStart: {\n          scale: settings.major.scale,\n          ref: settings.major.ref.start\n        },\n        binEnd: {\n          scale: settings.major.scale,\n          ref: settings.major.ref.end\n        }\n      })\n    });\n  } else if (_typeof(majorSettings) === 'object' && typeof majorSettings.binStart !== 'undefined' && typeof majorSettings.binEnd !== 'undefined') {\n    majorResolved = resolver.resolve({\n      data: data,\n      defaults: {\n        start: 0,\n        end: 1\n      },\n      scaled: scaled,\n      settings: extend(true, {}, {\n        binStart: {\n          scale: settings.major.scale,\n          ref: 'binStart'\n        },\n        binEnd: {\n          scale: settings.major.scale,\n          ref: 'binEnd'\n        }\n      }, settings.major)\n    });\n  } else {\n    majorResolved = resolver.resolve({\n      data: data,\n      scaled: scaled,\n      defaults: {\n        major: 0.5\n      },\n      settings: {\n        major: settings.major\n      }\n    });\n  }\n\n  var minorSettings = settings.minor || {};\n  var defaultMinorSettings = {};\n  ['start', 'end', 'min', 'max', 'med'].forEach(function (prop) {\n    if (minorSettings[prop] || data.items && data.items.length && data.items[0][prop]) {\n      defaultMinorSettings[prop] = {\n        scale: minorSettings.scale,\n        ref: prop\n      };\n    }\n  });\n  var minorResolved = resolver.resolve({\n    data: data,\n    defaults: {\n      start: 0,\n      end: 1\n    },\n    scaled: scaled,\n    settings: extend(true, {}, defaultMinorSettings, minorSettings)\n  });\n  var key;\n  var ext = {\n    major: majorResolved,\n    minor: minorResolved\n  };\n\n  for (var ki = 0, len = keys.length; ki < len; ki++) {\n    if (!settings[key] || settings[key].show !== false) {\n      key = keys[ki];\n      ext[key] = resolver.resolve({\n        data: data,\n        defaults: defaults[key],\n        settings: settings[key],\n        scaled: scaled\n      });\n    }\n  }\n\n  return ext;\n}\n\nvar DEFAULT_DATA_SETTINGS = {\n  oob: {\n    show: true,\n    type: 'n-polygon',\n    fill: '#999',\n    stroke: '#000',\n    strokeWidth: 0,\n    size: 10,\n    sides: 3,\n    startAngle: -90\n  },\n  box: {\n    show: true,\n    fill: '#fff',\n    stroke: '#000',\n    strokeWidth: 1,\n    strokeLinejoin: 'miter',\n    width: 1,\n    maxWidthPx: undefined,\n    minWidthPx: 1,\n    minHeightPx: 1\n  },\n  line: {\n    show: true,\n    stroke: '#000',\n    strokeWidth: 1\n  },\n  median: {\n    show: true,\n    stroke: '#000',\n    strokeWidth: 1\n  },\n  whisker: {\n    show: true,\n    stroke: '#000',\n    strokeWidth: 1,\n    fill: '',\n    type: 'line',\n    width: 1\n  }\n};\nvar dataKeys = Object.keys(DEFAULT_DATA_SETTINGS);\nvar component = {\n  require: ['chart', 'resolver', 'symbol'],\n  defaultSettings: {\n    settings: {},\n    data: {},\n    style: {\n      box: '$shape',\n      line: '$shape-guide',\n      whisker: '$shape-guide',\n      median: '$shape-guide--inverted'\n    }\n  },\n  created: function created() {\n    this.state = {};\n  },\n  render: function render(_ref) {\n    var _this = this;\n\n    var data = _ref.data;\n    var _this$rect = this.rect,\n        width = _this$rect.width,\n        height = _this$rect.height;\n    var flipXY = this.settings.settings.orientation === 'horizontal';\n    var style = this.style,\n        resolver = this.resolver,\n        symbol = this.symbol;\n    var keys = dataKeys.filter(function (key) {\n      return !_this.settings.settings[key] || _this.settings.settings[key].show !== false;\n    });\n    var defaultSettings = {};\n    keys.forEach(function (key) {\n      return defaultSettings[key] = DEFAULT_DATA_SETTINGS[key];\n    });\n    var resolved = complexResolver({\n      keys: keys,\n      data: data,\n      defaultSettings: defaultSettings,\n      style: style,\n      settings: this.settings.settings,\n      width: width,\n      height: height,\n      resolver: resolver\n    });\n    var settings = resolved.settings,\n        items = resolved.items;\n    var shapes = buildShapes({\n      items: items,\n      settings: settings,\n      width: width,\n      height: height,\n      flipXY: flipXY,\n      resolved: resolved,\n      keys: keys,\n      symbol: symbol\n    });\n    return shapes;\n  }\n};\n\nfunction box$1(picasso) {\n  picasso.component('box', component);\n  picasso.component('box-marker', component); // temporary backwards compatibility - DEPRECATED\n}\n/**\n * @typedef {object} component--box\n * @property {string} type - \"box\"\n * @property {component--box~data} data Box data\n * @property {component--box~settings} settings Box settings\n * @example\n * {\n *   type: \"box\",\n *   data: {\n *    mapTo: {\n *      min: { source: \"/qHyperCube/qMeasureInfo/0\" },\n *      start: { source: \"/qHyperCube/qMeasureInfo/1\" },\n *      med: { source: \"/qHyperCube/qMeasureInfo/2\" },\n *      end: { source: \"/qHyperCube/qMeasureInfo/3\" },\n *      max: { source: \"/qHyperCube/qMeasureInfo/4\" },\n *    },\n *    groupBy: {\n *      source: \"/qHyperCube/qDimensionInfo/0\"\n *    }\n *  },\n *  settings: {\n *    major: {\n *      scale: { source: \"/qHyperCube/qDimensionInfo/0\" }\n *    },\n *    minor: {\n *      scale: { source: [\"/qHyperCube/qMeasureInfo/0\",\n *               \"/qHyperCube/qMeasureInfo/1\",\n *               \"/qHyperCube/qMeasureInfo/2\",\n *               \"/qHyperCube/qMeasureInfo/3\",\n *               \"/qHyperCube/qMeasureInfo/4\"] }\n *    }\n *  }\n * }\n */\n\n/**\n * @typedef {object} component--box~settings\n * @property {object} major\n * @property {string} major.scale The scale to use along the major (dimension) axis\n * @property {string|component--box~settings~majorReference} [major.ref='self'] Reference to the data property along the major axis\n * @property {object} minor\n * @property {string} minor.scale The scale to use along the minor (measure) axis\n * @property {string} [orientation='vertical'] Which orientation to use (vertical or horizontal)\n * @property {object} [box] Visual properties for the box shape in the box marker\n * @property {boolean} [box.show=true] Boolean for showing the box shape\n * @property {string} [box.fill='#fff']\n * @property {string} [box.stroke='#000']\n * @property {number} [box.strokeWidth=1]\n * @property {string} [box.strokeLinejoin='miter']\n * @property {number} [box.width=1]\n * @property {number} [box.maxWidthPx=100] Maximum width of the box in pixels (not applicable when using major start and end)\n * @property {number} [box.minWidthPx=1] Minimum width of the box in pixels (not applicable when using major start and end)\n * @property {number} [box.minHeightPx=1] Minimum height of the box shape\n * @property {object} [line] Visual properties for lines between min-start, end-max.\n * @property {boolean} [line.show=true]\n * @property {string} [line.stroke='#000']\n * @property {number} [line.strokeWidth=1]\n * @property {object} [whisker] All the visual properties for whiskers at min and max.\n * @property {boolean} [whisker.show=true]\n * @property {string} [whisker.stroke='#000']\n * @property {number} [whisker.strokeWidth=1]\n * @property {number} [whisker.width=1]\n * @property {object} [median] Visual properties for the median\n * @property {number} [median.show=true]\n * @property {string} [median.stroke='#000']\n * @property {number} [median.strokeWidth=1]\n * @property {object} [oob] EXPERIMENTAL: Out of bounds symbol utilizing the symbol API\n * @property {number} [oob.show=true]\n * @property {string} [oob.type='n-polygon'] Type of the symbol to be used\n * @property {string} [oob.fill='#999'] Fill color of the symbol\n * @property {string} [oob.stroke='#000'] Stroke color\n * @property {number} [oob.strokeWidth=0] Stroke width\n * @property {number} [oob.size=10] Size/width of the symbol in pixels\n * @property {number} [oob.sides=3] Number of sides for a n-polygon (3 for triangle)\n */\n\n/**\n * @typedef {object} component--box~settings~majorReference\n * @property {string} start Reference to the data property of the start value along the major axis\n * @property {string} end Reference to the data property of the end value along the major axis\n */\n\n/**\n * @typedef {object} component--box~data\n * @property {number} [min] Min\n * @property {number} [max] Max\n * @property {number} [start] Start of box\n * @property {number} [end] End of box\n * @property {number} [med] Median\n */\n\nvar DEFAULT_ERROR_SETTINGS = {\n  errorShape: {\n    shape: 'saltire',\n    width: 2,\n    size: 0.5,\n    fill: '#333',\n    stroke: '#333',\n    strokeWidth: 0\n  }\n};\n/**\n  * @typedef {object}\n  * @alias component--point.settings\n  */\n\nvar DEFAULT_DATA_SETTINGS$1 = {\n  /** Type of shape\n   * @type {datum-string=} */\n  shape: 'circle',\n  label: '',\n\n  /** Fill color\n   * @type {datum-string=} */\n  fill: '#333',\n\n  /** Stroke color\n   * @type {datum-string=} */\n  stroke: '#ccc',\n\n  /** Stroke width\n   * @type {datum-number=} */\n  strokeWidth: 0,\n\n  /** Stroke line join\n   * @type {string=} */\n  strokeLinejoin: 'miter',\n\n  /** Opacity of shape\n   * @type {datum-number=} */\n  opacity: 1,\n\n  /** Normalized x coordinate\n   * @type {datum-number=} */\n  x: 0.5,\n\n  /** Normalized y coordinate\n   * @type {datum-number=} */\n  y: 0.5,\n\n  /** Normalized size of shape\n   * @type {datum-number=} */\n  size: 1,\n  strokeDasharray: ''\n};\n/**\n  * @typedef {object}\n  * @alias component--point.settings.sizeLimits\n  */\n\nvar SIZE_LIMITS = {\n  /** Maximum size of shape, in pixels\n   * @type {number=} */\n  maxPx: 10000,\n\n  /** Minimum size of shape, in pixels\n   * @type {number=} */\n  minPx: 1,\n\n  /** Maximum size relative linear scale extent\n   * @type {number=} */\n  maxRelExtent: 0.1,\n\n  /** Minimum size relative linear scale extent\n   * @type {number=} */\n  minRelExtent: 0.01,\n\n  /** Maximum size relative discrete scale banwidth\n   * @type {number=} */\n  maxRelDiscrete: 1,\n\n  /** Minimum size relative discrete scale banwidth\n   * @type {number=} */\n  minRelDiscrete: 0.1\n};\n\nfunction getPxSpaceFromScale(s, space) {\n  if (s && typeof s.bandwidth === 'function') {\n    // some kind of ordinal scale\n    return {\n      isBandwidth: true,\n      value: Math.max(1, s.bandwidth() * space)\n    };\n  }\n\n  return {\n    isBandwidth: false,\n    value: Math.max(1, space)\n  };\n}\n\nfunction getPointSizeLimits(x, y, width, height, limits) {\n  var xSpacePx = getPxSpaceFromScale(x ? x.scale : undefined, width);\n  var ySpacePx = getPxSpaceFromScale(y ? y.scale : undefined, height);\n  var maxSizePx = Math.min(xSpacePx.value * limits[xSpacePx.isBandwidth ? 'maxRelDiscrete' : 'maxRelExtent'], ySpacePx.value * limits[ySpacePx.isBandwidth ? 'maxRelDiscrete' : 'maxRelExtent']);\n  var minSizePx = Math.min(xSpacePx.value * limits[xSpacePx.isBandwidth ? 'minRelDiscrete' : 'minRelExtent'], ySpacePx.value * limits[ySpacePx.isBandwidth ? 'minRelDiscrete' : 'minRelExtent']);\n  var min = Math.max(1, Math.floor(minSizePx));\n  var max = Math.max(1, Math.floor(maxSizePx));\n  return {\n    min: min,\n    max: max,\n    maxGlobal: limits.maxPx,\n    minGlobal: limits.minPx\n  };\n}\n\nfunction createDisplayPoints(dataPoints, _ref, pointSize, shapeFn) {\n  var width = _ref.width,\n      height = _ref.height;\n  return dataPoints.filter(function (p) {\n    return !isNaN(p.x + p.y);\n  }).map(function (p) {\n    var s = notNumber(p.size) ? DEFAULT_ERROR_SETTINGS.errorShape : p;\n    var size = pointSize.min + s.size * (pointSize.max - pointSize.min);\n    var shapeSpec = {\n      type: s.shape === 'rect' ? 'square' : s.shape,\n      label: p.label,\n      x: p.x * width,\n      y: p.y * height,\n      fill: s.fill,\n      size: Math.min(pointSize.maxGlobal, Math.max(pointSize.minGlobal, size)),\n      stroke: s.stroke,\n      strokeWidth: s.strokeWidth,\n      strokeDasharray: s.strokeDasharray,\n      opacity: s.opacity\n    };\n\n    if (s === p.errorShape) {\n      shapeSpec.width = s.width;\n    }\n\n    var shape = shapeFn(shapeSpec);\n    shape.data = p.data;\n    return shape;\n  });\n}\n\nvar component$1 = {\n  require: ['chart', 'resolver'],\n  defaultSettings: {\n    settings: {},\n    data: {},\n    animations: {\n      enabled: false,\n      trackBy: function trackBy(node) {\n        return node.data.value;\n      }\n    },\n    style: {\n      item: '$shape'\n    }\n  },\n  render: function render(_ref2) {\n    var data = _ref2.data;\n    var resolved = this.resolver.resolve({\n      data: data,\n      defaults: extend({}, DEFAULT_DATA_SETTINGS$1, this.style.item),\n      settings: this.settings.settings,\n      scaled: {\n        x: this.rect.width,\n        y: this.rect.height\n      }\n    });\n    var _this$rect = this.rect,\n        width = _this$rect.width,\n        height = _this$rect.height;\n    var limits = extend({}, SIZE_LIMITS, this.settings.settings.sizeLimits);\n    var points = resolved.items;\n    var pointSize = getPointSizeLimits(resolved.settings.x, resolved.settings.y, width, height, limits);\n    return createDisplayPoints(points, this.rect, pointSize, this.settings.shapeFn || create$3);\n  }\n};\n\n/**\n * @typedef {object} component--point\n */\n\n/**\n * @type {string}\n * @memberof component--point\n */\n\nvar type = 'point';\nfunction pointMarker(picasso) {\n  picasso.component(type, component$1);\n  picasso.component('point-marker', component$1); // temporary backwards compatibility - DEPRECATED\n}\n\n/**\n * @typedef {object}\n * @alias component--pie-settings\n */\n\nvar DEFAULT_DATA_SETTINGS$2 = {\n  /** Start angle of the pie, in radians\n   * @type {number=} */\n  startAngle: 0,\n\n  /** End angle of the pie, in radians\n   * @type {number=} */\n  endAngle: 2 * Math.PI,\n\n  /**\n   * @typedef {object}\n   */\n  slice: {\n    label: '',\n\n    /** Absolute value of the slice's arc length\n     * @type {number=} */\n    arc: 1,\n\n    /** Visibility of the slice\n     * @type {boolean=} */\n    show: true,\n\n    /** Fill color of the slice\n     * @type {string=} */\n    fill: '#333',\n\n    /** Stroke color of the slice\n     * @type {string=} */\n    stroke: '#ccc',\n\n    /** Stroke width of the slice\n     * @type {number=} */\n    strokeWidth: 1,\n\n    /** Stroke line join\n     * @type {string=} */\n    strokeLinejoin: 'round',\n\n    /** Opacity of the slice\n     * @type {number=} */\n    opacity: 1,\n\n    /** Inner radius of the slice\n     * @type {number=} */\n    innerRadius: 0,\n\n    /** Outer radius of the slice\n     * @type {number=} */\n    outerRadius: 0.8,\n\n    /** Corner radius of the slice, in pixels\n     * @type {number=} */\n    cornerRadius: 0,\n\n    /** Radial offset of the slice\n     * @type {number=} */\n    offset: 0\n  }\n};\n/**\n * @typedef {object} component--pie\n * @property {string} [type='pie']\n * @example\n * {\n *   type: 'pie',\n *   data: {\n *     extract: {\n *       field: 'Region',\n *       props: {\n *         num: { field: 'Population' }\n *       }\n *     }\n *   },\n *   settings: {\n *     startAngle: Math.PI / 2,\n *     endAngle: -Math.PI / 2,\n *     slice: {\n *       arc: { ref: 'num' },\n *       fill: 'green',\n *       stroke: 'red',\n *       strokeWidth: 2,\n *       strokeLinejoin: 'round',\n *       innerRadius: 0.6,\n *       outerRadius 0.8,\n *       opacity: 0.8,\n *       offset: 0.2\n *     }\n *   }\n * }\n */\n\nfunction offsetSlice(centroid, offset, outerRadius, innerRadius) {\n  var _centroid = _slicedToArray(centroid, 2),\n      vx = _centroid[0],\n      vy = _centroid[1];\n\n  var vlen = Math.sqrt(vx * vx + vy * vy);\n  vx /= vlen;\n  vy /= vlen;\n  var diff = outerRadius - innerRadius;\n  return {\n    x: vx * offset * diff,\n    y: vy * offset * diff\n  };\n}\n\nfunction createDisplayPies(arcData, _ref, slices, sum) {\n  var x = _ref.x,\n      y = _ref.y,\n      width = _ref.width,\n      height = _ref.height;\n  var arcGen = arc();\n  var center = {\n    x: x + width / 2,\n    y: y + height / 2\n  };\n  var innerRadius = Math.min(width, height) / 2;\n  var outerRadius = Math.min(width, height) / 2;\n  var cornerRadius = outerRadius / 100;\n  return arcData.map(function (a, i) {\n    var slice = slices[i];\n    slice.type = 'path';\n    var or = outerRadius * slice.outerRadius;\n    var ir = innerRadius * slice.innerRadius;\n    arcGen.innerRadius(ir);\n    arcGen.outerRadius(or);\n    arcGen.cornerRadius(cornerRadius * slice.cornerRadius);\n    slice.d = arcGen(a);\n    var centroid = arcGen.centroid(a);\n    var offset = slice.offset ? offsetSlice(centroid, slice.offset, or, ir) : {\n      x: 0,\n      y: 0\n    };\n    slice.transform = \"translate(\".concat(offset.x, \", \").concat(offset.y, \") translate(\").concat(center.x, \", \").concat(center.y, \")\");\n    slice.desc = {\n      share: a.value / sum,\n      slice: {\n        start: a.startAngle,\n        end: a.endAngle,\n        innerRadius: ir,\n        outerRadius: or,\n        offset: {\n          x: center.x + offset.x,\n          y: center.y + offset.y\n        }\n      }\n    };\n    return slice;\n  });\n}\n\nfunction arcValue(stngs, item) {\n  if (stngs.slice && 'arc' in stngs.slice) {\n    return item.arc;\n  }\n\n  return item.data.value;\n}\nvar pieComponent = {\n  require: ['chart', 'resolver'],\n  defaultSettings: {\n    settings: {\n      startAngle: 0,\n      endAngle: 2 * Math.PI,\n      padAngle: 0,\n      slice: {}\n    },\n    style: {\n      slice: '$shape'\n    },\n    data: {}\n  },\n  render: function render(_ref2) {\n    var data = _ref2.data;\n    var arcValues = [];\n    var slices = [];\n    var stngs = this.settings.settings;\n\n    var _this$resolver$resolv = this.resolver.resolve({\n      data: data,\n      defaults: extend({}, DEFAULT_DATA_SETTINGS$2.slice, this.style.slice),\n      settings: stngs.slice\n    }),\n        items = _this$resolver$resolv.items;\n\n    var sum = 0;\n\n    for (var i = 0, len = items.length; i < len; i++) {\n      var val = arcValue(stngs, items[i]);\n\n      if (val > 0 && items[i].outerRadius >= items[i].innerRadius) {\n        arcValues.push(val);\n        slices.push(items[i]);\n        sum += val;\n      }\n    }\n\n    var pieGen = pie().sortValues(null);\n    pieGen.startAngle(stngs.startAngle);\n    pieGen.endAngle(stngs.endAngle);\n    pieGen.padAngle(stngs.padAngle);\n    var arcData = pieGen(arcValues);\n    return createDisplayPies(arcData, extend({}, this.rect, {\n      x: 0,\n      y: 0\n    }), slices, sum);\n  }\n};\n\nfunction pie$1(picasso) {\n  picasso.component('pie', pieComponent);\n}\n\n/**\n * Create a crispifier\n * @ignore\n *\n * @param  {Object} [crispMap] Optional crispmap if you need custom crisping.\n * @return {Function}          crispItem function\n *\n * @example\n * import { crispifierFactory } from \"core/crispifier\";\n *\n * let crispify = crispifierFactory(customCrispMap);\n *\n * // For a single item\n * crispify(myItem);\n *\n * // For multiple items\n * crispify.multiple(myArrayOfItems);\n */\nfunction crispifierFactory(crispMap) {\n  // Define the crispMap\n  if (crispMap === undefined) {\n    crispMap = {};\n    crispMap.line = {\n      append: ['x1', 'x2', 'y1', 'y2'],\n      round: [],\n      condition: function condition(item) {\n        return item.x1 === item.x2 || item.y1 === item.y2;\n      },\n      conditionAppend: function conditionAppend(item) {\n        return item.strokeWidth % 2 !== 0;\n      }\n    };\n    crispMap.rect = {\n      append: ['x', 'y'],\n      round: ['width', 'height'],\n      condition: function condition() {\n        return true;\n      },\n      conditionAppend: function conditionAppend(item) {\n        return item.strokeWidth % 2 !== 0;\n      }\n    };\n  } // Re-map the crispmap\n\n\n  Object.keys(crispMap).forEach(function (type) {\n    var self = crispMap[type];\n    self.items = [];\n    self.append.forEach(function (toAppend) {\n      self.items.push({\n        key: toAppend,\n        type: 'append'\n      });\n    });\n    self.round.forEach(function (toAppend) {\n      self.items.push({\n        key: toAppend,\n        type: 'round'\n      });\n    });\n  });\n  /**\n   * Crispify a single item\n   * @ignore\n   * @param  {Object} item  Item with renderer variables such as X, Y, and type.\n   * @return {Undefined}    Returns nothing, modifies the original item instead\n   */\n\n  function crispItem(item) {\n    if (crispMap[item.type] && crispMap[item.type].condition(item)) {\n      var self = crispMap[item.type];\n      var doAppend = self.conditionAppend === undefined || self.conditionAppend(item);\n      self.items.forEach(function (i) {\n        var rounded = Math.round(item[i.key]);\n        var diff = item[i.key] - rounded;\n        item[i.key] = rounded;\n\n        if (doAppend && i.type === 'append') {\n          if (diff > 0) {\n            item[i.key] += 0.5;\n          } else {\n            item[i.key] -= 0.5;\n          }\n        }\n      });\n    }\n  }\n  /**\n   * Crispify multiple items\n   * @ignore\n   *\n   * @param  {Array} items  Array of objects to crispify\n   * @return {Undefined}    Returns nothing, modifies the original item instead\n   */\n\n\n  crispItem.multiple = function (items) {\n    return items.forEach(function (item) {\n      return crispItem(item);\n    });\n  };\n\n  return crispItem;\n}\nvar crispifier = crispifierFactory();\n\nvar Transposer =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @private\n   */\n  function Transposer() {\n    _classCallCheck$1(this, Transposer);\n\n    this.reset();\n    this.push.apply(this, arguments);\n  }\n  /**\n   * Evaluate a key for a transposed coordinate\n   *\n   * @param  {String} key   Key\n   * @return {String}         Actual key\n   */\n\n\n  _createClass$1(Transposer, [{\n    key: \"transposeCoordinate\",\n\n    /**\n     * Transpose a coordinate according to this.flipXY and\n     * the available rendering area\n     *\n     * @param  {String} key        The key of the coordinate to transpose\n     * @param  {Number} coordinate The coordinate\n     * @return {Number}            The actual location of the coordinate\n     */\n    value: function transposeCoordinate(key, coordinate, flipXY) {\n      if (typeof coordinate === 'number' && isFinite(coordinate)) {\n        var firstChar = key.substring(0, 1);\n\n        if (firstChar === 'x' || key === 'cx') {\n          return coordinate * this.width;\n        }\n\n        if (key === 'width') {\n          return coordinate * this.width;\n        }\n\n        if (key === 'r') {\n          return coordinate * (!flipXY ? this.width : this.height);\n        }\n\n        if (firstChar === 'y' || key === 'cy') {\n          return coordinate * this.height;\n        }\n\n        if (key === 'height') {\n          return coordinate * this.height;\n        }\n      }\n\n      return coordinate;\n    }\n    /**\n     * Push an item into the storage of the transposer\n     *\n     * @param  {Object} items An item to be drawed\n     * @return {Object}       Can be chained\n     */\n\n  }, {\n    key: \"push\",\n    value: function push() {\n      var _this$storage;\n\n      (_this$storage = this.storage).push.apply(_this$storage, arguments);\n\n      return this;\n    }\n  }, {\n    key: \"processItem\",\n    value: function processItem(item) {\n      var newItem = {};\n      var flipXY = typeof item.flipXY !== 'undefined' ? item.flipXY : this.flipXY;\n      var crisp = typeof item.crisp !== 'undefined' ? item.crisp : this.crisp;\n\n      if (item.fn && typeof item.fn === 'function') {\n        var width = flipXY ? this.height : this.width;\n        var height = flipXY ? this.width : this.height;\n        item = item.fn({\n          width: width,\n          height: height,\n          flipXY: flipXY\n        });\n        var objectKeys = Object.keys(item);\n\n        for (var ki = 0, kl = objectKeys.length; ki < kl; ki++) {\n          var key = objectKeys[ki];\n          var nkey = Transposer.evaluateKey(key, flipXY);\n          newItem[nkey] = item[key];\n        }\n      } else {\n        var _objectKeys = Object.keys(item);\n\n        for (var _ki = 0, _kl = _objectKeys.length; _ki < _kl; _ki++) {\n          var _key = _objectKeys[_ki];\n\n          var _nkey = Transposer.evaluateKey(_key, flipXY);\n\n          var nval = this.transposeCoordinate(_nkey, item[_key], flipXY);\n          newItem[_nkey] = nval;\n        }\n      }\n\n      if (crisp) {\n        crispifier(newItem);\n      }\n\n      return newItem;\n    }\n    /**\n     * Get the output of the transposer\n     *\n     * @return {Array}   Array of objects\n     */\n\n  }, {\n    key: \"output\",\n    value: function output() {\n      var items = [];\n\n      for (var i = 0, l = this.storage.length; i < l; i++) {\n        var newItem = this.processItem(this.storage[i]);\n        items.push(newItem);\n      }\n\n      return items;\n    }\n    /**\n     * Reset the transposer\n     *\n     * @return {Undefined}  Does not return anything\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.storage = [];\n      this.flipXY = false;\n      this.crisp = false;\n      this.width = 0;\n      this.height = 0;\n    }\n  }], [{\n    key: \"evaluateKey\",\n    value: function evaluateKey(key, flipXY) {\n      if (flipXY) {\n        var firstChar = key.substring(0, 1);\n        var rest = key.substring(1);\n\n        if (firstChar === 'x') {\n          return \"y\".concat(rest);\n        }\n\n        if (firstChar === 'y') {\n          return \"x\".concat(rest);\n        }\n\n        if (key === 'cx') {\n          return 'cy';\n        }\n\n        if (key === 'cy') {\n          return 'cx';\n        }\n\n        if (key === 'width') {\n          return 'height';\n        }\n\n        if (key === 'height') {\n          return 'width';\n        }\n      }\n\n      return key;\n    }\n  }]);\n\n  return Transposer;\n}();\n\nfunction transposer() {\n  for (var _len = arguments.length, items = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {\n    items[_key2] = arguments[_key2];\n  }\n\n  return _construct(Transposer, items);\n}\n\n/**\n * Generate array of lines (ticks) from scale\n *\n * @param {object} scale - A scale supplied by the chart\n * @param {object} settings - The settings object from the grid line component\n * @param {object} rect - The rect containing width and height to renderer in\n * @returns {array} - Returns an array of ticks\n * @ignore\n */\n\nfunction lineGen(scale, distance) {\n  if (!scale || !distance) {\n    return [];\n  }\n\n  return scale.cachedTicks && scale.cachedTicks() || scale.ticks({\n    distance: distance\n  });\n}\n\nvar gridLineComponent = {\n  created: function created() {},\n  require: ['chart', 'renderer', 'resolver'],\n  defaultSettings: {\n    layout: {\n      displayOrder: 0\n    },\n    style: {\n      // Theming style\n      ticks: '$guide-line',\n      minorTicks: '$guide-line--minor'\n    }\n  },\n  beforeRender: function beforeRender() {\n    this.blueprint = transposer();\n    this.blueprint.width = this.rect.width;\n    this.blueprint.height = this.rect.height;\n    this.blueprint.x = this.rect.x;\n    this.blueprint.y = this.rect.y;\n    this.blueprint.crisp = true;\n  },\n  render: function render() {\n    var _this = this;\n\n    // Setup scales\n    this.x = this.settings.x ? this.chart.scale(this.settings.x) : null;\n    this.y = this.settings.y ? this.chart.scale(this.settings.y) : null;\n    updateScaleSize(this, 'x', this.rect.width);\n    updateScaleSize(this, 'y', this.rect.height); // Return an empty array to abort rendering when no scales are available to renderer\n\n    if (!this.x && !this.y) {\n      return [];\n    }\n\n    this.settings.ticks = extend({\n      show: true\n    }, this.style.ticks, this.settings.ticks || {});\n    this.settings.minorTicks = extend({\n      show: false\n    }, this.style.minorTicks, this.settings.minorTicks || {}); // Setup lines for X and Y\n\n    this.lines = {\n      x: [],\n      y: []\n    }; // Use the lineGen function to generate appropriate ticks\n\n    this.lines.x = lineGen(this.x, this.rect.width);\n    this.lines.y = lineGen(this.y, this.rect.height); // Set all Y lines to flipXY by default\n    // This makes the transposer flip them individually\n\n    this.lines.y = this.lines.y.map(function (i) {\n      return extend(i, {\n        flipXY: true\n      });\n    });\n\n    var addTicks = function addTicks(_ref) {\n      var dir = _ref.dir,\n          isMinor = _ref.isMinor;\n\n      var items = _this.lines[dir].filter(function (tick) {\n        return !!tick.isMinor === isMinor;\n      });\n\n      var settings = isMinor ? _this.settings.minorTicks : _this.settings.ticks;\n\n      var ticks = _this.resolver.resolve({\n        settings: settings,\n        data: {\n          items: items,\n          dir: dir\n        }\n      }).items;\n\n      ticks.forEach(function (style) {\n        var p = style.data; // If the style's show is falsy, don't renderer this item (to respect axis settings).\n\n        if (style.show) {\n          // Use the transposer to handle actual positioning\n          _this.blueprint.push({\n            type: 'line',\n            x1: p.position,\n            y1: 0,\n            x2: p.position,\n            y2: 1,\n            stroke: style.stroke || 'black',\n            strokeWidth: typeof style.strokeWidth !== 'undefined' ? style.strokeWidth : 1,\n            strokeDasharray: typeof style.strokeDasharray !== 'undefined' ? style.strokeDasharray : undefined,\n            flipXY: p.flipXY || false // This flips individual points (Y-lines)\n\n          });\n        }\n      });\n    };\n\n    addTicks({\n      dir: 'x',\n      isMinor: false\n    });\n    addTicks({\n      dir: 'x',\n      isMinor: true\n    });\n    addTicks({\n      dir: 'y',\n      isMinor: false\n    });\n    addTicks({\n      dir: 'y',\n      isMinor: true\n    });\n    return this.blueprint.output();\n  }\n};\n\n/**\n * @typedef {object} component--grid-line-settings\n * @property {object} x\n * @property {string} x.scale - The scale to use along x\n * @property {object} y\n * @property {string} y.scale - The scale to use along y\n * @property {object} [ticks]\n * @property {boolean} [ticks.show=true]\n * @property {string} [ticks.stroke='black']\n * @property {number} [ticks.strokeWidth='1']\n * @property {string} [ticks.strokeDasharray]\n * @property {object} [minorTicks]\n * @property {boolean} [minorTicks.show=true]\n * @property {string} [minorTicks.stroke='black']\n * @property {number} [minorTicks.strokeWidth='1']\n * @property {string} [minorTicks.strokeDasharray]\n */\n\nfunction gridLine(picasso) {\n  picasso.component('grid-line', gridLineComponent);\n}\n\n/**\n * Return a D property for a SVG path to get a direction marker\n *\n * @param {number} x - X coordinate\n * @param {number} y - Y coordinate\n * @param {number} r - Radius\n * @param {string} [d='bottom'] - Direction\n * @returns {string} - Finished D property\n * @ignore\n */\nfunction directionMarker(x, y, r) {\n  var d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'bottom';\n  r *= 0.8;\n\n  if (d === 'left' || d === 'right') {\n    var right = d === 'right';\n    return \"\\n      M \".concat(x, \" \").concat(y - r, \"\\n      A \").concat(r * 1.25, \" \").concat(r * 1.25, \", 0, 1, \").concat(right ? 0 : 1, \", \").concat(x, \" \").concat(y + r, \"\\n      L \").concat(right ? x + r : x - r, \" \").concat(y, \" Z\\n    \");\n  }\n\n  var bottom = d === 'bottom';\n  return \"\\n    M \".concat(x - r, \" \").concat(y, \"\\n    A \").concat(r * 1.25, \" \").concat(r * 1.25, \", 0, 1, \").concat(bottom ? 1 : 0, \", \").concat(x + r, \" \").concat(y, \"\\n    L \").concat(x, \" \").concat(bottom ? y + r : y - r, \" Z\\n  \");\n}\n\nfunction directionTriangle(x, y, r) {\n  var d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'bottom';\n  r *= 0.75;\n\n  if (d === 'left' || d === 'right') {\n    var right = d === 'right';\n    x += right ? r * 1.5 : -(r * 1.5);\n    return \"\\n      M \".concat(x, \" \").concat(y - r, \"\\n      L \").concat(x, \" \").concat(y + r, \"\\n      L \").concat(right ? x + r : x - r, \" \").concat(y, \" Z\\n    \");\n  }\n\n  var bottom = d === 'bottom';\n  y += bottom ? r * 1.5 : -(r * 1.5);\n  return \"\\n    M \".concat(x - r, \" \").concat(y, \"\\n    L \").concat(x + r, \" \").concat(y, \"\\n    L \").concat(x, \" \").concat(bottom ? y + r : y - r, \" Z\\n  \");\n}\n/**\n * Handle out of bound shapes\n * Does not return anything, modifies \"items\" property instead (should be re-considered)\n *\n * @param {object} oob - Out of bounds object from parent\n * @param {object} settings - Settings object from parent\n * @param {object[]} items - Array of all items (for collision detection)\n * @ignore\n */\n\n\nfunction oobManager(_ref) {\n  var blueprint = _ref.blueprint,\n      oob = _ref.oob,\n      settings = _ref.settings,\n      items = _ref.items;\n  var oobKeys = Object.keys(oob);\n  var style = settings.style.oob || {};\n\n  var _loop = function _loop(i, len) {\n    var key = oobKeys[i];\n    var value = oob[key];\n\n    if (value.length > 0) {\n      var position = key.charAt(1);\n      var flipXY = key.charAt(0) === 'y';\n      var xPadding = style.padding.x + style.width;\n      var yPadding = style.padding.y + style.width;\n      var direction = 'bottom';\n\n      if (flipXY) {\n        direction = position === '1' ? 'bottom' : 'top';\n      } else {\n        direction = position === '1' ? 'right' : 'left';\n      }\n\n      var indicator = blueprint.processItem({\n        fn: function fn(_ref2) {\n          var width = _ref2.width,\n              height = _ref2.height;\n\n          /* eslint no-loop-func: 0 */\n          var x = position * width + (position === '1' ? -xPadding : xPadding);\n          var y = flipXY ? yPadding : height - yPadding;\n\n          if (style.type === 'arc') {\n            return {\n              type: 'path',\n              d: directionMarker(flipXY ? y : x, flipXY ? x : y, style.width, direction),\n              x: x,\n              y: y,\n              stroke: style.stroke,\n              fill: style.fill,\n              strokeWidth: style.strokeWidth || 0\n            };\n          }\n\n          return {\n            type: 'circle',\n            cx: x,\n            cy: y,\n            r: style.width,\n            stroke: style.stroke,\n            fill: style.fill,\n            strokeWidth: style.strokeWidth || 0,\n            opacity: style.opacity,\n            data: value\n          };\n        },\n        flipXY: flipXY\n      });\n      var x = indicator.cx || indicator.x;\n      var y = indicator.cy || indicator.y;\n      var text = {\n        type: 'text',\n        text: value.length || '',\n        x: x - style.width * 0.4,\n        y: y + style.width * 0.4,\n        fontFamily: style.text.fontFamily,\n        fontSize: \"\".concat(style.width * 1.3, \"px\"),\n        stroke: style.text.stroke,\n        fill: style.text.fill,\n        strokeWidth: style.text.strokeWidth || 0,\n        opacity: style.text.opacity\n      };\n      var triangle = {\n        type: 'path',\n        d: directionTriangle(x, y, style.width, direction),\n        x: x,\n        y: y,\n        stroke: style.triangle.stroke,\n        fill: style.triangle.fill,\n        strokeWidth: style.triangle.strokeWidth || 0,\n        opacity: style.triangle.opacity\n      };\n      items.push(indicator, text, triangle);\n    }\n  };\n\n  for (var i = 0, len = oobKeys.length; i < len; i++) {\n    _loop(i);\n  }\n}\n\nfunction refLabelDefaultSettings() {\n  return {\n    fill: '#000',\n    fontFamily: 'Arial',\n    fontSize: '12px',\n    opacity: 1,\n    maxWidth: 1,\n    maxWidthPx: 9999,\n    padding: 5,\n    background: {\n      fill: '#fff',\n      stroke: 'transparent',\n      strokeWidth: 0,\n      opacity: 0.5\n    }\n  };\n}\n/**\n * Converts a numerical OR string value to a normalized value\n *\n * @param {string|number} align -Description how to align (Numerical from 0-1 or 'top', 'left', 'center', 'middle', 'bottom' or 'right')\n * @returns {number} - Normalized value 0...1\n * @ignore\n */\n\nfunction alignmentToNumber(align) {\n  if (typeof align === 'undefined') {\n    return 0;\n  }\n\n  if (typeof align === 'number' && isFinite(align)) {\n    return align;\n  }\n\n  if (typeof align === 'string') {\n    switch (align) {\n      case 'center':\n      case 'middle':\n        return 0.5;\n\n      case 'bottom':\n      case 'right':\n        return 1;\n\n      case 'top':\n      case 'left':\n      default:\n        return 0;\n    }\n  }\n\n  return 0;\n}\n/**\n * Create line and label (if applicable)\n * Does not return anything, modifies \"items\" property instead (should be re-considered)\n *\n * @param {object} p - Current point\n * @param {object} style - Applicable line styling\n * @param {object} settings - Settings object derived from parent\n * @param {object[]} items - Array of all items (for collision detection)\n * @ignore\n */\n\nfunction createLineWithLabel(_ref) {\n  var chart = _ref.chart,\n      blueprint = _ref.blueprint,\n      renderer = _ref.renderer,\n      p = _ref.p,\n      settings = _ref.settings,\n      items = _ref.items;\n  var doesNotCollide = true;\n  var line = false;\n  var rect = false;\n  var label = false;\n  var value = false;\n  var style = extend(true, {}, settings.style.line, p.line || {}); // Use the transposer to handle actual positioning\n\n  line = blueprint.processItem({\n    type: 'line',\n    x1: p.position,\n    y1: 0,\n    x2: p.position,\n    y2: 1,\n    stroke: style.stroke || 'black',\n    strokeWidth: style.strokeWidth || 1,\n    flipXY: p.flipXY || false // This flips individual points (Y-lines)\n\n  });\n\n  if (p.label) {\n    var item = extend(true, refLabelDefaultSettings(), settings.style.label || {}, {\n      fill: style.stroke\n    }, p.label);\n    var formatter;\n    var measuredValue = {\n      width: 0,\n      height: 0\n    };\n    var valueString = '';\n\n    if (typeof p.formatter === 'string') {\n      formatter = chart.formatter(p.formatter);\n    } else if (_typeof(p.formatter) === 'object') {\n      formatter = chart.formatter(p.formatter);\n    } else if (typeof p.scale !== 'undefined' && p.scale.data) {\n      // TODO - Add support for array as source into formatter\n      var scaleData = p.scale.data() && p.scale.data().fields;\n      formatter = scaleData && scaleData[0] ? scaleData[0].formatter() : null;\n    }\n\n    if (formatter) {\n      valueString = \" (\".concat(formatter(p.value), \")\");\n    } else if (p.scale) {\n      valueString = \" (\".concat(p.value, \")\");\n    }\n\n    if (valueString) {\n      measuredValue = renderer.measureText({\n        text: valueString,\n        fontFamily: item.fontFamily,\n        fontSize: item.fontSize\n      });\n    } // Measure the label text\n\n\n    var measuredLabel = renderer.measureText({\n      text: item.text || '',\n      fontFamily: item.fontFamily,\n      fontSize: item.fontSize\n    });\n    var measured = {\n      width: measuredLabel.width + measuredValue.width,\n      height: Math.max(measuredLabel.height, measuredValue.height)\n    };\n    var labelPadding = item.padding; // let anchor = item.anchor === 'end' ? 'end' : 'start';\n\n    var align = alignmentToNumber(p.flipXY ? item.vAlign : item.align);\n    var vAlign = alignmentToNumber(p.flipXY ? item.align : item.vAlign);\n    var calcWidth = Math.min(1 + measured.width + labelPadding * 2, item.maxWidth * blueprint.width, item.maxWidthPx);\n    var calcHeight = measured.height + labelPadding * 2;\n    var rectWidth = p.flipXY ? calcHeight : calcWidth;\n    var rectHeight = p.flipXY ? calcWidth : calcHeight;\n    rect = blueprint.processItem({\n      fn: function fn(_ref2) {\n        var width = _ref2.width,\n            height = _ref2.height;\n        var x = p.position * width - (p.flipXY ? calcHeight : calcWidth) * (1 - align);\n        x = p.flipXY ? x : Math.max(x, 0);\n        var y = Math.max(Math.abs(vAlign * height - rectHeight * vAlign), 0);\n        return {\n          type: 'rect',\n          x: x,\n          y: y,\n          width: p.flipXY ? rectWidth : Math.min(rectWidth, blueprint.width - x),\n          height: rectHeight,\n          stroke: item.background.stroke,\n          strokeWidth: item.background.strokeWidth,\n          fill: item.background.fill,\n          opacity: item.background.opacity\n        };\n      },\n      flipXY: p.flipXY || false // This flips individual points (Y-lines)\n\n    });\n\n    if (rect.x < -1 || rect.x + rect.width > blueprint.width + 1 || rect.y < -1 || rect.y + rect.height > blueprint.height + 1) {\n      // do not create labels if out of bounds\n      rect = undefined;\n    } else {\n      // Labels are just basic objects attached to a corner of a rect,\n      // and this rect needs to already be processed\n      // so there is no blueprint.processItem required here\n      label = {\n        type: 'text',\n        text: item.text || '',\n        fill: item.fill,\n        opacity: item.opacity,\n        fontFamily: item.fontFamily,\n        fontSize: item.fontSize,\n        x: rect.x + labelPadding,\n        y: rect.y + rect.height / 2 + measured.height / 3,\n        maxWidth: rect.width - labelPadding * 2 - measuredValue.width,\n        anchor: 'start'\n      };\n\n      if (valueString) {\n        value = {\n          type: 'text',\n          text: valueString || '',\n          fill: item.fill,\n          opacity: item.opacity,\n          fontFamily: item.fontFamily,\n          fontSize: item.fontSize,\n          x: label.x + 3 + (rect.width - (measuredValue.width + labelPadding * 2)),\n          y: label.y\n        };\n      } // Detect collisions with other labels/rects or lines\n\n\n      for (var i = 0, len = items.length; i < len; i++) {\n        var curItem = items[i];\n\n        if (curItem.type === 'rect') {\n          // We only detect rects here, since rects are always behind labels,\n          // and we wouldn't want to measure text one more time\n          if (testRectRect(rect, curItem)) {\n            doesNotCollide = false;\n          }\n        } else if (curItem.type === 'line') {\n          // This will only collide when flipXY are the same for both objects,\n          // So it only collides on objects on the same \"axis\"\n          if (p.flipXY === curItem.flipXY && testRectLine(rect, curItem)) {\n            doesNotCollide = false;\n          }\n        }\n      }\n    }\n  } // Always push the line,\n  // but this is done after collision detection,\n  // because otherwise it would collide with it's own line\n\n\n  items.push(line); // Only push rect & label if we haven't collided and both are defined\n\n  if (doesNotCollide && rect && label) {\n    items.push(rect, label);\n\n    if (value) {\n      items.push(value);\n    }\n  }\n}\n\nfunction createOobData(line) {\n  var data = {\n    value: line.value\n  };\n\n  if (line.label) {\n    data.label = line.label.text;\n  }\n\n  return data;\n}\n\nfunction filterUndefinedValue(line) {\n  return typeof line.value !== 'undefined';\n}\n/**\n * @typedef {object} component--ref-line\n * @experimental\n * @property {refline-generic-style} [style=refline-generic-style] - x coordinate\n * @property {object} lines - X & Y Lines\n * @property {reflines-x[]} [lines.x=refline-line[]] - lines along X\n * @property {reflines-y[]} [lines.y=refline-line[]] - lines along Y\n */\n\n/**\n * @typedef {object} component--ref-line.style\n * @property {refline-oob-style} [oob=component--ref-line.style.oob] - Style for out of bounds object (oob)\n * @property {refline-line} [line=refline-line] - Generic style for lines\n * @property {refline-line-label} [label=refline-line-label] - Generic style for labels\n */\n\n/**\n * @typedef {object} component--ref-line.style.oob\n * @property {boolean} [show=true] - Show out of bounds items\n * @property {string} [type=undefined] - EXPERIMENTAL:  Set this to 'arc' for an experimental out of bounds shape (only works with SVG)\n * @property {number} [width=10] - Width of the out of bounds object\n * @property {string} [fill='#1A1A1A'] - Fill color of the OOB object\n * @property {string} [stroke='transparent'] - Stroke of the OOB object\n * @property {number} [strokeWidth=0] - Stroke width of the OOB object\n * @property {number} [opacity=1] - Opacity of the OOB object\n * @property {refline-generic-text} [text=refline-generic-text] - Text configuration for out of bounds\n * @property {refline-generic-object} [triangle=refline-generic-object] - The triangle in OOB\n * @property {object} [padding] - Padding on X\n * @property {number} [padding.x=28] - Padding on X\n * @property {number} [padding.y=5] - Padding on X\n */\n\n/**\n * @typedef {object} component--ref-line.generic-text\n * @property {string} [text=''] - Text (if applicable)\n * @property {string} [fontSize='12px'] - Font size (if applicable)\n * @property {string} [fontFamily='Arial'] - Font family\n * @property {string} [fill='#fff'] - Fill color\n * @property {string} [stroke='transparent'] - Stroke\n * @property {number} [strokeWidth=0] - Stroke width\n * @property {number} [opacity=1] - Opacity\n */\n\n/**\n * @typedef {object} component--ref-line.line\n * @property {number} value - The value of the reference line. If a scale is specified, it is applied.\n * @property {Scale} [scale=undefined] - Scale to use (if undefined will use normalized value 0-1)\n * @property {refline-generic-object} [line=refline-generic-object] - The style of the line\n * @property {refline-line-label} [label=refline-line-label] - The label style of the line\n */\n\n/**\n * @typedef {object} component--ref-line.line-label\n * @property {number} padding=5 - Padding inside the label\n * @property {string} [text=''] - Text\n * @property {string} [fontSize='12px'] - Font size\n * @property {string} [fontFamily='Arial'] - Font family\n * @property {string} [stroke='transparent'] - Stroke\n * @property {number} [strokeWidth=0] - Stroke width\n * @property {number} [opacity=1] - Opacity\n * @property {number|string} [align=0] - Alignment property left to right (0 = left, 1 = right). Also supports string ('left', 'center', 'middle', 'right')\n * @property {number|string} [vAlign=0] - Alignment property top to bottom (0 = top, 1 = bottom). Also supports string ('top', 'center', 'middle', 'bottom')\n * @property {number} [maxWidth=1] - The maximum relative width to the width of the rendering area (see maxWidthPx below aswell)\n * @property {number} [maxWidthPx=9999] - The maximum width in pixels.\n * @property {refline-line-label-background} [background=refline-line-label-background] - The background style (rect behind text)\n */\n\n/**\n * @example\n * // Labels will be rendered with the maximum size of the smallest value of maxWidth and maxWidthPx size, so you may specify maxWidth 0.8 but maxWidthPx 100 and will never be over 100px and never over 80% of the renderable area.\n */\n\n/**\n * @typedef {object} component--ref-line.line-label-background\n * @property {string} [fill='#fff'] - Fill color\n * @property {string} [stroke='transparent'] - Stroke\n * @property {number} [strokeWidth=0] - Stroke width\n * @property {number} [opacity=0.5] - Opacity\n */\n\n/**\n * @typedef {object} component--ref-line.generic-object\n * @property {string} [fill='#fff'] - Fill color\n * @property {string} [stroke='transparent'] - Stroke\n * @property {number} [strokeWidth=0] - Stroke width\n * @property {number} [opacity=1] - Opacity\n */\n\n\nvar refLineComponent = {\n  require: ['chart', 'renderer'],\n  defaultSettings: {\n    layout: {\n      displayOrder: 0\n    },\n    style: {\n      oob: {\n        show: true,\n        width: 10,\n        fill: '#1A1A1A',\n        stroke: 'transparent',\n        strokeWidth: 0,\n        opacity: 1,\n        text: {\n          fontFamily: 'Arial',\n          stroke: 'transparent',\n          fill: '#fff',\n          strokeWidth: 0,\n          opacity: 1\n        },\n        triangle: {\n          fill: '#4D4D4D',\n          stroke: 'transparent',\n          strokeWidth: 0,\n          opacity: 1\n        },\n        padding: {\n          x: 28,\n          y: 5\n        }\n      },\n      line: {\n        stroke: '#000'\n      },\n      label: {\n        strokeWidth: 0\n      }\n    }\n  },\n  preferredSize: function preferredSize() {\n    return 30;\n  },\n  beforeRender: function beforeRender() {\n    this.blueprint = transposer();\n    this.blueprint.width = this.rect.width;\n    this.blueprint.height = this.rect.height;\n    this.blueprint.x = this.rect.x;\n    this.blueprint.y = this.rect.y;\n    this.blueprint.crisp = true;\n  },\n  render: function render() {\n    var _this = this;\n\n    var settings = this.settings; // Setup lines for X and Y\n\n    this.lines = {\n      x: [],\n      y: []\n    };\n    this.lines.x = settings.lines && settings.lines.x || [];\n    this.lines.y = settings.lines && settings.lines.y || [];\n\n    if (this.lines.x.length === 0 && this.lines.y.length === 0) {\n      return [];\n    }\n\n    var oob = {\n      x0: [],\n      x1: [],\n      y0: [],\n      y1: []\n    }; // Convert a value to an actual position using the scale\n\n    this.lines.x = this.lines.x.filter(filterUndefinedValue).map(function (line) {\n      if (line.scale) {\n        var scale = _this.chart.scale(line.scale);\n\n        return extend(line, {\n          scale: scale,\n          position: scale(line.value)\n        });\n      }\n\n      return extend(line, {\n        position: line.value\n      });\n    }); // Set all Y lines to flipXY by default\n    // This makes the transposer flip them individually\n\n    this.lines.y = this.lines.y.filter(filterUndefinedValue).map(function (line) {\n      if (line.scale) {\n        var scale = _this.chart.scale(line.scale);\n\n        return extend(line, {\n          scale: scale,\n          position: scale(line.value),\n          flipXY: true\n        });\n      }\n\n      return extend(line, {\n        position: line.value,\n        flipXY: true\n      });\n    }); // Move out of bounds lines (OOB) to separate rendering\n\n    this.lines.x = this.lines.x.filter(function (line) {\n      if (line.position < 0 || line.position > 1) {\n        oob[\"x\".concat(line.position > 1 ? 1 : 0)].push(createOobData(line));\n        return false;\n      }\n\n      return true;\n    });\n    this.lines.y = this.lines.y.filter(function (line) {\n      if (line.position < 0 || line.position > 1) {\n        oob[\"y\".concat(line.position > 1 ? 1 : 0)].push(createOobData(line));\n        return false;\n      }\n\n      return true;\n    });\n    var items = []; // Loop through all X and Y lines\n\n    [].concat(_toConsumableArray$1(this.lines.x), _toConsumableArray$1(this.lines.y)).forEach(function (p) {\n      var show = p.show === true || typeof p.show === 'undefined';\n\n      if (show) {\n        // Create line with labels\n        createLineWithLabel({\n          chart: _this.chart,\n          blueprint: _this.blueprint,\n          renderer: _this.renderer,\n          p: p,\n          settings: settings,\n          items: items\n        });\n      }\n    }); // Handle out of bounds\n\n    if (settings.style.oob.show) {\n      oobManager({\n        blueprint: this.blueprint,\n        oob: oob,\n        settings: settings,\n        items: items\n      });\n    }\n\n    return items;\n  }\n};\n\nfunction refLine(picasso) {\n  picasso.component('ref-line', refLineComponent);\n}\n\nfunction appendStyle(struct, buildOpts) {\n  extend(struct, buildOpts.style);\n  var halfWidth = struct.strokeWidth / 2;\n\n  if (buildOpts.align === 'top') {\n    struct.y1 -= halfWidth;\n    struct.y2 -= halfWidth;\n  } else if (buildOpts.align === 'bottom') {\n    struct.y1 += halfWidth;\n    struct.y2 += halfWidth;\n  } else if (buildOpts.align === 'left') {\n    struct.x1 -= halfWidth;\n    struct.x2 -= halfWidth;\n  } else if (buildOpts.align === 'right') {\n    struct.x1 += halfWidth;\n    struct.x2 += halfWidth;\n  }\n}\n\nfunction buildLine(buildOpts) {\n  var struct = {\n    type: 'line',\n    x1: 0,\n    x2: 0,\n    y1: 0,\n    y2: 0,\n    collider: {\n      type: null\n    }\n  };\n\n  if (buildOpts.align === 'top' || buildOpts.align === 'bottom') {\n    struct.x1 = buildOpts.innerRect.x - buildOpts.outerRect.x;\n    struct.x2 = buildOpts.innerRect.width + buildOpts.innerRect.x;\n    struct.y1 = struct.y2 = buildOpts.align === 'top' ? buildOpts.innerRect.height - buildOpts.padding : buildOpts.padding;\n  } else {\n    struct.x1 = struct.x2 = buildOpts.align === 'left' ? buildOpts.innerRect.width - buildOpts.padding : buildOpts.padding;\n    struct.y1 = buildOpts.innerRect.y - buildOpts.outerRect.y;\n    struct.y2 = buildOpts.innerRect.height + buildOpts.innerRect.y;\n  }\n\n  appendStyle(struct, buildOpts);\n  return struct;\n}\n\nfunction checkText(text) {\n  return typeof text === 'string' || typeof text === 'number' ? text : '-';\n}\n\nfunction appendStyle$1(struct, buildOpts) {\n  ['fill', 'fontSize', 'fontFamily'].forEach(function (style) {\n    struct[style] = buildOpts.style[style];\n  });\n}\n\nfunction clampEnds(struct, buildOpts) {\n  if (buildOpts.tilted || buildOpts.stepSize) {\n    return;\n  }\n\n  if (buildOpts.align === 'top' || buildOpts.align === 'bottom') {\n    var leftBoundary = 0;\n    var rightBoundary = buildOpts.outerRect.width;\n    var textWidth = Math.min(buildOpts.maxWidth / 2, buildOpts.textRect.width / 2);\n    var leftTextBoundary = struct.x - textWidth;\n    var rightTextBoundary = struct.x + textWidth;\n\n    if (leftTextBoundary < leftBoundary) {\n      struct.anchor = 'start';\n      struct.x = buildOpts.innerRect.x - buildOpts.outerRect.x;\n    } else if (rightTextBoundary > rightBoundary) {\n      struct.anchor = 'end';\n      struct.x = buildOpts.innerRect.width + buildOpts.innerRect.x;\n    }\n  } else {\n    var topBoundary = 0;\n    var bottomBoundary = buildOpts.outerRect.height;\n    var textHeight = buildOpts.maxHeight / 2;\n    var topTextBoundary = struct.y - textHeight;\n    var bottomTextBoundary = struct.y + textHeight;\n\n    if (topTextBoundary < topBoundary) {\n      struct.y = buildOpts.innerRect.y - buildOpts.outerRect.y;\n      struct.baseline = 'text-before-edge';\n    } else if (bottomTextBoundary > bottomBoundary) {\n      struct.y = buildOpts.innerRect.height + (buildOpts.innerRect.y - buildOpts.outerRect.y);\n      struct.baseline = 'text-after-edge';\n    }\n  }\n}\n\nfunction appendPadding(struct, buildOpts) {\n  if (buildOpts.align === 'top') {\n    struct.y -= buildOpts.padding;\n  } else if (buildOpts.align === 'bottom') {\n    struct.y += buildOpts.padding + buildOpts.maxHeight;\n  } else if (buildOpts.align === 'left') {\n    struct.x -= buildOpts.padding;\n  } else if (buildOpts.align === 'right') {\n    struct.x += buildOpts.padding;\n  }\n}\n\nfunction appendTilting(struct, buildOpts) {\n  if (buildOpts.tilted) {\n    var r = -buildOpts.angle;\n    var radians = r * (Math.PI / 180);\n\n    if (buildOpts.align === 'bottom') {\n      struct.x -= buildOpts.maxHeight * Math.sin(radians) / 2;\n      struct.y -= buildOpts.maxHeight;\n      struct.y += buildOpts.maxHeight * Math.cos(radians) / 2;\n    } else {\n      struct.x -= buildOpts.maxHeight * Math.sin(radians) / 3;\n    }\n\n    struct.transform = \"rotate(\".concat(r, \", \").concat(struct.x, \", \").concat(struct.y, \")\");\n    struct.anchor = buildOpts.align === 'bottom' === buildOpts.angle < 0 ? 'start' : 'end'; // adjustForEnds\n\n    var textWidth = Math.cos(radians) * buildOpts.maxWidth;\n\n    if (buildOpts.align === 'bottom' === buildOpts.angle < 0) {\n      // right\n      var rightBoundary = buildOpts.outerRect.width - buildOpts.paddingEnd;\n      var rightTextBoundary = struct.x + textWidth;\n\n      if (rightTextBoundary > rightBoundary) {\n        struct.maxWidth = (rightBoundary - struct.x - 10) / Math.cos(radians);\n      }\n    } else {\n      // left\n      var leftBoundary = buildOpts.paddingEnd;\n      var leftTextBoundary = struct.x - textWidth;\n\n      if (leftTextBoundary < leftBoundary) {\n        struct.maxWidth = (struct.x - leftBoundary - 10) / Math.cos(radians);\n      }\n    }\n  }\n}\n\nfunction bandwidthCollider(tick, struct, buildOpts) {\n  if (buildOpts.align === 'bottom' || buildOpts.align === 'top') {\n    var tickCenter = tick.position * buildOpts.innerRect.width;\n    var leftBoundary = tickCenter + (buildOpts.innerRect.x - buildOpts.outerRect.x - buildOpts.stepSize / 2);\n    struct.collider = {\n      type: 'rect',\n      x: leftBoundary,\n      y: 0,\n      width: leftBoundary < 0 ? buildOpts.stepSize + leftBoundary : buildOpts.stepSize,\n      // Adjust collider so that it doesnt extend onto neighbor collider\n      height: buildOpts.innerRect.height\n    };\n  } else {\n    var _tickCenter = tick.position * buildOpts.innerRect.height;\n\n    var topBoundary = _tickCenter + (buildOpts.innerRect.y - buildOpts.outerRect.y - buildOpts.stepSize / 2);\n    struct.collider = {\n      type: 'rect',\n      x: 0,\n      y: topBoundary,\n      width: buildOpts.innerRect.width,\n      height: topBoundary < 0 ? buildOpts.stepSize + topBoundary : buildOpts.stepSize // Adjust collider so that it doesnt extend onto neighbor collider\n\n    };\n  } // Clip edges of the collider, should not extend beyoned the outerRect\n\n\n  var collider = struct.collider;\n  collider.x = Math.max(collider.x, 0);\n  collider.y = Math.max(collider.y, 0);\n  var widthClip = collider.x + collider.width - (buildOpts.outerRect.x + buildOpts.outerRect.width);\n  collider.width = widthClip > 0 ? collider.width - widthClip : collider.width;\n  var heightClip = collider.y + collider.height - (buildOpts.outerRect.y + buildOpts.outerRect.height);\n  collider.height = heightClip > 0 ? collider.height - heightClip : collider.height;\n}\n\nfunction boundsCollider(tick, struct) {\n  struct.collider = {\n    type: 'polygon',\n    vertices: [{\n      x: struct.boundingRect.x,\n      y: struct.boundingRect.y\n    }, {\n      x: struct.boundingRect.x + struct.boundingRect.width,\n      y: struct.boundingRect.y\n    }, {\n      x: struct.boundingRect.x + struct.boundingRect.width,\n      y: struct.boundingRect.y + struct.boundingRect.height\n    }, {\n      x: struct.boundingRect.x,\n      y: struct.boundingRect.y + struct.boundingRect.height\n    }]\n  };\n}\n\nfunction tiltedCollider(tick, struct, buildOpts) {\n  var radians = buildOpts.angle * (Math.PI / 180);\n  var halfWidth = Math.max(buildOpts.stepSize / 2, struct.boundingRect.height / 2); // Handle if bandwidth is zero\n\n  var startAnchor = struct.anchor === 'start';\n  var em = struct.anchor === 'end' && radians < 0;\n  var sp = struct.anchor === 'start' && radians >= 0;\n  var y = struct.boundingRect.y + (sp || em ? struct.boundingRect.height : 0); // Generate starting points at bandwidth boundaries\n\n  var points = [{\n    x: struct.x - halfWidth,\n    y: y\n  }, {\n    x: struct.x + halfWidth,\n    y: y\n  }].map(function (p) {\n    return rotate(p, radians, {\n      x: struct.x,\n      y: struct.y\n    });\n  }); // Rotate around center point to counteract labels rotation\n  // Append points to wrap polygon around label\n\n  var margin = 10; // extend slightly to handle single char labels better\n\n  var leftPoint = {\n    x: startAnchor ? struct.boundingRect.x + struct.boundingRect.width + margin : struct.boundingRect.x - margin,\n    y: struct.boundingRect.y + struct.boundingRect.height\n  };\n  var rightPoint = {\n    x: startAnchor ? struct.boundingRect.x + struct.boundingRect.width + margin : struct.boundingRect.x - margin,\n    y: struct.boundingRect.y\n  };\n  var orderedPoints = radians >= 0 ? [leftPoint, rightPoint] : [rightPoint, leftPoint];\n  points.push.apply(points, orderedPoints);\n  struct.collider = {\n    type: 'polygon',\n    vertices: points\n  };\n}\n\nfunction appendCollider(tick, struct, buildOpts) {\n  if (buildOpts.layered || !buildOpts.stepSize) {\n    boundsCollider(tick, struct);\n  } else if (buildOpts.tilted) {\n    tiltedCollider(tick, struct, buildOpts);\n  } else {\n    bandwidthCollider(tick, struct, buildOpts);\n  }\n}\n\nfunction appendBounds(struct, buildOpts) {\n  struct.boundingRect = buildOpts.textBounds(struct);\n}\n\nfunction wiggle(buildOpts, isVertical) {\n  var a = isNaN(buildOpts.style.align) ? 0.5 : Math.min(Math.max(buildOpts.style.align, 0), 1);\n  var w = 0;\n\n  if (buildOpts.tilted) {\n    w = buildOpts.stepSize * a;\n  } else {\n    var size = isVertical ? buildOpts.textRect.height : buildOpts.textRect.width;\n    w = Math.max(0, buildOpts.stepSize - size) * a;\n  }\n\n  return w;\n}\n\nfunction buildNode(tick, buildOpts) {\n  var struct = {\n    type: 'text',\n    text: checkText(tick.label),\n    x: 0,\n    y: 0,\n    maxWidth: buildOpts.maxWidth,\n    maxHeight: buildOpts.maxHeight\n  };\n\n  if (buildOpts.align === 'top' || buildOpts.align === 'bottom') {\n    struct.x = tick.start * buildOpts.innerRect.width + (buildOpts.innerRect.x - buildOpts.outerRect.x) + wiggle(buildOpts, false);\n    struct.y = buildOpts.align === 'top' ? buildOpts.innerRect.height : 0;\n    struct.anchor = buildOpts.stepSize ? 'start' : 'middle';\n    struct.x += isNaN(buildOpts.style.offset) ? 0 : +buildOpts.style.offset;\n  } else {\n    struct.y = tick.start * buildOpts.innerRect.height + (buildOpts.innerRect.y - buildOpts.outerRect.y) + wiggle(buildOpts, true);\n    struct.x = buildOpts.align === 'left' ? buildOpts.innerRect.width : 0;\n    struct.anchor = buildOpts.align === 'left' ? 'end' : 'start';\n    struct.baseline = buildOpts.stepSize ? 'text-before-edge' : 'central';\n    struct.y += isNaN(buildOpts.style.offset) ? 0 : +buildOpts.style.offset;\n  }\n\n  appendStyle$1(struct, buildOpts);\n  clampEnds(struct, buildOpts);\n  appendPadding(struct, buildOpts);\n  appendTilting(struct, buildOpts);\n  appendBounds(struct, buildOpts);\n  appendCollider(tick, struct, buildOpts);\n  return struct;\n}\n\nfunction appendStyle$2(struct, buildOpts) {\n  extend(struct, buildOpts.style);\n}\n\nfunction appendPadding$1(struct, buildOpts) {\n  if (buildOpts.align === 'top') {\n    struct.y1 -= buildOpts.padding;\n    struct.y2 -= buildOpts.padding;\n  } else if (buildOpts.align === 'bottom') {\n    struct.y1 += buildOpts.padding;\n    struct.y2 += buildOpts.padding;\n  } else if (buildOpts.align === 'left') {\n    struct.x1 -= buildOpts.padding;\n    struct.x2 -= buildOpts.padding;\n  } else if (buildOpts.align === 'right') {\n    struct.x1 += buildOpts.padding;\n    struct.x2 += buildOpts.padding;\n  }\n}\n\nfunction adjustForEnds(struct, buildOpts) {\n  var halfWidth = struct.strokeWidth / 2;\n\n  if (struct.x1 === buildOpts.innerRect.width) {\n    // outer end tick\n    struct.x1 -= halfWidth;\n    struct.x2 -= halfWidth;\n  } else if (struct.x1 === 0) {\n    // outer start tick\n    struct.x1 += halfWidth;\n    struct.x2 += halfWidth;\n  } else if (struct.y1 === buildOpts.innerRect.height) {\n    struct.y1 -= halfWidth;\n    struct.y2 -= halfWidth;\n  } else if (struct.y1 === 0) {\n    struct.y1 += halfWidth;\n    struct.y2 += halfWidth;\n  }\n}\n\nfunction buildNode$1(tick, buildOpts) {\n  var struct = {\n    type: 'line',\n    x1: 0,\n    x2: 0,\n    y1: 0,\n    y2: 0,\n    collider: {\n      type: null\n    }\n  };\n\n  if (buildOpts.align === 'top' || buildOpts.align === 'bottom') {\n    struct.x1 = struct.x2 = tick.position * buildOpts.innerRect.width + (buildOpts.innerRect.x - buildOpts.outerRect.x);\n    struct.y1 = buildOpts.align === 'top' ? buildOpts.innerRect.height : 0;\n    struct.y2 = buildOpts.align === 'top' ? struct.y1 - buildOpts.tickSize : struct.y1 + buildOpts.tickSize;\n  } else {\n    struct.y1 = struct.y2 = tick.position * buildOpts.innerRect.height + (buildOpts.innerRect.y - buildOpts.outerRect.y);\n    struct.x1 = buildOpts.align === 'left' ? buildOpts.innerRect.width : 0;\n    struct.x2 = buildOpts.align === 'left' ? struct.x1 - buildOpts.tickSize : struct.x1 + buildOpts.tickSize;\n  }\n\n  appendStyle$2(struct, buildOpts);\n  appendPadding$1(struct, buildOpts);\n  adjustForEnds(struct, buildOpts);\n  return struct;\n}\n\nfunction isMajorTick(tick) {\n  return !tick.isMinor && tick.position >= 0 && tick.position <= 1;\n}\n\nfunction isVerticalLabelOverlapping(_ref) {\n  var majorTicks = _ref.majorTicks,\n      measureText = _ref.measureText,\n      rect = _ref.rect;\n  var size = rect.height;\n  var textHeight = measureText('M').height;\n\n  if (majorTicks.length < 2) {\n    return false;\n  }\n\n  var d = size * Math.abs(majorTicks[0].position - majorTicks[1].position);\n\n  if (d < textHeight) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isHorizontalLabelOverlapping(_ref2) {\n  var majorTicks = _ref2.majorTicks,\n      measureText = _ref2.measureText,\n      rect = _ref2.rect,\n      state = _ref2.state;\n\n  /*\n   * Currently isn't any good way of doing a accurate measurement on size available (bandWidth * width) for labels.\n   * It's a lifecycle limitation as components docked either left or right can affect the width available after the calculation is done.\n   * <number of components docked left/right> * <width of components> => Less accurate ===> Can result in only ellips char rendered as labels.\n   */\n  var m = state.labels.activeMode === 'layered' ? 2 : 1;\n  var size = rect.width;\n  var tickSize = majorTicks.map(function (tick) {\n    return tick.label;\n  }).map(function (l) {\n    return \"\".concat(l.slice(0, 1)).concat(l.length > 1 ? '…' : '');\n  }) // Measure the size of 1 chars + the ellips char.\n  .map(measureText).map(function (r) {\n    return r.width;\n  });\n\n  for (var i = 0; i < majorTicks.length; ++i) {\n    var tick = majorTicks[i];\n    var d1 = m * size * Math.abs(tick.start - tick.end);\n    var d2 = tickSize[i];\n\n    if (d1 < d2) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction shouldAutoTilt(_ref3) {\n  var majorTicks = _ref3.majorTicks,\n      measure = _ref3.measure,\n      rect = _ref3.rect,\n      state = _ref3.state,\n      settings = _ref3.settings;\n  var glyphCount = settings.labels.maxGlyphCount;\n  var m = state.labels.activeMode === 'layered' ? 2 : 1;\n  var magicSizeRatioMultipler = settings.labels.tiltThreshold ? settings.labels.tiltThreshold : 0.7; // So that if less the 70% of labels are visible, toggle on tilt or use variable tiltThreshold\n\n  var ellipsCharSize = measure('…').width; // include ellipsed char in calc as it's generally large then the char it replaces\n\n  var size = rect.width;\n  var maxLabelWidth = 0;\n  var d1 = 0;\n\n  if (!isNaN(glyphCount)) {\n    var minBandwidth = majorTicks.reduce(function (prev, curr) {\n      return Math.min(Math.abs(curr.start - curr.end), prev);\n    }, Infinity);\n    d1 = m * size * minBandwidth;\n    maxLabelWidth = measure('M').width * magicSizeRatioMultipler * glyphCount;\n\n    if (maxLabelWidth + ellipsCharSize > d1) {\n      return true;\n    }\n  } else {\n    for (var i = 0; i < majorTicks.length; i++) {\n      var tick = majorTicks[i];\n      var label = tick.label;\n      var width = measure(label).width * (label.length > 1 ? magicSizeRatioMultipler : 1);\n      d1 = m * size * Math.abs(tick.start - tick.end);\n\n      if (width + ellipsCharSize > d1) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction isTiltedLabelOverlapping(_ref4) {\n  var majorTicks = _ref4.majorTicks,\n      measureText = _ref4.measureText,\n      rect = _ref4.rect,\n      bleedSize = _ref4.bleedSize,\n      angle = _ref4.angle;\n\n  if (majorTicks.length < 2) {\n    return false;\n  }\n\n  if (angle === 0) {\n    return true; // TODO 0 angle should be considered non-tilted\n  }\n\n  var absAngle = Math.abs(angle);\n  var size = rect.width - bleedSize;\n  var stepSize = size * Math.abs(majorTicks[0].position - majorTicks[1].position);\n  var textHeight = measureText('M').height;\n  var reciprocal = 1 / stepSize; // 1 === Math.sin(90 * (Math.PI / 180))\n\n  var distanceBetweenLabels = Math.sin(absAngle * (Math.PI / 180)) / reciprocal;\n  return textHeight > distanceBetweenLabels;\n}\n\nfunction isToLarge(_ref5) {\n  var rect = _ref5.rect,\n      state = _ref5.state,\n      majorTicks = _ref5.majorTicks,\n      measure = _ref5.measure,\n      horizontal = _ref5.horizontal;\n\n  if (horizontal) {\n    return isHorizontalLabelOverlapping({\n      majorTicks: majorTicks,\n      measureText: measure,\n      rect: rect,\n      state: state\n    });\n  }\n\n  return isVerticalLabelOverlapping({\n    majorTicks: majorTicks,\n    measureText: measure,\n    rect: rect,\n    state: state\n  });\n}\n\nfunction getClampedValue(_ref6) {\n  var value = _ref6.value,\n      maxValue = _ref6.maxValue,\n      minValue = _ref6.minValue,\n      range = _ref6.range,\n      modifier = _ref6.modifier;\n\n  if (!isNaN(range) && !isNaN(modifier)) {\n    value = range * modifier;\n  }\n\n  if (value > maxValue) {\n    value = maxValue;\n  }\n\n  if (value < minValue) {\n    value = minValue;\n  }\n\n  return value;\n}\nfunction getSize(_ref7) {\n  var isDiscrete = _ref7.isDiscrete,\n      rect = _ref7.rect,\n      formatter = _ref7.formatter,\n      measureText = _ref7.measureText,\n      scale = _ref7.scale,\n      settings = _ref7.settings,\n      state = _ref7.state;\n  var size = 0;\n  var edgeBleed = {\n    left: 0,\n    top: 0,\n    right: 0,\n    bottom: 0\n  };\n  var _settings$labels = settings.labels,\n      maxValue = _settings$labels.maxLengthPx,\n      minValue = _settings$labels.minLengthPx;\n\n  if (settings.labels.show) {\n    var align = settings.align;\n    var horizontal = align === 'top' || align === 'bottom';\n    var distance = horizontal ? rect.width : rect.height;\n    var majorTicks = scale.ticks({\n      settings: settings,\n      distance: distance,\n      formatter: formatter\n    }).filter(isMajorTick);\n\n    var measure = function measure(text) {\n      var m = measureText({\n        text: text,\n        fontSize: settings.labels.fontSize,\n        fontFamily: settings.labels.fontFamily\n      });\n      m.width = getClampedValue({\n        value: m.width,\n        maxValue: maxValue,\n        minValue: minValue\n      });\n      return m;\n    };\n\n    if (isDiscrete && horizontal && settings.labels.mode === 'auto') {\n      if (shouldAutoTilt({\n        majorTicks: majorTicks,\n        measure: measure,\n        rect: rect,\n        state: state,\n        settings: settings\n      })) {\n        state.labels.activeMode = 'tilted';\n      } else {\n        state.labels.activeMode = 'horizontal';\n      }\n    }\n\n    if (!settings.labels.filterOverlapping && state.labels.activeMode !== 'tilted' && isToLarge({\n      rect: rect,\n      state: state,\n      majorTicks: majorTicks,\n      measure: measure,\n      horizontal: horizontal\n    })) {\n      var toLargeSize = Math.max(rect.width, rect.height); // used to hide the axis\n\n      return {\n        size: toLargeSize,\n        isToLarge: true\n      };\n    }\n\n    var sizeFromTextRect;\n\n    if (state.labels.activeMode === 'tilted') {\n      var radians = Math.abs(settings.labels.tiltAngle) * (Math.PI / 180); // angle in radians\n\n      sizeFromTextRect = function sizeFromTextRect(r) {\n        return getClampedValue({\n          value: r.width,\n          maxValue: maxValue,\n          minValue: minValue\n        }) * Math.sin(radians) + r.height * Math.cos(radians);\n      };\n    } else if (horizontal) {\n      sizeFromTextRect = function sizeFromTextRect(r) {\n        return r.height;\n      };\n    } else {\n      sizeFromTextRect = function sizeFromTextRect(r) {\n        return getClampedValue({\n          value: r.width,\n          maxValue: maxValue,\n          minValue: minValue\n        });\n      };\n    }\n\n    var labels;\n\n    if (horizontal && state.labels.activeMode !== 'tilted') {\n      labels = ['M'];\n    } else if (!isNaN(settings.labels.maxGlyphCount)) {\n      var label = '';\n\n      for (var i = 0; i < settings.labels.maxGlyphCount; i++) {\n        label += 'M';\n      }\n\n      labels = [label];\n    } else {\n      labels = majorTicks.map(function (tick) {\n        return tick.label;\n      });\n    }\n\n    var tickMeasures = labels.map(measure);\n    var labelSizes = tickMeasures.map(sizeFromTextRect);\n    var textSize = Math.max.apply(Math, _toConsumableArray$1(labelSizes).concat([0]));\n    size += textSize;\n    size += settings.labels.margin;\n\n    if (state.labels.activeMode === 'layered') {\n      size *= 2;\n    }\n\n    if (state.labels.activeMode === 'tilted') {\n      var extendLeft = settings.align === 'bottom' === settings.labels.tiltAngle >= 0;\n\n      var _radians = Math.abs(settings.labels.tiltAngle) * (Math.PI / 180); // angle in radians\n\n\n      var h = measureText('M').height;\n      var maxWidth = (textSize - h * Math.cos(_radians)) / Math.sin(_radians);\n\n      var labelWidth = function labelWidth(r) {\n        return Math.min(maxWidth, r.width) * Math.cos(_radians) + r.height;\n      };\n\n      var adjustByPosition = function adjustByPosition(s, i) {\n        var pos = majorTicks[i] ? majorTicks[i].position : 0;\n\n        if (extendLeft) {\n          return s - pos * rect.width;\n        }\n\n        return s - (1 - pos) * rect.width;\n      };\n\n      var bleedSize = Math.min(settings.labels.maxEdgeBleed, Math.max.apply(Math, _toConsumableArray$1(tickMeasures.map(labelWidth).map(adjustByPosition)).concat([0]))) + settings.paddingEnd;\n      var bleedDir = extendLeft ? 'left' : 'right';\n      edgeBleed[bleedDir] = bleedSize;\n\n      if (!settings.labels.filterOverlapping && isTiltedLabelOverlapping({\n        majorTicks: majorTicks,\n        measureText: measureText,\n        rect: rect,\n        bleedSize: bleedSize,\n        angle: settings.labels.tiltAngle\n      })) {\n        return {\n          size: Math.max(rect.width, rect.height),\n          isToLarge: true\n        };\n      }\n    }\n  }\n\n  return {\n    size: size,\n    edgeBleed: edgeBleed\n  };\n}\n\nvar PADDING = 2;\n\nvar tickDistance = function tickDistance(rect, start, end) {\n  return rect.width * Math.abs(start.position - end.position);\n};\n\nvar getLeftEdgeWidth = function getLeftEdgeWidth(_ref) {\n  var innerRect = _ref.innerRect,\n      outerRect = _ref.outerRect,\n      tick = _ref.tick,\n      nextWidth = _ref.nextWidth;\n  var leftEdgeBleed = innerRect.x - outerRect.x;\n  var left = innerRect.width * tick.position + leftEdgeBleed;\n  var minDubble = Math.min(nextWidth, left) * 2;\n  var minWidth = tick.position === 0 ? innerRect.width / 2 - PADDING : 0;\n  return Math.max(nextWidth, minDubble, minWidth);\n};\n\nvar getRightEdgeWidth = function getRightEdgeWidth(_ref2) {\n  var innerRect = _ref2.innerRect,\n      outerRect = _ref2.outerRect,\n      tick = _ref2.tick,\n      prevWidth = _ref2.prevWidth;\n  var leftEdgeBleed = innerRect.x - outerRect.x;\n  var rightEdgeBleed = outerRect.width - innerRect.width - leftEdgeBleed;\n  var right = innerRect.width - innerRect.width * tick.position + rightEdgeBleed;\n  var minDubble = Math.min(prevWidth, right) * 2;\n  var minWidth = tick.position === 1 ? innerRect.width / 2 - PADDING : 0;\n  return Math.max(prevWidth, minDubble, minWidth);\n};\n\nfunction getHorizontalWidth(_ref3) {\n  var layered = _ref3.layered,\n      major = _ref3.major,\n      innerRect = _ref3.innerRect,\n      outerRect = _ref3.outerRect,\n      tick = _ref3.tick,\n      index = _ref3.index;\n  var step = layered ? 2 : 1;\n  var prev = major[index - step];\n  var next = major[index + step];\n  var prevWidth = prev ? tickDistance(innerRect, tick, prev) / 2 - PADDING : Infinity;\n  var nextWidth = next ? tickDistance(innerRect, tick, next) / 2 - PADDING : Infinity;\n\n  if (major.length < 2) {\n    return innerRect.width;\n  }\n\n  if (!prev) {\n    return getLeftEdgeWidth({\n      innerRect: innerRect,\n      outerRect: outerRect,\n      tick: tick,\n      nextWidth: nextWidth\n    });\n  }\n\n  if (!next) {\n    return getRightEdgeWidth({\n      innerRect: innerRect,\n      outerRect: outerRect,\n      tick: tick,\n      prevWidth: prevWidth\n    });\n  }\n\n  return Math.min(prevWidth, nextWidth) * 2;\n}\n\nfunction tickSpacing(settings) {\n  var spacing = 0;\n  spacing += settings.paddingStart;\n  spacing += settings.line.show ? settings.line.strokeWidth : 0;\n  spacing += settings.ticks.show ? settings.ticks.margin : 0;\n  return spacing;\n}\n\nfunction tickMinorSpacing(settings) {\n  return settings.line.strokeWidth + settings.minorTicks.margin;\n}\n\nfunction labelsSpacing(settings) {\n  var spacing = 0;\n  spacing += settings.ticks.show ? settings.ticks.tickSize : 0;\n  spacing += tickSpacing(settings) + settings.labels.margin;\n  return spacing;\n}\n\nfunction calcActualTextRect(_ref) {\n  var style = _ref.style,\n      measureText = _ref.measureText,\n      tick = _ref.tick;\n  return measureText({\n    text: tick.label,\n    fontSize: style.fontSize,\n    fontFamily: style.fontFamily\n  });\n}\n\nfunction majorTicks(ticks) {\n  return ticks.filter(function (t) {\n    return !t.isMinor;\n  });\n}\n\nfunction minorTicks(ticks) {\n  return ticks.filter(function (t) {\n    return t.isMinor;\n  });\n}\n\nfunction tickBuilder(ticks, buildOpts) {\n  return ticks.map(function (tick) {\n    return buildNode$1(tick, buildOpts);\n  });\n}\n\nfunction tickBandwidth(scale, tick) {\n  return tick ? Math.abs(tick.end - tick.start) : scale.bandwidth();\n}\n\nfunction labelBuilder(ticks, buildOpts, resolveTickOpts) {\n  return ticks.map(function (tick, idx) {\n    resolveTickOpts(tick, idx);\n    var label = buildNode(tick, buildOpts);\n    label.data = tick.data;\n    return label;\n  });\n}\n\nfunction layeredLabelBuilder(ticks, buildOpts, settings, resolveTickOpts) {\n  var padding = buildOpts.padding;\n  var spacing = labelsSpacing(settings);\n  return ticks.map(function (tick, idx) {\n    resolveTickOpts(tick, idx);\n    var padding2 = spacing + buildOpts.maxHeight + settings.labels.margin;\n    buildOpts.layer = idx % 2;\n    buildOpts.padding = idx % 2 === 0 ? padding : padding2;\n    var label = buildNode(tick, buildOpts);\n    label.data = tick.data;\n    return label;\n  });\n}\n\nfunction filterOverlappingLabels(labels, ticks, buildOpts) {\n  var isOverlapping = function isOverlapping(i, k) {\n    var rect1 = expandRect(1, labels[i].boundingRect);\n    var rect2 = expandRect(1, labels[k].boundingRect);\n    return testRectRect(rect1, rect2);\n  };\n\n  if (buildOpts && buildOpts.tilted) {\n    var absAngle = Math.abs(buildOpts.angle);\n\n    isOverlapping = function isOverlapping(i, k) {\n      var stepSize = Math.abs(labels[i].x - labels[k].x);\n      var reciprocal = 1 / stepSize;\n      var distanceBetweenLabels = Math.sin(absAngle * (Math.PI / 180)) / reciprocal;\n      return labels[i].boundingRect.height > distanceBetweenLabels;\n    };\n  }\n\n  for (var i = 0; i <= labels.length - 1; i++) {\n    for (var k = i + 1; k <= Math.min(i + 5, i + (labels.length - 1)); k++) {\n      // TODO Find a better way to handle exteme/layered labels then to iterare over ~5 next labels\n      if (labels[i] && labels[k] && isOverlapping(i, k)) {\n        if (k === labels.length - 1) {\n          // On collition with last label, remove current label instead\n          labels.splice(i, 1);\n\n          if (ticks) {\n            ticks.splice(i, 1);\n          }\n        } else {\n          labels.splice(k, 1);\n\n          if (ticks) {\n            ticks.splice(k, 1);\n          }\n        }\n\n        k--;\n        i--;\n      }\n    }\n  }\n}\n\nfunction discreteCalcMaxTextRect(_ref2) {\n  var textMetrics = _ref2.textMetrics,\n      settings = _ref2.settings,\n      innerRect = _ref2.innerRect,\n      scale = _ref2.scale,\n      tilted = _ref2.tilted,\n      layered = _ref2.layered,\n      tick = _ref2.tick;\n  var h = textMetrics.height;\n  var bandwidth = tickBandwidth(scale, tick);\n  var textRect = {\n    width: 0,\n    height: h\n  };\n\n  if (settings.align === 'left' || settings.align === 'right') {\n    textRect.width = innerRect.width - labelsSpacing(settings) - settings.paddingEnd;\n  } else if (layered) {\n    textRect.width = bandwidth * innerRect.width * 2;\n  } else if (tilted) {\n    var radians = Math.abs(settings.labels.tiltAngle) * (Math.PI / 180);\n    textRect.width = (innerRect.height - labelsSpacing(settings) - settings.paddingEnd - h * Math.cos(radians)) / Math.sin(radians);\n  } else {\n    textRect.width = bandwidth * innerRect.width;\n  }\n\n  textRect.width = getClampedValue({\n    value: textRect.width,\n    maxValue: settings.labels.maxLengthPx,\n    minValue: settings.labels.minLengthPx\n  });\n  return textRect;\n}\n\nfunction continuousCalcMaxTextRect(_ref3) {\n  var textMetrics = _ref3.textMetrics,\n      settings = _ref3.settings,\n      innerRect = _ref3.innerRect,\n      outerRect = _ref3.outerRect,\n      tilted = _ref3.tilted,\n      layered = _ref3.layered,\n      tick = _ref3.tick,\n      index = _ref3.index,\n      major = _ref3.major;\n  var h = textMetrics.height;\n  var textRect = {\n    width: 0,\n    height: h\n  };\n\n  if (settings.align === 'left' || settings.align === 'right') {\n    textRect.width = innerRect.width - labelsSpacing(settings) - settings.paddingEnd;\n  } else if (tilted) {\n    var radians = Math.abs(settings.labels.tiltAngle) * (Math.PI / 180);\n    textRect.width = (innerRect.height - labelsSpacing(settings) - settings.paddingEnd - h * Math.cos(radians)) / Math.sin(radians);\n  } else {\n    textRect.width = getHorizontalWidth({\n      layered: layered,\n      major: major,\n      innerRect: innerRect,\n      outerRect: outerRect,\n      tick: tick,\n      index: index\n    });\n  }\n\n  textRect.width = getClampedValue({\n    value: textRect.width,\n    maxValue: settings.labels.maxLengthPx,\n    minValue: settings.labels.minLengthPx\n  });\n  return textRect;\n}\n\nfunction getStepSizeFn(_ref4) {\n  var innerRect = _ref4.innerRect,\n      scale = _ref4.scale,\n      settings = _ref4.settings,\n      tick = _ref4.tick;\n  var size = settings.align === 'top' || settings.align === 'bottom' ? innerRect.width : innerRect.height;\n  var bandwidth = tickBandwidth(scale, tick);\n  return size * bandwidth;\n}\n\nfunction nodeBuilder(isDiscrete) {\n  var resolveLabelRect;\n\n  function continuous() {\n    resolveLabelRect = continuousCalcMaxTextRect;\n    return continuous;\n  }\n\n  function discrete() {\n    resolveLabelRect = discreteCalcMaxTextRect;\n    return discrete;\n  }\n\n  function build(_ref5) {\n    var settings = _ref5.settings,\n        scale = _ref5.scale,\n        innerRect = _ref5.innerRect,\n        outerRect = _ref5.outerRect,\n        measureText = _ref5.measureText,\n        ticks = _ref5.ticks,\n        state = _ref5.state,\n        textBounds = _ref5.textBounds;\n    var nodes = [];\n    var major = majorTicks(ticks);\n    var minor = minorTicks(ticks);\n    var buildOpts = {\n      innerRect: innerRect,\n      align: settings.align,\n      outerRect: outerRect\n    };\n    var tilted = state.labels.activeMode === 'tilted';\n    var layered = state.labels.activeMode === 'layered';\n    var majorTickNodes;\n\n    if (settings.line.show) {\n      buildOpts.style = settings.line;\n      buildOpts.padding = settings.paddingStart;\n      nodes.push(buildLine(buildOpts));\n    }\n\n    if (settings.ticks.show) {\n      buildOpts.style = settings.ticks;\n      buildOpts.tickSize = settings.ticks.tickSize;\n      buildOpts.padding = tickSpacing(settings);\n      majorTickNodes = tickBuilder(major, buildOpts);\n    }\n\n    if (settings.labels.show) {\n      var padding = labelsSpacing(settings);\n      buildOpts.style = settings.labels;\n      buildOpts.padding = padding;\n      buildOpts.tilted = tilted;\n      buildOpts.layered = layered;\n      buildOpts.angle = settings.labels.tiltAngle;\n      buildOpts.paddingEnd = settings.paddingEnd;\n      buildOpts.textBounds = textBounds;\n\n      var resolveTickOpts = function resolveTickOpts(tick, index) {\n        buildOpts.textRect = calcActualTextRect({\n          tick: tick,\n          measureText: measureText,\n          style: buildOpts.style\n        });\n        var maxSize = resolveLabelRect({\n          textMetrics: buildOpts.textRect,\n          settings: settings,\n          innerRect: innerRect,\n          outerRect: outerRect,\n          scale: scale,\n          tilted: tilted,\n          layered: layered,\n          tick: tick,\n          major: major,\n          index: index\n        });\n        buildOpts.maxWidth = maxSize.width;\n        buildOpts.maxHeight = maxSize.height;\n        buildOpts.stepSize = getStepSizeFn({\n          innerRect: innerRect,\n          scale: scale,\n          ticks: ticks,\n          settings: settings,\n          tick: tick\n        });\n      };\n\n      var labelNodes = [];\n\n      if (layered && (settings.align === 'top' || settings.align === 'bottom')) {\n        labelNodes = layeredLabelBuilder(major, buildOpts, settings, resolveTickOpts);\n      } else {\n        labelNodes = labelBuilder(major, buildOpts, resolveTickOpts);\n      } // Remove labels (and paired tick) that are overlapping\n\n\n      if (settings.labels.filterOverlapping) {\n        filterOverlappingLabels(labelNodes, majorTickNodes, buildOpts);\n      }\n\n      nodes.push.apply(nodes, _toConsumableArray$1(labelNodes));\n    }\n\n    if (settings.minorTicks && settings.minorTicks.show && minor.length > 0) {\n      buildOpts.style = settings.minorTicks;\n      buildOpts.tickSize = settings.minorTicks.tickSize;\n      buildOpts.padding = tickMinorSpacing(settings);\n      nodes.push.apply(nodes, _toConsumableArray$1(tickBuilder(minor, buildOpts)));\n    }\n\n    if (majorTickNodes) {\n      nodes.push.apply(nodes, _toConsumableArray$1(majorTickNodes));\n    }\n\n    return nodes;\n  }\n\n  continuous.build = build;\n  discrete.build = build;\n  return isDiscrete ? discrete() : continuous();\n}\n\n// const DEFAULT_LAYOUT_SETTINGS = { // TODO create dis and con specific settings\n//   anchor: 'auto', // TODO re-name from align..\n//   // orientation: 'auto', // TODO impl. v/h/auto\n//   // direction: 'auto', // TODO impl. left/right/top/bottom/auto\n//   padding: { // TODO use dock layout margin instead..\n//     start: 0,\n//     end: 10\n//   },\n//   maxGlyphCount: NaN,\n//   maxEdgeBleed: Infinity\n//   // labelMode: 'auto' // TODO move here? auto, horizontal, layered\n// };\n\n/**\n * Discrete axis settings\n * @typedef {object}\n * @alias component--axis-discrete\n */\nvar DEFAULT_DISCRETE_SETTINGS = {\n  /**\n   * @typedef {object}\n   */\n  labels: {\n    /** Toggle labels on/off\n    * @type {boolean=} */\n    show: true,\n\n    /** Tilting angle in degrees. Capped between -90 and 90. Only applicable when labels are in `tilted` mode.\n    * @type {number=} */\n    tiltAngle: 40,\n\n    /** Threshold for toggle of tilted labels. Capped between 0 and 1. For example, if it is set to 0.7, then tilted labels will be toggled if less than 70% of the labels are visible.\n    * @type {number=}\n    * @experimental */\n    tiltThreshold: 0.7,\n\n    /** Control the amount of space (in pixels) that labes can occupy outside their docking area. Only applicable when labels are in `tilted` mode.\n    * @type {number=} */\n    maxEdgeBleed: Infinity,\n\n    /** Space in pixels between the tick and label.\n    * @type {number=} */\n    margin: 4,\n\n    /** Max length of labels in pixels\n    * @type {number=} */\n    maxLengthPx: 150,\n\n    /** Min length of labels in pixels. Labels will always at least require this much space\n    * @type {number=} */\n    minLengthPx: 0,\n\n    /** Control how labels arrange themself. Availabe modes are `auto`, `horizontal`, `layered` and `tilted`. When set to `auto` the axis determines the best possible layout in the current context.\n    * @type {string=} */\n    mode: 'auto',\n\n    /** When only a sub-set of data is available, ex. when paging. This property can be used to let the axis estimate how much space the labels will consume, allowing it to give a consistent space estimate over the entire dataset when paging.\n    * @type {number=} */\n    maxGlyphCount: NaN,\n\n    /** Align act as a slider for the text bounding rect over the item bandwidth, given that the item have a bandwidth. Except when labels are tilted, then the align is a pure align that shifts the position of the label anchoring point.\n    * @type {number=} */\n    align: 0.5,\n\n    /** Offset in pixels along the axis direction.\n    * @type {number=} */\n    offset: 0,\n\n    /**\n     * Toggle whether labels should be filtered if they are overlapping. Filtering may be applied in a non-sequential order.\n     * If labels are overlapping and this setting is toggled off, the axis will automatically hide.\n     * @type {boolean=}\n     */\n    filterOverlapping: false\n  },\n\n  /**\n   * @typedef {object}\n   */\n  ticks: {\n    /** Toggle ticks on/off\n    * @type {boolean=} */\n    show: false,\n\n    /** Space in pixels between the ticks and the line.\n    * @type {number=} */\n    margin: 0,\n\n    /** Size of the ticks in pixels.\n    * @type {number=} */\n    tickSize: 4\n  },\n\n  /**\n   * @typedef {object}\n   */\n  line: {\n    /** Toggle line on/off\n    * @type {boolean=} */\n    show: false\n  },\n\n  /** Padding in direction perpendicular to the axis\n    * @type {number=} */\n  paddingStart: 0,\n\n  /** Padding in direction perpendicular to the axis\n    * @type {number=} */\n  paddingEnd: 10,\n\n  /** Set the anchoring point of the axis. Avaialable options are `auto/left/right/bottom/top`. In `auto` the axis determines the best option. The options are restricted based on the axis orientation, a vertical axis may only anchor on `left` or `right`\n    * @type {string=} */\n  align: 'auto'\n};\n/**\n * Continuous axis settings\n * @typedef {object}\n * @alias component--axis-continuous\n */\n\nvar DEFAULT_CONTINUOUS_SETTINGS = {\n  /**\n   * @typedef {object}\n   */\n  labels: {\n    /** Toggle labels on/off\n    * @type {boolean=} */\n    show: true,\n\n    /** Space in pixels between the tick and label.\n    * @type {number=} */\n    margin: 4,\n\n    /** Max length of labels in pixels\n    * @type {number=} */\n    maxLengthPx: 150,\n\n    /** Min length of labels in pixels. Labels will always at least require this much space\n    * @type {number=} */\n    minLengthPx: 0,\n\n    /** Align act as a slider for the text bounding rect over the item bandwidth, given that the item have a bandwidth.\n    * @type {number=} */\n    align: 0.5,\n\n    /** Offset in pixels along the axis direction.\n    * @type {number=} */\n    offset: 0,\n\n    /**\n     * Toggle whether labels should be filtered if they are overlapping. Filtering may be applied in a non-sequential order.\n     * If labels are overlapping and this setting is toggled off, the axis will automatically hide.\n     * @type {boolean=}\n     */\n    filterOverlapping: true\n  },\n\n  /**\n   * @typedef {object}\n   */\n  ticks: {\n    /** Toggle ticks on/off\n    * @type {boolean=} */\n    show: true,\n\n    /** Space in pixels between the ticks and the line.\n    * @type {number=} */\n    margin: 0,\n\n    /** Size of the ticks in pixels.\n    * @type {number=} */\n    tickSize: 8\n  },\n\n  /**\n   * @typedef {object}\n   */\n  minorTicks: {\n    /** Toggle minor-ticks on/off\n    * @type {boolean=} */\n    show: false,\n\n    /** Size of the ticks in pixels.\n    * @type {number=} */\n    tickSize: 3,\n\n    /** Space in pixels between the ticks and the line.\n    * @type {number=} */\n    margin: 0\n  },\n\n  /**\n   * @typedef {object}\n   */\n  line: {\n    /** Toggle line on/off\n    * @type {boolean=} */\n    show: true\n  },\n\n  /** Padding in direction perpendicular to the axis\n    * @type {number=} */\n  paddingStart: 0,\n\n  /** Padding in direction perpendicular to the axis\n    * @type {number=} */\n  paddingEnd: 10,\n\n  /** Set the anchoring point of the axis. Avaialable options are `auto/left/right/bottom/top`. In `auto` the axis determines the best option. The options are restricted based on the axis orientation, a vertical axis may only anchor on `left` or `right`\n    * @type {string=} */\n  align: 'auto'\n};\n\nfunction calcRequiredSize(_ref) {\n  var isDiscrete = _ref.isDiscrete,\n      rect = _ref.rect,\n      formatter = _ref.formatter,\n      measureText = _ref.measureText,\n      scale = _ref.scale,\n      settings = _ref.settings,\n      state = _ref.state;\n  var size = 0;\n\n  var _getLabelSize = getSize({\n    isDiscrete: isDiscrete,\n    rect: rect,\n    formatter: formatter,\n    measureText: measureText,\n    scale: scale,\n    settings: settings,\n    state: state\n  }),\n      labelSize = _getLabelSize.size,\n      edgeBleed = _getLabelSize.edgeBleed,\n      isToLarge = _getLabelSize.isToLarge;\n\n  size += labelSize;\n\n  if (isToLarge) {\n    return {\n      size: size\n    };\n  }\n\n  if (settings.ticks.show) {\n    size += settings.ticks.margin;\n    size += settings.ticks.tickSize;\n  }\n\n  if (settings.minorTicks && settings.minorTicks.show) {\n    var minorTicksSize = settings.minorTicks.margin + settings.minorTicks.tickSize;\n\n    if (minorTicksSize > size) {\n      size = minorTicksSize;\n    }\n  }\n\n  if (settings.line.show) {\n    size += settings.line.strokeWidth;\n  }\n\n  size += settings.paddingStart;\n  size += settings.paddingEnd;\n  return {\n    size: size,\n    edgeBleed: edgeBleed\n  };\n}\n\nfunction alignTransform(_ref) {\n  var align = _ref.align,\n      inner = _ref.inner;\n\n  if (align === 'left') {\n    return {\n      x: inner.width + inner.x\n    };\n  }\n\n  if (align === 'right' || align === 'bottom') {\n    return inner;\n  }\n\n  return {\n    y: inner.y + inner.height\n  };\n}\n\nfunction resolveAlign(align, dock) {\n  var horizontal = ['top', 'bottom'];\n  var vertical = ['left', 'right'];\n\n  if (horizontal.indexOf(align) !== -1 && vertical.indexOf(dock) === -1) {\n    return align;\n  }\n\n  if (vertical.indexOf(align) !== -1 && horizontal.indexOf(dock) === -1) {\n    return align;\n  }\n\n  return dock; // Invalid align, return current dock as default\n}\n/**\n * @ignore\n * @param {object} context - The component context\n */\n\n\nfunction resolveLocalSettings(_ref2) {\n  var state = _ref2.state,\n      style = _ref2.style,\n      settings = _ref2.settings;\n  var defaultStgns = extend(true, {}, state.isDiscrete ? DEFAULT_DISCRETE_SETTINGS : DEFAULT_CONTINUOUS_SETTINGS, style);\n  var localStgns = extend(true, {}, defaultStgns, settings.settings);\n  var dock = settings.layout.dock || state.defaultDock;\n  localStgns.dock = dock;\n  localStgns.align = resolveAlign(settings.settings.align, dock);\n  localStgns.labels.tiltAngle = Math.max(-90, Math.min(localStgns.labels.tiltAngle, 90));\n  return localStgns;\n}\n\nfunction updateActiveMode(state, settings, isDiscrete) {\n  var mode = settings.labels.mode;\n\n  if (!isDiscrete || !state.isHorizontal) {\n    return 'horizontal';\n  }\n\n  if (mode === 'auto') {\n    return state.labels.activeMode;\n  }\n\n  if (['layered', 'tilted'].indexOf(settings.labels.mode) !== -1 && ['top', 'bottom'].indexOf(settings.dock) !== -1) {\n    return mode;\n  }\n\n  return 'horizontal';\n}\n\nvar axisComponent = {\n  require: ['chart', 'renderer', 'dockConfig'],\n  defaultSettings: {\n    layout: {\n      displayOrder: 0,\n      prioOrder: 0\n    },\n    settings: {},\n    style: {\n      labels: '$label',\n      ticks: '$guide-line',\n      minorTicks: '$guide-line--minor',\n      line: '$guide-line'\n    }\n  },\n  created: function created() {\n    // State is a representation of properties that are private to this component defintion and may be modified by only in this context.\n    this.state = {\n      isDiscrete: !!this.scale.bandwidth,\n      isHorizontal: false,\n      labels: {\n        activeMode: 'horizontal'\n      },\n      ticks: [],\n      innerRect: {\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0\n      },\n      outerRect: {\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0\n      },\n      defaultDock: undefined,\n      concreteNodeBuilder: undefined,\n      settings: undefined\n    };\n\n    if (this.state.isDiscrete) {\n      this.state.defaultDock = 'bottom';\n    } else {\n      this.state.defaultDock = 'left';\n    }\n\n    this.setState(this.settings);\n  },\n  setState: function setState() {\n    this.state.isDiscrete = !!this.scale.bandwidth;\n    this.state.settings = resolveLocalSettings(this);\n    this.state.concreteNodeBuilder = nodeBuilder(this.state.isDiscrete);\n    this.dockConfig.dock(this.state.settings.dock); // Override the dock setting (TODO should be removed)\n\n    this.state.isHorizontal = this.state.settings.align === 'top' || this.state.settings.align === 'bottom';\n    this.state.labels.activeMode = updateActiveMode(this.state, this.state.settings, this.state.isDiscrete);\n  },\n  preferredSize: function preferredSize(opts) {\n    var formatter = this.formatter,\n        state = this.state,\n        scale = this.scale;\n    var distance = this.state.isHorizontal ? opts.inner.width : opts.inner.height;\n    this.state.pxScale = scaleWithSize(scale, distance);\n    var reqSize = calcRequiredSize({\n      isDiscrete: this.state.isDiscrete,\n      rect: opts.inner,\n      formatter: formatter,\n      measureText: this.renderer.measureText,\n      scale: this.state.pxScale,\n      settings: this.state.settings,\n      state: state\n    });\n    return reqSize;\n  },\n  beforeUpdate: function beforeUpdate() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var settings = opts.settings;\n    this.setState(settings);\n  },\n  resize: function resize(opts) {\n    var inner = opts.inner,\n        outer = opts.outer;\n    var extendedInner = extend({}, inner, alignTransform({\n      align: this.state.settings.align,\n      inner: inner\n    }));\n    var finalOuter = outer || extendedInner;\n    extend(this.state.innerRect, extendedInner);\n    extend(this.state.outerRect, finalOuter);\n    return outer;\n  },\n  beforeRender: function beforeRender() {\n    var scale = this.scale,\n        formatter = this.formatter;\n    var distance = this.state.isHorizontal ? this.state.innerRect.width : this.state.innerRect.height;\n    this.state.pxScale = scaleWithSize(scale, distance);\n    this.state.ticks = this.state.pxScale.ticks({\n      distance: distance,\n      formatter: formatter\n    }).filter(function (t) {\n      return t.position >= 0 && t.position <= 1;\n    });\n  },\n  render: function render() {\n    var state = this.state;\n    var nodes = [];\n    nodes.push.apply(nodes, _toConsumableArray$1(this.state.concreteNodeBuilder.build({\n      settings: this.state.settings,\n      scale: this.state.pxScale,\n      innerRect: this.state.innerRect,\n      outerRect: this.state.outerRect,\n      measureText: this.renderer.measureText,\n      textBounds: this.renderer.textBounds,\n      ticks: this.state.ticks,\n      state: state\n    })));\n    crispifier.multiple(nodes);\n    return nodes;\n  }\n};\n\n/**\n * @typedef {object} component--axis\n */\n\n/**\n * @type {string}\n * @memberof component--axis\n */\n\nvar type$1 = 'axis';\nfunction axis(picasso) {\n  picasso.component(type$1, axisComponent);\n}\n\nfunction parseTitle(text, join, scale) {\n  var title = '';\n\n  if (typeof text === 'function') {\n    title = text();\n  } else if (typeof text === 'string') {\n    title = text;\n  } else if (scale) {\n    var data = scale.data();\n    var titles = (data.fields || []).map(function (field) {\n      return field.title();\n    });\n    title = titles.join(join);\n  }\n\n  return title;\n}\n\nfunction getTextAnchor(dock, anchor) {\n  var val = 'middle';\n\n  if (dock === 'left') {\n    if (anchor === 'top') {\n      val = 'end';\n    } else if (anchor === 'bottom') {\n      val = 'start';\n    }\n  } else if (dock === 'right') {\n    if (anchor === 'top') {\n      val = 'start';\n    } else if (anchor === 'bottom') {\n      val = 'end';\n    }\n  } else if (anchor === 'left') {\n    val = 'start';\n  } else if (anchor === 'right') {\n    val = 'end';\n  }\n\n  return val;\n}\n\nfunction generateTitle(_ref) {\n  var title = _ref.title,\n      definitionSettings = _ref.definitionSettings,\n      dock = _ref.dock,\n      rect = _ref.rect,\n      measureText = _ref.measureText,\n      style = _ref.style;\n  var struct = {\n    type: 'text',\n    text: title,\n    x: 0,\n    y: 0,\n    dx: 0,\n    dy: 0,\n    anchor: getTextAnchor(dock, definitionSettings.anchor),\n    baseline: 'alphabetical'\n  };\n  extend(struct, style.text);\n  var textRect = measureText(struct);\n\n  if (dock === 'top' || dock === 'bottom') {\n    var x = rect.width / 2;\n\n    if (definitionSettings.anchor === 'left') {\n      x = definitionSettings.paddingLeft || 0;\n    } else if (definitionSettings.anchor === 'right') {\n      x = rect.width - (definitionSettings.paddingRight || 0);\n    }\n\n    struct.x = x;\n    struct.y = dock === 'top' ? rect.height - definitionSettings.paddingStart : definitionSettings.paddingStart + textRect.height;\n    struct.dy = dock === 'top' ? -(textRect.height / 6) : -(textRect.height / 3);\n    struct.maxWidth = rect.width * 0.8;\n  } else {\n    var y = rect.height / 2;\n\n    if (definitionSettings.anchor === 'top') {\n      y = definitionSettings.paddingStart;\n    } else if (definitionSettings.anchor === 'bottom') {\n      y = rect.height - definitionSettings.paddingStart;\n    }\n\n    struct.y = y;\n    struct.x = dock === 'left' ? rect.width - definitionSettings.paddingStart : definitionSettings.paddingStart;\n    struct.dx = dock === 'left' ? -(textRect.height / 3) : textRect.height / 3;\n    var rotation = dock === 'left' ? 270 : 90;\n    struct.transform = \"rotate(\".concat(rotation, \", \").concat(struct.x + struct.dx, \", \").concat(struct.y + struct.dy, \")\");\n    struct.maxWidth = rect.height * 0.8;\n  }\n\n  if (!isNaN(definitionSettings.maxLengthPx)) {\n    struct.maxWidth = Math.min(struct.maxWidth, definitionSettings.maxLengthPx);\n  }\n\n  return struct;\n}\n/**\n * @typedef {object} component--text\n * @property {string} [type='text']\n * @property {string|function} text\n * @property {component--text-settings} settings - Text settings\n * @example\n * {\n *  type: 'text',\n *  text: 'my title',\n *  dock: 'left',\n *  settings: {\n *    anchor: 'left',\n *    style: {\n *      fill: 'red'\n *    }\n *  }\n * }\n */\n\n/**\n * @typedef {object} component--text-settings\n * @property {number} [paddingStart=5]\n * @property {number} [paddingEnd=5]\n * @property {number} [paddingLeft=0]\n * @property {number} [paddingRight=0]\n * @property {string} [anchor='center'] - Where to v- or h-align the text. Supports `left`, `right`, `top`, `bottom` and `center`\n * @property {string} [join=', '] - String to add when joining titles from multiple sources\n * @property {number} [maxLengthPx] - Limit the text length to this value in pixels\n */\n\n\nvar textComponent = {\n  require: ['renderer', 'chart'],\n  defaultSettings: {\n    layout: {\n      dock: 'bottom',\n      displayOrder: 0,\n      prioOrder: 0\n    },\n    settings: {\n      paddingStart: 5,\n      paddingEnd: 5,\n      paddingLeft: 0,\n      paddingRight: 0,\n      anchor: 'center',\n      join: ', ',\n      maxLengthPx: NaN\n    },\n    style: {\n      text: '$title'\n    }\n  },\n  created: function created() {\n    this.definitionSettings = this.settings.settings;\n    var text = this.settings.text;\n    var join = this.definitionSettings.join;\n    this.title = parseTitle(text, join, this.scale);\n  },\n  preferredSize: function preferredSize() {\n    var height = this.renderer.measureText({\n      text: this.title,\n      fontSize: this.style.text.fontSize,\n      fontFamily: this.style.text.fontFamily\n    }).height;\n    return height + this.definitionSettings.paddingStart + this.definitionSettings.paddingEnd;\n  },\n  render: function render() {\n    var title = this.title,\n        definitionSettings = this.definitionSettings,\n        rect = this.rect;\n    var nodes = [];\n    nodes.push(generateTitle({\n      title: title,\n      dock: this.settings.layout.dock,\n      definitionSettings: definitionSettings,\n      rect: rect,\n      measureText: this.renderer.measureText,\n      style: this.style\n    }));\n    return nodes;\n  },\n  beforeUpdate: function beforeUpdate(opts) {\n    if (opts.settings) {\n      extend(this.settings, opts.settings);\n      this.definitionSettings = opts.settings.settings;\n    }\n\n    var text = this.settings.text;\n    var join = this.definitionSettings.join;\n    this.title = parseTitle(text, join, this.scale);\n  }\n};\n\nfunction text(picasso) {\n  picasso.component('text', textComponent);\n}\n\n/**\n * @typedef {object} component--scrollbar\n * @private\n */\n\n/**\n * @typedef {object} component--scrollbar.settings\n * @property {boolean} [backgroundColor = '#eee']\n * @property {boolean} [thumbColor = '#ccc']\n * @property {boolean} [width = 16]\n */\nfunction start(_scrollbar, pos) {\n  var dock = _scrollbar.settings.layout.dock;\n  var invert = _scrollbar.settings.settings.invert;\n  var horizontal = dock === 'top' || dock === 'bottom';\n  var lengthAttr = horizontal ? 'width' : 'height';\n  var length = _scrollbar.rect[lengthAttr];\n\n  var scroll = _scrollbar.chart.scroll(_scrollbar.settings.scroll);\n\n  var currentMove;\n  {\n    // local scope to allow reuse of variable names later\n    var offset = pos[horizontal ? 'x' : 'y'];\n\n    if (invert) {\n      offset = length - offset;\n    }\n\n    var scrollState = scroll.getState();\n    currentMove = {\n      startOffset: offset,\n      startScroll: scrollState.start,\n      swipe: false\n    }; // Detect swipe start outsize the thumb & change startScroll to jump the scroll there.\n\n    var scrollPoint = offset / length * (scrollState.max - scrollState.min) + scrollState.min;\n\n    if (scrollPoint < scrollState.start) {\n      currentMove.startScroll = scrollPoint;\n    } else if (scrollPoint > scrollState.start + scrollState.viewSize) {\n      currentMove.startScroll = scrollPoint - scrollState.viewSize;\n    }\n  }\n\n  var update = function update(p) {\n    var offset = p[horizontal ? 'x' : 'y'];\n\n    if (invert) {\n      offset = length - offset;\n    }\n\n    if (!currentMove.swipe) {\n      if (Math.abs(currentMove.startOffset - offset) <= 1) {\n        return;\n      }\n\n      currentMove.swipe = true;\n    }\n\n    var scrollState = scroll.getState();\n    var scrollMove = (offset - currentMove.startOffset) / length * (scrollState.max - scrollState.min);\n    var scrollStart = currentMove.startScroll + scrollMove;\n    scroll.moveTo(scrollStart);\n  };\n\n  var end = function end(p) {\n    var offset = p[horizontal ? 'x' : 'y'];\n\n    if (invert) {\n      offset = length - offset;\n    }\n\n    var scrollState = scroll.getState();\n\n    if (currentMove.swipe) {\n      var scrollMove = (offset - currentMove.startOffset) / length * (scrollState.max - scrollState.min);\n      var scrollStart = currentMove.startScroll + scrollMove;\n      scroll.moveTo(scrollStart);\n    } else {\n      var scrollCenter = offset / length * (scrollState.max - scrollState.min) + scrollState.min;\n\n      var _scrollStart = scrollCenter - scrollState.viewSize / 2;\n\n      scroll.moveTo(_scrollStart);\n    }\n  };\n\n  return {\n    update: update,\n    end: end\n  };\n}\n\nfunction getLocalPos(event, renderer) {\n  var containerRect = renderer.element().getBoundingClientRect();\n  return {\n    x: event.center.x - containerRect.left,\n    y: event.center.y - containerRect.top\n  };\n}\n\nvar scrollbarComponent = {\n  require: ['chart', 'renderer'],\n  on: {\n    panStart: function panStart(event) {\n      var pos = getLocalPos(event, this.renderer);\n      var startPos = {\n        x: pos.x - event.deltaX,\n        y: pos.y - event.deltaY\n      };\n      this.currentMove = start(this, startPos);\n      this.currentMove.update(pos);\n    },\n    panMove: function panMove(event) {\n      if (!this.currentMove) {\n        return;\n      }\n\n      var pos = getLocalPos(event, this.renderer);\n      this.currentMove.update(pos);\n    },\n    panEnd: function panEnd(event) {\n      if (!this.currentMove) {\n        return;\n      }\n\n      var pos = getLocalPos(event, this.renderer);\n      this.currentMove.end(pos);\n      this.currentMove = null;\n    },\n    panCancel: function panCancel() {\n      this.currentMove = null;\n    },\n    tap: function tap(event) {\n      var pos = getLocalPos(event, this.renderer);\n      var move = start(this, pos);\n      move.end(pos);\n    }\n  },\n  defaultSettings: {\n    settings: {\n      backgroundColor: '#eee',\n      thumbColor: '#ccc',\n      width: 16 // 32 for touch\n\n    }\n  },\n  preferredSize: function preferredSize(rect) {\n    var scrollState = this.chart.scroll(this.settings.scroll).getState(); // hide the scrollbar if it is not possible to scroll\n\n    if (scrollState.viewSize >= scrollState.max - scrollState.min) {\n      var toLargeSize = Math.max(rect.width, rect.height);\n      return toLargeSize;\n    }\n\n    return this.settings.settings.width;\n  },\n  render: function render(h) {\n    var _style;\n\n    var dock = this.settings.layout.dock;\n    var invert = this.settings.settings.invert;\n    var horizontal = dock === 'top' || dock === 'bottom';\n    var lengthAttr = horizontal ? 'width' : 'height';\n    var _rect = this.rect;\n    var length = _rect[lengthAttr];\n    var scrollState = this.chart.scroll(this.settings.scroll).getState();\n    var thumbStart = length * (scrollState.start - scrollState.min) / (scrollState.max - scrollState.min);\n    var thumbRange = length * scrollState.viewSize / (scrollState.max - scrollState.min);\n\n    if (invert) {\n      thumbStart = length - thumbStart - thumbRange;\n    }\n\n    return h('div', {\n      style: {\n        position: 'relative',\n        width: '100%',\n        height: '100%',\n        background: this.settings.settings.backgroundColor,\n        pointerEvents: 'auto'\n      }\n    }, [].concat(h('div', {\n      class: 'scroller',\n      style: (_style = {\n        position: 'absolute'\n      }, _defineProperty(_style, horizontal ? 'left' : 'top', \"\".concat(thumbStart, \"px\")), _defineProperty(_style, horizontal ? 'top' : 'left', '25%'), _defineProperty(_style, horizontal ? 'height' : 'width', '50%'), _defineProperty(_style, lengthAttr, \"\".concat(Math.max(1, thumbRange), \"px\")), _defineProperty(_style, \"background\", this.settings.settings.thumbColor), _style)\n    })));\n  },\n  renderer: 'dom'\n};\nfunction scrollbar(picasso) {\n  picasso.component('scrollbar', scrollbarComponent);\n}\n\nvar TARGET_SIZE = 5;\nvar VERTICAL = 0;\nvar HORIZONTAL = 1;\n\nfunction buildLine$1(_ref) {\n  var h = _ref.h,\n      isVertical = _ref.isVertical,\n      value = _ref.value,\n      pos = _ref.pos,\n      align = _ref.align,\n      borderHit = _ref.borderHit,\n      state = _ref.state,\n      idx = _ref.idx;\n  var isAlignStart = align !== 'end';\n  var alignStart = {\n    left: '0',\n    top: '0'\n  };\n  var alignEnd = {\n    right: '0',\n    bottom: '0'\n  };\n  var alignStyle = isAlignStart ? alignStart : alignEnd;\n  var start = 0;\n  var width = '100%';\n  var height = '100%';\n\n  if (state.targetRect && state.settings.bubbles.align === 'start') {\n    width = \"\".concat(state.targetRect.x + state.targetRect.width, \"px\");\n    height = \"\".concat(state.targetRect.y + state.targetRect.height, \"px\");\n  } else if (state.targetRect && state.settings.bubbles.align === 'end') {\n    start = isVertical ? state.targetRect.x : state.targetRect.y;\n    width = \"\".concat(state.rect.width - start, \"px\");\n    height = \"\".concat(state.rect.height - start, \"px\");\n  }\n\n  if (!isAlignStart) {\n    pos -= borderHit;\n  } // edge\n\n\n  return h('div', {\n    onmouseover: function onmouseover(e) {\n      e.srcElement.children[0].style.backgroundColor = '#000';\n      e.srcElement.children[0].style[isVertical ? 'height' : 'width'] = '2px';\n    },\n    onmouseout: function onmouseout(e) {\n      e.srcElement.children[0].style.backgroundColor = state.style.line.stroke;\n      e.srcElement.children[0].style[isVertical ? 'height' : 'width'] = '1px';\n    },\n    'data-value': value,\n    'data-key': [state.key, 'edge', idx].join('-'),\n    style: {\n      cursor: isVertical ? 'ns-resize' : 'ew-resize',\n      position: 'absolute',\n      left: isVertical ? \"\".concat(start, \"px\") : \"\".concat(pos, \"px\"),\n      top: isVertical ? \"\".concat(pos, \"px\") : \"\".concat(start, \"px\"),\n      height: isVertical ? \"\".concat(borderHit, \"px\") : height,\n      width: isVertical ? width : \"\".concat(borderHit, \"px\"),\n      pointerEvents: 'auto'\n    }\n  }, [// line\n  h('div', {\n    style: extend({\n      backgroundColor: state.style.line.stroke,\n      position: 'absolute',\n      height: isVertical ? \"\".concat(1, \"px\") : '100%',\n      width: isVertical ? '100%' : \"\".concat(1, \"px\"),\n      pointerEvents: 'none'\n    }, alignStyle)\n  })]);\n}\n\nfunction buildBubble(_ref2) {\n  var _style;\n\n  var h = _ref2.h,\n      isVertical = _ref2.isVertical,\n      label = _ref2.label,\n      otherValue = _ref2.otherValue,\n      rangeIdx = _ref2.rangeIdx,\n      idx = _ref2.idx,\n      pos = _ref2.pos,\n      align = _ref2.align,\n      state = _ref2.state,\n      value = _ref2.value;\n  var isAlignStart = align !== 'end';\n  var isOutside = state.settings.bubbles.placement === 'outside';\n  var outside = 'none';\n  var bubbleDock;\n\n  if (isVertical) {\n    bubbleDock = isAlignStart ? 'left' : 'right';\n\n    if (isOutside) {\n      outside = isAlignStart ? 'translate(-100%,  0px)' : 'translate(100%,  0px)';\n    }\n  } else {\n    bubbleDock = isAlignStart ? 'top' : 'bottom';\n\n    if (isOutside) {\n      outside = isAlignStart ? 'translate(0px, -100%)' : 'translate(0px,  100%)';\n    }\n  }\n\n  var inEdit = state.edit && state.edit.rangeIdx === rangeIdx && state.edit.bubbleIdx === idx;\n  var bubbleStyle = {\n    position: 'relative',\n    borderRadius: \"\".concat(state.style.bubble.borderRadius, \"px\"),\n    border: \"\".concat(state.style.bubble.strokeWidth, \"px solid \").concat(state.style.bubble.stroke),\n    backgroundColor: state.style.bubble.fill,\n    color: state.style.bubble.color,\n    fontFamily: state.style.bubble.fontFamily,\n    fontSize: state.style.bubble.fontSize,\n    padding: '4px 8px',\n    textAlign: 'center',\n    overflow: 'hidden',\n    textOverflow: 'ellipsis',\n    whiteSpace: 'nowrap',\n    maxWidth: '150px',\n    minWidth: '50px',\n    minHeight: '1em',\n    pointerEvents: 'auto',\n    transform: isVertical ? 'translate(0,-50%)' : 'translate(-50%,0)',\n    cursor: isVertical ? 'ns-resize' : 'ew-resize'\n  };\n  var currentBorderColor = state.style.bubble.stroke;\n  var bubble = inEdit ? h('input', {\n    type: 'text',\n    value: value,\n    style: _objectSpread2({}, bubbleStyle, {\n      textAlign: 'start',\n      textOverflow: '',\n      fontSize: '13px' // TODO - make it styleable\n\n    }),\n    onkeyup: function onkeyup(e) {\n      if (e.key === 'Enter') {\n        e.preventDefault();\n        e.stopPropagation();\n        var newValue = parseFloat(e.target.value);\n\n        if (isNaN(newValue)) {\n          currentBorderColor = 'rgba(230, 78, 78, 0.6)';\n          e.target.style.border = \"\".concat(state.style.bubble.strokeWidth, \"px solid \").concat(currentBorderColor);\n        } else {\n          state.onEditConfirmed(rangeIdx, newValue, otherValue);\n        }\n      } else if (e.key === 'Escape') {\n        e.preventDefault();\n        e.stopPropagation();\n        state.onEditCanceled();\n      }\n    }\n  }) : h('div', {\n    'data-key': [state.key, 'bubble', rangeIdx].join('-'),\n    'data-other-value': otherValue,\n    'data-idx': rangeIdx,\n    'data-bidx': idx,\n    style: bubbleStyle\n  }, [label]); // bubble wrapper\n\n  return h('div', {\n    style: (_style = {\n      position: 'absolute'\n    }, _defineProperty(_style, bubbleDock, '0'), _defineProperty(_style, isVertical ? 'top' : 'left', \"\".concat(pos, \"px\")), _defineProperty(_style, \"transform\", outside), _style)\n  }, [// bubble\n  bubble]);\n}\n\nfunction buildArea(_ref3) {\n  var h = _ref3.h,\n      isVertical = _ref3.isVertical,\n      top = _ref3.top,\n      height = _ref3.height,\n      color = _ref3.color,\n      on = _ref3.on,\n      opacity = _ref3.opacity;\n  return h('div', extend({\n    style: {\n      backgroundColor: color,\n      opacity: opacity,\n      position: 'absolute',\n      left: isVertical ? 0 : \"\".concat(top, \"px\"),\n      top: isVertical ? \"\".concat(top, \"px\") : 0,\n      height: isVertical ? \"\".concat(height, \"px\") : '100%',\n      width: isVertical ? '100%' : \"\".concat(height, \"px\"),\n      pointerEvents: 'auto'\n    }\n  }, on), []);\n}\n\nfunction buildRange(_ref4) {\n  var borderHit = _ref4.borderHit,\n      els = _ref4.els,\n      isVertical = _ref4.isVertical,\n      state = _ref4.state,\n      vStart = _ref4.vStart,\n      vEnd = _ref4.vEnd,\n      idx = _ref4.idx;\n  var targetOffset = 0;\n\n  if (state.targetRect) {\n    targetOffset = isVertical ? state.targetRect.y : state.targetRect.x;\n  }\n\n  var hasScale = !!state.scale;\n  var start = hasScale ? state.scale.norm(vStart) * state.size : vStart;\n  var end = hasScale ? state.scale.norm(vEnd) * state.size : vEnd;\n  var height = Math.abs(start - end);\n  var top = Math.min(start, end) + targetOffset;\n  var bottom = top + height;\n\n  if (state.targetRect) {\n    var target = state.targetFillRect || state.targetRect;\n    var targetSize = isVertical ? target.height : target.width;\n    var targetStart = hasScale ? state.scale.norm(vStart) * targetSize : vStart;\n    var targetEnd = hasScale ? state.scale.norm(vEnd) * targetSize : vEnd;\n    var targetHeight = Math.abs(targetStart - targetEnd);\n    var targetTop = Math.min(targetStart, targetEnd);\n    var targetArea = {\n      h: state.h,\n      isVertical: isVertical,\n      top: targetTop,\n      height: targetHeight,\n      color: state.style.target.fill,\n      opacity: state.style.target.opacity\n    };\n\n    if (state.style.target.opacity < 0.8) {\n      targetArea.on = {\n        onmouseover: function onmouseover(e) {\n          e.srcElement.style.opacity = state.style.target.opacity + 0.1;\n        },\n        onmouseout: function onmouseout(e) {\n          e.srcElement.style.opacity = state.style.target.opacity;\n        }\n      };\n    }\n\n    els.push(state.h('div', {\n      style: {\n        position: 'absolute',\n        left: \"\".concat(target.x, \"px\"),\n        top: \"\".concat(target.y, \"px\"),\n        height: \"\".concat(target.height, \"px\"),\n        width: \"\".concat(target.width, \"px\")\n      }\n    }, [buildArea(targetArea)]));\n  } // active range area\n  // els.push(buildArea({\n  //   h: state.h,\n  //   isVertical,\n  //   top,\n  //   height,\n  //   color: state.settings.fill\n  // }));\n\n\n  var valStart = start < end ? vStart : vEnd;\n  var valEnd = start < end ? vEnd : vStart;\n\n  var _ref5 = hasScale ? state.scale.domain() : [Math.min(vStart, vEnd), Math.max(vStart, vEnd)],\n      _ref6 = _slicedToArray(_ref5, 2),\n      min = _ref6[0],\n      max = _ref6[1];\n\n  var isStartVisible = valStart + 1e-5 >= min && valStart - 1e-5 <= max; // accept minor floating point difference\n\n  var isEndVisible = valEnd - 1e-5 <= max && valEnd + 1e-5 >= min;\n\n  if (isStartVisible) {\n    els.push(buildLine$1({\n      h: state.h,\n      isVertical: isVertical,\n      borderHit: borderHit,\n      value: valStart,\n      pos: top,\n      align: 'start',\n      state: state,\n      idx: idx\n    }));\n  }\n\n  if (isEndVisible) {\n    els.push(buildLine$1({\n      h: state.h,\n      isVertical: isVertical,\n      borderHit: borderHit,\n      value: valEnd,\n      pos: bottom,\n      align: 'end',\n      state: state,\n      idx: idx\n    }));\n  }\n\n  var bubbles = state.settings.bubbles;\n\n  if (bubbles && bubbles.show) {\n    var fontSize = bubbles.fontSize;\n    var fontFamily = bubbles.fontFamily;\n    var fill = bubbles.fill;\n    var style = {\n      fontSize: fontSize,\n      fontFamily: fontFamily,\n      color: fill\n    };\n    var range = [vStart, vEnd];\n\n    if (isStartVisible) {\n      els.push(buildBubble({\n        h: state.h,\n        isVertical: isVertical,\n        align: bubbles.align,\n        style: style,\n        rangeIdx: idx,\n        idx: 0,\n        otherValue: valEnd,\n        value: valStart,\n        label: \"\".concat(state.format(valStart, range)),\n        pos: top,\n        state: state\n      }));\n    }\n\n    if (isEndVisible) {\n      els.push(buildBubble({\n        h: state.h,\n        isVertical: isVertical,\n        align: bubbles.align,\n        style: style,\n        rangeIdx: idx,\n        idx: 1,\n        otherValue: valStart,\n        value: valEnd,\n        label: \"\".concat(state.format(valEnd, range)),\n        pos: bottom,\n        state: state\n      }));\n    }\n  }\n}\nfunction getMoveDelta(state) {\n  var posDelta = state.active.limitHigh - state.active.end;\n  var negDelta = state.active.limitLow - state.active.start;\n  var delta = state.current - state.start;\n\n  if (delta < 0) {\n    delta = Math.max(delta, negDelta);\n  } else {\n    delta = Math.min(delta, posDelta);\n  }\n\n  return delta;\n}\nfunction nodes(state) {\n  var els = [];\n  var isVertical = state.direction === VERTICAL;\n\n  if (Array.isArray(state.ranges)) {\n    // add all other ranges\n    state.ranges.forEach(function (r, i) {\n      if (!state.active || i !== state.active.idx) {\n        buildRange({\n          borderHit: TARGET_SIZE,\n          els: els,\n          isVertical: isVertical,\n          state: state,\n          vStart: Math.min(r.min, r.max),\n          vEnd: Math.max(r.min, r.max),\n          idx: i\n        });\n      }\n    });\n  }\n\n  if (state.active) {\n    // add active range\n    var vStart = state.start;\n    var vEnd = state.current;\n\n    if (state.active.idx !== -1) {\n      if (state.active.mode === 'foo') {\n        vStart = Math.min(state.active.start, state.active.end);\n        vEnd = Math.max(state.active.start, state.active.end);\n      } else if (state.active.mode === 'modify') {\n        vStart = Math.min(state.start, state.current);\n        vEnd = Math.max(state.start, state.current);\n      } else {\n        var delta = getMoveDelta(state);\n        vStart = state.active.start + delta;\n        vEnd = state.active.end + delta;\n      }\n    }\n\n    buildRange({\n      borderHit: TARGET_SIZE,\n      els: els,\n      isVertical: isVertical,\n      state: state,\n      vStart: vStart,\n      vEnd: vEnd,\n      idx: state.active.idx\n    });\n  }\n\n  return els;\n}\n\nfunction rangelimits(state) {\n  return {\n    min: state.scale.min(),\n    max: state.scale.max()\n  };\n}\n\nfunction areaLimits(state) {\n  return {\n    min: 0,\n    max: state.direction ? state.rect.width : state.rect.height\n  };\n}\n\nfunction findActive(state, value, limits) {\n  var rs = state.ranges;\n  var i;\n  var activeIdx = -1;\n\n  for (i = 0; i < rs.length; i++) {\n    if (rs[i].min <= value && value <= rs[i].max) {\n      activeIdx = i;\n      limits.min = i ? rs[i - 1].max : limits.min;\n      limits.max = i + 1 < rs.length ? rs[i + 1].min : limits.max;\n      break;\n    } else if (value < rs[i].min) {\n      limits.max = rs[i].min;\n      limits.min = i ? rs[i - 1].max : limits.min;\n      break;\n    }\n  }\n\n  if (activeIdx === -1 && rs.length && i >= rs.length) {\n    limits.min = rs[rs.length - 1].max;\n  }\n\n  var activeRange;\n\n  if (activeIdx !== -1) {\n    activeRange = {\n      idx: activeIdx,\n      start: rs[activeIdx].min,\n      end: rs[activeIdx].max,\n      limitLow: limits.min,\n      limitHigh: limits.max,\n      mode: 'foo'\n    };\n  }\n\n  state.active = activeRange;\n}\n\nfunction startArea(_ref) {\n  var state = _ref.state,\n      e = _ref.e,\n      renderer = _ref.renderer,\n      ranges = _ref.ranges,\n      targetSize = _ref.targetSize;\n\n  if (state.started) {\n    return;\n  }\n\n  var x = e.center.x - e.deltaX;\n  var y = e.center.y - e.deltaY;\n  var target = document.elementFromPoint(x, y);\n\n  if (!renderer.element().contains(target)) {\n    target = null;\n  }\n\n  var tempState = {\n    started: true\n  };\n  state.offset = renderer.element().getBoundingClientRect();\n  state.ranges = ranges(state);\n  var relX = x - state.offset.left; // coordinate relative renderer\n\n  var relY = y - state.offset.top;\n  var startPoint = e.center[state.cssCoord.coord] - e[state.cssCoord.pos] - state.offset[state.cssCoord.offset];\n  var relStart = e.center[state.cssCoord.coord] - state.offset[state.cssCoord.offset];\n  var v = relStart;\n  var vStart = startPoint;\n  tempState.start = startPoint;\n  tempState.current = relStart;\n  var rs = state.ranges;\n  var limits = areaLimits(state);\n  var i;\n  var activeIdx = -1;\n\n  if (target && target.hasAttribute('data-idx')) {\n    activeIdx = parseInt(target.getAttribute('data-idx'), 10);\n    limits.min = activeIdx > 0 ? rs[activeIdx - 1].max : limits.min;\n    limits.max = activeIdx + 1 < rs.length ? rs[activeIdx + 1].min : limits.max;\n  } else {\n    for (i = 0; i < rs.length; i++) {\n      if (rs[i].min <= vStart && vStart <= rs[i].max) {\n        activeIdx = i;\n        limits.min = i ? rs[i - 1].max : limits.min;\n        limits.max = i + 1 < rs.length ? rs[i + 1].min : limits.max;\n        break;\n      } else if (vStart < rs[i].min) {\n        limits.max = rs[i].min;\n        limits.min = i ? rs[i - 1].max : limits.min;\n        break;\n      }\n    }\n\n    if (activeIdx === -1 && rs.length && i >= rs.length) {\n      limits.min = rs[rs.length - 1].max;\n    }\n  }\n\n  if (activeIdx === -1 && !state.multi) {\n    tempState.ranges = [];\n    limits.min = 0;\n    limits.max = state.direction ? state.rect.width : state.rect.height;\n  }\n\n  var activeRange;\n\n  if (activeIdx !== -1) {\n    activeRange = {\n      idx: activeIdx,\n      start: rs[activeIdx].min,\n      end: rs[activeIdx].max,\n      limitLow: limits.min,\n      limitHigh: limits.max,\n      mode: 'move'\n    };\n\n    if (target && target.hasAttribute('data-other-value')) {\n      tempState.start = parseFloat(target.getAttribute('data-other-value'));\n      activeRange.mode = 'modify';\n    } else {\n      var pxStart = activeRange.start;\n      var pxEnd = activeRange.end;\n\n      if (Math.abs(startPoint - pxStart) <= targetSize) {\n        tempState.start = activeRange.end;\n        activeRange.mode = 'modify';\n      } else if (Math.abs(startPoint - pxEnd) <= targetSize) {\n        tempState.start = activeRange.start;\n        activeRange.mode = 'modify';\n      }\n    }\n  } else {\n    activeRange = {\n      idx: -1,\n      start: vStart,\n      end: v,\n      limitLow: limits.min,\n      limitHigh: limits.max,\n      mode: 'current'\n    };\n  }\n\n  tempState.active = activeRange;\n\n  if (activeRange.mode !== 'modify' && state.targetRect && !testRectPoint(state.targetRect, {\n    x: relX,\n    y: relY\n  })) ; else {\n    Object.keys(tempState).forEach(function (key) {\n      return state[key] = tempState[key];\n    });\n  }\n}\nfunction start$1(_ref2) {\n  var state = _ref2.state,\n      e = _ref2.e,\n      renderer = _ref2.renderer,\n      ranges = _ref2.ranges,\n      targetSize = _ref2.targetSize;\n\n  if (state.started) {\n    return;\n  }\n\n  state.edit = null;\n  var x = e.center.x - e.deltaX;\n  var y = e.center.y - e.deltaY;\n  var target = document.elementFromPoint(x, y);\n\n  if (!renderer.element().contains(target)) {\n    target = null;\n  }\n\n  var tempState = {\n    started: true\n  };\n  state.offset = extend({}, renderer.element().getBoundingClientRect());\n  var relX = x - state.offset.left; // coordinate relative renderer\n\n  var relY = y - state.offset.top;\n  state.offset.left += state.targetRect ? state.targetRect.x : 0; // make offset relative to targetRect\n\n  state.offset.top += state.targetRect ? state.targetRect.y : 0;\n  state.ranges = ranges(state, state.fauxBrushInstance || state.brushInstance);\n  var startPoint = e.center[state.cssCoord.coord] - e[state.cssCoord.pos] - state.offset[state.cssCoord.offset];\n  var relStart = e.center[state.cssCoord.coord] - state.offset[state.cssCoord.offset];\n  tempState.current = state.scale.normInvert(relStart / state.size);\n  tempState.start = state.scale.normInvert(startPoint / state.size);\n  var rs = state.ranges;\n  var limits = rangelimits(state);\n  var i;\n  var activeIdx = -1;\n\n  if (target && target.hasAttribute('data-idx')) {\n    activeIdx = parseInt(target.getAttribute('data-idx'), 10);\n    limits.min = activeIdx > 0 ? rs[activeIdx - 1].max : limits.min;\n    limits.max = activeIdx + 1 < rs.length ? rs[activeIdx + 1].min : limits.max;\n  } else {\n    for (i = 0; i < rs.length; i++) {\n      if (rs[i].min <= tempState.start && tempState.start <= rs[i].max) {\n        activeIdx = i;\n        limits.min = i ? rs[i - 1].max : limits.min;\n        limits.max = i + 1 < rs.length ? rs[i + 1].min : limits.max;\n        break;\n      } else if (tempState.start < rs[i].min) {\n        limits.max = rs[i].min;\n        limits.min = i ? rs[i - 1].max : limits.min;\n        break;\n      }\n    }\n\n    if (activeIdx === -1 && rs.length && i >= rs.length) {\n      limits.min = rs[rs.length - 1].max;\n    }\n  }\n\n  if (activeIdx === -1 && !state.multi) {\n    tempState.ranges = [];\n    limits.min = state.scale.min();\n    limits.max = state.scale.max();\n  }\n\n  var activeRange;\n\n  if (activeIdx !== -1) {\n    activeRange = {\n      idx: activeIdx,\n      start: rs[activeIdx].min,\n      end: rs[activeIdx].max,\n      limitLow: limits.min,\n      limitHigh: limits.max,\n      mode: 'move'\n    };\n\n    if (target && target.hasAttribute('data-other-value')) {\n      tempState.start = parseFloat(target.getAttribute('data-other-value'));\n      activeRange.mode = 'modify';\n    } else {\n      var pxStart = state.scale.norm(activeRange.start) * state.size;\n      var pxEnd = state.scale.norm(activeRange.end) * state.size;\n\n      if (Math.abs(startPoint - pxStart) <= targetSize) {\n        tempState.start = activeRange.end;\n        activeRange.mode = 'modify';\n      } else if (Math.abs(startPoint - pxEnd) <= targetSize) {\n        tempState.start = activeRange.start;\n        activeRange.mode = 'modify';\n      }\n    }\n  } else {\n    activeRange = {\n      idx: -1,\n      start: tempState.start,\n      end: tempState.current,\n      limitLow: limits.min,\n      limitHigh: limits.max,\n      mode: 'current'\n    };\n  }\n\n  tempState.active = activeRange;\n\n  if (activeRange.mode !== 'modify' && state.targetRect && !testRectPoint(state.targetRect, {\n    x: relX,\n    y: relY\n  })) ; else {\n    Object.keys(tempState).forEach(function (key) {\n      return state[key] = tempState[key];\n    });\n  }\n}\nfunction end(state, ranges) {\n  state.started = false;\n  state.ranges = ranges(state, state.fauxBrushInstance || state.brushInstance);\n  var limits = rangelimits(state);\n  findActive(state, state.current, limits);\n}\nfunction endArea(state, ranges) {\n  state.started = false;\n  state.ranges = ranges(state);\n  var limits = areaLimits(state);\n  findActive(state, state.current, limits);\n}\nfunction move(state, e) {\n  var relY = e.center[state.cssCoord.coord] - state.offset[state.cssCoord.offset];\n  var rel = relY / state.size;\n  var v = state.scale.normInvert(rel);\n  state.current = Math.max(Math.min(v, state.active.limitHigh), state.active.limitLow);\n}\nfunction moveArea(state, e) {\n  var rel = e.center[state.cssCoord.coord] - state.offset[state.cssCoord.offset];\n  state.current = Math.max(Math.min(rel, state.active.limitHigh), state.active.limitLow);\n}\n\nfunction _render(state) {\n  state.renderer.render(nodes(state));\n}\n\nfunction ranges(state, brush) {\n  if (!brush || !brush.isActive()) {\n    return [];\n  }\n\n  var sourceData = state.scale.data();\n  var sourceFields = sourceData ? sourceData.fields || [] : [];\n  var sources = sourceFields.map(function (field) {\n    return field.id();\n  });\n  var rangeBrush = brush.brushes().filter(function (f) {\n    return f.type === 'range' && sources.indexOf(f.id) !== -1;\n  })[0];\n\n  if (!rangeBrush) {\n    return [];\n  }\n\n  return rangeBrush.brush.ranges();\n}\n\nfunction setRanges(state) {\n  var rs = state.ranges.map(function (r) {\n    return {\n      min: r.min,\n      max: r.max\n    };\n  });\n\n  if (state.active.idx !== -1) {\n    if (state.active.mode === 'modify') {\n      rs[state.active.idx].min = Math.min(state.start, state.current);\n      rs[state.active.idx].max = Math.max(state.start, state.current);\n    } else {\n      var delta = getMoveDelta(state);\n      rs[state.active.idx].min += delta;\n      rs[state.active.idx].max += delta;\n    }\n  } else {\n    rs.push({\n      min: Math.min(state.start, state.current),\n      max: Math.max(state.start, state.current)\n    });\n  }\n\n  var scaleData = state.scale.data();\n\n  if (scaleData && scaleData.fields) {\n    scaleData.fields.forEach(function (field) {\n      if (state.fauxBrushInstance) {\n        var ordRS = ranges(state, state.fauxBrushInstance);\n        var oldValues = state.findValues(ordRS);\n        var values = state.findValues(rs);\n        var addedValues = values.filter(function (v) {\n          return oldValues.indexOf(v) === -1;\n        });\n        var removedValues = oldValues.filter(function (v) {\n          return values.indexOf(v) === -1;\n        });\n        var addItems = addedValues.map(function (v) {\n          return {\n            key: field.id(),\n            value: v\n          };\n        });\n        var removeItems = removedValues.map(function (v) {\n          return {\n            key: field.id(),\n            value: v\n          };\n        });\n        state.brushInstance.addAndRemoveValues(addItems, removeItems);\n        state.fauxBrushInstance.setRange(field.id(), rs);\n      } else {\n        state.brushInstance.setRange(field.id(), rs);\n      }\n    });\n  }\n}\n\nfunction setEditedRanges(state, idx, startValue, endValue) {\n  var rs = state.ranges.map(function (r) {\n    return {\n      min: r.min,\n      max: r.max\n    };\n  });\n  var limitMin = state.scale.min();\n  var limitMax = state.scale.max();\n  rs[idx] = {\n    min: Math.max(limitMin, Math.min(startValue, endValue)),\n    max: Math.min(limitMax, Math.max(startValue, endValue))\n  };\n  state.ranges[idx] = _objectSpread2({}, rs[idx]);\n  var scaleData = state.scale.data();\n\n  if (scaleData && scaleData.fields) {\n    scaleData.fields.forEach(function (field) {\n      if (!state.fauxBrushInstance) {\n        state.brushInstance.setRange(field.id(), rs);\n      }\n    });\n  }\n}\n\nfunction findClosest(value, scale) {\n  var name;\n  var minDist = Infinity;\n  var domain = scale.domain();\n  var halfBandwidth = scale.bandwidth() / 2;\n\n  for (var i = 0; i < domain.length; ++i) {\n    var d = Math.abs(value - halfBandwidth - scale(domain[i]));\n\n    if (d < minDist) {\n      minDist = d;\n      name = domain[i];\n    }\n  }\n\n  return name;\n}\n\nfunction findClosestLabel(value, scale) {\n  var ticks = scale.ticks();\n  var idx = scale.domain().indexOf(findClosest(value, scale));\n  return idx !== -1 ? ticks[idx].label : '-';\n}\n\nfunction rangesOverlap(r1, r2) {\n  return Math.min.apply(Math, _toConsumableArray$1(r1)) <= Math.max.apply(Math, _toConsumableArray$1(r2)) && Math.max.apply(Math, _toConsumableArray$1(r1)) >= Math.min.apply(Math, _toConsumableArray$1(r2));\n}\n\nfunction findValues(rangesValues, scale) {\n  var domain = scale.domain();\n  var scaleRange = scale.range();\n  var values = [];\n  rangesValues.forEach(function (range) {\n    if (!rangesOverlap(scaleRange, [range.min, range.max])) {\n      return;\n    }\n\n    var startIdx = domain.indexOf(findClosest(range.min, scale));\n    var endIdx = domain.indexOf(findClosest(range.max, scale));\n    values.push.apply(values, domain.slice(Math.min(startIdx, endIdx), Math.max(startIdx, endIdx) + 1));\n    /* eslint prefer-spread:0 */\n  });\n  return values;\n}\n\nfunction resolveNodeBounds(targetNodes) {\n  var points = targetNodes.reduce(function (ary, node) {\n    ary.push.apply(ary, _toConsumableArray$1(rectToPoints(node.bounds)));\n    return ary;\n  }, []);\n  return pointsToRect(points);\n}\n\nfunction resolveTarget(ctx) {\n  var resolved = {\n    targetRect: null,\n    targetFillRect: null,\n    scale: null,\n    size: null\n  };\n  var stngs = ctx.settings.settings;\n  var targets = stngs.target && (stngs.target.components || (stngs.target.component ? [stngs.target.component] : [])).map(function (c) {\n    return ctx.chart.component(c);\n  }).filter(function (c) {\n    return !!c && !!c.rect;\n  });\n  var targetNodes = stngs.target && stngs.target.selector ? ctx.chart.findShapes(stngs.target.selector) : [];\n  var targetFillNodes = stngs.target && stngs.target.fillSelector ? ctx.chart.findShapes(stngs.target.fillSelector) : [];\n\n  if (targetNodes.length > 0) {\n    var bounds = resolveNodeBounds(targetNodes);\n    resolved.size = bounds[ctx.state.direction === VERTICAL ? 'height' : 'width'];\n    resolved.scale = scaleWithSize(ctx.chart.scale(stngs.scale), resolved.size);\n    resolved.targetRect = bounds;\n\n    if (targetFillNodes.length > 0) {\n      var fillBounds = resolveNodeBounds(targetFillNodes);\n      resolved.targetFillRect = fillBounds;\n    }\n  } else if (targets && targets.length > 0) {\n    var targetRect = targets.slice(1).reduce(function (prev, curr) {\n      return {\n        x0: Math.min(prev.x0, curr.rect.computedInner.x),\n        y0: Math.min(prev.y0, curr.rect.computedInner.y),\n        x1: Math.max(prev.x1, curr.rect.computedInner.x + curr.rect.computedInner.width),\n        y1: Math.max(prev.y1, curr.rect.computedInner.y + curr.rect.computedInner.height)\n      };\n    }, {\n      x0: targets[0].rect.computedInner.x,\n      y0: targets[0].rect.computedInner.y,\n      x1: targets[0].rect.computedInner.x + targets[0].rect.computedInner.width,\n      y1: targets[0].rect.computedInner.y + targets[0].rect.computedInner.height\n    });\n    resolved.targetRect = {\n      x: targetRect.x0 - ctx.state.rect.x,\n      y: targetRect.y0 - ctx.state.rect.y,\n      width: targetRect.x1 - targetRect.x0,\n      height: targetRect.y1 - targetRect.y0\n    };\n  }\n\n  return resolved;\n}\n/**\n * @typedef {object} component--brush-range-settings\n * @property {string|object} brush - Brush context to apply changes to\n * @property {string} scale - Scale to extract data from\n * @property {string} [direction=vertical] - Rendering direction [horizontal|vertical]\n * @property {object} [bubbles]\n * @property {boolean} [bubbles.show=true] - True to show label bubble, false otherwise\n * @property {string} [bubbles.align=start] - Where to anchor bubble [start|end]\n * @property {function} [bubbles.label] - Callback function for the labels\n * @property {object} [target]\n * @property {string} [target.component] - Render matching overlay on target component. @deprecated Use `components` instead\n * @property {string[]} [target.components] - Render matching overlay on target components\n * @property {string} [target.selector] - Instead of targeting a component, target one or more shapes\n * @property {string} [target.fillSelector] - Target a subset of the selector as fill area. Only applicable if `selector` property is set\n */\n\n/**\n * @typedef {object} component--brush-range-style\n * @property {object} [bubble]\n * @property {string} [bubble.fontSize]\n * @property {string} [bubble.fontFamily]\n * @property {string} [bubble.fill]\n * @property {string} [bubble.color]\n * @property {string} [bubble.stroke]\n * @property {number} [bubble.strokeWidth]\n * @property {number} [bubble.borderRadius]\n * @property {object} [line]\n * @property {string} [line.stroke]\n * @property {number} [line.strokeWidth]\n * @property {object} [target]\n * @property {string} [target.fill]\n * @property {number} [target.strokeWidth]\n * @property {number} [target.opacity]\n */\n\n\nvar brushRangeComponent = {\n  require: ['chart', 'settings', 'renderer'],\n  defaultSettings: {\n    settings: {\n      bubbles: {\n        show: true,\n        align: 'start'\n      }\n    },\n    style: {\n      bubble: '$label-overlay',\n      line: '$shape-guide--inverted',\n      target: '$selection-area-target'\n    }\n  },\n  renderer: 'dom',\n  on: {\n    rangeStart: function rangeStart(e) {\n      this.start(e);\n    },\n    rangeMove: function rangeMove(e) {\n      this.move(e);\n    },\n    rangeEnd: function rangeEnd(e) {\n      this.end(e);\n    },\n    rangeClear: function rangeClear(e) {\n      this.clear(e);\n    },\n    bubbleStart: function bubbleStart(e) {\n      this.bubbleStart(e);\n    }\n  },\n  created: function created() {\n    this.state = {\n      key: this.settings.key || 'brush-range'\n    };\n  },\n  beforeRender: function beforeRender(opts) {\n    this.state.rect = opts.size.computedInner;\n  },\n  renderRanges: function renderRanges() {\n    if (!this.state.started) {\n      this.state.ranges = ranges(this.state, this.state.brushInstance);\n      this.state.active = null;\n\n      _render(this.state);\n    }\n  },\n  render: function render(h) {\n    var _this = this;\n\n    var stngs = this.settings.settings;\n    this.state.direction = stngs.direction === 'vertical' ? VERTICAL : HORIZONTAL;\n    var offset = this.renderer.element().getBoundingClientRect();\n    var size = this.state.rect[this.state.direction === VERTICAL ? 'height' : 'width'];\n    var scale = scaleWithSize(this.chart.scale(stngs.scale), size);\n    var target = resolveTarget(this);\n    scale = target.scale ? target.scale : scale;\n    this.state.targetRect = target.targetRect;\n    this.state.targetFillRect = target.targetFillRect;\n    this.state.size = target.size === null ? size : target.size;\n    this.state.settings = stngs;\n    this.state.style = this.style;\n    this.state.offset = offset;\n    this.state.brush = _typeof(stngs.brush) === 'object' ? stngs.brush.context : stngs.brush;\n    this.state.brushInstance = this.chart.brush(this.state.brush);\n    this.state.renderer = this.renderer;\n    this.state.multi = !!stngs.multiple;\n    this.state.h = h;\n\n    this.state.onEditConfirmed = function (rangeIdx, value, otherValue) {\n      _this.state.edit = null;\n      setEditedRanges(_this.state, rangeIdx, value, otherValue);\n\n      _this.emit('bubbleEnd');\n\n      _render(_this.state);\n    };\n\n    this.state.onEditCanceled = function () {\n      _this.state.edit = null;\n\n      _render(_this.state);\n    };\n\n    this.state.cssCoord = {\n      offset: this.state.direction === VERTICAL ? 'top' : 'left',\n      coord: this.state.direction === VERTICAL ? 'y' : 'x',\n      pos: this.state.direction === VERTICAL ? 'deltaY' : 'deltaX'\n    };\n    this.state.format = typeof stngs.bubbles.label === 'function' ? function (v, r) {\n      return stngs.bubbles.label.call(undefined, {\n        datum: v,\n        data: r,\n        scale: scale,\n        resources: {\n          scale: _this.chart.scale,\n          formatter: _this.chart.formatter\n        }\n      });\n    } : false;\n\n    if (!{}.hasOwnProperty.call(scale, 'norm')) {\n      // Non-linear scale if norm method is unavailable\n      this.state.editable = false;\n      this.state.scale = scaleLinear();\n      this.state.scale.data = scale.data;\n\n      if (!this.state.format) {\n        this.state.format = function (v, r) {\n          if (!rangesOverlap(scale.range(), r)) {\n            return '-';\n          }\n\n          return findClosestLabel(v, scale);\n        };\n      }\n\n      this.state.fauxBrushInstance = brush();\n\n      this.state.findValues = function (valueRanges) {\n        return findValues(valueRanges, scale);\n      };\n    } else {\n      this.state.editable = true;\n      this.state.observeBrush = _typeof(stngs.brush) === 'object' ? stngs.brush.observe : false;\n      this.state.fauxBrushInstance = null;\n      this.state.findValues = null;\n      this.state.scale = scale;\n      var scaleData = this.state.scale.data();\n\n      if (!this.state.format && scaleData && scaleData.fields && scaleData.fields[0]) {\n        this.state.format = scaleData.fields[0].formatter();\n      }\n    }\n\n    this.state.ranges = ranges(this.state, this.state.brushInstance);\n    return this.state.observeBrush || this.state.sourcedFromThisComponent ? [nodes(this.state)] : [];\n  },\n  mounted: function mounted() {\n    if (this.state.observeBrush && this.state.brushInstance) {\n      this.state.brushInstance.on('update', this.renderRanges);\n    }\n  },\n  beforeDestroy: function beforeDestroy() {\n    if (this.state.observeBrush && this.state.brushInstance) {\n      this.state.brushInstance.removeListener('update', this.renderRanges);\n    }\n  },\n  start: function start(e) {\n    start$1({\n      e: e,\n      state: this.state,\n      renderer: this.renderer,\n      ranges: ranges,\n      targetSize: TARGET_SIZE\n    });\n  },\n  end: function end$1() {\n    if (!this.state.started) {\n      return;\n    }\n\n    end(this.state, ranges);\n\n    _render(this.state);\n\n    this.state.sourcedFromThisComponent = true;\n    this.state.active = null;\n  },\n  move: function move$1(e) {\n    if (!this.state.started) {\n      return;\n    }\n\n    move(this.state, e);\n\n    setRanges(this.state);\n\n    _render(this.state);\n  },\n  clear: function clear() {\n    if (this.state.fauxBrushInstance) {\n      this.state.fauxBrushInstance.clear();\n    }\n\n    this.state.renderer.render([]);\n    this.state.started = false;\n    this.state.active = null;\n    this.state.sourcedFromThisComponent = false;\n  },\n  bubbleStart: function bubbleStart(e) {\n    if (!this.state.editable) {\n      return;\n    }\n\n    var ee = e.srcEvent || e;\n    var target = ee.target;\n    var ed = {\n      rangeIdx: parseInt(target.getAttribute('data-idx'), 10),\n      bubbleIdx: parseInt(target.getAttribute('data-bidx'), 10)\n    };\n\n    if (isNaN(ed.rangeIdx) || JSON.stringify(ed) === JSON.stringify(this.state.edit)) {\n      return;\n    }\n\n    this.state.edit = ed;\n    ee.stopPropagation();\n    ee.stopImmediatePropagation();\n    ee.preventDefault();\n    var wrapper = target.parentNode;\n\n    _render(this.state);\n\n    var inputEl = wrapper.querySelector('input');\n    inputEl.focus();\n    inputEl.select();\n  }\n};\n\nfunction render(state) {\n  state.renderer.render(nodes(state));\n}\n\nfunction ranges$1(state) {\n  return state.rc.ranges();\n}\n\nfunction shapesFromRange(state, brushRange) {\n  var shapeAt = {\n    x: state.direction ? brushRange.min + state.rect.x : state.rect.x,\n    y: state.direction ? state.rect.y : brushRange.min + state.rect.y,\n    width: state.direction ? brushRange.max - brushRange.min : state.rect.width + state.rect.x,\n    height: state.direction ? state.rect.height + state.rect.y : brushRange.max - brushRange.min\n  };\n  return state.chart.shapesAt(shapeAt, state.settings.brush);\n}\n\nfunction brushFromShape(state, newShapes) {\n  state.chart.brushFromShapes(newShapes, state.settings.brush);\n}\n\nfunction setRanges$1(state) {\n  var rs = state.ranges.map(function (r) {\n    return {\n      min: r.min,\n      max: r.max\n    };\n  });\n\n  if (state.active.idx !== -1) {\n    if (state.active.mode === 'modify') {\n      rs[state.active.idx].min = Math.min(state.start, state.current);\n      rs[state.active.idx].max = Math.max(state.start, state.current);\n    } else {\n      var delta = getMoveDelta(state);\n      rs[state.active.idx].min = state.active.start + delta;\n      rs[state.active.idx].max = state.active.end + delta;\n    }\n  } else {\n    rs.push({\n      min: Math.min(state.start, state.current),\n      max: Math.max(state.start, state.current)\n    });\n  }\n\n  state.rc.set(rs);\n  var shapes = [];\n  rs.forEach(function (range) {\n    shapes.push.apply(shapes, _toConsumableArray$1(shapesFromRange(state, range)));\n  });\n  brushFromShape(state, shapes);\n}\n\nfunction getBubbleLabel(state, value, range) {\n  var min = Math.min.apply(Math, _toConsumableArray$1(range));\n  var max = Math.max.apply(Math, _toConsumableArray$1(range));\n  var shapeAt = {\n    x: state.direction ? min + state.rect.x : state.rect.x,\n    y: state.direction ? state.rect.y : min + state.rect.y,\n    width: state.direction ? max - min : state.rect.width + state.rect.x,\n    height: state.direction ? state.rect.height + state.rect.y : max - min\n  };\n  var shapes = state.chart.shapesAt(shapeAt, state.settings.brush);\n\n  if (shapes.length === 0) {\n    return '-';\n  }\n\n  var labelShape = shapes.reduce(function (s0, s1) {\n    // Min value\n    var bounds0 = s0.bounds;\n    var bounds1 = s1.bounds;\n\n    if (value === min) {\n      if (bounds0[state.cssCoord.coord] <= bounds1[state.cssCoord.coord]) {\n        return s0;\n      }\n\n      return s1;\n    } // Max value\n\n\n    if (bounds0[state.cssCoord.coord] + bounds0[state.cssCoord.area] >= bounds1[state.cssCoord.coord] + bounds1[state.cssCoord.area]) {\n      return s0;\n    }\n\n    return s1;\n  });\n  var compConfig = state.settings.brush.components.reduce(function (c0, c1) {\n    return c0.key === labelShape.key ? c0 : c1;\n  });\n\n  if (typeof state.settings.bubbles.label === 'function') {\n    return state.settings.bubbles.label(labelShape.data);\n  }\n\n  if (Array.isArray(compConfig.data) && compConfig.data.length) {\n    return labelShape.data[compConfig.data[0]].label;\n  }\n\n  return labelShape.data && labelShape.data.label ? labelShape.data.label : '-';\n}\n/**\n * @typedef {object} component--brush-area-dir-settings\n * @property {object} brush\n * @property {array} brush.components\n * @property {object} brush.components[].key - Component key\n * @property {object} brush.components[].contexts[] - Brush context to apply changes to\n * @property {object} [brush.components[].data] - Data reference\n * @property {object} [brush.components[].action] - Type of brush action\n * @property {string} [direction=vertical] - Rendering direction [horizontal|vertical]\n * @property {object} [bubbles]\n * @property {boolean} [bubbles.show=true] - True to show label bubble, false otherwise\n * @property {string} [bubbles.align=start] - Where to anchor bubble [start|end]\n * @property {function} [bubbles.label] - Callback function for the labels\n * @property {object} [target]\n * @property {string} [target.component] - Render matching overlay on target component. @deprecated Use `components` instead\n * @property {string[]} [target.components] - Render matching overlay on target components\n */\n\n/**\n * @typedef {object} component--brush-area-dir-style\n * @property {object} [bubble]\n * @property {string} [bubble.fontSize]\n * @property {string} [bubble.fontFamily]\n * @property {string} [bubble.fill]\n * @property {string} [bubble.color]\n * @property {string} [bubble.stroke]\n * @property {number} [bubble.strokeWidth]\n * @property {number} [bubble.borderRadius]\n * @property {object} [line]\n * @property {string} [line.stroke]\n * @property {number} [line.strokeWidth]\n * @property {object} [target]\n * @property {string} [target.fill]\n * @property {number} [target.strokeWidth]\n * @property {number} [target.opacity]\n */\n\n\nvar brushAreaDirectionalComponent = {\n  require: ['chart', 'settings', 'renderer'],\n  defaultSettings: {\n    settings: {\n      bubbles: {\n        show: true,\n        align: 'start'\n      }\n    },\n    style: {\n      bubble: '$label-overlay',\n      line: '$shape-guide--inverted',\n      target: '$selection-area-target'\n    }\n  },\n  renderer: 'dom',\n  on: {\n    areaStart: function areaStart(e) {\n      this.start(e);\n    },\n    areaMove: function areaMove(e) {\n      this.move(e);\n    },\n    areaEnd: function areaEnd(e) {\n      this.end(e);\n    },\n    areaClear: function areaClear(e) {\n      this.clear(e);\n    }\n  },\n  created: function created() {\n    this.state = {\n      key: this.settings.key || 'brush-area-dir'\n    };\n  },\n  render: function render(h) {\n    var _this = this;\n\n    this.state.rect = this.rect;\n    var stngs = this.settings.settings;\n    var direction = stngs.direction === 'vertical' ? VERTICAL : HORIZONTAL;\n    var size = this.state.rect[direction === VERTICAL ? 'height' : 'width'];\n    var offset = this.renderer.element().getBoundingClientRect();\n    var targets = (stngs.target ? stngs.target.components || [stngs.target.component] : []).map(function (c) {\n      return _this.chart.component(c);\n    }).filter(function (c) {\n      return !!c && !!c.rect;\n    });\n    var targetRect = targets[0] ? targets.slice(1).reduce(function (prev, curr) {\n      return {\n        x0: Math.min(prev.x0, curr.rect.x),\n        y0: Math.min(prev.y0, curr.rect.y),\n        x1: Math.max(prev.x1, curr.rect.x + curr.rect.width),\n        y1: Math.max(prev.y1, curr.rect.y + curr.rect.height)\n      };\n    }, {\n      x0: targets[0].rect.x,\n      y0: targets[0].rect.y,\n      x1: targets[0].rect.x + targets[0].rect.width,\n      y1: targets[0].rect.y + targets[0].rect.height\n    }) : null;\n    this.state.targetRect = targetRect ? {\n      x: targetRect.x0 - this.rect.x,\n      y: targetRect.y0 - this.rect.y,\n      width: targetRect.x1 - targetRect.x0,\n      height: targetRect.y1 - targetRect.y0\n    } : null;\n    this.state.style = this.style;\n    this.state.chart = this.chart;\n    this.state.direction = direction;\n    this.state.settings = stngs;\n    this.state.offset = offset;\n    this.state.rc = rangeCollection();\n    this.state.renderer = this.renderer;\n    this.state.multi = !!stngs.multiple;\n    this.state.h = h;\n    this.state.size = size;\n    this.state.cssCoord = {\n      offset: this.state.direction === VERTICAL ? 'top' : 'left',\n      coord: this.state.direction === VERTICAL ? 'y' : 'x',\n      pos: this.state.direction === VERTICAL ? 'deltaY' : 'deltaX',\n      area: this.state.direction === VERTICAL ? 'height' : 'width'\n    };\n\n    this.state.format = function getFormat(v, r) {\n      return getBubbleLabel(this, v, r);\n    };\n\n    return [];\n  },\n  start: function start(e) {\n    startArea({\n      e: e,\n      state: this.state,\n      renderer: this.renderer,\n      ranges: ranges$1,\n      targetSize: TARGET_SIZE\n    });\n  },\n  end: function end() {\n    if (!this.state.started) {\n      return;\n    }\n\n    endArea(this.state, ranges$1);\n    render(this.state);\n  },\n  move: function move(e) {\n    if (!this.state.started) {\n      return;\n    }\n\n    moveArea(this.state, e);\n    setRanges$1(this.state);\n    render(this.state);\n  },\n  clear: function clear() {\n    if (this.state.rc) {\n      this.state.rc.clear();\n    }\n\n    this.state.renderer.render([]);\n  }\n};\n\nfunction rangeBrush(picasso) {\n  picasso.component('brush-range', brushRangeComponent);\n  picasso.component('brush-area-dir', brushAreaDirectionalComponent);\n}\n\nvar FILL = '#ccc';\nvar OPACITY = 1;\n\nfunction ranges$2(state) {\n  var brush = state.brush;\n\n  if (!brush || !brush.isActive()) {\n    return [];\n  }\n\n  var sourceData = state.scale.data();\n  var sourceFields = sourceData ? sourceData.fields || [] : [];\n  var sources = sourceFields.map(function (field) {\n    return field.id();\n  });\n  var rangeBrush = brush.brushes().filter(function (f) {\n    return f.type === 'range' && sources.indexOf(f.id) !== -1;\n  })[0];\n\n  if (!rangeBrush) {\n    return [];\n  }\n\n  return rangeBrush.brush.ranges();\n}\n\nfunction shapes(state) {\n  var isVertical = state.direction === 'vertical';\n  var size = state.rect[isVertical ? 'height' : 'width'];\n  var otherSize = state.rect[isVertical ? 'width' : 'height'];\n  return ranges$2(state).map(function (range) {\n    var start = state.scale(range.min) * size;\n    var end = state.scale(range.max) * size;\n    var low = Math.min(start, end);\n    var s = Math.abs(start - end);\n    return {\n      type: 'rect',\n      fill: state.fill,\n      opacity: state.opacity,\n      x: isVertical ? 0 : low,\n      width: isVertical ? otherSize : s,\n      y: isVertical ? low : 0,\n      height: isVertical ? s : otherSize\n    };\n  });\n}\n\nfunction onStart(state) {\n  state.renderer.render(shapes(state));\n}\n\nfunction onUpdate(state) {\n  state.renderer.render(shapes(state));\n}\n\nfunction onEnd(state) {\n  state.renderer.render(shapes(state));\n}\n\nfunction setup(state, brush, scale, renderer) {\n  state.brush = brush;\n\n  if (!brush) {\n    return;\n  }\n\n  function start() {\n    onStart(state);\n  }\n\n  function update() {\n    onUpdate(state);\n  }\n\n  function end() {\n    onEnd(state);\n  }\n\n  brush.on('start', start);\n  brush.on('update', update);\n  brush.on('end', end);\n  state.start = start;\n  state.update = update;\n  state.end = end;\n  state.brush = brush;\n  state.scale = scale;\n  state.renderer = renderer;\n}\n\nfunction teardown(state) {\n  if (state.brush) {\n    state.brush.removeListener('start', state.start);\n    state.brush.removeListener('update', state.update);\n    state.brush.removeListener('end', state.end);\n  }\n\n  state.start = undefined;\n  state.update = undefined;\n  state.end = undefined;\n  state.brush = undefined;\n  state.scale = undefined;\n  state.renderer = undefined;\n}\n/**\n * @typedef {object} component--range\n */\n\n/**\n * @typedef {object} component--range.settings\n * @property {string} brush - Name of brush instance\n * @property {string} scale - Name of a scale\n * @property {string} [direction='horizontal'] - Direction of the brush\n * @property {string} [fill='#ccc'] - Fill color\n * @property {number} [opacity=1] - Layer opacity\n */\n\n\nvar rangeComponent = {\n  require: ['chart', 'settings', 'renderer'],\n  defaultSettings: {\n    settings: {}\n  },\n  preferredSize: function preferredSize() {\n    return 50;\n  },\n  created: function created() {\n    this.state = {};\n  },\n  render: function render() {\n    var stngs = this.settings.settings;\n    var brush = this.chart.brush(stngs.brush);\n    var direction = stngs.direction || 'horizontal';\n    var distance = direction === 'horizontal' ? this.rect.width : this.rect.height;\n    var scale = scaleWithSize(this.chart.scale(stngs.scale), distance);\n    teardown(this.state);\n    setup(this.state, brush, scale, this.renderer);\n    this.state.rect = this.rect;\n    this.state.fill = stngs.fill || FILL;\n    this.state.opacity = typeof stngs.opacity !== 'undefined' ? stngs.opacity : OPACITY;\n    this.state.direction = direction;\n    return shapes(this.state);\n  },\n  beforeDestroy: function beforeDestroy() {\n    teardown(this.state);\n  }\n};\n\nfunction rangeBrush$1(picasso) {\n  picasso.component('range', rangeComponent);\n}\n\nfunction getPoint(rendererBounds, event) {\n  var eventOffsetX = event.center.x;\n  var eventOffsetY = event.center.y;\n  return {\n    x: eventOffsetX - rendererBounds.left,\n    y: eventOffsetY - rendererBounds.top\n  }; // return {\n  //   x: Math.min(Math.max(eventOffsetX - rendererBounds.left, 0), rendererBounds.width),\n  //   y: Math.min(Math.max(eventOffsetY - rendererBounds.top, 0), rendererBounds.height)\n  // };\n}\n\nfunction withinThreshold(p, state, settings) {\n  var startPoint = state.points[0];\n  var sqrDist = sqrDistance(p, startPoint);\n  return sqrDist < Math.pow(settings.settings.snapIndicator.threshold, 2);\n}\n\nfunction appendToPath(state, p) {\n  if (state.path.d == null) {\n    state.path.d = \"M\".concat(p.x, \" \").concat(p.y, \" \");\n  } else {\n    state.path.d += \"L\".concat(p.x, \" \").concat(p.y, \" \");\n  }\n\n  state.points.push(p);\n}\n\nfunction render$1(state, renderer) {\n  var nodes = [state.startPoint, state.path, state.snapIndicator].filter(function (node) {\n    return node.visible;\n  });\n  renderer.render(nodes);\n}\n\nfunction setSnapIndictor(_ref) {\n  var state = _ref.state,\n      _ref$start = _ref.start,\n      start = _ref$start === void 0 ? null : _ref$start,\n      _ref$end = _ref.end,\n      end = _ref$end === void 0 ? null : _ref$end;\n\n  if (start !== null) {\n    state.snapIndicator.x1 = start.x;\n    state.snapIndicator.y1 = start.y;\n  }\n\n  if (end !== null) {\n    state.snapIndicator.x2 = end.x;\n    state.snapIndicator.y2 = end.y;\n  }\n}\n\nfunction showSnapIndicator(state, show) {\n  state.snapIndicator.visible = show;\n}\n\nfunction setStartPoint(state, p) {\n  state.startPoint.cx = p.x;\n  state.startPoint.cy = p.y;\n}\n\nfunction getComponentDelta(chart, rendererBounds) {\n  var chartBounds = chart.element.getBoundingClientRect();\n  return {\n    x: rendererBounds.left - chartBounds.left,\n    y: rendererBounds.top - chartBounds.top\n  };\n}\n\nfunction doLineBrush(state, chart) {\n  if (state.active) {\n    var p1 = state.points[state.points.length - 2];\n    var p2 = state.points[state.points.length - 1];\n    state.lineBrushShape.x1 = p1.x + state.componentDelta.x;\n    state.lineBrushShape.y1 = p1.y + state.componentDelta.y;\n    state.lineBrushShape.x2 = p2.x + state.componentDelta.x;\n    state.lineBrushShape.y2 = p2.y + state.componentDelta.y;\n    var shapes = chart.shapesAt(state.lineBrushShape, {\n      components: state.brushConfig\n    });\n    chart.brushFromShapes(shapes, {\n      components: state.brushConfig\n    });\n  }\n}\n\nfunction doPolygonBrush(state, chart) {\n  if (state.active) {\n    var dx = state.componentDelta.x;\n    var dy = state.componentDelta.y;\n    var vertices = state.points.map(function (p) {\n      return {\n        x: p.x + dx,\n        y: p.y + dy\n      };\n    });\n    var shapes = chart.shapesAt({\n      vertices: vertices\n    }, {\n      components: state.brushConfig\n    });\n    chart.brushFromShapes(shapes, {\n      components: state.brushConfig\n    });\n  }\n}\n\nfunction initPath(stgns) {\n  return {\n    visible: true,\n    type: 'path',\n    d: null,\n    fill: stgns.fill,\n    stroke: stgns.stroke,\n    strokeWidth: stgns.strokeWidth,\n    opacity: stgns.opacity,\n    strokeDasharray: stgns.strokeDasharray,\n    collider: {\n      type: null\n    }\n  };\n}\n\nfunction initSnapIndicator(stgns) {\n  return {\n    visible: false,\n    type: 'line',\n    x1: 0,\n    y1: 0,\n    x2: 0,\n    y2: 0,\n    strokeDasharray: stgns.strokeDasharray,\n    stroke: stgns.stroke,\n    strokeWidth: stgns.strokeWidth,\n    opacity: stgns.opacity,\n    collider: {\n      type: null\n    }\n  };\n}\n\nfunction initStartPoint(stgns) {\n  return {\n    visible: true,\n    type: 'circle',\n    cx: 0,\n    cy: 0,\n    r: stgns.r,\n    fill: stgns.fill,\n    opacity: stgns.opacity,\n    stroke: stgns.stroke,\n    strokeWidth: stgns.strokeWidth,\n    collider: {\n      type: null\n    }\n  };\n}\n\nfunction getBrushConfig(settings) {\n  return settings.settings.brush.components.map(function (b) {\n    return {\n      key: b.key,\n      contexts: b.contexts || ['lassoBrush'],\n      data: b.data || [''],\n      action: b.action || 'add'\n    };\n  });\n}\n\nfunction endBrush(state, chart) {\n  state.brushConfig.forEach(function (config) {\n    config.contexts.forEach(function (context) {\n      chart.brush(context).end();\n    });\n  });\n}\n\nfunction resetState() {\n  return {\n    points: [],\n    active: false,\n    path: null,\n    snapIndicator: null,\n    startPoint: null,\n    rendererBounds: null,\n    componentDelta: null,\n    brushConfig: null,\n    lineBrushShape: {\n      x1: 0,\n      y1: 0,\n      x2: 0,\n      y2: 0\n    } // Keep a single shape instance to avoid instantiating a new object on each lookup\n\n  };\n}\n/**\n * @typedef {object} component--brush-lasso\n */\n\n/**\n * @typedef {object} component--brush-lasso-settings\n * @property {object} [lasso] - Lasso style settings\n * @property {string} [lasso.fill='transparent']\n * @property {string} [lasso.stroke='black']\n * @property {number} [lasso.strokeWidth=2]\n * @property {number} [lasso.opacity=0.7]\n * @property {number} [lasso.strokeDasharray]\n * @property {object} [snapIndicator] - Snap indicator settings\n * @property {number} [snapIndicator.threshold=75] - The distance in pixel to show the snap indicator, if less then threshold the indicator is dispalyed\n * @property {string} [snapIndicator.strokeDasharray='5, 5']\n * @property {string} [snapIndicator.stroke='black']\n * @property {number} [snapIndicator.strokeWidth=2]\n * @property {number} [snapIndicator.opacity=0.5]\n * @property {object} [startPoint] - Start point style settings\n * @property {number} [startPoint.r=10] - Circle radius\n * @property {string} [startPoint.stroke='green']\n * @property {number} [startPoint.strokeWidth=1]\n * @property {number} [startPoint.opacity=1]\n * @property {object} [brush]\n * @property {object[]} brush.components - Array of components to brush on.\n * @property {string} [brush.components[].component.key] - Component key\n * @property {string[]} [brush.components[].component.contexts=['brushLasso']] - Name of the brushing contexts to affect\n * @property {string[]} [brush.components[].component.data=['']] - The mapped data properties to add to the brush\n * @property {string} [brush.components[].component.action='add'] - Type of action to respond with\n */\n\n\nvar brushLassoComponent = {\n  require: ['chart', 'renderer', 'settings'],\n  defaultSettings: {\n    layout: {\n      displayOrder: 0\n    },\n    settings: {\n      brush: {\n        components: []\n      },\n      snapIndicator: {\n        threshold: 75,\n        strokeDasharray: '5, 5',\n        stroke: 'black',\n        strokeWidth: 2,\n        opacity: 0.5\n      },\n      lasso: {\n        fill: 'transparent',\n        stroke: 'black',\n        strokeWidth: 2,\n        opacity: 0.7,\n        strokeDasharray: '20, 10'\n      },\n      startPoint: {\n        r: 10,\n        fill: 'green',\n        stroke: 'black',\n        strokeWidth: 1,\n        opacity: 1\n      }\n    }\n  },\n  on: {\n    lassoStart: function lassoStart(e) {\n      this.start(e);\n    },\n    lassoEnd: function lassoEnd(e) {\n      this.end(e);\n    },\n    lassoMove: function lassoMove(e) {\n      this.move(e);\n    },\n    lassoCancel: function lassoCancel() {\n      this.cancel();\n    }\n  },\n  created: function created() {\n    this.state = resetState();\n  },\n  start: function start(e) {\n    this.state.active = true;\n    this.state.path = initPath(this.settings.settings.lasso);\n    this.state.snapIndicator = initSnapIndicator(this.settings.settings.snapIndicator);\n    this.state.startPoint = initStartPoint(this.settings.settings.startPoint);\n    this.state.rendererBounds = this.renderer.element().getBoundingClientRect();\n    this.state.componentDelta = getComponentDelta(this.chart, this.state.rendererBounds);\n    this.state.brushConfig = getBrushConfig(this.settings);\n    var p = getPoint(this.state.rendererBounds, e);\n    appendToPath(this.state, p);\n    setSnapIndictor({\n      state: this.state,\n      start: p\n    });\n    setStartPoint(this.state, p);\n  },\n  move: function move(e) {\n    if (!this.state.active) {\n      return;\n    }\n\n    var p = getPoint(this.state.rendererBounds, e);\n\n    if (withinThreshold(p, this.state, this.settings)) {\n      showSnapIndicator(this.state, true);\n    } else {\n      showSnapIndicator(this.state, false);\n    }\n\n    appendToPath(this.state, p);\n    setSnapIndictor({\n      state: this.state,\n      end: p\n    });\n    render$1(this.state, this.renderer);\n    doLineBrush(this.state, this.chart);\n  },\n  end: function end(e) {\n    if (!this.state.active) {\n      return;\n    }\n\n    showSnapIndicator(this.state, false);\n    var p = getPoint(this.state.rendererBounds, e);\n    var shouldSnap = withinThreshold(p, this.state, this.settings);\n\n    if (shouldSnap) {\n      doPolygonBrush(this.state, this.chart);\n    }\n\n    this.state = resetState();\n    this.renderer.render([]);\n  },\n  cancel: function cancel() {\n    if (!this.state.active) {\n      return;\n    }\n\n    endBrush(this.state, this.chart);\n    this.state = resetState();\n    this.renderer.render([]);\n  },\n  render: function render() {// Do nothing\n  }\n};\n\nfunction lassoBrush(picasso) {\n  picasso.component('brush-lasso', brushLassoComponent);\n}\n\n/**\n * Using the basic example found here: https://en.wikipedia.org/wiki/Binary_search_algorithm\n *\n * Finds the first node that may intersect the label.\n * @private\n */\n\nfunction binaryLeftSearch(labelBounds, ary, coord, side, extractBounds) {\n  var left = 0;\n  var right = ary.length - 1;\n  var bounds;\n\n  while (left < right) {\n    var m = Math.floor((left + right) / 2);\n    bounds = extractBounds(ary[m]);\n\n    if (bounds[coord] + bounds[side] < labelBounds[coord]) {\n      // label is on right side\n      left = m + 1;\n    } else {\n      // label is on the left side\n      right = m;\n    }\n  }\n\n  return left;\n}\n/**\n * The purpose of this module is to act as a filtering function to remove any labels\n * that meets one of the following criterias:\n * -- The label is not fully inside the container, such that it would be fully or partially clipped if rendered\n * -- The label overlaps another label\n * -- The label overlaps another bar which is not the bar the label is originating from\n *\n * Assumes that the nodes are sorted from left/top to right/down, as that allows\n * some optimizations to be performed.\n * @private\n * @returns {function} Filter function, returns false if label be removed and true otherwise\n */\n\nfunction filterOverlappingLabels$1(_ref) {\n  var orientation = _ref.orientation,\n      targetNodes = _ref.targetNodes,\n      labels = _ref.labels,\n      container = _ref.container;\n  var findLeft = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : binaryLeftSearch;\n  var renderLabels = [];\n  var coord = orientation === 'v' ? 'x' : 'y';\n  var side = orientation === 'v' ? 'width' : 'height';\n\n  var getTextBounds = function getTextBounds(item) {\n    return item.textBounds;\n  };\n\n  var getNodeBounds = function getNodeBounds(item) {\n    return item.node.localBounds;\n  };\n\n  return function (doNotUse, labelIndex) {\n    var _labels$labelIndex = labels[labelIndex],\n        labelBounds = _labels$labelIndex.textBounds,\n        labelNode = _labels$labelIndex.node; // ### Test if label is not fully inside container based on the orientation ###\n\n    if (labelBounds[coord] < container[coord] || labelBounds[coord] + labelBounds[side] > container[coord] + container[side]) {\n      return false;\n    } // ### Test label to label collision ###\n\n\n    var leftStartLabel = findLeft(labelBounds, renderLabels, coord, side, getTextBounds);\n\n    for (var i = leftStartLabel; i < renderLabels.length; i++) {\n      if (testRectRect(labelBounds, renderLabels[i].textBounds)) {\n        return false;\n      }\n    } // ### Test label to node collision ###\n\n\n    var leftStartNode = findLeft(labelBounds, targetNodes, coord, side, getNodeBounds);\n    var labelRightBoundary = labelBounds[coord] + labelBounds[side];\n\n    for (var _i = leftStartNode; _i < targetNodes.length; _i++) {\n      var node = targetNodes[_i].node; // Do not test beyond this node, as they are assumed to not collide with the label\n\n      if (labelRightBoundary < node.localBounds[coord]) {\n        break;\n      }\n\n      if (testRectRect(labelBounds, node.localBounds) && labelNode !== node) {\n        return false;\n      }\n    } // No collision occured, allow the label to be rendered\n\n\n    renderLabels.push(labels[labelIndex]);\n    return true;\n  };\n}\n\nvar PADDING$1 = 4; // const DOUBLE_PADDING = PADDING * 2;\n\nfunction cbContext(node, chart) {\n  return {\n    node: node,\n    data: node.data,\n    scale: chart.scale,\n    formatter: chart.formatter,\n    dataset: chart.dataset\n  };\n}\n\nfunction isValidText(text) {\n  var type = _typeof(text);\n\n  return (type === 'string' || type === 'number') && text !== '';\n}\n\nfunction toBackground(label) {\n  return _objectSpread2({\n    type: 'rect',\n    rx: 2,\n    ry: 2,\n    fill: label.backgroundColor\n  }, label.backgroundBounds);\n}\n\nfunction isTextInRect(rect, textMetrics, opts) {\n  return opts.rotate ? !(rect.width < textMetrics.height || rect.height < textMetrics.width) : !(rect.width < textMetrics.width || rect.height < textMetrics.height);\n}\nfunction placeSegmentInSegment(majorSegmentPosition, majorSegmentSize, minorSegmentSize, align) {\n  var majorSegmentCenter = majorSegmentPosition + majorSegmentSize * 0.5;\n  var offset = (align - 0.5) * (majorSegmentSize - minorSegmentSize);\n  var minorSegmentCenter = majorSegmentCenter + offset;\n  var minorSegmentPosition = minorSegmentCenter - minorSegmentSize * 0.5;\n  return minorSegmentPosition;\n}\nfunction placeTextInRect(rect, text, opts) {\n  var label = {\n    type: 'text',\n    text: text,\n    maxWidth: opts.rotate ? rect.height : rect.width,\n    x: 0,\n    y: rect.y,\n    dx: 0,\n    dy: 0,\n    fill: opts.fill,\n    anchor: opts.rotate ? 'end' : 'start',\n    baseline: 'central',\n    fontSize: \"\".concat(opts.fontSize, \"px\"),\n    fontFamily: opts.fontFamily\n  };\n  var textMetrics = opts.textMetrics;\n\n  if (!opts.overflow && !isTextInRect(rect, textMetrics, opts)) {\n    return false;\n  }\n\n  var baseLineOffset = textMetrics.height * 0.5;\n\n  if (opts.rotate) {\n    label.x = placeSegmentInSegment(rect.x, rect.width, textMetrics.height, opts.align) + baseLineOffset;\n    label.y = placeSegmentInSegment(rect.y, rect.height, textMetrics.width, opts.justify);\n    label.transform = \"rotate(-90, \".concat(label.x + label.dx, \", \").concat(label.y + label.dy, \")\");\n  } else {\n    label.x = placeSegmentInSegment(rect.x, rect.width, textMetrics.width, opts.align);\n    label.y = placeSegmentInSegment(rect.y, rect.height, textMetrics.height, opts.justify) + baseLineOffset;\n  }\n\n  return label;\n}\n\nfunction limitBounds(bounds, view) {\n  var minY = Math.max(0, Math.min(bounds.y, view.height));\n  var maxY = Math.max(0, Math.min(bounds.y + bounds.height, view.height));\n  var minX = Math.max(0, Math.min(bounds.x, view.width));\n  var maxX = Math.max(0, Math.min(bounds.x + bounds.width, view.width));\n  bounds.x = minX;\n  bounds.width = maxX - minX;\n  bounds.y = minY;\n  bounds.height = maxY - minY;\n}\n\nfunction pad$1(bounds) {\n  var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _padding$top = padding.top,\n      top = _padding$top === void 0 ? PADDING$1 : _padding$top,\n      _padding$bottom = padding.bottom,\n      bottom = _padding$bottom === void 0 ? PADDING$1 : _padding$bottom,\n      _padding$left = padding.left,\n      left = _padding$left === void 0 ? PADDING$1 : _padding$left,\n      _padding$right = padding.right,\n      right = _padding$right === void 0 ? PADDING$1 : _padding$right;\n  bounds.x += left;\n  bounds.width -= left + right;\n  bounds.y += top;\n  bounds.height -= top + bottom;\n}\n\nfunction getBarRect(_ref) {\n  var bar = _ref.bar,\n      view = _ref.view,\n      direction = _ref.direction,\n      position = _ref.position,\n      _ref$padding = _ref.padding,\n      padding = _ref$padding === void 0 ? PADDING$1 : _ref$padding;\n  var bounds = {};\n  extend(bounds, bar);\n\n  if (!position || position === 'inside') ; else if (direction === 'up' || direction === 'down') {\n    var start = Math.max(0, Math.min(bar.y, view.height));\n    var end = Math.max(0, Math.min(bar.y + bar.height, view.height));\n\n    if (position === 'outside' && direction === 'up' || position === 'opposite' && direction === 'down') {\n      bounds.y = 0;\n      bounds.height = start;\n    } else if (position === 'outside' && direction === 'down' || position === 'opposite' && direction === 'up') {\n      bounds.y = end;\n      bounds.height = view.height - end;\n    }\n  } else {\n    var _start = Math.max(0, Math.min(bar.x, view.width));\n\n    var _end = Math.max(0, Math.min(bar.x + bar.width, view.width));\n\n    if (position === 'outside' && direction === 'left' || position === 'opposite' && direction === 'right') {\n      bounds.x = 0;\n      bounds.width = _start;\n    } else if (position === 'outside' && direction === 'right' || position === 'opposite' && direction === 'left') {\n      bounds.x = _end;\n      bounds.width = view.width - _end;\n    }\n  }\n\n  limitBounds(bounds, view);\n  pad$1(bounds, padding);\n  return bounds;\n}\nfunction findBestPlacement(_ref2) {\n  var direction = _ref2.direction,\n      fitsHorizontally = _ref2.fitsHorizontally,\n      measured = _ref2.measured,\n      node = _ref2.node,\n      orientation = _ref2.orientation,\n      placementSettings = _ref2.placementSettings,\n      rect = _ref2.rect;\n  var barRect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getBarRect;\n  var largest;\n  var bounds;\n  var placement;\n  var testBounds;\n  var p;\n  var boundaries = [];\n\n  for (p = 0; p < placementSettings.length; p++) {\n    placement = placementSettings[p];\n    testBounds = barRect({\n      bar: node.localBounds,\n      view: rect,\n      direction: direction,\n      position: placement.position,\n      padding: placement.padding\n    });\n    boundaries.push(testBounds);\n    largest = !p || testBounds.height > largest.height ? testBounds : largest;\n\n    if (orientation === 'v' && (fitsHorizontally && testBounds.height >= measured.height || !fitsHorizontally && testBounds.height >= measured.width && testBounds.width >= measured.height)) {\n      bounds = testBounds;\n      break;\n    } else if (orientation === 'h' && testBounds.height >= measured.height && testBounds.width >= measured.width) {\n      bounds = testBounds;\n      break;\n    }\n  } // fallback strategy - place the text in the largest rectangle\n\n\n  if (!bounds) {\n    bounds = largest;\n    p = boundaries.indexOf(bounds);\n  }\n\n  placement = placementSettings[p];\n  return {\n    bounds: bounds,\n    placement: placement\n  };\n}\n\nfunction approxTextBounds(label, textMetrics, rotated, rect) {\n  var padding = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  var _padding$top2 = padding.top,\n      top = _padding$top2 === void 0 ? PADDING$1 : _padding$top2,\n      _padding$bottom2 = padding.bottom,\n      bottom = _padding$bottom2 === void 0 ? PADDING$1 : _padding$bottom2,\n      _padding$left2 = padding.left,\n      left = _padding$left2 === void 0 ? PADDING$1 : _padding$left2,\n      _padding$right2 = padding.right,\n      right = _padding$right2 === void 0 ? PADDING$1 : _padding$right2;\n  var x0 = label.x + label.dx;\n  var y0 = label.y + label.dy;\n  var height = rotated ? Math.min(textMetrics.width, rect.height) : Math.min(textMetrics.height, rect.width);\n  var width = rotated ? Math.min(textMetrics.height, rect.height) : Math.min(textMetrics.width, rect.width);\n  var offset = textMetrics.height * 0.5;\n  var PADDING_OFFSET = 1e-9; // Needed to support a case when multiple bars are on the same location\n\n  var x = rotated ? x0 - offset : x0;\n  var y = rotated ? y0 : y0 - offset;\n  var bounds = {\n    x: x - left - PADDING_OFFSET,\n    y: y - top - PADDING_OFFSET,\n    width: width + (left + right) - PADDING_OFFSET,\n    height: height + (top + bottom) - PADDING_OFFSET\n  };\n  return bounds;\n}\n\nfunction placeInBars(_ref3) {\n  var chart = _ref3.chart,\n      targetNodes = _ref3.targetNodes,\n      rect = _ref3.rect,\n      fitsHorizontally = _ref3.fitsHorizontally,\n      collectiveOrientation = _ref3.collectiveOrientation;\n  var findPlacement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : findBestPlacement;\n  var placer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : placeTextInRect;\n  var postFilter = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : filterOverlappingLabels$1;\n  var labels = [];\n  var postFilterContext = {\n    container: rect,\n    targetNodes: targetNodes,\n    labels: [],\n    orientation: collectiveOrientation\n  };\n  var label;\n  var target;\n  var node;\n  var text;\n  var justify;\n  var bounds;\n  var fill;\n  var measured;\n  var direction;\n  var lblStngs;\n  var placement;\n  var placements;\n  var arg;\n  var orientation;\n\n  for (var i = 0, len = targetNodes.length; i < len; i++) {\n    bounds = null;\n    target = targetNodes[i];\n    node = target.node;\n    arg = cbContext(node, chart);\n    direction = target.direction;\n    orientation = direction === 'left' || direction === 'right' ? 'h' : 'v';\n\n    for (var j = 0; j < target.texts.length; j++) {\n      text = target.texts[j];\n\n      if (!isValidText(text)) {\n        continue;\n      }\n\n      lblStngs = target.labelSettings[j];\n      measured = target.measurements[j];\n      placements = lblStngs.placements;\n      var bestPlacement = findPlacement({\n        direction: direction,\n        fitsHorizontally: fitsHorizontally,\n        lblStngs: lblStngs,\n        measured: measured,\n        node: node,\n        orientation: orientation,\n        placements: placements,\n        placementSettings: target.placementSettings[j],\n        rect: rect\n      });\n      bounds = bestPlacement.bounds;\n      placement = bestPlacement.placement;\n\n      if (bounds && placement) {\n        justify = placement.justify;\n        fill = typeof placement.fill === 'function' ? placement.fill(arg, i) : placement.fill;\n        var linkData = typeof lblStngs.linkData === 'function' ? lblStngs.linkData(arg, i) : undefined;\n        var overflow = typeof placement.overflow === 'function' ? placement.overflow(arg, i) : placement.overflow;\n\n        if (direction === 'up') {\n          justify = 1 - justify;\n        }\n\n        if (placement.position === 'opposite') {\n          justify = 1 - justify;\n        }\n\n        if (direction === 'left') {\n          justify = 1 - justify;\n        }\n\n        var isRotated = !(collectiveOrientation === 'h' || fitsHorizontally);\n        label = placer(bounds, text, {\n          fill: fill,\n          justify: orientation === 'h' ? placement.align : justify,\n          align: orientation === 'h' ? justify : placement.align,\n          fontSize: lblStngs.fontSize,\n          fontFamily: lblStngs.fontFamily,\n          textMetrics: measured,\n          rotate: isRotated,\n          overflow: !!overflow\n        });\n\n        if (label) {\n          if (typeof linkData !== 'undefined') {\n            label.data = linkData;\n          }\n\n          if (_typeof(placement.background) === 'object') {\n            label.backgroundColor = typeof placement.background.fill === 'function' ? placement.background.fill(arg, i) : placement.background.fill;\n\n            if (typeof label.backgroundColor !== 'undefined') {\n              label.backgroundBounds = approxTextBounds(label, measured, isRotated, bounds, placement.background.padding);\n            }\n          }\n\n          labels.push(label);\n          postFilterContext.labels.push({\n            node: node,\n            textBounds: approxTextBounds(label, measured, isRotated, bounds, placement.padding)\n          });\n        }\n      }\n    }\n  }\n\n  var filteredLabels = labels.filter(postFilter(postFilterContext));\n  var backgrounds = filteredLabels.filter(function (lb) {\n    return typeof lb.backgroundBounds !== 'undefined';\n  }).map(toBackground);\n  return [].concat(_toConsumableArray$1(backgrounds), _toConsumableArray$1(filteredLabels));\n}\nfunction precalculate(_ref4) {\n  var nodes = _ref4.nodes,\n      rect = _ref4.rect,\n      chart = _ref4.chart,\n      labelSettings = _ref4.labelSettings,\n      placementSettings = _ref4.placementSettings,\n      settings = _ref4.settings,\n      renderer = _ref4.renderer;\n  var labelStruct = {};\n  var targetNodes = [];\n  var target;\n  var fitsHorizontally = true;\n  var hasHorizontalDirection = false;\n  var node;\n  var text;\n  var bounds;\n  var measured;\n  var lblStng;\n  var direction;\n\n  for (var i = 0; i < nodes.length; i++) {\n    node = nodes[i];\n    bounds = node.localBounds;\n\n    if (!testRectRect(bounds, rect)) {\n      continue;\n    }\n\n    var arg = cbContext(node, chart);\n    target = {\n      node: node,\n      texts: [],\n      measurements: [],\n      labelSettings: [],\n      placementSettings: [] // direction: 'up'\n\n    };\n\n    for (var j = 0; j < labelSettings.length; j++) {\n      lblStng = labelSettings[j];\n      text = typeof lblStng.label === 'function' ? lblStng.label(arg, i) : undefined;\n\n      if (!isValidText(text)) {\n        continue; // eslint-ignore-line\n      }\n\n      direction = typeof settings.direction === 'function' ? settings.direction(arg, i) : settings.direction || 'up';\n      hasHorizontalDirection = hasHorizontalDirection || direction === 'left' || direction === 'right';\n      labelStruct.fontFamily = lblStng.fontFamily;\n      labelStruct.fontSize = \"\".concat(lblStng.fontSize, \"px\");\n      labelStruct.text = text;\n      measured = renderer.measureText(labelStruct);\n      target.measurements.push(measured);\n      target.texts.push(text);\n      target.labelSettings.push(lblStng);\n      target.placementSettings.push(placementSettings[j]);\n      target.direction = direction;\n      fitsHorizontally = fitsHorizontally && measured.width <= bounds.width - PADDING$1 * 2;\n    }\n\n    targetNodes.push(target);\n  }\n\n  return {\n    targetNodes: targetNodes,\n    fitsHorizontally: fitsHorizontally,\n    hasHorizontalDirection: hasHorizontalDirection\n  };\n}\n/**\n * @typedef {object} component--labels~label-strategy\n *\n */\n\n/**\n * @typedef {object} component--labels~label-strategy.settings\n * @property {string|function} [direction='up'] - The direction in which the bars are growing: 'up', 'down', 'right' or 'left'.\n * @property {string} [fontFamily='Arial']\n * @property {number} [fontSize=12]\n * @property {Array<object>} labels\n * @property {string|function} labels[].label - The text value\n * @property {function} labels[].linkData - Link data to the label\n * @property {Array<object>} labels[].placements\n * @property {string} labels[].placements[].position - 'inside' | 'outside' | 'opposite'\n * @property {number} [labels[].placements[].justify=0] - Placement of the label along the direction of the bar\n * @property {number} [labels[].placements[].align=0.5] - Placement of the label along the perpendicular direction of the bar\n * @property {string} [labels[].placements[].fill='#333'] - Color of the label\n * @property {boolean} [labels[].placements[].overflow=false] - True if the label is allowed to overflow the bar\n * @property {object} labels[].placements[].padding - Padding between the label and the bar\n * @property {number} [labels[].placements[].padding.top=4] - Padding-top between the label and the bar\n * @property {number} [labels[].placements[].padding.bottom=4] - Padding-bottom between the label and the bar\n * @property {number} [labels[].placements[].padding.left=4] - Padding-left between the label and the bar\n * @property {number} [labels[].placements[].padding.right=4] - Padding-right between the label and the bar\n * @property {object} labels[].placements[].background - Background of the label\n * @property {string|function} labels[].placements[].background.fill - Background color of the label\n * @property {object} labels[].placements[].background.padding - Padding between the label and the background\n * @property {number} [labels[].placements[].background.padding.top=4] - Padding-top between the label and the background\n * @property {number} [labels[].placements[].background.padding.bottom=4] - Padding-bottom between the label and the background\n * @property {number} [labels[].placements[].background.padding.left=4] - Padding-left between the label and the background\n * @property {number} [labels[].placements[].background.padding.right=4] - Padding-right between the label and the background\n */\n\nfunction bars(_ref5) {\n  var settings = _ref5.settings,\n      chart = _ref5.chart,\n      nodes = _ref5.nodes,\n      rect = _ref5.rect,\n      renderer = _ref5.renderer,\n      style = _ref5.style;\n  var placer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : placeInBars;\n  var defaults = extend({\n    fontSize: 12,\n    fontFamily: 'Arial',\n    align: 0.5,\n    justify: 0,\n    fill: '#333'\n  }, style.label);\n  defaults.fontSize = parseInt(defaults.fontSize, 10);\n  var labelSettings = settings.labels.map(function (labelSetting) {\n    return extend({}, defaults, settings, labelSetting);\n  });\n  var placementSettings = settings.labels.map(function (labelSetting) {\n    return labelSetting.placements.map(function (placement) {\n      return extend({}, defaults, settings, labelSetting, placement);\n    });\n  });\n\n  var _precalculate = precalculate({\n    nodes: nodes,\n    chart: chart,\n    renderer: renderer,\n    settings: settings,\n    rect: rect,\n    labelSettings: labelSettings,\n    placementSettings: placementSettings\n  }),\n      fitsHorizontally = _precalculate.fitsHorizontally,\n      hasHorizontalDirection = _precalculate.hasHorizontalDirection,\n      targetNodes = _precalculate.targetNodes;\n\n  var coord = hasHorizontalDirection ? 'y' : 'x';\n  var side = hasHorizontalDirection ? 'height' : 'width';\n  targetNodes.sort(function (a, b) {\n    return a.node.localBounds[coord] + a.node.localBounds[side] - (b.node.localBounds[coord] + b.node.localBounds[side]);\n  });\n  return placer({\n    chart: chart,\n    targetNodes: targetNodes,\n    stngs: settings,\n    rect: rect,\n    fitsHorizontally: fitsHorizontally,\n    collectiveOrientation: hasHorizontalDirection ? 'h' : 'v'\n  });\n}\n\nvar LABEL_OVERLAP_THRESHOLD_X = 4;\n\nfunction normalize$1(angle) {\n  var PI2 = Math.PI * 2;\n  return (angle % PI2 + PI2) % PI2; // normalize\n}\n\nfunction pad$2(bounds, padding) {\n  bounds.x += padding;\n  bounds.width -= padding * 2;\n  bounds.y += padding;\n  bounds.height -= padding * 2;\n}\n\nfunction getTopLeftBounds(bounds) {\n  var x = bounds.x;\n  var y = bounds.y - bounds.height / 2;\n  return {\n    x: x,\n    y: y,\n    width: bounds.width,\n    height: bounds.height\n  };\n} // assume 0 <= angle < (PI / 2)\n\n\nfunction getLineCircleIntersection(radius, offset, angle) {\n  var x = offset.x,\n      y = offset.y;\n\n  if (x * x + y * y > radius * radius) {\n    return null;\n  }\n\n  var dx = Math.sin(angle);\n  var dy = Math.cos(angle);\n  var D = x * dy - y * dx;\n  var d = radius * radius - D * D;\n\n  if (d < 0) {\n    return null;\n  }\n\n  var sqrtD = Math.sqrt(d);\n  return {\n    x: D * dy + dx * sqrtD,\n    y: -(D * dx) + dy * sqrtD\n  };\n} // assume 0 <= angle < (PI * 2)\n\n\nfunction getRectFromCircleIntersection(_ref) {\n  var radius = _ref.radius,\n      size = _ref.size,\n      angle = _ref.angle;\n  var width = size.width,\n      height = size.height;\n  var lineOffset = {\n    x: width / 2,\n    y: height / 2\n  };\n  var section = Math.floor(angle / (Math.PI / 2));\n  var intersection;\n  var offset;\n\n  switch (section) {\n    case 0:\n      intersection = getLineCircleIntersection(radius, lineOffset, angle);\n\n      if (!intersection) {\n        return null;\n      }\n\n      intersection.y *= -1;\n      offset = {\n        x: -width,\n        y: 0\n      };\n      break;\n\n    case 1:\n      intersection = getLineCircleIntersection(radius, lineOffset, Math.PI - angle);\n\n      if (!intersection) {\n        return null;\n      }\n\n      offset = {\n        x: -width,\n        y: -height\n      };\n      break;\n\n    case 2:\n      intersection = getLineCircleIntersection(radius, lineOffset, angle - Math.PI);\n\n      if (!intersection) {\n        return null;\n      }\n\n      intersection.x *= -1;\n      offset = {\n        x: 0,\n        y: -height\n      };\n      break;\n\n    case 3:\n      intersection = getLineCircleIntersection(radius, lineOffset, 2 * Math.PI - angle);\n\n      if (!intersection) {\n        return null;\n      }\n\n      intersection.x *= -1;\n      intersection.y *= -1;\n      offset = {\n        x: 0,\n        y: 0\n      };\n      break;\n\n    default:\n      throw new Error('invalid angle');\n  }\n\n  var bounds = {\n    x: intersection.x + offset.x,\n    y: intersection.y + offset.y,\n    width: width,\n    height: height\n  };\n  return bounds;\n}\n\nfunction getHorizontalInsideSliceRect(_ref2) {\n  var slice = _ref2.slice,\n      padding = _ref2.padding,\n      measured = _ref2.measured,\n      store = _ref2.store;\n  var start = slice.start,\n      end = slice.end,\n      outerRadius = slice.outerRadius;\n  var middle = normalize$1((start + end) / 2);\n  var size = {\n    width: measured.width + padding * 2,\n    height: measured.height + padding * 2\n  };\n  var bounds = getRectFromCircleIntersection({\n    radius: outerRadius,\n    size: size,\n    angle: middle\n  });\n\n  if (!bounds) {\n    return null;\n  }\n\n  bounds.baseline = 'top';\n  pad$2(bounds, padding);\n\n  if (store.insideLabelBounds.some(function (rect) {\n    return testRectRect(rect, bounds);\n  })) {\n    return null;\n  }\n\n  store.insideLabelBounds.push({\n    x: bounds.x - LABEL_OVERLAP_THRESHOLD_X,\n    y: bounds.y,\n    width: bounds.width + LABEL_OVERLAP_THRESHOLD_X * 2,\n    height: bounds.height\n  }); // Copy as bounds is mutated else where\n\n  return bounds;\n}\n\nfunction getHorizontalIntoSliceRect(_ref3) {\n  var slice = _ref3.slice,\n      padding = _ref3.padding,\n      measured = _ref3.measured;\n  var start = slice.start,\n      end = slice.end,\n      innerRadius = slice.innerRadius,\n      outerRadius = slice.outerRadius;\n  var middle = normalize$1((start + end) / 2);\n  var size = {\n    width: measured.width + padding * 2,\n    height: measured.height + padding * 2\n  };\n  var bounds = getRectFromCircleIntersection({\n    radius: outerRadius,\n    size: size,\n    angle: middle\n  });\n\n  if (!bounds) {\n    return null;\n  }\n\n  bounds.baseline = 'top';\n  var startLine = {\n    x1: 0,\n    y1: 0,\n    x2: Math.sin(start) * outerRadius,\n    y2: -Math.cos(start) * outerRadius\n  };\n\n  if (testRectLine(bounds, startLine)) {\n    return null;\n  }\n\n  var endLine = {\n    x1: 0,\n    y1: 0,\n    x2: Math.sin(end) * outerRadius,\n    y2: -Math.cos(end) * outerRadius\n  };\n\n  if (testRectLine(bounds, endLine)) {\n    return null;\n  }\n\n  var circle = {\n    cx: 0,\n    cy: 0,\n    r: innerRadius\n  };\n\n  if (testCircleRect(circle, bounds)) {\n    return null;\n  }\n\n  pad$2(bounds, padding);\n  return bounds;\n} // TODO: this case can support a justify setting\n\n\nfunction getRotatedInsideSliceRect(_ref4) {\n  var slice = _ref4.slice,\n      measured = _ref4.measured,\n      padding = _ref4.padding;\n  var start = slice.start,\n      end = slice.end,\n      innerRadius = slice.innerRadius,\n      outerRadius = slice.outerRadius;\n  var maxWidth = outerRadius - innerRadius - padding * 2;\n  var size = end - start;\n\n  if (size < Math.PI) {\n    var x = (measured.height / 2 + padding) / Math.tan(size / 2);\n\n    if (x > innerRadius) {\n      maxWidth = outerRadius - x - padding * 2;\n    }\n  }\n\n  if (maxWidth < 0 || maxWidth < measured.minReqWidth) {\n    return null;\n  }\n\n  var middle = normalize$1((start + end) / 2);\n  var r = outerRadius - padding;\n  var bounds = {\n    x: Math.sin(middle) * r,\n    y: -Math.cos(middle) * r,\n    width: maxWidth,\n    height: measured.height\n  };\n\n  if (middle < Math.PI) {\n    bounds.angle = middle - Math.PI / 2;\n    bounds.anchor = 'end';\n  } else {\n    bounds.angle = middle + Math.PI / 2;\n    bounds.anchor = 'start';\n  }\n\n  return bounds;\n}\n\nfunction getRotatedOusideSliceRect(_ref5) {\n  var slice = _ref5.slice,\n      measured = _ref5.measured,\n      padding = _ref5.padding,\n      view = _ref5.view;\n  var start = slice.start,\n      end = slice.end,\n      outerRadius = slice.outerRadius,\n      offset = slice.offset;\n  var r = outerRadius + padding;\n  var size = end - start;\n\n  if (size < Math.PI) {\n    var minR = (measured.height / 2 + padding) / Math.tan(size / 2);\n\n    if (minR > r) {\n      return null;\n    }\n  }\n\n  var middle = normalize$1((start + end) / 2);\n  var x = Math.sin(middle) * r;\n  var y = -Math.cos(middle) * r;\n  var maxWidth = measured.width;\n  var v = middle % Math.PI;\n\n  if (v > Math.PI / 2) {\n    v = Math.PI - v;\n  }\n\n  if (Math.cos(v) > 0.001) {\n    var edge = y < 0 ? view.y : view.y + view.height;\n    var d = Math.abs(edge - offset.y);\n    var w = d / Math.cos(v) - Math.tan(v) * (measured.height / 2) - padding * 2 - outerRadius;\n\n    if (w < maxWidth) {\n      maxWidth = w;\n    }\n  }\n\n  if (Math.sin(v) > 0.001) {\n    var _edge = x < 0 ? view.x : view.x + view.width;\n\n    var _d = Math.abs(_edge - offset.x);\n\n    var _w = _d / Math.sin(v) - measured.height / 2 / Math.tan(v) - padding * 2 - outerRadius;\n\n    if (_w < maxWidth) {\n      maxWidth = _w;\n    }\n  }\n\n  if (maxWidth <= 0 || maxWidth < measured.minReqWidth) {\n    return null;\n  }\n\n  var bounds = {\n    x: x,\n    y: y,\n    width: maxWidth,\n    height: measured.height\n  };\n\n  if (middle < Math.PI) {\n    bounds.angle = middle - Math.PI / 2;\n    bounds.anchor = 'start';\n  } else {\n    bounds.angle = middle + Math.PI / 2;\n    bounds.anchor = 'end';\n  }\n\n  return bounds;\n}\n\nfunction outOfSpace(context, section, view) {\n  switch (section) {\n    case 0:\n      return context.q1maxY < 0;\n\n    case 1:\n      return context.q2minY > view.height;\n\n    case 2:\n      return context.q3minY > view.height;\n\n    case 3:\n      return context.q4maxY < 0;\n\n    default:\n      return true;\n  }\n}\n\nfunction adjustBounds(bounds, context, slice) {\n  var LINE_PADDING = 2;\n  var LIMIT = 1;\n  var start = slice.start,\n      end = slice.end,\n      offset = slice.offset,\n      outerRadius = slice.outerRadius;\n  var middle = normalize$1((start + end) / 2);\n  var section = Math.floor(middle / (Math.PI / 2));\n\n  switch (section) {\n    case 0:\n      if (context.q1maxY !== undefined) {\n        var y = Math.min(bounds.y, context.q1maxY - bounds.height);\n        var dy = bounds.y - y;\n        bounds.y = y;\n\n        if (dy > LIMIT) {\n          var r = outerRadius + LINE_PADDING;\n          bounds.line = {\n            type: 'line',\n            x1: bounds.x - LINE_PADDING,\n            y1: bounds.y + LINE_PADDING,\n            x2: offset.x + Math.sin(middle) * r,\n            y2: offset.y - Math.cos(middle) * r,\n            strokeWidth: 1\n          };\n        }\n      }\n\n      break;\n\n    case 1:\n      if (context.q2minY !== undefined) {\n        var _y = Math.max(bounds.y, context.q2minY);\n\n        var _dy = _y - bounds.y;\n\n        bounds.y = _y;\n\n        if (_dy > LIMIT) {\n          var _r = outerRadius + LINE_PADDING;\n\n          bounds.line = {\n            type: 'line',\n            x1: bounds.x - LINE_PADDING,\n            y1: bounds.y - LINE_PADDING,\n            x2: offset.x + Math.sin(middle) * _r,\n            y2: offset.y - Math.cos(middle) * _r,\n            strokeWidth: 1\n          };\n        }\n      }\n\n      break;\n\n    case 2:\n      if (context.q3minY !== undefined) {\n        var _y2 = Math.max(bounds.y, context.q3minY);\n\n        var _dy2 = _y2 - bounds.y;\n\n        bounds.y = _y2;\n\n        if (_dy2 > LIMIT) {\n          var _r2 = outerRadius + LINE_PADDING;\n\n          bounds.line = {\n            type: 'line',\n            x1: bounds.x + LINE_PADDING,\n            y1: bounds.y - LINE_PADDING,\n            x2: offset.x + Math.sin(middle) * _r2,\n            y2: offset.y - Math.cos(middle) * _r2,\n            strokeWidth: 1\n          };\n        }\n      }\n\n      break;\n\n    case 3:\n      if (context.q4maxY !== undefined) {\n        var _y3 = Math.min(bounds.y, context.q4maxY - bounds.height);\n\n        var _dy3 = bounds.y - _y3;\n\n        bounds.y = _y3;\n\n        if (_dy3 > LIMIT) {\n          var _r3 = outerRadius + LINE_PADDING;\n\n          bounds.line = {\n            type: 'line',\n            x1: bounds.x + LINE_PADDING,\n            y1: bounds.y + LINE_PADDING,\n            x2: offset.x + Math.sin(middle) * _r3,\n            y2: offset.y - Math.cos(middle) * _r3,\n            strokeWidth: 1\n          };\n        }\n      }\n\n      break;\n\n    default:\n      break;\n  }\n}\n\nfunction updateContext(_ref6) {\n  var context = _ref6.context,\n      node = _ref6.node,\n      bounds = _ref6.bounds;\n  var PADDING = 2;\n  var _node$desc$slice = node.desc.slice,\n      start = _node$desc$slice.start,\n      end = _node$desc$slice.end;\n  var middle = normalize$1((start + end) / 2);\n  var section = Math.floor(middle / (Math.PI / 2));\n\n  switch (section) {\n    case 0:\n      context.q1maxY = bounds.y - PADDING;\n\n      if (context.q2minY === undefined) {\n        context.q2minY = bounds.y + bounds.height + PADDING;\n      }\n\n      break;\n\n    case 1:\n      context.q2minY = bounds.y + bounds.height + PADDING;\n      break;\n\n    case 2:\n      context.q3minY = bounds.y + bounds.height + PADDING;\n      break;\n\n    case 3:\n      context.q4maxY = bounds.y - PADDING;\n\n      if (context.q3minY === undefined) {\n        context.q3minY = bounds.y + bounds.height + PADDING;\n      }\n\n      break;\n\n    default:\n      break;\n  }\n}\n\nfunction getHorizontalOusideSliceRect(_ref7) {\n  var slice = _ref7.slice,\n      measured = _ref7.measured,\n      padding = _ref7.padding,\n      view = _ref7.view,\n      context = _ref7.context;\n  var start = slice.start,\n      end = slice.end,\n      outerRadius = slice.outerRadius,\n      offset = slice.offset;\n  var middle = normalize$1((start + end) / 2);\n  var section = Math.floor(middle / (Math.PI / 2));\n\n  if (outOfSpace(context, section, view)) {\n    return null;\n  }\n\n  var r = outerRadius + padding + measured.height / 2;\n  var x = Math.sin(middle) * r;\n  var y = -Math.cos(middle) * r;\n  var maxWidth = measured.width;\n\n  if (middle < Math.PI) {\n    var w = Math.abs(view.x + view.width - (x + offset.x));\n\n    if (w < maxWidth) {\n      maxWidth = w;\n    }\n  } else {\n    var _w2 = Math.abs(view.x - (x + offset.x));\n\n    if (_w2 < maxWidth) {\n      maxWidth = _w2;\n    }\n  }\n\n  if (maxWidth < measured.minReqWidth) {\n    return null;\n  }\n\n  var bounds = {\n    x: x,\n    y: y,\n    width: maxWidth,\n    height: measured.height\n  };\n\n  if (middle < Math.PI) {\n    bounds.anchor = 'start';\n  } else {\n    bounds.anchor = 'end';\n  }\n\n  return bounds;\n}\n\nfunction cbContext$1(node, chart) {\n  return {\n    node: node,\n    data: node.data,\n    scale: chart.scale,\n    formatter: chart.formatter,\n    dataset: chart.dataset\n  };\n}\n\nfunction placeTextOnPoint(rect, text, opts) {\n  var label = {\n    type: 'text',\n    text: text,\n    maxWidth: rect.width,\n    x: rect.x,\n    y: rect.y + (rect.baseline === 'top' ? rect.height / 2 : 0),\n    fill: opts.fill,\n    anchor: rect.anchor || 'start',\n    baseline: 'middle',\n    fontSize: \"\".concat(opts.fontSize, \"px\"),\n    fontFamily: opts.fontFamily\n  };\n\n  if (!isNaN(rect.angle)) {\n    var angle = rect.angle * (360 / (Math.PI * 2));\n    label.transform = \"rotate(\".concat(angle, \", \").concat(label.x, \", \").concat(label.y, \")\");\n  }\n\n  return label;\n}\n\nfunction getSliceRect(_ref8) {\n  var slice = _ref8.slice,\n      direction = _ref8.direction,\n      position = _ref8.position,\n      padding = _ref8.padding,\n      measured = _ref8.measured,\n      view = _ref8.view,\n      context = _ref8.context,\n      store = _ref8.store;\n  var start = slice.start,\n      end = slice.end,\n      innerRadius = slice.innerRadius,\n      offset = slice.offset;\n  var bounds;\n  var s;\n\n  switch (position) {\n    case 'into':\n      if (direction === 'rotate') {\n        bounds = getRotatedInsideSliceRect({\n          slice: slice,\n          measured: measured,\n          padding: padding\n        });\n      } else {\n        bounds = getHorizontalIntoSliceRect({\n          slice: slice,\n          measured: measured,\n          padding: padding\n        });\n      }\n\n      break;\n\n    case 'inside':\n      s = {\n        start: start,\n        end: end,\n        innerRadius: 0,\n        outerRadius: innerRadius\n      };\n\n      if (direction === 'rotate') {\n        bounds = getRotatedInsideSliceRect({\n          slice: s,\n          measured: measured,\n          padding: padding\n        });\n      } else {\n        bounds = getHorizontalInsideSliceRect({\n          slice: s,\n          measured: measured,\n          padding: padding,\n          store: store\n        });\n      }\n\n      break;\n\n    case 'outside':\n      if (direction === 'rotate') {\n        bounds = getRotatedOusideSliceRect({\n          slice: slice,\n          measured: measured,\n          padding: padding,\n          view: view\n        });\n      } else {\n        bounds = getHorizontalOusideSliceRect({\n          slice: slice,\n          measured: measured,\n          padding: padding,\n          view: view,\n          context: context\n        });\n      }\n\n      break;\n\n    default:\n      throw new Error('not implemented');\n  }\n\n  if (bounds) {\n    bounds.x += offset.x;\n    bounds.y += offset.y;\n\n    if (position === 'outside' && direction !== 'rotate') {\n      adjustBounds(bounds, context, slice);\n    }\n  }\n\n  return bounds;\n}\n\nfunction findBestPlacement$1(_ref9) {\n  var context = _ref9.context,\n      direction = _ref9.direction,\n      measured = _ref9.measured,\n      node = _ref9.node,\n      placementSettings = _ref9.placementSettings,\n      rect = _ref9.rect,\n      store = _ref9.store;\n  var sliceRect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getSliceRect;\n\n  for (var p = 0; p < placementSettings.length; p++) {\n    var placement = placementSettings[p];\n    var bounds = sliceRect({\n      context: context,\n      slice: node.desc.slice,\n      view: rect,\n      direction: direction,\n      position: placement.position,\n      measured: measured,\n      padding: placement.padding,\n      store: store\n    });\n\n    if (!bounds) {\n      continue;\n    }\n\n    return {\n      bounds: bounds,\n      placement: placement\n    };\n  }\n\n  return {\n    bounds: null,\n    placement: null\n  };\n}\n/*\n * Sorts the nodes so that\n *   in each quarter sort nodes from the center (in y) outwards\n *   first quarter before the second\n *   forth quarter before the third\n */\n\n\nfunction sortNodes(nodes) {\n  var q1 = [];\n  var q2 = [];\n  var q3 = [];\n  var q4 = [];\n\n  for (var i = 0; i < nodes.length; ++i) {\n    var _nodes$i$desc$slice = nodes[i].desc.slice,\n        start = _nodes$i$desc$slice.start,\n        end = _nodes$i$desc$slice.end;\n    var middle = normalize$1((start + end) / 2);\n    var section = Math.floor(middle / (Math.PI / 2));\n\n    switch (section) {\n      case 0:\n        q1.push(nodes[i]);\n        break;\n\n      case 1:\n        q2.push(nodes[i]);\n        break;\n\n      case 2:\n        q3.push(nodes[i]);\n        break;\n\n      case 3:\n        q4.push(nodes[i]);\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  var sortFn = function sortFn(a, b) {\n    var middleA = normalize$1((a.desc.slice.start + a.desc.slice.end) / 2);\n    var middleB = normalize$1((b.desc.slice.start + b.desc.slice.end) / 2);\n    return middleA - middleB;\n  };\n\n  var reverseSortFn = function reverseSortFn(a, b) {\n    return sortFn(b, a);\n  };\n\n  q1.sort(reverseSortFn);\n  q2.sort(sortFn);\n  q3.sort(reverseSortFn);\n  q4.sort(sortFn);\n  return q1.concat(q2, q4, q3);\n}\n\nfunction measureText(text, stgns, renderer) {\n  var fontFamily = stgns.fontFamily;\n  var fontSize = \"\".concat(stgns.fontSize, \"px\");\n  var metrics = renderer.measureText({\n    text: text,\n    fontFamily: fontFamily,\n    fontSize: fontSize\n  });\n  metrics.minReqWidth = Math.min(metrics.width, renderer.measureText({\n    text: \"\".concat(text[0], \"\\u2026\"),\n    fontFamily: fontFamily,\n    fontSize: fontSize\n  }).width);\n  return metrics;\n}\n/**\n * @typedef {object} component--labels~slices-label-strategy\n *\n */\n\n/**\n * @typedef {object} component--labels~slices-label-strategy.settings\n * @property {string|function} [direction='horizontal'] - The direction of the text: 'horizontal' or 'rotate'.\n * @property {string} [fontFamily='Arial']\n * @property {number} [fontSize=12]\n * @property {Array<object>} labels\n * @property {string|function} labels[].label - The text value\n * @property {function} labels[].linkData - Link data to the label\n * @property {Array<object>} labels[].placements\n * @property {string} [labels[].placements[].position='into'] - 'inside' | 'into' | 'outside' (outside is not implmented yet)\n * @property {string} [labels[].placements[].fill='#333'] - Color of the label\n */\n\n\nfunction slices(_ref10) {\n  var settings = _ref10.settings,\n      chart = _ref10.chart,\n      nodes = _ref10.nodes,\n      rect = _ref10.rect,\n      renderer = _ref10.renderer,\n      style = _ref10.style;\n  var findPlacement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : findBestPlacement$1;\n  var placer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : placeTextOnPoint;\n  var defaults = extend({\n    fontSize: 12,\n    fontFamily: 'Arial',\n    fill: '#333',\n    padding: 4,\n    position: 'into'\n  }, style.label);\n  defaults.fontSize = parseInt(defaults.fontSize, 10);\n  var labelSettings = settings.labels.map(function (labelSetting) {\n    return extend({}, defaults, settings, labelSetting);\n  });\n  var placementSettings = settings.labels.map(function (labelSetting) {\n    return labelSetting.placements.map(function (placement) {\n      return extend({}, defaults, settings, labelSetting, placement);\n    });\n  });\n  var labels = [];\n  var store = {\n    insideLabelBounds: []\n  };\n  nodes = sortNodes(nodes);\n  var context = {};\n\n  for (var i = 0, len = nodes.length; i < len; i++) {\n    var node = nodes[i];\n    var arg = cbContext$1(node, chart);\n\n    for (var j = 0; j < labelSettings.length; j++) {\n      var lblStngs = labelSettings[j];\n      var text = typeof lblStngs.label === 'function' ? lblStngs.label(arg, i) : '';\n\n      if (!text) {\n        continue;\n      }\n\n      var direction = typeof lblStngs.direction === 'function' ? lblStngs.direction(arg, i) : lblStngs.direction || 'horizontal';\n      var linkData = typeof lblStngs.linkData === 'function' ? lblStngs.linkData(arg, i) : undefined;\n      var measured = measureText(text, lblStngs, renderer);\n      var bestPlacement = findPlacement({\n        context: context,\n        direction: direction,\n        lblStngs: lblStngs,\n        measured: measured,\n        node: node,\n        placementSettings: placementSettings[j],\n        rect: rect,\n        store: store\n      });\n      var bounds = bestPlacement.bounds;\n      var placement = bestPlacement.placement;\n\n      if (bounds && placement) {\n        if (placement.position === 'outside' && direction !== 'rotate') {\n          updateContext({\n            context: context,\n            node: node,\n            bounds: bounds\n          });\n          var topLeftBounds = getTopLeftBounds(bounds);\n\n          if (!rectContainsRect(topLeftBounds, rect)) {\n            continue;\n          }\n        }\n\n        var fill = typeof placement.fill === 'function' ? placement.fill(arg, i) : placement.fill;\n        var label = placer(bounds, text, {\n          fill: fill,\n          fontSize: lblStngs.fontSize,\n          fontFamily: lblStngs.fontFamily,\n          textMetrics: measured\n        });\n\n        if (label) {\n          if (typeof linkData !== 'undefined') {\n            label.data = linkData;\n          }\n\n          labels.push(label);\n\n          if (bounds.line) {\n            bounds.line.stroke = fill;\n            labels.push(bounds.line);\n          }\n        }\n      }\n    }\n  }\n\n  return labels;\n}\n\nvar LINEBREAK_REGEX = /\\n+|\\r+|\\r\\n/;\nvar WHITESPACE_REGEX = /\\s/;\nvar HYPHEN_REGEX = /[a-zA-Z\\u00C0-\\u00F6\\u00F8-\\u00FF\\u00AD]/;\nvar NO_BREAK = 0;\nvar MANDATORY = 1;\nvar BREAK_ALLOWED = 2;\nfunction includesLineBreak(c) {\n  if (typeof c === 'string') {\n    return c.search(LINEBREAK_REGEX) !== -1;\n  }\n\n  return String(c).search(LINEBREAK_REGEX) !== -1;\n}\n\nfunction includesWhiteSpace(c) {\n  return c.search(WHITESPACE_REGEX) !== -1;\n}\n\nfunction hyphenationAllowed(c) {\n  /* Latin character set. Excluding numbers, sign and symbol characters, but including soft hyphen */\n  return c.search(HYPHEN_REGEX) !== -1;\n}\n\nfunction resolveBreakOpportunity(chunk, i, chunks, mandatory, noBreakAllowed) {\n  if (mandatory.some(function (fn) {\n    return fn(chunk, i, chunks);\n  })) {\n    return MANDATORY;\n  }\n\n  if (noBreakAllowed.some(function (fn) {\n    return fn(chunk, i, chunks);\n  })) {\n    return NO_BREAK;\n  }\n\n  return BREAK_ALLOWED;\n}\n\nfunction cleanEmptyChunks(chunks) {\n  if (chunks[0] === '') {\n    chunks.shift();\n  }\n\n  if (chunks[chunks.length - 1] === '') {\n    chunks.pop();\n  }\n}\n\nfunction clamp$1(val, min, max) {\n  return Math.max(min, Math.min(max, val));\n}\n\nfunction stringTokenizer() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      string = _ref.string,\n      _ref$separator = _ref.separator,\n      separator = _ref$separator === void 0 ? '' : _ref$separator,\n      _ref$reverse = _ref.reverse,\n      reverse = _ref$reverse === void 0 ? false : _ref$reverse,\n      _ref$measureText = _ref.measureText,\n      measureText = _ref$measureText === void 0 ? function (text) {\n    return {\n      width: text.length,\n      height: 1\n    };\n  } : _ref$measureText,\n      _ref$mandatoryBreakId = _ref.mandatoryBreakIdentifiers,\n      mandatoryBreakIdentifiers = _ref$mandatoryBreakId === void 0 ? [includesLineBreak] : _ref$mandatoryBreakId,\n      _ref$noBreakAllowedId = _ref.noBreakAllowedIdentifiers,\n      noBreakAllowedIdentifiers = _ref$noBreakAllowedId === void 0 ? [] : _ref$noBreakAllowedId,\n      _ref$suppressIdentifi = _ref.suppressIdentifier,\n      suppressIdentifier = _ref$suppressIdentifi === void 0 ? [includesWhiteSpace, includesLineBreak, function (chunk) {\n    return chunk === '';\n  }] : _ref$suppressIdentifi,\n      _ref$hyphenationIdent = _ref.hyphenationIdentifiers,\n      hyphenationIdentifiers = _ref$hyphenationIdent === void 0 ? [hyphenationAllowed] : _ref$hyphenationIdent;\n\n  var chunks = String(string).split(separator);\n  cleanEmptyChunks(chunks);\n  var length = chunks.length;\n  var isNotDone = reverse ? function (p) {\n    return p >= 0;\n  } : function (p) {\n    return p < length;\n  };\n  var position = reverse ? length : -1; // Set init position 1 step before or after to make first next call go to first position\n\n  function peek(peekAt) {\n    var i = clamp$1(peekAt, 0, length - 1);\n    var chunk = chunks[i];\n    var textMeasure = measureText(chunk);\n    var opportunity = resolveBreakOpportunity(chunk, i, chunks, mandatoryBreakIdentifiers, noBreakAllowedIdentifiers);\n    return {\n      index: i,\n      value: chunk,\n      breakOpportunity: opportunity,\n      suppress: suppressIdentifier.some(function (fn) {\n        return fn(chunk, i, chunks);\n      }),\n      hyphenation: hyphenationIdentifiers.some(function (fn) {\n        return fn(chunk, i, chunks);\n      }),\n      width: textMeasure.width,\n      height: textMeasure.height,\n      done: false\n    };\n  }\n\n  function next(jumpToPosition) {\n    if (isNaN(jumpToPosition)) {\n      if (reverse) {\n        position--;\n      } else {\n        position++;\n      }\n    } else {\n      position = clamp$1(jumpToPosition, 0, length - 1);\n    }\n\n    if (isNotDone(position)) {\n      return peek(position);\n    }\n\n    return {\n      done: true\n    };\n  }\n\n  return {\n    next: next,\n    peek: peek,\n    length: length\n  };\n}\n\nvar HYPHENS_CHAR = \"\\u2010\";\nvar ELLIPSIS_CHAR = '…';\n\nvar BASE = 24;\nvar PAD = 4;\nvar BUMP = 1e-12;\nvar DEFAULT_FONT_HEIGHT = 16;\nvar DEFAULT_LINE_HEIGHT = 1.2;\nvar TEXT_REGEX = /^\\s*\\d+(\\.\\d+)?px\\s*$/i;\n\nfunction isValidFontSize(val) {\n  var type = _typeof(val);\n\n  if (type === 'string') {\n    return TEXT_REGEX.test(val);\n  }\n\n  return false;\n}\n\nfunction fontSizeToHeight(fontSize) {\n  if (isValidFontSize(fontSize)) {\n    var size = parseFloat(fontSize);\n    var m = PAD * Math.ceil((size + BUMP) / BASE);\n    return size + m;\n  }\n\n  return DEFAULT_FONT_HEIGHT;\n}\nfunction fontSizeToLineHeight(node) {\n  var fontSize = node['font-size'] || node.fontSize;\n\n  if (isValidFontSize(fontSize)) {\n    return parseFloat(fontSize) * Math.max(isNaN(node.lineHeight) ? DEFAULT_LINE_HEIGHT : node.lineHeight, 0);\n  }\n\n  return DEFAULT_FONT_HEIGHT * DEFAULT_LINE_HEIGHT;\n}\n\nfunction resolveMaxAllowedLines(node) {\n  var maxHeight = node.maxHeight;\n  var maxLines = Math.max(node.maxLines, 1) || Infinity;\n\n  if (isNaN(maxHeight)) {\n    return maxLines;\n  }\n\n  var computedLineHeight = fontSizeToLineHeight(node);\n  return Math.max(1, Math.min(Math.floor(maxHeight / computedLineHeight), maxLines));\n}\n\nfunction initState(node, measureText) {\n  return {\n    lines: [],\n    line: '',\n    width: 0,\n    maxLines: resolveMaxAllowedLines(node),\n    maxWidth: node.maxWidth,\n    hyphens: {\n      enabled: node.hyphens === 'auto',\n      char: HYPHENS_CHAR,\n      metrics: measureText(HYPHENS_CHAR)\n    }\n  };\n}\n\nfunction newLine(state) {\n  state.lines.push(state.line);\n  state.line = '';\n  state.width = 0;\n}\n\nfunction appendToLine(state, token) {\n  state.line += token.value;\n  state.width += token.width;\n}\n\nfunction insertHyphenAndJump(state, token, iterator) {\n  if (token.width > state.maxWidth) {\n    return token;\n  }\n\n  var startIndex = token.index;\n\n  for (var i = 1; i < 5; i++) {\n    var pairToken = iterator.peek(token.index - 1);\n\n    if (!token.hyphenation || !pairToken.hyphenation || token.index === 0) {\n      return token;\n    }\n\n    if (state.width + state.hyphens.metrics.width <= state.maxWidth) {\n      state.line += state.hyphens.char;\n      return token;\n    }\n\n    if (state.line.length === 1) {\n      return token;\n    }\n\n    token = iterator.next(startIndex - i);\n    state.line = state.line.slice(0, -1);\n    state.width -= token.width;\n  }\n\n  return token;\n}\n\nfunction breakSequence(state, token, measureText) {\n  var charTokenIterator = stringTokenizer({\n    string: token.value,\n    measureText: measureText\n  });\n\n  while (state.lines.length < state.maxLines) {\n    var charToken = charTokenIterator.next();\n\n    if (charToken.done) {\n      break;\n    } else if (state.width + charToken.width > state.maxWidth && charToken.breakOpportunity === BREAK_ALLOWED && state.line.length > 0) {\n      charToken = state.hyphens.enabled ? insertHyphenAndJump(state, charToken, charTokenIterator) : charToken;\n      newLine(state);\n      appendToLine(state, charToken);\n    } else {\n      appendToLine(state, charToken);\n    }\n  }\n}\n\nfunction breakAll(node, measureText) {\n  var text = node.text;\n  var iterator = stringTokenizer({\n    string: text,\n    separator: '',\n    measureText: measureText,\n    noBreakAllowedIdentifiers: [function (chunk, i) {\n      return i === 0;\n    }]\n  });\n  var state = initState(node, measureText);\n  var reduced = true;\n\n  while (state.lines.length < state.maxLines) {\n    var token = iterator.next();\n\n    if (token.done) {\n      newLine(state);\n      reduced = false;\n      break;\n    } else if (token.breakOpportunity === MANDATORY) {\n      newLine(state);\n    } else if (state.width + token.width > state.maxWidth && token.breakOpportunity === BREAK_ALLOWED) {\n      if (token.suppress) {\n        // Token is suppressable and can be ignored\n        state.width += token.width;\n      } else {\n        token = state.hyphens.enabled ? insertHyphenAndJump(state, token, iterator) : token;\n        newLine(state);\n        appendToLine(state, token);\n      }\n    } else {\n      appendToLine(state, token);\n    }\n  }\n\n  return {\n    lines: state.lines,\n    reduced: reduced\n  };\n}\nfunction breakWord(node, measureText) {\n  var text = node.text;\n  var iterator = stringTokenizer({\n    string: text,\n    separator: /(\\s|-|\\u2010)/,\n    measureText: measureText\n  });\n  var state = initState(node, measureText);\n  var reduced = true;\n\n  while (state.lines.length < state.maxLines) {\n    var token = iterator.next();\n\n    if (token.done) {\n      newLine(state);\n      reduced = false;\n      break;\n    } else if (token.breakOpportunity === MANDATORY) {\n      newLine(state);\n    } else if (state.width + token.width > state.maxWidth && token.breakOpportunity === BREAK_ALLOWED) {\n      if (token.suppress) {\n        // Token is suppressable and can be ignored\n        newLine(state);\n      } else if (token.width > state.maxWidth) {\n        // Single sequence is wider then maxWidth, break sequence into multiple lines\n        breakSequence(state, token, measureText);\n      } else {\n        newLine(state);\n        appendToLine(state, token);\n      }\n    } else {\n      appendToLine(state, token);\n    }\n  }\n\n  return {\n    lines: state.lines,\n    reduced: reduced\n  };\n}\n\nfunction generateLineNodes(result, item, halfLead, height) {\n  var container = {\n    type: 'container',\n    children: []\n  };\n\n  if (typeof item.id !== 'undefined') {\n    // TODO also inherit data attribute and more?\n    container.id = item.id;\n  }\n\n  var currentY = 0;\n  result.lines.forEach(function (line, i) {\n    var node = extend({}, item);\n    node.text = line;\n    node._lineBreak = true; // Flag node as processed to avoid duplicate linebreak run\n\n    currentY += halfLead; // leading height above\n\n    if (result.reduced && i === result.lines.length - 1) {\n      node.text += ELLIPSIS_CHAR;\n    } else {\n      delete node.maxWidth;\n    }\n\n    node.dy = isNaN(node.dy) ? currentY : node.dy + currentY;\n    currentY += height;\n    currentY += halfLead; // Leading height below\n\n    container.children.push(node);\n  });\n  return container;\n}\n\nfunction shouldLineBreak(item) {\n  // If type text and not already broken into lines\n  return item.type === 'text' && !item._lineBreak;\n}\n\nfunction wrappedMeasureText(node, measureText) {\n  return function (text) {\n    return measureText({\n      text: text,\n      fontSize: node.fontSize,\n      fontFamily: node.fontFamily\n    });\n  };\n}\n\nfunction resolveLineBreakAlgorithm(node) {\n  var WORDBREAK = {\n    'break-all': breakAll,\n    'break-word': breakWord\n  };\n  return WORDBREAK[node.wordBreak];\n}\n/**\n * Apply wordBreak rules to text nodes.\n * @ignore\n * @param {function} measureText\n * @returns {function} Event function to convert a text node into multiple nodes\n */\n\nfunction onLineBreak(measureText) {\n  return function (state) {\n    var item = state.node;\n\n    if (shouldLineBreak(item)) {\n      var wordBreakFn = resolveLineBreakAlgorithm(item);\n\n      if (!wordBreakFn) {\n        return;\n      }\n\n      var tm = measureText(item);\n\n      if (tm.width > item.maxWidth || includesLineBreak(item.text)) {\n        var diff = fontSizeToLineHeight(item) - tm.height;\n        var halfLead = diff / 2;\n        var result = wordBreakFn(item, wrappedMeasureText(item, measureText));\n        state.node = generateLineNodes(result, item, halfLead, tm.height); // Convert node to container\n      }\n    }\n  };\n}\n\nfunction ellipsText(_ref, measureText) {\n  var text = _ref.text,\n      fontSize = _ref['font-size'],\n      fontFamily = _ref['font-family'],\n      maxWidth = _ref.maxWidth;\n  // eslint-disable-line import/prefer-default-export\n  text = typeof text === 'string' ? text : \"\".concat(text);\n\n  if (maxWidth === undefined) {\n    return text;\n  }\n\n  var textWidth = measureText({\n    text: text,\n    fontSize: fontSize,\n    fontFamily: fontFamily\n  }).width;\n\n  if (textWidth <= maxWidth) {\n    return text;\n  }\n\n  var min = 0;\n  var max = text.length - 1;\n\n  while (min <= max) {\n    var reduceIndex = Math.floor((min + max) / 2);\n    var reduceText = text.substr(0, reduceIndex) + ELLIPSIS_CHAR;\n    textWidth = measureText({\n      text: reduceText,\n      fontSize: fontSize,\n      fontFamily: fontFamily\n    }).width;\n\n    if (textWidth <= maxWidth) {\n      min = reduceIndex + 1;\n    } else {\n      // textWidth > maxWidth\n      max = reduceIndex - 1;\n    }\n  }\n\n  return text.substr(0, max) + ELLIPSIS_CHAR;\n}\n\n/**\n * Currently some browsers, IE11 and Edge confirmed, doesn't support the dominant-baseline svg-attribute and\n * the browser that does, have different implementations. Thus giving an unpredictable result when rendering'\n * text and predicting it's position (ex. in collision detection).\n *\n * To supplement and the aid in aligning/positioning text with various items, this function can be used\n * to follow a common heuristic across supported renderers.\n * @ignore\n * @param {object} textNode\n * @param {string|number} [textNode['font-size']=0] - String in px format or number\n * @param {string} [textNode['dominant-baseline']] - If baseline is omitted dominant-baseline is used\n * @param {string} [textNode.baseline]\n * @returns {number} Delta-y required to adjust for baseline\n */\nfunction baselineHeuristic(textNode) {\n  var baseline = textNode.baseline || textNode['dominant-baseline'];\n  var dy = 0;\n  var fontSize = parseInt(textNode.fontSize || textNode['font-size'], 10) || 0;\n\n  switch (baseline) {\n    case 'hanging':\n      dy = fontSize * 0.75;\n      break;\n\n    case 'text-before-edge':\n      dy = fontSize * 0.85;\n      break;\n\n    case 'middle':\n      dy = fontSize * 0.25;\n      break;\n\n    case 'central':\n      dy = fontSize * 0.35;\n      break;\n\n    case 'mathemetical':\n      dy = fontSize / 2;\n      break;\n\n    case 'text-after-edge':\n    case 'ideographic':\n      dy = -fontSize * 0.2;\n      break;\n\n    default:\n      dy = 0;\n      break;\n  }\n\n  return dy;\n}\n\nvar heightCache = {};\nvar widthCache = {};\nvar contextCache = {\n  fontSize: undefined,\n  fontFamily: undefined\n};\nvar context;\n\nfunction setContext() {\n  context = context || document.createElement('canvas').getContext('2d');\n}\n\nfunction setFont(fontSize, fontFamily) {\n  if (contextCache.fontSize === fontSize && contextCache.fontFamily === fontFamily) {\n    return;\n  }\n\n  context.font = fontSize + ' ' + fontFamily; // eslint-disable-line\n\n  contextCache.fontSize = fontSize;\n  contextCache.fontFamily = fontFamily;\n}\n\nfunction measureTextWidth(text, fontSize, fontFamily) {\n  var key = text + fontSize + fontFamily;\n\n  if (typeof widthCache[key] !== 'number') {\n    setContext();\n    setFont(fontSize, fontFamily);\n    widthCache[key] = context.measureText(text).width;\n  }\n\n  return widthCache[key];\n}\n\nfunction measureTextHeight(fontSize) {\n  if (typeof heightCache[fontSize] !== 'number') {\n    heightCache[fontSize] = fontSizeToHeight(fontSize);\n  }\n\n  return heightCache[fontSize];\n}\n/**\n * @private\n * @param {object} opts\n * @param {string} opts.text - Text to measure\n * @param {string} opts.fontSize - Font size with a unit definition, ex. 'px' or 'em'\n * @param {string} opts.fontFamily - Font family\n * @return {object} Width and height of text in pixels\n * @example\n * measureText({\n *  text: 'my text',\n *  fontSize: '12px',\n *  fontFamily: 'Arial'\n * }); // returns { width: 20, height: 12 }\n */\n\n\nfunction measureText$1(_ref) {\n  var text = _ref.text,\n      fontSize = _ref.fontSize,\n      fontFamily = _ref.fontFamily;\n  var w = measureTextWidth(text, fontSize, fontFamily);\n  var h = measureTextHeight(fontSize);\n  return {\n    width: w,\n    height: h\n  };\n}\n/**\n * Calculates the bounding rectangle of a text node.\n * The bounding rectangle is a approximate of the \"em square\" seen here (http://www.w3resource.com/html5-canvas/html5-canvas-text.php)\n * @ignore\n * @param {object} attrs - Text node definition\n * @param {number} [attrs.x] - X-coordinate\n * @param {number} [attrs.y] - Y-coordinate\n * @param {number} [attrs.dx] - Delta x-coordinate\n * @param {number} [attrs.dy] - Delta y-coordinate\n * @param {string} [attrs.anchor] - Text anchor\n * @param {number} [attrs.maxWidth] - Maximum allowed text width\n * @return {object} The bounding rectangle\n */\n\nfunction calcTextBounds(attrs) {\n  var measureFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : measureText$1;\n  var fontSize = attrs['font-size'] || attrs.fontSize;\n  var fontFamily = attrs['font-family'] || attrs.fontFamily;\n  var textMeasure = measureFn({\n    text: attrs.text,\n    fontFamily: fontFamily,\n    fontSize: fontSize\n  });\n  var calWidth = Math.min(attrs.maxWidth || textMeasure.width, textMeasure.width); // Use actual value if max is not set\n\n  var x = attrs.x || 0;\n  var y = attrs.y || 0;\n  var dx = attrs.dx || 0;\n  var dy = (attrs.dy || 0) + baselineHeuristic(attrs);\n  var boundingRect = {\n    x: 0,\n    y: y + dy - textMeasure.height * 0.75,\n    // Magic number for alphabetical baseline\n    width: calWidth,\n    height: textMeasure.height\n  };\n  var anchor = attrs['text-anchor'] || attrs.anchor;\n\n  if (anchor === 'middle') {\n    boundingRect.x = x + dx - calWidth / 2;\n  } else if (anchor === 'end') {\n    boundingRect.x = x + dx - calWidth;\n  } else {\n    boundingRect.x = x + dx;\n  }\n\n  return boundingRect;\n}\n/**\n * Calculates the bounding rectangle of a text node. Including any line breaks.\n * @ignore\n * @param {object} node\n * @param {string} node.text - Text to measure\n * @param {number} [node.x=0] - X-coordinate\n * @param {number} [node.y=0] - Y-coordinate\n * @param {number} [node.dx=0] - Delta x-coordinate\n * @param {number} [node.dy=0] - Delta y-coordinate\n * @param {string} [node.anchor='start'] - Text anchor\n * @param {string} [node.fontSize] - Font size\n * @param {string} [node.fontFamily] - Font family\n * @param {string} [node['font-size']] - Font size\n * @param {string} [node['font-family']] - Font family\n * @param {string} [node.wordBreak] - Word-break option\n * @param {number} [node.maxWidth] - Maximum allowed text width\n * @param {number} [node.maxHeight] - Maximum allowed text height. If both maxLines and maxHeight are set, the property that results in the fewest number of lines is used\n * @param {number} [node.maxLines] - Maximum number of lines allowed.\n * @param {number} [node.lineHeight=1.2] - Line height\n * @param {function} [measureFn] - Optional text measure function\n * @return {object} The bounding rectangle\n */\n\n\nfunction textBounds(node) {\n  var measureFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : measureText$1;\n  var lineBreakFn = resolveLineBreakAlgorithm(node);\n  var fontSize = node['font-size'] || node.fontSize;\n  var fontFamily = node['font-family'] || node.fontFamily;\n  var tm = measureFn({\n    text: node.text,\n    fontFamily: fontFamily,\n    fontSize: fontSize\n  });\n\n  if (lineBreakFn && (tm.width > node.maxWidth || includesLineBreak(node.text))) {\n    var resolvedLineBreaks = lineBreakFn(node, function (text) {\n      return measureFn({\n        text: text,\n        fontFamily: fontFamily,\n        fontSize: fontSize\n      });\n    });\n    var nodeCopy = extend({}, node);\n    var maxWidth = 0;\n    var widestLine = '';\n\n    for (var i = 0, len = resolvedLineBreaks.lines.length; i < len; i++) {\n      var line = resolvedLineBreaks.lines[i];\n      line += i === len - 1 && resolvedLineBreaks.reduced ? ELLIPSIS_CHAR : '';\n      var width = measureFn({\n        text: line,\n        fontSize: fontSize,\n        fontFamily: fontFamily\n      }).width;\n\n      if (width >= maxWidth) {\n        maxWidth = width;\n        widestLine = line;\n      }\n    }\n\n    nodeCopy.text = widestLine;\n    var bounds = calcTextBounds(nodeCopy, measureFn);\n    bounds.height = fontSizeToLineHeight(node) * resolvedLineBreaks.lines.length;\n    return bounds;\n  }\n\n  return calcTextBounds(node, measureFn);\n}\n\nvar LINE_HEIGHT = 1.2;\nvar CIRCLE_FACTOR = 0.9;\n\nfunction cbContext$2(node, chart) {\n  return {\n    node: node,\n    data: node.data,\n    scale: chart.scale,\n    formatter: chart.formatter,\n    dataset: chart.dataset\n  };\n}\n\nfunction placeTextInRect$1(rect, text, opts) {\n  var label = {\n    type: 'text',\n    text: text,\n    maxWidth: rect.width,\n    x: 0,\n    y: rect.y,\n    dx: 0,\n    dy: 0,\n    fill: opts.fill,\n    anchor: 'start',\n    baseline: 'alphabetical',\n    fontSize: \"\".concat(opts.fontSize, \"px\"),\n    fontFamily: opts.fontFamily\n  };\n  var textMetrics = opts.textMetrics;\n\n  if (rect.width < opts.fontSize) {\n    return false;\n  }\n\n  var wiggleWidth = Math.max(0, rect.width - textMetrics.width);\n  label.x = rect.x + opts.align * wiggleWidth;\n  label.y = rect.y + textMetrics.height / LINE_HEIGHT;\n  return label;\n}\n\nfunction getRectFromCircle(_ref) {\n  var cx = _ref.cx,\n      cy = _ref.cy,\n      r = _ref.r;\n  return {\n    type: 'circle',\n    bounds: {\n      cx: cx,\n      cy: cy,\n      r: r\n    }\n  };\n}\n\nfunction getSliceBounds(slice) {\n  var EPSILON = 1e-12;\n  var start = slice.start,\n      end = slice.end,\n      innerRadius = slice.innerRadius,\n      outerRadius = slice.outerRadius,\n      offset = slice.offset;\n\n  if (Math.abs(start + 2 * Math.PI - end) > EPSILON) {\n    return {\n      type: null,\n      bounds: null\n    };\n  }\n\n  var r = innerRadius !== 0 ? innerRadius : outerRadius;\n  return getRectFromCircle({\n    cx: offset.x,\n    cy: offset.y,\n    r: r\n  });\n}\n\nfunction getBounds(node) {\n  if (node.desc && node.desc.slice) {\n    return getSliceBounds(node.desc.slice);\n  }\n\n  if (node.type === 'circle') {\n    return getRectFromCircle(node.attrs);\n  }\n\n  if (node.type === 'rect') {\n    return {\n      type: 'rect',\n      bounds: node.bounds\n    };\n  } // defualt to node.bounds ?\n\n\n  return {\n    type: null,\n    bounds: null\n  };\n}\n/**\n * @typedef {object} component--labels~rows-label-strategy\n *\n */\n\n/**\n * @typedef {object} component--labels~rows-label-strategy.settings\n * @property {string} [fontFamily='Arial']\n * @property {number} [fontSize=12]\n * @property {number} [justify=0.5]\n * @property {number} [padding=4]\n * @property {Array<object>} labels\n * @property {string|function} labels[].label - The text value\n * @property {function} labels[].linkData - Link data to the label\n * @property {number} [labels[].align=0.5]\n * @property {string|function} [labels[].fill='#333']\n */\n\n\nfunction rows(_ref2) {\n  var settings = _ref2.settings,\n      chart = _ref2.chart,\n      nodes = _ref2.nodes,\n      renderer = _ref2.renderer,\n      style = _ref2.style;\n  var placer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : placeTextInRect$1;\n  var defaults = extend({\n    fontSize: 12,\n    fontFamily: 'Arial',\n    fill: '#333',\n    padding: 4,\n    align: 0.5,\n    justify: 0.5\n  }, style.label);\n  defaults.fontSize = parseInt(defaults.fontSize, 10);\n  var rowSettings = extend({}, defaults, settings);\n  var labelSettings = settings.labels.map(function (labelSetting) {\n    return extend({}, rowSettings, labelSetting);\n  });\n  var labelStruct = {};\n  var labels = [];\n\n  for (var i = 0, len = nodes.length; i < len; i++) {\n    var node = nodes[i];\n    var arg = cbContext$2(node, chart);\n\n    var _getBounds = getBounds(node),\n        type = _getBounds.type,\n        bounds = _getBounds.bounds;\n\n    if (!bounds) {\n      continue;\n    }\n\n    var totalHeight = 0;\n    var measurements = [];\n    var texts = [];\n    var maxHeight = type === 'circle' ? 2 * bounds.r * CIRCLE_FACTOR : bounds.height;\n    totalHeight += rowSettings.padding;\n    var j = void 0;\n\n    for (j = 0; j < labelSettings.length; j++) {\n      var lblStngs = labelSettings[j];\n      var text = typeof lblStngs.label === 'function' ? lblStngs.label(arg, i) : '';\n      labelStruct.fontFamily = lblStngs.fontFamily;\n      labelStruct.fontSize = \"\".concat(lblStngs.fontSize, \"px\");\n      labelStruct.text = text;\n      var measured = renderer.measureText(labelStruct);\n      totalHeight += measured.height + lblStngs.padding;\n\n      if (totalHeight > maxHeight) {\n        break;\n      }\n\n      texts.push(text);\n      measurements.push(measured);\n    }\n\n    var labelCount = j;\n    var wiggleHeight = Math.max(0, maxHeight - totalHeight);\n    var currentY = void 0;\n\n    if (type === 'circle') {\n      currentY = bounds.cy - bounds.r * CIRCLE_FACTOR;\n    } else {\n      currentY = bounds.y;\n    }\n\n    currentY += rowSettings.justify * wiggleHeight + rowSettings.padding;\n\n    for (j = 0; j < labelCount; j++) {\n      var _lblStngs = labelSettings[j];\n      var rect = void 0;\n\n      if (type === 'circle') {\n        var maxYDistToCenter = Math.max(Math.abs(currentY - bounds.cy), Math.abs(currentY + measurements[j].height - bounds.cy));\n        var halfWidth = Math.sqrt(bounds.r * bounds.r - maxYDistToCenter * maxYDistToCenter);\n        rect = {\n          x: bounds.cx - halfWidth + rowSettings.padding,\n          y: currentY,\n          width: 2 * halfWidth - 2 * rowSettings.padding,\n          height: measurements[j].height\n        };\n      } else {\n        rect = {\n          x: bounds.x + rowSettings.padding,\n          y: currentY,\n          width: bounds.width - 2 * rowSettings.padding,\n          height: measurements[j].height\n        };\n      }\n\n      currentY += measurements[j].height + rowSettings.padding;\n      var fill = typeof _lblStngs.fill === 'function' ? _lblStngs.fill(arg, i) : _lblStngs.fill;\n      var linkData = typeof _lblStngs.linkData === 'function' ? _lblStngs.linkData(arg, i) : undefined;\n      var label = placer(rect, texts[j], {\n        fill: fill,\n        align: _lblStngs.align,\n        fontSize: _lblStngs.fontSize,\n        fontFamily: _lblStngs.fontFamily,\n        textMetrics: measurements[j]\n      });\n\n      if (label) {\n        if (label.text && label.text !== ELLIPSIS_CHAR) {\n          var ellipsed = ellipsText(label, renderer.measureText);\n\n          if (ELLIPSIS_CHAR === ellipsed) {\n            // don't include label if it's only an ellipsis\n            continue;\n          }\n\n          label.ellipsed = ellipsed;\n        }\n\n        if (typeof linkData !== 'undefined') {\n          label.data = linkData;\n        }\n\n        labels.push(label);\n      }\n    }\n  }\n\n  return labels;\n}\n\nvar strategies = {\n  bar: bars,\n  slice: slices,\n  rows: rows\n};\n\n/**\n * @typedef {object} component--labels\n * @property {string} [type='labels']\n */\n\n/**\n * @typedef {object} component--labels.settings\n * @property {Array<object>} sources\n * @property {string} sources[].component\n * @property {string} sources[].selector\n * @property {component--labels~label-strategy} sources[].strategy\n */\n\nfunction strategy(_ref, fn) {\n  var chart = _ref.chart,\n      source = _ref.source,\n      rect = _ref.rect,\n      renderer = _ref.renderer,\n      style = _ref.style;\n  var component = chart.component(source.component);\n\n  if (!component) {\n    return [];\n  }\n\n  var nodes = chart.findShapes(source.selector).filter(function (n) {\n    return n.key === source.component;\n  });\n  return fn({\n    chart: chart,\n    settings: source.strategy.settings,\n    nodes: nodes,\n    rect: {\n      x: 0,\n      y: 0,\n      width: rect.width,\n      height: rect.height\n    },\n    renderer: renderer,\n    style: style\n  });\n}\nvar labelsComponent = {\n  require: ['chart', 'renderer', 'settings'],\n  defaultSettings: {\n    settings: {},\n    style: {\n      label: '$label'\n    }\n  },\n  render: function render() {\n    var _this = this;\n\n    var stngs = this.settings.settings;\n    var labels = [];\n    (stngs.sources || []).forEach(function (source) {\n      if (source.strategy && strategies[source.strategy.type] && source.component) {\n        labels.push.apply(labels, _toConsumableArray$1(strategy({\n          chart: _this.chart,\n          rect: _this.rect,\n          renderer: _this.renderer,\n          source: source,\n          style: _this.style\n        }, strategies[source.strategy.type])));\n      }\n    });\n    return labels;\n  }\n};\n\nfunction labels(picasso) {\n  picasso.component('labels', labelsComponent);\n}\n\n/**\n * @typedef {object}\n * @alias component--legend-cat.settings\n */\n\nvar DEFAULT_SETTINGS$6 = {\n  /**\n   * @typedef {object=}\n   */\n  layout: {\n    /**\n     * Maximum number of columns (vertical) or rows (horizontal)\n     * @type {number=}\n     */\n    size: 1,\n\n    /**\n     * Layout direction. Either `'ltr'` or `'rtl'`\n     * @type {string=}\n     */\n    direction: 'ltr',\n\n    /** Initial scroll offset\n     * @type {number=} */\n    scrollOffset: 0\n  },\n\n  /**\n   * Settings applied per item\n   * @typedef {object=}\n   */\n  item: {\n    /** Whether to show the current item\n     * @type {boolean=} */\n    show: true,\n    justify: 0.5,\n    align: 0.5,\n\n    /**\n     * @typedef {object=} */\n    label: {\n      fontSize: '12px',\n      fontFamily: 'Arial',\n      fill: '#595959',\n\n      /** Word break rule, how to apply line break if label text overflows its maxWidth property. Either `'break-word'` or `'break-all'`\n       * @type {string=} */\n      wordBreak: 'none',\n\n      /** Max number of lines allowed if label is broken into multiple lines (only applicable with wordBreak)\n       * @type {number=} */\n      maxLines: 2,\n\n      /** Maximum width of label, in px\n       * @type {number=} */\n      maxWidth: 136,\n      lineHeight: 1.2\n    },\n\n    /**\n     * @typedef {object=} */\n    shape: {\n      /**\n       * @type {string=} */\n      type: 'square',\n\n      /**\n       * @type {number=} */\n      size: 12\n    }\n  },\n\n  /**\n   * @typedef {object=} */\n  title: {\n    /** Whether to show the title\n     * @type {boolean=} */\n    show: true,\n\n    /** Title text. Defaults to the title of the provided data field\n     * @type {string=} */\n    text: undefined,\n\n    /** Horizontal alignment of the text. Allowed values are `'start'`, `'middle'` and `'end'`\n     * @type {string}\n     */\n    anchor: 'start',\n    fontSize: '16px',\n    fontFamily: 'Arial',\n    fill: '#595959',\n\n    /** Word break rule, how to apply line break if label text overflows its maxWidth property. Either `'break-word'` or `'break-all'`\n     * @type {string=} */\n    wordBreak: 'none',\n\n    /** Max number of lines allowed if label is broken into multiple lines, is only appled when `wordBreak` is not set to `'none'`\n     * @type {number=} */\n    maxLines: 2,\n\n    /** Maximum width of title, in px\n     * @type {number=} */\n    maxWidth: 156,\n    lineHeight: 1.25\n  },\n\n  /**\n   * @typedef {object=} */\n  navigation: {\n    /**\n     * @typedef {object=} */\n    button: {\n      /**\n       * @type {object<string, boolean>=} */\n      class: undefined,\n\n      /**\n       * @type {function} */\n      content: undefined\n    },\n\n    /** Whether the button should be disabled or not\n     * @type {boolean=} */\n    disabled: false\n  }\n};\n/**\n * Resolve settings based on input, defaults, and data\n *\n * @ignore\n * @param {legendComponent} comp - The component instance\n */\n\nfunction resolveSettings$2(comp) {\n  var domain = comp.scale.domain();\n  var data = {\n    items: []\n  };\n  var dock = comp.settings.layout.dock;\n\n  if (comp.scale.type === 'threshold-color') {\n    var fields = comp.scale.data().fields;\n    var sourceField = fields[0];\n\n    var formatter = function formatter(v) {\n      return String(v);\n    };\n\n    if (comp.settings.formatter) {\n      formatter = comp.chart.formatter(comp.settings.formatter);\n    } else if (sourceField) {\n      formatter = sourceField.formatter();\n    }\n\n    for (var i = 0; i < domain.length - 1; i++) {\n      var it = {\n        value: domain[i],\n        label: \"\".concat(formatter(domain[i]), \" - < \").concat(formatter(domain[i + 1]))\n      };\n\n      if (sourceField) {\n        it.source = {\n          field: sourceField.id()\n        };\n      }\n\n      data.items.push(it);\n    }\n\n    var orientation = dock === 'top' || dock === 'bottom' ? 'horizontal' : 'vertical';\n\n    if (orientation === 'vertical') {\n      data.items.reverse();\n    }\n  } else {\n    var _labels = comp.scale.labels ? comp.scale.labels() : null;\n\n    data.items = domain.map(function (d, idx) {\n      var datum = comp.scale.datum ? extend({}, comp.scale.datum(d)) : {\n        value: d\n      };\n      datum.value = d;\n\n      if (comp.scale.label) {\n        datum.label = comp.scale.label(d);\n      } else if (_labels) {\n        datum.label = _labels[idx];\n      }\n\n      return datum;\n    });\n  }\n\n  var title = comp.resolver.resolve({\n    data: {\n      fields: comp.scale.data().fields\n    },\n    defaults: extend(true, {}, DEFAULT_SETTINGS$6.title, comp.style.title),\n    settings: comp.settings.settings.title\n  });\n  var layout = comp.resolver.resolve({\n    data: {\n      fields: comp.scale.data().fields\n    },\n    defaults: DEFAULT_SETTINGS$6.layout,\n    settings: comp.settings.settings.layout\n  });\n  var labels = comp.resolver.resolve({\n    data: data,\n    defaults: extend(true, {}, DEFAULT_SETTINGS$6.item.label, comp.style.item.label),\n    settings: (comp.settings.settings.item || {}).label\n  });\n  var shapeSettings = extend(true, {}, (comp.settings.settings.item || {}).shape);\n\n  if (typeof shapeSettings.fill === 'undefined' && comp.settings.scale) {\n    shapeSettings.fill = {\n      scale: comp.settings.scale\n    };\n  }\n\n  var symbols = comp.resolver.resolve({\n    data: data,\n    defaults: extend(true, {}, DEFAULT_SETTINGS$6.item.shape, comp.style.item.shape),\n    settings: shapeSettings\n  });\n  var items = comp.resolver.resolve({\n    data: data,\n    defaults: extend(true, {}, {\n      show: DEFAULT_SETTINGS$6.item.show\n    }),\n    settings: {\n      show: (comp.settings.settings.item || {}).show\n    }\n  });\n\n  function range(item, i) {\n    var v = item.data.value;\n    var next = domain[i + 1];\n    item.data.value = [v, next];\n  }\n\n  if (comp.scale.type === 'threshold-color') {\n    var _orientation = dock === 'top' || dock === 'bottom' ? 'horizontal' : 'vertical';\n\n    if (_orientation === 'vertical') {\n      items.items.reverse().forEach(range);\n      items.items.reverse();\n    } else {\n      items.items.forEach(range);\n    }\n  }\n\n  return {\n    title: title,\n    labels: labels,\n    symbols: symbols,\n    items: items,\n    layout: layout\n  };\n}\n\n/* eslint no-mixed-operators:0 */\n\nfunction placeTextInRect$2(rect, label, opts) {\n  var textMetrics = opts.textMetrics;\n\n  if (rect.height < textMetrics.height) {\n    return false;\n  }\n\n  var wiggleWidth = Math.max(0, rect.width - textMetrics.width);\n  label.baseline = 'text-before-edge';\n  var wiggleHeight = Math.max(0, rect.height - textMetrics.height);\n  label.x = rect.x + opts.align * wiggleWidth;\n  label.y = rect.y + opts.justify * wiggleHeight + parseInt(label.fontSize, 10) * 0.175; // 0.175 - basline offset\n\n  return label;\n}\n\nfunction wiggleSymbol(container, size, opts) {\n  var wiggleWidth = Math.max(0, container.width - size);\n  var wiggleHeight = Math.max(0, container.height - size);\n  return {\n    x: container.x + size / 2 + opts.align * wiggleWidth,\n    y: container.y + size / 2 + opts.justify * wiggleHeight\n  };\n}\n\nfunction createRenderItem(_ref) {\n  var _ref$x = _ref.x,\n      x = _ref$x === void 0 ? 0 : _ref$x,\n      y = _ref.y,\n      item = _ref.item,\n      globalMetrics = _ref.globalMetrics,\n      _ref$symbolFn = _ref.symbolFn,\n      symbolFn = _ref$symbolFn === void 0 ? create$3 : _ref$symbolFn,\n      _ref$direction = _ref.direction,\n      direction = _ref$direction === void 0 ? 'ltr' : _ref$direction;\n  var label = item.label.displayObject;\n  var labelBounds = item.label.bounds;\n  var symbolItem = item.symbol.meta;\n  var rtl = direction === 'rtl';\n  var labelRect = {\n    x: rtl ? x + globalMetrics.maxLabelBounds.width : x + globalMetrics.maxSymbolSize + globalMetrics.spacing,\n    y: y,\n    width: globalMetrics.maxLabelBounds.width,\n    height: Math.max(globalMetrics.maxSymbolSize, globalMetrics.maxLabelBounds.height)\n  };\n  var wiggled = wiggleSymbol({\n    x: rtl ? x + globalMetrics.maxLabelBounds.width + globalMetrics.spacing : x,\n    y: y,\n    width: globalMetrics.maxSymbolSize,\n    height: labelRect.height\n  }, symbolItem.size, {\n    align: typeof symbolItem.align === 'undefined' ? 0.5 : symbolItem.align,\n    justify: typeof symbolItem.justify === 'undefined' ? 0.5 : symbolItem.justify\n  });\n  var symbol = symbolFn(extend({}, symbolItem, wiggled));\n  delete symbol.collider;\n  label.anchor = rtl ? 'end' : 'start';\n  placeTextInRect$2(labelRect, label, {\n    textMetrics: labelBounds,\n    fontSize: parseInt(label.fontSize, 10),\n    align: 0.0,\n    justify: 0.5\n  });\n  var container = {\n    type: 'container',\n    data: item.label.displayObject.data,\n    children: [symbol, label],\n    collider: {\n      type: 'rect',\n      x: x,\n      y: y,\n      width: globalMetrics.maxItemBounds.width,\n      height: globalMetrics.maxItemBounds.height\n    }\n  };\n  return {\n    item: container,\n    metrics: labelRect\n  };\n}\n\nfunction _getItemsToRender(_ref2, rect, _ref3) {\n  var viewRect = _ref2.viewRect;\n  var itemized = _ref3.itemized,\n      _ref3$create = _ref3.create,\n      create = _ref3$create === void 0 ? createRenderItem : _ref3$create,\n      parallels = _ref3.parallels;\n  var direction = itemized.layout.direction;\n  var globalMetrics = itemized.globalMetrics;\n  var legendItems = itemized.items;\n  var isHorizontal = itemized.layout.orientation === 'horizontal';\n  var s = 0;\n  var renderItems = [];\n  var fixedHeight = globalMetrics.maxItemBounds.height;\n  var fixedWidth = globalMetrics.maxItemBounds.width;\n  var rowHeight = itemized.layout.margin.vertical + fixedHeight;\n  var columnWidth = itemized.layout.margin.horizontal + fixedWidth;\n  var x = rect.x;\n  var y = rect.y;\n  var shift = viewRect.x - rect.x;\n\n  for (var i = 0; i < legendItems.length; i++) {\n    var renderItem = create({\n      y: y,\n      x: direction === 'rtl' ? viewRect.x + shift + viewRect.width - fixedWidth - (x - rect.x) : x,\n      item: legendItems[i],\n      globalMetrics: globalMetrics,\n      direction: direction\n    });\n\n    if (isHorizontal && x >= viewRect.x - fixedWidth || !isHorizontal && y >= viewRect.y - fixedHeight) {\n      renderItems.push(renderItem.item);\n    }\n\n    s++;\n\n    if (s >= parallels) {\n      s = 0;\n\n      if (isHorizontal) {\n        x += columnWidth; // next column\n\n        y = rect.y; // reset y to first row\n      } else {\n        y += rowHeight; // next row\n\n        x = rect.x; // reset x to first column\n      }\n    } else if (isHorizontal) {\n      y += rowHeight; // next row\n    } else {\n      x += columnWidth; // next column\n    }\n\n    if (!isHorizontal && y > viewRect.y + viewRect.height) {\n      break;\n    } else if (isHorizontal && x > viewRect.x + viewRect.width) {\n      break;\n    }\n  }\n\n  return renderItems;\n}\n\nfunction _itemize(_ref4, renderer) {\n  var resolved = _ref4.resolved,\n      dock = _ref4.dock;\n  var label;\n  var items = [];\n  var item;\n  var sourceItems = resolved.items.items;\n  var sourceSymbols = resolved.symbols.items;\n  var sourceLabels = resolved.labels.items;\n  var maxSymbolSize = 0;\n  var maxLabelWidth = 0;\n  var maxLabelHeight = 0;\n\n  for (var i = 0; i < sourceItems.length; i++) {\n    if (sourceItems[i].show === false) {\n      continue;\n    }\n\n    var text = typeof sourceLabels[i].text !== 'undefined' ? sourceLabels[i].text : sourceLabels[i].data.label || '';\n    label = extend({}, sourceLabels[i], {\n      // create the displayObject here in order to measure it\n      type: 'text',\n      fontSize: \"\".concat(parseInt(sourceLabels[i].fontSize, 10), \"px\"),\n      text: text,\n      title: text\n    });\n    item = {\n      symbol: {\n        // can't create a displayObject here due to need to wiggle the center position of the symbol later on,\n        // just store the object needed later on\n        meta: sourceSymbols[i]\n      },\n      label: {\n        displayObject: label,\n        bounds: renderer.textBounds(label)\n      }\n    };\n    items.push(item);\n    maxSymbolSize = Math.max(sourceSymbols[i].size, maxSymbolSize);\n    maxLabelWidth = Math.max(item.label.bounds.width, maxLabelWidth);\n    maxLabelHeight = Math.max(item.label.bounds.height, maxLabelHeight);\n  }\n\n  return {\n    items: items,\n    globalMetrics: {\n      spacing: 8,\n      maxSymbolSize: maxSymbolSize,\n      maxItemBounds: {\n        height: Math.max(maxSymbolSize, maxLabelHeight),\n        width: maxSymbolSize + 8 + maxLabelWidth\n      },\n      maxLabelBounds: {\n        width: maxLabelWidth,\n        height: maxLabelHeight\n      }\n    },\n    layout: {\n      margin: {\n        vertical: typeof resolved.layout.item.vertical !== 'undefined' ? resolved.layout.item.vertical : 4,\n        horizontal: typeof resolved.layout.item.horizontal !== 'undefined' ? resolved.layout.item.horizontal : 4\n      },\n      mode: resolved.layout.item.mode,\n      size: resolved.layout.item.size,\n      orientation: dock === 'top' || dock === 'bottom' ? 'horizontal' : 'vertical',\n      direction: resolved.layout.item.direction,\n      scrollOffset: resolved.layout.item.scrollOffset\n    }\n  };\n}\n\nfunction _extent(itemized, parallels) {\n  var count = itemized.items.length;\n  var size = Math.ceil(count / parallels);\n  var property = itemized.layout.orientation === 'horizontal' ? 'width' : 'height';\n  var margin = property === 'width' ? 'horizontal' : 'vertical';\n  return itemized.globalMetrics.maxItemBounds[property] * size + (size - 1) * itemized.layout.margin[margin];\n}\n\nfunction _spread(itemized, parallels) {\n  var size = parallels;\n  var property = itemized.layout.orientation === 'horizontal' ? 'height' : 'width';\n  var margin = property === 'width' ? 'horizontal' : 'vertical';\n  return itemized.globalMetrics.maxItemBounds[property] * size + // expected vertical size of items\n  (size - 1) * itemized.layout.margin[margin]; // expected spacing between items\n}\n\nfunction _parallelize(availableExtent, availableSpread, itemized) {\n  var count = itemized.items.length;\n  var extentProperty = itemized.layout.orientation === 'horizontal' ? 'width' : 'height';\n  var margin = extentProperty === 'width' ? 'horizontal' : 'vertical';\n  var extentInPx = itemized.globalMetrics.maxItemBounds[extentProperty] * count + (count - 1) * itemized.layout.margin[margin];\n  var numNeeded = Math.ceil(extentInPx / availableExtent);\n\n  if (availableSpread != null) {\n    var spreadProperty = itemized.layout.orientation === 'horizontal' ? 'height' : 'width';\n    var numAllowed = Math.floor(availableSpread / (4 + itemized.globalMetrics.maxItemBounds[spreadProperty]));\n    numNeeded = Math.min(numNeeded, numAllowed);\n  }\n\n  var numInput = isNaN(itemized.layout.size) ? 1 : itemized.layout.size;\n  return Math.max(1, Math.min(numNeeded, numInput));\n}\nfunction itemRendererFactory (legend, _ref5) {\n  var _ref5$onScroll = _ref5.onScroll,\n      onScroll = _ref5$onScroll === void 0 ? function () {} : _ref5$onScroll;\n  var itemized;\n  var parallels;\n  var viewRect;\n  var containerRect;\n  var _offset = null;\n  var overflow = 0;\n  var api = {\n    itemize: function itemize(obj) {\n      itemized = _itemize(obj, legend.renderer);\n      _offset = !isNaN(itemized.layout.scrollOffset) ? itemized.layout.scrollOffset : _offset; // Set the initial offset\n    },\n    getItemsToRender: function getItemsToRender(obj) {\n      viewRect = obj.viewRect;\n      overflow = api.getContentOverflow(viewRect);\n      var ext = api.extent();\n      _offset = Math.max(0, Math.min(_offset, overflow));\n      containerRect = extend({}, viewRect);\n      var offsetProperty = api.orientation() === 'horizontal' ? 'x' : 'y';\n      containerRect[offsetProperty] -= _offset;\n      containerRect[offsetProperty === 'x' ? 'width' : 'height'] = ext;\n      return _getItemsToRender(obj, containerRect, {\n        itemized: itemized,\n        parallels: parallels\n      });\n    },\n    parallelize: function parallelize(availableExtent, availableSpread) {\n      parallels = _parallelize(availableExtent, availableSpread, itemized);\n      return parallels;\n    },\n    hasContentOverflow: function hasContentOverflow() {\n      var property = itemized.layout.orientation === 'horizontal' ? 'width' : 'height';\n      return _extent(itemized, parallels) > viewRect[property];\n    },\n    getContentOverflow: function getContentOverflow() {\n      var rect = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : viewRect;\n      var property = itemized.layout.orientation === 'horizontal' ? 'width' : 'height';\n      return Math.max(0, _extent(itemized, parallels) - rect[property]);\n    },\n    getNextSize: function getNextSize() {\n      // TODO - calculate the actual size to next item to ensure alignment\n      var property = itemized.layout.orientation === 'horizontal' ? 'width' : 'height';\n      var margin = property === 'width' ? 'horizontal' : 'vertical';\n      return itemized.globalMetrics.maxItemBounds[property] + itemized.layout.margin[margin];\n    },\n    getPrevSize: function getPrevSize() {\n      // TODO - calculate the actual size to next item to ensure alignment\n      var property = itemized.layout.orientation === 'horizontal' ? 'width' : 'height';\n      var margin = property === 'width' ? 'horizontal' : 'vertical';\n      return itemized.globalMetrics.maxItemBounds[property] + itemized.layout.margin[margin];\n    },\n    hasNext: function hasNext() {\n      if (api.orientation() === 'horizontal') {\n        return viewRect.x + viewRect.width < containerRect.x + containerRect.width;\n      }\n\n      return viewRect.y + viewRect.height < containerRect.y + containerRect.height;\n    },\n    hasPrev: function hasPrev() {\n      if (api.orientation() === 'horizontal') {\n        return containerRect.x < viewRect.x;\n      }\n\n      return containerRect.y < viewRect.y;\n    },\n    next: function next() {\n      api.scroll(-api.getNextSize());\n    },\n    prev: function prev() {\n      api.scroll(api.getPrevSize());\n    },\n    scroll: function scroll(delta) {\n      var current = Math.max(0, Math.min(overflow, _offset - delta));\n\n      if (current === _offset) {\n        return;\n      }\n\n      _offset = current;\n      onScroll();\n    },\n    offset: function offset() {\n      return _offset;\n    },\n    orientation: function orientation() {\n      return itemized.layout.orientation;\n    },\n    direction: function direction() {\n      return itemized.layout.direction;\n    },\n    extent: function extent() {\n      return _extent(itemized, parallels);\n    },\n    // total amount of space along orientation\n    spread: function spread() {\n      return _spread(itemized, parallels);\n    } // total amount of space perpendicular to orientation\n\n  };\n  return api;\n}\n\n/**\n * Concatenate object keys into a space separated string. Use for transforming a 'class name map' into a class string\n * @private\n * @param  {Object} classMap Object with class names as keys and true or false values depending on if they should be in the returned class string or not\n * @return {String} Space separated string with class names\n */\nfunction classString(classMap) {\n  return Object.keys(classMap).filter(function (className) {\n    return classMap[className];\n  }).join(' ');\n}\n\nvar DIR = {\n  up: \"\\u25B2\",\n  right: \"\\u25B6\",\n  down: \"\\u25BC\",\n  left: \"\\u25C0\"\n};\n\nfunction _itemize$1(_ref) {\n  var dock = _ref.dock,\n      navigation = _ref.navigation;\n  return {\n    layout: {\n      orientation: dock === 'top' || dock === 'bottom' ? 'vertical' : 'horizontal'\n    },\n    navigation: navigation\n  };\n}\n\nfunction btn(h, _ref2) {\n  var size = _ref2.size,\n      isActive = _ref2.isActive,\n      direction = _ref2.direction,\n      nav = _ref2.nav,\n      attrs = _ref2.attrs;\n  var c = {};\n  var content = '';\n\n  if (nav && nav.button) {\n    if (typeof nav.button.class === 'function') {\n      c = nav.button.class({\n        direction: direction\n      });\n    } else if (nav.button.class) {\n      c = nav.button.class;\n    }\n\n    if (typeof nav.button.content === 'function') {\n      content = nav.button.content(h, {\n        direction: direction\n      });\n    }\n  }\n\n  var style = {\n    width: \"\".concat(size, \"px\"),\n    minWidth: \"\".concat(size, \"px\"),\n    height: \"\".concat(size, \"px\")\n  };\n\n  if (!Object.keys(c).length) {\n    // if no classes are set, add some basic styling\n    style.border = '0';\n    style.background = 'none';\n  }\n\n  var attrsMerged = attrs;\n\n  if (!isActive || nav && nav.disabled) {\n    attrsMerged.disabled = 'disabled';\n  }\n\n  return h('button', extend({\n    class: classString(c),\n    style: style\n  }, attrsMerged), [content || h('span', {\n    style: {\n      pointerEvents: 'none'\n    }\n  }, [DIR[direction]])]);\n}\n\nfunction _render$1(renderer, _ref3, itemized, legend) {\n  var rect = _ref3.rect,\n      itemRenderer = _ref3.itemRenderer;\n\n  if (!renderer || !renderer.renderArgs) {\n    return;\n  }\n\n  renderer.size(rect);\n  var h = renderer.renderArgs[0];\n  var isVertical = itemized.layout.orientation === 'vertical'; // orientation of the navigation (not the legend)\n\n  var isRtl = itemRenderer.direction() === 'rtl';\n  var hasNext = itemRenderer.hasNext();\n  var hasPrev = itemRenderer.hasPrev();\n\n  if (!hasPrev && !hasNext) {\n    renderer.render([]);\n    return;\n  }\n\n  var buttonSize = 32;\n  var order = isVertical ? ['right', 'left'] : ['down', 'up'];\n\n  if (isRtl && isVertical) {\n    order.reverse();\n  }\n\n  var nodes = [h('div', {\n    style: {\n      position: 'relative',\n      display: 'flex',\n      'flex-direction': isVertical ? 'column' : 'row',\n      'justify-content': 'center',\n      height: '100%',\n      pointerEvents: 'auto'\n    },\n    dir: isRtl && !isVertical ? 'rtl' : 'ltr'\n  }, [btn(h, {\n    size: buttonSize,\n    isActive: hasNext,\n    direction: order[0],\n    attrs: {\n      'data-action': 'next',\n      'data-component-key': legend.settings.key\n    },\n    nav: itemized.navigation\n  }), btn(h, {\n    size: buttonSize,\n    isActive: hasPrev,\n    direction: order[1],\n    attrs: {\n      'data-action': 'prev',\n      'data-component-key': legend.settings.key\n    },\n    nav: itemized.navigation\n  })])];\n  renderer.render(nodes);\n}\n\nfunction navigationRendererFactory (legend) {\n  var itemized;\n  var nav = {\n    itemize: function itemize(obj) {\n      itemized = _itemize$1(obj);\n    },\n    render: function render(obj) {\n      return _render$1(nav.renderer, obj, itemized, legend);\n    },\n    extent: function extent() {\n      return 32;\n    },\n    spread: function spread() {\n      return 64;\n    }\n  };\n  return nav;\n}\n\nfunction _itemize$2(_ref, legend) {\n  var resolved = _ref.resolved;\n\n  if (resolved.title.item.show === false) {\n    return null;\n  }\n\n  var t = extend({}, resolved.title.item, {\n    type: 'text'\n  });\n\n  if (resolved.layout.item.direction === 'rtl') {\n    if (!t.anchor || t.anchor === 'start') {\n      t.anchor = 'end';\n    } else if (t.anchor === 'end') {\n      t.anchor = 'start';\n    }\n  }\n\n  if (typeof resolved.title.settings.text === 'undefined') {\n    var fields = legend.scale.data().fields;\n    t.text = fields && fields[0] ? fields[0].title() : '';\n  }\n\n  return {\n    displayObject: t,\n    bounds: legend.renderer.textBounds(t)\n  };\n}\n\nfunction _render$2(_ref2, renderer, itemized) {\n  var rect = _ref2.rect;\n\n  if (!renderer) {\n    return;\n  }\n\n  var nodes = [];\n  renderer.size(rect);\n\n  if (itemized) {\n    var align = {\n      start: 0,\n      end: rect.width,\n      middle: rect.width / 2\n    };\n    nodes.push(extend({}, itemized.displayObject, {\n      x: align[itemized.displayObject.anchor] || 0,\n      y: 0,\n      baseline: 'text-before-edge',\n      title: itemized.displayObject.text\n    }));\n  }\n\n  renderer.render(nodes);\n}\n\nfunction titleRendererFactory (legend) {\n  var itemized;\n  var api = {\n    itemize: function itemize(obj) {\n      itemized = _itemize$2(obj, legend);\n    },\n    render: function render(obj) {\n      _render$2(obj, api.renderer, itemized);\n    },\n    spread: function spread() {\n      return itemized ? itemized.bounds.height : 0;\n    },\n    extent: function extent() {\n      return itemized ? itemized.bounds.width : 0;\n    }\n  };\n  return api;\n}\n\n/* eslint no-mixed-operators:0 */\n\nfunction layout(rect, display, orientation, _ref) {\n  var itemRenderer = _ref.itemRenderer,\n      navigationRenderer = _ref.navigationRenderer,\n      titleRenderer = _ref.titleRenderer,\n      _ref$isPreliminary = _ref.isPreliminary,\n      isPreliminary = _ref$isPreliminary === void 0 ? false : _ref$isPreliminary;\n  var title;\n  var content;\n  var navigation;\n  var preferredSize = 0;\n  var paddedRect = {\n    x: display.spacing,\n    y: display.spacing,\n    width: rect.width - 2 * display.spacing,\n    height: rect.height - 2 * display.spacing\n  };\n  title = {\n    x: paddedRect.x,\n    y: paddedRect.y,\n    width: paddedRect.width,\n    height: titleRenderer.spread()\n  };\n\n  if (orientation === 'horizontal') {\n    // const titleAtTop = false;\n    // if (titleAtTop) { // this might be a nicer layout sometimes\n    //   // |------------------|\n    //   // |title             |\n    //   // |------------|-----|\n    //   // |content     | nav |\n    //   // |------------|-----|\n    //   // available space for items without navigation UI\n    //   const availableExtentForItems = paddedRect.width;\n    //   const availableSpreadForItems = paddedRect.height - (title.y + title.height) + 8;\n    //   const isRtl = itemRenderer.direction() === 'rtl';\n    //   itemRenderer.parallelize(availableExtentForItems, isPreliminary ? undefined : availableSpreadForItems);\n    //   const navigationSize = itemRenderer.extent() > availableExtentForItems ? navigationRenderer.extent() : 0;\n    //   content = {\n    //     x: paddedRect.x,\n    //     y: title.y + title.height,\n    //     width: paddedRect.width - navigationSize,\n    //     height: availableSpreadForItems\n    //   };\n    //   navigation = {\n    //     x: content.x + content.width,\n    //     y: title.y + title.height,\n    //     width: navigationSize,\n    //     height: paddedRect.height - (title.y + title.height) + 8\n    //   };\n    //   if (isRtl) { // switch navigation and content\n    //     navigation.x = content.x;\n    //     content.x = navigation.x + navigation.width;\n    //     // totalContent.x = navigation.x;\n    //   }\n    //   preferredSize = title.height + Math.max(navigationRenderer.spread(), itemRenderer.spread());\n    // } else {\n    // |-----|------------|-----|\n    // |title|content     | nav |\n    // |-----|------------|-----|\n    title = {\n      x: paddedRect.x,\n      y: paddedRect.y,\n      width: titleRenderer.extent(),\n      height: titleRenderer.spread()\n    }; // available space for items without navigation UI\n\n    var availableExtentForItems = paddedRect.width - title.width - (title.width ? display.spacing : 0);\n    var availableSpreadForItems = paddedRect.height;\n    itemRenderer.parallelize(availableExtentForItems, isPreliminary ? undefined : availableSpreadForItems);\n    var navigationSize = itemRenderer.extent() > availableExtentForItems ? navigationRenderer.extent() : 0;\n    var spread = itemRenderer.spread();\n    var navigationSpread = navigationSize ? navigationRenderer.spread() : 0;\n    content = {\n      x: title.x + title.width + (title.width ? display.spacing : 0),\n      y: paddedRect.y + Math.max(0, (navigationSpread - spread) / 2),\n      width: paddedRect.width - navigationSize - title.width - (navigationSize ? display.spacing : 0) - (title.width ? display.spacing : 0),\n      height: availableSpreadForItems\n    };\n    navigation = {\n      x: content.x + content.width + (navigationSize ? display.spacing : 0),\n      y: paddedRect.y,\n      width: navigationSize,\n      height: paddedRect.height\n    };\n    title.y = content.y;\n    var isRtl = itemRenderer.direction() === 'rtl';\n\n    if (isRtl) {\n      // switch title, content and navigation\n      navigation.x = paddedRect.x;\n      content.x = navigation.x + navigation.width + (navigation.width ? display.spacing : 0);\n      title.x = content.x + content.width + (title.width ? display.spacing : 0);\n    }\n\n    preferredSize = Math.max(title.height, navigationSpread, itemRenderer.spread()); // }\n  } else {\n    // |------------|\n    // |title       |\n    // |------------|\n    // |content     |\n    // |------------|\n    // |navigation  |\n    // |------------|\n    var _availableExtentForItems = paddedRect.height - title.height - (title.height ? display.spacing : 0);\n\n    var _availableSpreadForItems = paddedRect.width;\n    itemRenderer.parallelize(_availableExtentForItems, isPreliminary ? undefined : _availableSpreadForItems);\n\n    var _navigationSize = itemRenderer.extent() > _availableExtentForItems ? navigationRenderer.extent() : 0;\n\n    navigation = {\n      x: paddedRect.x,\n      y: paddedRect.y + paddedRect.height - _navigationSize,\n      width: paddedRect.width,\n      height: _navigationSize\n    };\n    content = {\n      x: paddedRect.x,\n      y: title.y + title.height + (title.height ? display.spacing : 0),\n      width: paddedRect.width,\n      height: paddedRect.height - title.height - (title.height ? display.spacing : 0) - navigation.height - (navigation.height ? display.spacing : 0)\n    };\n    preferredSize = Math.max(titleRenderer.extent(), _navigationSize ? navigationRenderer.spread() : 0, itemRenderer.spread());\n  }\n\n  content = extend({}, rect, {\n    x: rect.x + content.x,\n    y: rect.y + content.y,\n    width: content.width,\n    height: content.height\n  });\n  navigation.x += rect.x;\n  navigation.y += rect.y;\n  title.x += rect.x;\n  title.y += rect.y;\n  return {\n    title: extend({}, rect, title),\n    content: extend({}, rect, content),\n    navigation: extend({}, rect, navigation),\n    orientation: orientation,\n    preferredSize: preferredSize\n  };\n}\n\nfunction update(comp) {\n  comp.state.resolved = resolveSettings$2(comp);\n  comp.titleRenderer.itemize({\n    resolved: comp.state.resolved,\n    dock: comp.settings.layout.dock || 'center'\n  });\n  comp.itemRenderer.itemize({\n    resolved: comp.state.resolved,\n    dock: comp.settings.layout.dock || 'center'\n  });\n  comp.navigationRenderer.itemize({\n    resolved: comp.state.resolved,\n    dock: comp.settings.layout.dock || 'center',\n    navigation: comp.settings.settings.navigation\n  });\n  comp.state.display = {\n    spacing: 8\n  };\n}\n\nfunction _preferredSize(comp, size) {\n  var s = 0;\n  var dock = comp.settings.layout.dock || 'center';\n  var orientation = dock === 'top' || dock === 'bottom' ? 'horizontal' : 'vertical';\n  var d = comp.state.display;\n  var tempLayout = layout(size.inner, d, orientation, {\n    itemRenderer: comp.itemRenderer,\n    navigationRenderer: comp.navigationRenderer,\n    titleRenderer: comp.titleRenderer,\n    isPreliminary: true\n  });\n  s += d.spacing; // start padding in both vertical and horizontal mode\n\n  s += tempLayout.preferredSize;\n  s += d.spacing; // end padding in both vertical and horizontal mode\n\n  return s;\n}\n\nfunction _render$3(legend) {\n  var rect = legend.rect,\n      settings = legend.settings,\n      state = legend.state,\n      itemRenderer = legend.itemRenderer,\n      navigationRenderer = legend.navigationRenderer,\n      titleRenderer = legend.titleRenderer;\n  var dock = settings.layout.dock;\n  var orientation = dock === 'top' || dock === 'bottom' ? 'horizontal' : 'vertical';\n  var l = layout(rect, state.display, orientation, {\n    itemRenderer: itemRenderer,\n    navigationRenderer: navigationRenderer,\n    titleRenderer: titleRenderer\n  });\n  legend.renderer.size(l.content); // l.content.x = 0;\n  // l.content.y = 0;\n  // l.navigation.x += rect.x;\n  // l.navigation.y += rect.y;\n  // l.title.x += rect.x;\n  // l.title.y += rect.y;\n\n  var contentItems = itemRenderer.getItemsToRender({\n    viewRect: extend({}, l.content, {\n      x: 0,\n      y: 0\n    })\n  });\n  navigationRenderer.render({\n    rect: l.navigation,\n    itemRenderer: itemRenderer\n  });\n  titleRenderer.render({\n    rect: l.title\n  });\n  legend.state.views = {\n    layout: l\n  };\n  return contentItems;\n}\n\nvar component$2 = {\n  require: ['chart', 'settings', 'renderer', 'update', 'resolver', 'registries'],\n  defaultSettings: {\n    settings: {},\n    style: {\n      item: {\n        label: '$label',\n        shape: '$shape'\n      },\n      title: '$title'\n    }\n  },\n  mounted: function mounted(renderElement) {\n    if (renderElement && renderElement.parentNode) {\n      this.navigationRenderer.renderer.appendTo(renderElement.parentNode);\n      this.titleRenderer.renderer.appendTo(renderElement.parentNode);\n      renderElement.parentNode.insertBefore(this.navigationRenderer.renderer.element(), renderElement);\n      renderElement.parentNode.insertBefore(this.titleRenderer.renderer.element(), renderElement);\n    }\n\n    this.navigationRenderer.render({\n      rect: this.state.views.layout.navigation,\n      itemRenderer: this.itemRenderer\n    });\n    this.titleRenderer.render({\n      rect: this.state.views.layout.title\n    });\n  },\n  beforeUnmount: function beforeUnmount() {\n    this.navigationRenderer.renderer.clear();\n    this.titleRenderer.renderer.clear();\n  },\n  on: {\n    panstart: function panstart() {\n      if (this.state.interaction.started) {\n        return;\n      }\n\n      var contentOverflow = this.itemRenderer.getContentOverflow();\n\n      if (!contentOverflow) {\n        return;\n      }\n\n      this.state.interaction.started = true;\n      this.state.interaction.delta = 0;\n    },\n    panmove: function panmove(e) {\n      if (!this.state.interaction.started) {\n        return;\n      }\n\n      var delta = this.itemRenderer.orientation() === 'horizontal' ? (this.itemRenderer.direction() === 'rtl' ? -1 : 1) * e.deltaX : e.deltaY;\n      this.itemRenderer.scroll(delta - this.state.interaction.delta);\n      this.state.interaction.delta = delta;\n    },\n    panend: function panend() {\n      this.state.interaction.started = false;\n    },\n    scroll: function scroll(delta) {\n      this.itemRenderer.scroll(-delta);\n    },\n    next: function next() {\n      this.itemRenderer.next();\n    },\n    prev: function prev() {\n      this.itemRenderer.prev();\n    }\n  },\n  created: function created() {\n    var _this = this;\n\n    this.state = {\n      interaction: {}\n    };\n\n    this.onScroll = function () {\n      var items = _render$3(_this);\n\n      _this.update(items);\n    };\n\n    this.itemRenderer = itemRendererFactory(this, {\n      onScroll: this.onScroll\n    });\n    this.navigationRenderer = navigationRendererFactory(this);\n    this.titleRenderer = titleRendererFactory(this);\n    this.navigationRenderer.renderer = this.registries.renderer('dom')();\n    this.titleRenderer.renderer = this.registries.renderer(this.settings.renderer)();\n    update(this);\n  },\n  preferredSize: function preferredSize(obj) {\n    return _preferredSize(this, obj);\n  },\n  beforeUpdate: function beforeUpdate() {\n    update(this);\n  },\n  render: function render() {\n    return _render$3(this);\n  },\n  beforeDestroy: function beforeDestroy() {\n    this.navigationRenderer.renderer.destroy();\n    this.titleRenderer.renderer.destroy();\n  },\n  additionalElements: function additionalElements() {\n    return [this.titleRenderer.renderer.element(), this.navigationRenderer.renderer.element()];\n  },\n  _DO_NOT_USE_getInfo: function _DO_NOT_USE_getInfo() {\n    return {\n      offset: this.itemRenderer.offset()\n    };\n  }\n};\n\n/**\n * @typedef {object} component--legend-cat\n * @property {string} scale\n */\n\n/**\n * @type {string}\n * @memberof component--legend-cat\n */\n\nvar type$2 = 'legend-cat';\nfunction categoricalLegend(picasso) {\n  picasso.component(type$2, component$2);\n}\n\nfunction applyAlignJustify(ctx, node) {\n  var wiggle = 0;\n  var cmd = {\n    type: ctx.state.isVertical ? 'justify' : 'align',\n    coord: ctx.state.isVertical ? 'y' : 'x',\n    pos: ctx.state.isVertical ? 'height' : 'width',\n    fn: ctx.state.isVertical ? 'requiredHeight' : 'requiredWidth'\n  };\n  wiggle = ctx.state.rect[cmd.pos] - ctx.state.legend.length() - ctx.state.title[cmd.fn]();\n  wiggle *= Math.min(1, Math.max(ctx.stgns[cmd.type], 0));\n  node[cmd.coord] += wiggle;\n}\n\nfunction generateStopNodes(ctx) {\n  var fillScale = ctx.state.legend.fillScale;\n  var majorScale = ctx.state.legend.majorScale;\n  var stops = fillScale.domain().map(function (d) {\n    return {\n      type: 'stop',\n      color: fillScale(d),\n      offset: Math.min(1, Math.max(0, majorScale.norm(d)))\n    };\n  });\n  return stops.sort(function (a, b) {\n    return a.offset - b.offset;\n  });\n}\nfunction createTitleNode(ctx) {\n  var state = ctx.state;\n  var settings = ctx.stgns;\n  var isTickLeft = state.ticks.anchor === 'left';\n  var isTickTop = state.ticks.anchor === 'top';\n  var x = state.rect.x;\n  var y = state.rect.y;\n  var textAnchor = 'start';\n\n  if (state.title.anchor === 'left') {\n    x += state.title.requiredWidth() - settings.title.padding;\n    y += state.title.textMetrics.height;\n    y += isTickTop ? state.rect.height - state.title.textBounds.height : 0;\n    textAnchor = 'end';\n  } else if (state.title.anchor === 'right') {\n    x += state.legend.length();\n    x += settings.title.padding;\n    y += state.title.textMetrics.height;\n    y += isTickTop ? state.rect.height - state.title.textBounds.height : 0;\n  } else if (state.title.anchor === 'top') {\n    x += isTickLeft ? state.rect.width : 0;\n    y += state.title.textMetrics.height;\n    textAnchor = isTickLeft ? 'end' : 'start';\n  }\n\n  var node = {\n    tag: 'legend-title',\n    type: 'text',\n    x: x,\n    y: Math.min(y, state.rect.y + state.rect.height),\n    text: settings.title.text,\n    fill: settings.title.fill,\n    fontSize: settings.title.fontSize,\n    fontFamily: settings.title.fontFamily,\n    maxWidth: settings.title.maxLengthPx,\n    maxLines: settings.title.maxLines,\n    wordBreak: settings.title.wordBreak,\n    hyphens: settings.title.hyphens,\n    lineHeight: settings.title.lineHeight,\n    anchor: textAnchor,\n    title: settings.title.text\n  };\n  applyAlignJustify(ctx, node);\n  return node;\n}\nfunction createLegendRectNode(ctx, stops) {\n  var state = ctx.state;\n  var settings = ctx.stgns;\n  var container = state.rect;\n  var x = container.x;\n  var y = container.y;\n  var width = state.isVertical ? settings.size : state.legend.length();\n  var height = state.isVertical ? state.legend.length() : settings.size;\n\n  if (state.ticks.anchor === 'left') {\n    x += state.rect.width - settings.size;\n  } else if (state.ticks.anchor === 'top') {\n    y += state.rect.height - settings.size;\n  }\n\n  if (state.title.anchor === 'top') {\n    y += state.title.requiredHeight();\n  } else if (state.title.anchor === 'left') {\n    x += state.title.requiredWidth();\n  }\n\n  var node = {\n    type: 'rect',\n    x: x,\n    y: y,\n    width: width,\n    height: height,\n    fill: {\n      type: 'gradient',\n      stops: stops,\n      degree: state.isVertical ? 90 : 180\n    }\n  };\n  applyAlignJustify(ctx, node);\n  return node;\n}\nfunction createTickNodes(ctx, legendNode) {\n  var state = ctx.state;\n  var settings = ctx.stgns;\n  var anchor = 'start';\n  var rangeSelectorRect = {\n    type: 'rect',\n    x: legendNode.x,\n    y: legendNode.y,\n    width: state.isVertical ? 0 : legendNode.width,\n    height: state.isVertical ? legendNode.height : 0,\n    fill: 'transparent'\n  };\n  var nodes = state.ticks.values.map(function (tick) {\n    var x = 0;\n    var y = 0;\n    var dx = 0;\n    var dy = 0;\n    var baseline = 'alphabetical';\n\n    if (state.isVertical) {\n      y = legendNode.y + legendNode.height * tick.pos;\n      baseline = tick.pos === 0 ? 'text-before-edge' : 'text-after-edge';\n    } else {\n      x = legendNode.x + legendNode.width * tick.pos;\n    }\n\n    if (state.ticks.anchor === 'right') {\n      x = legendNode.x + settings.size + settings.tick.padding;\n      rangeSelectorRect.x = legendNode.x + legendNode.width;\n    } else if (state.ticks.anchor === 'left') {\n      x = legendNode.x - settings.tick.padding;\n      anchor = 'end';\n    } else if (state.ticks.anchor === 'top') {\n      y = legendNode.y - settings.tick.padding;\n      dy -= tick.textMetrics.height * 0.25;\n      anchor = tick.pos === 0 ? 'start' : 'end';\n    } else if (state.ticks.anchor === 'bottom') {\n      y = legendNode.y + legendNode.height + settings.tick.padding;\n      dy = tick.textMetrics.height * 0.8;\n      anchor = tick.pos === 0 ? 'start' : 'end';\n      rangeSelectorRect.y = legendNode.y + legendNode.height;\n    }\n\n    var node = {\n      type: 'text',\n      x: x,\n      y: y,\n      dx: dx,\n      dy: dy,\n      text: tick.label,\n      fontSize: settings.tick.fontSize,\n      fontFamily: settings.tick.fontFamily,\n      fill: settings.tick.fill,\n      maxWidth: state.isVertical ? settings.tick.maxLengthPx : Math.min(settings.tick.maxLengthPx, state.legend.length() / 2),\n      anchor: anchor,\n      textBoundsFn: ctx.renderer.textBounds,\n      title: tick.label,\n      baseline: baseline\n    };\n    return node;\n  });\n  return {\n    type: 'container',\n    id: 'legend-seq-ticks',\n    children: [].concat(_toConsumableArray$1(nodes), [rangeSelectorRect])\n  };\n}\n\nfunction resolveAnchor(dock, anchor, map) {\n  var mapped = map[dock];\n\n  if (_typeof(mapped) === 'object') {\n    if (mapped.valid.indexOf(anchor) !== -1) {\n      return anchor;\n    }\n\n    return mapped.default;\n  }\n\n  return map.default;\n}\n\nfunction resolveTickAnchor(settings) {\n  var dock = settings.layout.dock;\n  var anchor = settings.settings.tick.anchor;\n  var dockAnchorMap = {\n    left: {\n      valid: ['left', 'right'],\n      default: 'left'\n    },\n    right: {\n      valid: ['left', 'right'],\n      default: 'right'\n    },\n    top: {\n      valid: ['top', 'bottom'],\n      default: 'top'\n    },\n    bottom: {\n      valid: ['top', 'bottom'],\n      default: 'bottom'\n    },\n    default: 'right'\n  };\n  return resolveAnchor(dock, anchor, dockAnchorMap);\n}\n\nfunction resolveTitleAnchor(settings) {\n  var dockAnchorMap = {\n    left: {\n      valid: ['top'],\n      default: 'top'\n    },\n    right: {\n      valid: ['top'],\n      default: 'top'\n    },\n    top: {\n      valid: ['left', 'right'],\n      default: 'left'\n    },\n    bottom: {\n      valid: ['left', 'right'],\n      default: 'left'\n    },\n    default: 'top'\n  };\n  var dock = settings.layout.dock;\n  var anchor = settings.settings.title.anchor;\n  return resolveAnchor(dock, anchor, dockAnchorMap);\n}\n\nfunction initRect(ctx, size) {\n  var rect = {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  };\n  var padding = ctx.stgns.padding;\n  rect.x = padding.left;\n  rect.y = padding.top;\n  rect.width = size.width - padding.left - padding.right;\n  rect.height = size.height - padding.top - padding.bottom;\n  return rect;\n}\n\nfunction getTicks(ctx, majorScale) {\n  var values = majorScale.domain();\n  var labels = values;\n  var labelFn = ctx.stgns.tick.label;\n\n  if (!labelFn && ctx.formatter) {\n    labelFn = ctx.formatter;\n  } else if (!labelFn && majorScale.data().fields) {\n    labelFn = majorScale.data().fields[0].formatter();\n  }\n\n  if (typeof labelFn === 'function') {\n    labels = values.map(labelFn).map(String);\n  }\n\n  var ticks = values.map(function (value, i) {\n    var label = labels[i];\n    return {\n      value: value,\n      label: label,\n      pos: majorScale.norm(parseFloat(value, 10)),\n      textMetrics: ctx.renderer.measureText({\n        text: label,\n        fontSize: ctx.stgns.tick.fontSize,\n        fontFamily: ctx.stgns.tick.fontFamily\n      })\n    };\n  });\n  return ticks;\n}\n\nfunction initState$1(ctx) {\n  var isVertical = ctx.settings.layout.dock !== 'top' && ctx.settings.layout.dock !== 'bottom';\n  var titleStgns = ctx.stgns.title;\n  var fillScale = ctx.chart.scale(ctx.stgns.fill);\n  var majorScale = ctx.chart.scale(ctx.stgns.major);\n  var tickValues = getTicks(ctx, majorScale);\n  var tickAnchor = resolveTickAnchor(ctx.settings);\n\n  if (typeof titleStgns.text === 'undefined') {\n    var fields = majorScale.data().fields;\n    titleStgns.text = fields && fields[0] ? fields[0].title() : '';\n  }\n\n  var titleTextMetrics = ctx.renderer.measureText({\n    text: titleStgns.text,\n    fontSize: titleStgns.fontSize,\n    fontFamily: titleStgns.fontFamily\n  });\n  var titleTextBounds = ctx.renderer.textBounds({\n    text: titleStgns.text,\n    fontSize: titleStgns.fontSize,\n    fontFamily: titleStgns.fontFamily,\n    maxLines: titleStgns.maxLines,\n    maxWidth: titleStgns.maxLengthPx,\n    wordBreak: titleStgns.wordBreak,\n    hyphens: titleStgns.hyphens,\n    lineHeight: titleStgns.lineHeight\n  });\n  var state = {\n    isVertical: isVertical,\n    nodes: [],\n    title: {\n      anchor: resolveTitleAnchor(ctx.settings),\n      textMetrics: titleTextMetrics,\n      textBounds: titleTextBounds,\n      requiredWidth: function requiredWidth() {\n        if (!titleStgns.show) {\n          return 0;\n        }\n\n        var w = titleTextBounds.width;\n        var mw = titleStgns.maxLengthPx;\n\n        if (!isVertical) {\n          w += titleStgns.padding;\n          mw += titleStgns.padding;\n        }\n\n        return Math.min(w, mw, state.rect.width);\n      },\n      requiredHeight: function requiredHeight() {\n        if (!titleStgns.show) {\n          return 0;\n        }\n\n        var h = titleTextBounds.height;\n\n        if (isVertical) {\n          h += titleStgns.padding;\n        }\n\n        return Math.min(h, state.rect.height);\n      }\n    },\n    ticks: {\n      values: tickValues,\n      anchor: tickAnchor,\n      length: Math.min(Math.max.apply(Math, _toConsumableArray$1(tickValues.map(function (t) {\n        return t.textMetrics.width;\n      }))), ctx.stgns.tick.maxLengthPx),\n      requiredHeight: function requiredHeight() {\n        return tickAnchor === 'top' ? Math.max.apply(Math, _toConsumableArray$1(state.ticks.values.map(function (t) {\n          return t.textMetrics.height;\n        }))) + ctx.stgns.tick.padding : 0;\n      },\n      height: Math.max.apply(Math, _toConsumableArray$1(tickValues.map(function (t) {\n        return t.textMetrics.height;\n      })))\n    },\n    legend: {\n      fillScale: fillScale,\n      majorScale: majorScale,\n      length: function length() {\n        var pos = isVertical ? 'height' : 'width';\n        var fnPos = isVertical ? 'requiredHeight' : 'requiredWidth';\n        var len = Math.min(state.rect[pos], state.rect[pos] * ctx.stgns.length) - state.title[fnPos]();\n        return Math.max(0, Math.min(len, ctx.stgns.maxLengthPx));\n      }\n    }\n  };\n  return state;\n}\n/**\n * @typedef {object} component--legend-seq\n * @property {string} fill - Reference to definition of sequential color scale\n * @property {string} major - Reference to definition of linear scale\n * @property {number} [size=15] - Size in pixels of the legend, if vertical is the width and height otherwise\n * @property {number} [length=1] - A value in the range 0-1 indicating the length of the legend node\n * @property {number} [maxLengthPx=250] - Max length in pixels\n * @property {number} [align=0.5] - A value in the range 0-1 indicating horizontal alignment of the legend's content. 0 aligns to the left, 1 to the right.\n * @property {number} [justify=0] - A value in the range 0-1 indicating vertical alignment of the legend's content. 0 aligns to the top, 1 to the bottom.\n * @property {object} [padding]\n * @property {number} [padding.left=5]\n * @property {number} [padding.right=5]\n * @property {number} [padding.top=5]\n * @property {number} [padding.bottom=5]\n * @property {object} [tick]\n * @property {function} [tick.label] - Function applied to all tick values, returned values are used as labels\n * @property {string} [tick.fill='#595959']\n * @property {string} [tick.fontSize='12px']\n * @property {string} [tick.fontFamily='Arial']\n * @property {number} [tick.maxLengthPx=150] - Max length in pixels\n * @property {string} [tick.anchor='right'] - Where to anchor the tick in relation to the legend node, supported values are [top, bottom, left and right]\n * @property {number} [tick.padding=5] - padding in pixels to the legend node\n * @property {object} [title] - Title settings\n * @property {boolean} [title.show=true] - Toggle title on/off\n * @property {string} [title.text=''] - Title text. Defaults to the title of the provided data field\n * @property {string} [title.fill='#595959']\n * @property {string} [title.fontSize='12px']\n * @property {string} [title.fontFamily='Arial']\n * @property {number} [title.maxLengthPx=100] - Max length in pixels\n * @property {number} [title.padding=5] - padding in pixels to the legend node\n * @property {string} [title.anchor='top'] - Where to anchor the title in relation to the legend node, supported values are [top, left and right]\n * @property {string} [title.wordBreak='none'] - How overflowing title is handled, if it should insert line breaks at word boundries (break-word) or character boundries (break-all)\n * @property {string} [title.hyphens='auto'] - How words should be hyphenated when text wraps across multiple lines (only applicable with wordBreak)\n * @property {number} [title.maxLines=2] - Number of allowed lines if title contains line breaks (only applicable with wordBreak)\n * @property {number} [title.lineHeight=1.2] - A multiplier defining the distance between lines (only applicable with wordBreak)\n */\n\n\nvar legendDef = {\n  require: ['chart', 'settings', 'renderer'],\n  defaultSettings: {\n    layout: {\n      displayOrder: 0,\n      dock: 'right'\n    },\n    settings: {\n      size: 15,\n      length: 0.5,\n      maxLengthPx: 250,\n      align: 0.5,\n      justify: 0,\n      padding: {\n        left: 5,\n        right: 5,\n        top: 5,\n        bottom: 5\n      },\n      tick: {\n        label: null,\n        fill: '#595959',\n        fontSize: '12px',\n        fontFamily: 'Arial',\n        maxLengthPx: 100,\n        anchor: null,\n        // Use default based on dock\n        padding: 5\n      },\n      title: {\n        show: true,\n        text: undefined,\n        fill: '#595959',\n        fontSize: '12px',\n        fontFamily: 'Arial',\n        maxLengthPx: 100,\n        padding: 5,\n        maxLines: 2,\n        wordBreak: 'none',\n        lineHeight: 1.2,\n        hyphens: 'auto',\n        anchor: null // Use default based on dock\n\n      }\n    }\n  },\n  preferredSize: function preferredSize(opts) {\n    var state = this.state;\n    state.rect = initRect(this, opts.inner); // Init with size of legend\n\n    var prefSize = this.stgns.size; // Append paddings\n\n    var paddings = state.isVertical ? this.stgns.padding.left + this.stgns.padding.right : this.stgns.padding.top + this.stgns.padding.bottom;\n    prefSize += paddings; // Append tick size\n\n    var maxSize = Math.max(opts.inner.width, opts.inner.height);\n\n    if (state.ticks.anchor === 'left' || state.ticks.anchor === 'right') {\n      var tHeight = state.ticks.values.reduce(function (sum, t) {\n        return sum + t.textMetrics.height;\n      }, 0);\n\n      if (tHeight > this.state.legend.length()) {\n        return maxSize;\n      }\n\n      prefSize += state.ticks.length;\n    } else {\n      var tWidth = state.ticks.length;\n\n      if (tWidth > this.state.legend.length()) {\n        return maxSize;\n      }\n\n      prefSize += Math.max.apply(Math, _toConsumableArray$1(state.ticks.values.map(function (t) {\n        return t.textMetrics.height;\n      })));\n    }\n\n    prefSize += this.stgns.tick.padding; // Append or use title size\n\n    if (this.stgns.title.show) {\n      if (state.title.anchor === 'left' || state.title.anchor === 'right') {\n        prefSize = Math.max(state.title.textBounds.height + paddings, prefSize);\n      } else {\n        prefSize = Math.max(prefSize, state.title.requiredWidth() + paddings);\n      }\n    }\n\n    this.state.preferredSize = prefSize;\n    return prefSize;\n  },\n  created: function created() {\n    this.stgns = this.settings.settings;\n    this.state = initState$1(this);\n  },\n  beforeUpdate: function beforeUpdate(opts) {\n    this.stgns = opts.settings.settings;\n    this.state = initState$1(this);\n  },\n  beforeRender: function beforeRender(opts) {\n    this.state.nodes = [];\n    this.state.rect = initRect(this, opts.size);\n\n    if (this.stgns.title.show) {\n      var titleNode = createTitleNode(this);\n      this.state.nodes.push(titleNode);\n    }\n\n    var stopNodes = generateStopNodes(this);\n    var rectNode = createLegendRectNode(this, stopNodes);\n    var tickNodes = createTickNodes(this, rectNode);\n    var targetNode = {\n      // The target node enables range selection component to limit its range to a specific area\n      id: 'legend-seq-target',\n      type: 'container',\n      children: [rectNode, tickNodes]\n    };\n    this.state.nodes.push(targetNode);\n  },\n  render: function render() {\n    return this.state.nodes;\n  }\n};\n\nfunction sequentialLegend(picasso) {\n  picasso.component('legend-seq', legendDef);\n}\n\nvar CURVES = {\n  step: curveStep,\n  stepAfter: stepAfter,\n  stepBefore: stepBefore,\n  linear: curveLinear,\n  basis: curveBasis,\n  cardinal: curveCardinal.tension(0),\n  catmullRom: curveCatmullRom,\n  monotonex: monotoneX,\n  monotoney: monotoneY,\n  natural: curveNatural\n};\n/**\n * @callback component--line~layerSort\n * @param {object} a\n * @param {string} a.id\n * @param {Array<datum-extract>} a.data\n * @param {object} b\n * @param {string} b.id\n * @param {Array<datum-extract>} b.data\n */\n\n/**\n * @typedef {object}\n * @alias component--line-settings\n */\n\nvar SETTINGS = {\n  /**\n   * @typedef {object}\n   */\n  coordinates: {\n    /**\n     * @type {number} */\n    minor: 0.5,\n\n    /**\n     * @type {number} */\n    major: 0.5,\n\n    /**\n     * @type {number=} */\n    layerId: 0\n  },\n\n  /**\n   * @type {boolean=} */\n  connect: false,\n\n  /**\n   * @type {string=} */\n  orientation: 'horizontal',\n\n  /**\n   * @typedef {object} */\n  layers: {\n    /**\n     * @type {string=} */\n    curve: 'linear',\n\n    /**\n     * @type {boolean=} */\n    show: true,\n\n    /**\n     * @type {component--line~layerSort=} */\n    sort: undefined,\n\n    /**\n     * @typedef {object} */\n    line: {\n      /**\n       * @type {string=} */\n      stroke: '#ccc',\n\n      /**\n       * @type {number=} */\n      strokeWidth: 1,\n\n      /**\n       * @type {string=} */\n      strokeLinejoin: 'miter',\n\n      /**\n       * @type {string=} */\n      strokeDasharray: undefined,\n\n      /**\n       * @type {number=} */\n      opacity: 1,\n\n      /**\n       * @type {boolean=} */\n      show: true\n    },\n\n    /**\n     * @typedef {object} */\n    area: {\n      /**\n       * @type {string=} */\n      fill: '#ccc',\n\n      /**\n       * @type {number=} */\n      opacity: 0.8,\n\n      /**\n       * @type {boolean=} */\n      show: true\n    }\n  }\n};\n/**\n * @type {datum-boolean=}\n * @memberof component--line-settings.coordinates\n * @name defined\n * @default true\n */\n\nfunction createDisplayLayer(points, _ref) {\n  var generator = _ref.generator,\n      item = _ref.item,\n      data = _ref.data;\n  var fill = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  var path = generator(points);\n  var d = {\n    type: 'path',\n    d: path,\n    opacity: item.opacity,\n    stroke: item.stroke,\n    strokeWidth: item.strokeWidth,\n    strokeLinejoin: item.strokeLinejoin,\n    fill: fill || item.fill,\n    data: data\n  };\n\n  if (item.strokeDasharray) {\n    d.strokeDasharray = item.strokeDasharray;\n  }\n\n  return d;\n}\n\nfunction createDisplayLayers(layers, _ref2) {\n  var width = _ref2.width,\n      height = _ref2.height,\n      missingMinor0 = _ref2.missingMinor0,\n      stngs = _ref2.stngs;\n  var nodes = [];\n  var layerStngs = stngs.layers || {};\n  layers.forEach(function (layer) {\n    var lineObj = layer.lineObj,\n        layerObj = layer.layerObj,\n        areaObj = layer.areaObj,\n        points = layer.points;\n    var areaGenerator = area();\n    var defined = stngs.coordinates ? stngs.coordinates.defined : null;\n    var lineGenerator;\n    var secondaryLineGenerator;\n    var minor = {\n      size: height,\n      p: 'y'\n    };\n    var major = {\n      size: width,\n      p: 'x'\n    };\n\n    if (stngs.orientation === 'vertical') {\n      var temp = extend(true, {}, major);\n      major = extend(true, {}, minor);\n      minor = extend(true, {}, temp);\n    }\n\n    areaGenerator[major.p](function (d) {\n      return d.major * major.size;\n    }) // eslint-disable-line no-unexpected-multiline\n    [\"\".concat(minor.p, \"1\")](function (d) {\n      return d.minor * minor.size;\n    }) // eslint-disable-line no-unexpected-multiline\n    [\"\".concat(minor.p, \"0\")](function (d) {\n      return d.minor0 * minor.size;\n    }) // eslint-disable-line no-unexpected-multiline\n    .curve(CURVES[layerObj.curve === 'monotone' ? \"monotone\".concat(major.p) : layerObj.curve]);\n\n    if (defined) {\n      areaGenerator.defined(function (d) {\n        return !d.dummy && typeof d.minor === 'number' && !isNaN(d.minor) && d.defined;\n      });\n    } else {\n      areaGenerator.defined(function (d) {\n        return !d.dummy && typeof d.minor === 'number' && !isNaN(d.minor);\n      });\n    }\n\n    var filteredPoints = stngs.connect ? points.filter(areaGenerator.defined()) : points;\n    lineGenerator = areaGenerator[\"line\".concat(minor.p.toUpperCase(), \"1\")]();\n    secondaryLineGenerator = areaGenerator[\"line\".concat(minor.p.toUpperCase(), \"0\")](); // area layer\n\n    if (layerStngs.area && areaObj.show !== false) {\n      nodes.push(createDisplayLayer(filteredPoints, {\n        data: layer.consumableData,\n        item: areaObj,\n        generator: areaGenerator\n      }));\n    } // main line layer\n\n\n    if (lineObj && lineObj.show !== false) {\n      nodes.push(createDisplayLayer(filteredPoints, {\n        data: layer.consumableData,\n        item: lineObj,\n        generator: lineGenerator\n      }, 'none')); // secondary line layer, used only when rendering area\n\n      if (!missingMinor0 && layerStngs.area && areaObj.show !== false) {\n        nodes.push(createDisplayLayer(filteredPoints, {\n          data: layer.consumableData,\n          item: lineObj,\n          generator: secondaryLineGenerator\n        }, 'none'));\n      }\n    }\n  });\n  return nodes;\n}\n\nfunction resolve$1(_ref3) {\n  var data = _ref3.data,\n      stngs = _ref3.stngs,\n      rect = _ref3.rect,\n      resolver = _ref3.resolver,\n      style = _ref3.style,\n      domain = _ref3.domain;\n  var width = rect.width,\n      height = rect.height;\n  var coordinates = resolver.resolve({\n    data: data,\n    defaults: SETTINGS.coordinates,\n    settings: stngs.coordinates || {},\n    scaled: {\n      major: stngs.orientation === 'vertical' ? height : width,\n      minor: stngs.orientation === 'vertical' ? width : height\n    }\n  }); // there are two cases when a line should be interrupted:\n  // 1. When the minor value is undefined (this case is easily handled by the lineGenerator.defined).\n  // 2. When a line is moving over a domain that may not coincide with the domain on the major scale.\n  // For the second case, dummy points need to be injected in order to create values which will cause gaps as they fulfill the first case.\n  // These dummy points need to be injected only when: the domain is discrete, connect !== false and multiple layers are defined\n\n  var injectDummy = !stngs.connect && domain.length > 2 && (typeof stngs.coordinates.layerId === 'function' || _typeof(stngs.coordinates.layerId) === 'object'); // collect points into layers\n\n  var layerIds = {};\n  var numLines = 0;\n\n  for (var i = 0; i < coordinates.items.length; i++) {\n    var p = coordinates.items[i];\n    var lid = p.layerId;\n\n    if (injectDummy) {\n      // inject dummy if the previous point on the major domain is not the same as the prev point on the line's domain.\n      // this works only if a datum's value property is the same primitive as in the domain.\n      var lastItem = layerIds[lid] ? layerIds[lid].items[layerIds[lid].items.length - 1] : null;\n      var lastOrderIdx = lastItem ? domain.indexOf(lastItem.data.major ? lastItem.data.major.value : lastItem.data.value) : null;\n\n      if (lastItem && domain.indexOf(p.data.major ? p.data.major.value : p.data.value) - 1 !== lastOrderIdx) {\n        layerIds[lid].items.push({\n          dummy: true\n        });\n      }\n    }\n\n    layerIds[lid] = layerIds[lid] || {\n      order: numLines++,\n      id: lid,\n      items: [],\n      dataItems: [],\n      consumableData: {}\n    };\n    layerIds[lid].dataItems.push(p.data);\n    layerIds[lid].items.push(p);\n  }\n\n  var metaLayers = Object.keys(layerIds).map(function (lid) {\n    layerIds[lid].consumableData = _objectSpread2({\n      points: layerIds[lid].dataItems\n    }, layerIds[lid].dataItems[0]);\n    return layerIds[lid];\n  });\n  var layersData = {\n    items: metaLayers.map(function (layer) {\n      return layer.consumableData;\n    })\n  };\n  var layerStngs = stngs.layers || {};\n  var layersResolved = resolver.resolve({\n    data: layersData,\n    defaults: {\n      curve: SETTINGS.layers.curve,\n      show: SETTINGS.layers.show\n    },\n    settings: {\n      curve: layerStngs.curve,\n      show: layerStngs.show\n    }\n  });\n  var linesResolved = resolver.resolve({\n    data: layersData,\n    defaults: extend({}, SETTINGS.layers.line, style.line),\n    settings: layerStngs.line\n  });\n  var areasResolved = resolver.resolve({\n    data: layersData,\n    defaults: extend({}, SETTINGS.layers.area, style.area),\n    settings: layerStngs.area\n  });\n  return {\n    coordinates: coordinates,\n    metaLayers: metaLayers,\n    layers: layersResolved,\n    lines: linesResolved,\n    areas: areasResolved\n  };\n}\n\nfunction calculateVisibleLayers(opts) {\n  var _resolve = resolve$1(opts),\n      metaLayers = _resolve.metaLayers,\n      coordinates = _resolve.coordinates,\n      layers = _resolve.layers,\n      lines = _resolve.lines,\n      areas = _resolve.areas;\n\n  var visibleLayers = [];\n  metaLayers.forEach(function (layer, ix) {\n    var layerObj = layers.items[ix];\n\n    if (layerObj.show === false) {\n      return;\n    } // layerObj.points = [];\n\n\n    layerObj.datum = layerObj.data;\n    layerObj.data = [];\n    layerObj.id = layer.id;\n    var values = [];\n    var points = [];\n    var point;\n    var pData;\n\n    for (var i = 0; i < layer.items.length; i++) {\n      point = layer.items[i];\n      pData = point.data;\n\n      if (!point.dummy) {\n        if (isNaN(point.major)) {\n          continue;\n        }\n\n        if (opts.missingMinor0) {\n          point.minor0 = coordinates.settings.minor.scale ? coordinates.settings.minor.scale(pData.minor0 ? pData.minor0.value : 0) : 0;\n        }\n\n        if (!isNaN(point.minor)) {\n          values.push(point.minor);\n        }\n\n        layerObj.data.push(point.data);\n      }\n\n      points.push(point);\n    }\n\n    var median = values.sort(function (a, b) {\n      return a - b;\n    })[Math.floor((values.length - 1) / 2)];\n    visibleLayers.push({\n      layerObj: layerObj,\n      lineObj: lines.items[ix],\n      areaObj: areas.items[ix],\n      median: median,\n      points: points,\n      consumableData: layer.consumableData\n    });\n  });\n  return visibleLayers;\n}\n\nvar lineMarkerComponent = {\n  require: ['chart', 'resolver'],\n  defaultSettings: {\n    style: {\n      area: '$shape',\n      line: '$shape-outline'\n    }\n  },\n  created: function created() {},\n  render: function render(_ref4) {\n    var data = _ref4.data;\n    // console.log(\"DATA\", data);\n    var _this$rect = this.rect,\n        width = _this$rect.width,\n        height = _this$rect.height;\n    this.stngs = this.settings.settings || {};\n    var missingMinor0 = !this.stngs.coordinates || typeof this.stngs.coordinates.minor0 === 'undefined';\n    var visibleLayers = calculateVisibleLayers({\n      data: data,\n      stngs: this.stngs,\n      rect: this.rect,\n      resolver: this.resolver,\n      style: this.style,\n      missingMinor0: missingMinor0,\n      domain: this.stngs.coordinates && this.stngs.coordinates.major && this.stngs.coordinates.major.scale ? this.chart.scale(this.stngs.coordinates.major.scale).domain() : []\n    });\n\n    if (this.stngs.layers && this.stngs.layers.sort) {\n      var sortable = visibleLayers.map(function (v) {\n        return {\n          id: v.layerObj.id,\n          data: v.layerObj.data\n        };\n      });\n      sortable.sort(this.stngs.layers.sort).map(function (s) {\n        return s.id;\n      });\n      visibleLayers.sort(function (a, b) {\n        return sortable.indexOf(b.layerObj.id) - sortable.indexOf(a.layerObj.id);\n      });\n    } else {\n      visibleLayers.sort(function (a, b) {\n        return a.median - b.median;\n      });\n    } // generate visuals\n\n\n    return createDisplayLayers(visibleLayers, {\n      width: width,\n      height: height,\n      missingMinor0: missingMinor0,\n      stngs: this.stngs\n    });\n  }\n};\n\n/**\n * @typedef {object} component--line\n */\n\n/**\n * @type {string}\n * @memberof component--line\n */\n\nvar type$3 = 'line';\nfunction line$2(picasso) {\n  picasso.component(type$3, lineMarkerComponent);\n}\n\n/**\n * @typedef {object} component--brush-area-brush\n * @property {string} key - Component key\n * @property {string[]} [contexts] - Name of the brushing contexts to affect\n * @property {string[]} [data] - The mapped data properties to add to the brush\n * @property {string} [action='set'] - Type of action to respond with\n */\n\n/**\n  * @typedef {object}\n  * @alias component--brush-area-settings\n  */\n\nvar DEFAULT_SETTINGS$7 = {\n  /**\n   * @type {object}\n   */\n  brush: {\n    /**\n    * @type {Array<component--brush-area-brush>}\n    */\n    components: []\n  }\n};\n/**\n * Transform the incoming event into point in the local coordinate system. That is the coordinate system of the component.\n * @private\n * @param {object} ctx - Context\n * @param {object} event - Incoming event, either native event or hammer event\n * @param {boolean} clamp - True to clamp the point inside the component bounds\n * @returns {point}\n */\n\nfunction getLocalPoint(ctx, event) {\n  var clamp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var x;\n  var y;\n\n  if (_typeof(event.center) === 'object') {\n    x = event.center.x;\n    y = event.center.y;\n  } else {\n    x = event.clientX;\n    y = event.clientY;\n  }\n\n  var localX = x - ctx.state.boundingRect.left;\n  var localY = y - ctx.state.boundingRect.top;\n  return {\n    x: clamp ? Math.max(0, Math.min(localX, ctx.rect.width)) : localX,\n    y: clamp ? Math.max(0, Math.min(localY, ctx.rect.height)) : localY\n  };\n}\n/**\n * Transform a local point into a point in the chart coordinate system.\n * @private\n * @param {object} ctx - Context\n * @param {object} p - Point to transform\n * @returns {point}\n */\n\n\nfunction localToChartPoint(ctx, p) {\n  return {\n    x: p.x + ctx.rect.x,\n    y: p.y + ctx.rect.y\n  };\n}\n/**\n * Extract and apply default brush configuration.\n * @private\n * @param {object} settings\n * @returns {object[]} An Array of brush configurations\n */\n\n\nfunction getBrushConfig$1(settings) {\n  return settings.settings.brush.components.map(function (b) {\n    return {\n      key: b.key,\n      contexts: b.contexts,\n      data: b.data,\n      action: b.action || 'set'\n    };\n  });\n}\n/**\n * End all active brush contexts.\n * @private\n * @param {oject} state\n * @param {object} chart - Chart instance\n */\n\n\nfunction doEndBrush(state, chart) {\n  state.brushConfig.forEach(function (config) {\n    if (Array.isArray(config.contexts)) {\n      config.contexts.forEach(function (context) {\n        chart.brush(context).end();\n      });\n    }\n  });\n}\n/**\n * Convert two points into a rectangle.\n * @private\n * @param {point} p0\n * @param {point} p1\n * @returns {rect}\n */\n\n\nfunction toRect(p0, p1) {\n  var xMin = Math.min(p0.x, p1.x);\n  var yMin = Math.min(p0.y, p1.y);\n  var xMax = Math.max(p0.x, p1.x);\n  var yMax = Math.max(p0.y, p1.y);\n  return {\n    x: xMin,\n    y: yMin,\n    width: xMax - xMin,\n    height: yMax - yMin\n  };\n}\n/**\n * Perform a brush on the given area.\n * @private\n * @param {object} ctx\n */\n\n\nfunction doAreaBrush(ctx) {\n  if (ctx.state.active) {\n    var start = localToChartPoint(ctx, ctx.state.start);\n    var end = localToChartPoint(ctx, ctx.state.end);\n    var shapes = ctx.chart.shapesAt(toRect(start, end), {\n      components: ctx.state.brushConfig\n    });\n    ctx.chart.brushFromShapes(shapes, {\n      components: ctx.state.brushConfig\n    });\n  }\n}\n\nfunction render$2(ctx) {\n  ctx.renderer.render([extend({\n    type: 'rect'\n  }, toRect(ctx.state.start, ctx.state.end), ctx.style.area)]);\n}\n\nfunction resetState$1() {\n  return {\n    start: {\n      x: 0,\n      y: 0\n    },\n    end: {\n      x: 0,\n      y: 0\n    },\n    active: false\n  };\n}\n\nvar definition = {\n  require: ['chart', 'renderer'],\n  defaultSettings: {\n    layout: {\n      displayOrder: 99\n    },\n    settings: DEFAULT_SETTINGS$7,\n    style: {\n      area: '$selection-area-target'\n    }\n  },\n  on: {\n    areaStart: function areaStart(e) {\n      this.start(e);\n    },\n    areaMove: function areaMove(e) {\n      this.move(e);\n    },\n    areaEnd: function areaEnd(e) {\n      this.end(e);\n    },\n    areaCancel: function areaCancel() {\n      this.cancel();\n    }\n  },\n  created: function created() {\n    this.state = resetState$1();\n  },\n  preferredSize: function preferredSize() {\n    return 0;\n  },\n  render: function render() {},\n  start: function start(e) {\n    this.state.boundingRect = this.renderer.element().getBoundingClientRect();\n    var p = getLocalPoint(this, e, false); // Require event to be inside the component bounds\n\n    if (!testRectPoint({\n      x: 0,\n      y: 0,\n      width: this.rect.width,\n      height: this.rect.height\n    }, p)) {\n      return;\n    }\n\n    this.state.brushConfig = getBrushConfig$1(this.settings);\n    this.state.start = getLocalPoint(this, e);\n    this.state.active = true;\n  },\n  move: function move(e) {\n    if (!this.state.active) {\n      return;\n    }\n\n    this.state.end = getLocalPoint(this, e);\n    doAreaBrush(this);\n    render$2(this);\n  },\n  end: function end() {\n    if (!this.state.active) {\n      return;\n    }\n\n    this.state = resetState$1();\n    this.renderer.render([]);\n  },\n  cancel: function cancel() {\n    if (!this.state.active) {\n      return;\n    }\n\n    doEndBrush(this.state, this.chart);\n    this.state = resetState$1();\n    this.renderer.render([]);\n  }\n};\n\nfunction areaBrush(picasso) {\n  picasso.component('brush-area', definition);\n}\n\nfunction extractor(nodes, _ref) {\n  var chart = _ref.chart,\n      scale = _ref.scale,\n      props = _ref.props,\n      h = _ref.h;\n  var dataCtx = {\n    resources: {\n      dataset: chart.dataset,\n      scale: chart.scale,\n      formatter: chart.formatter\n    },\n    scale: scale,\n    h: h\n  };\n  var data = [];\n  nodes.forEach(function (node) {\n    if (typeof props.extract === 'function') {\n      var ctx = extend({\n        node: node\n      }, dataCtx);\n      data.push(props.extract(ctx));\n    }\n  });\n  return data;\n}\n\nfunction resolveClasses(props, opts) {\n  return {\n    tooltip: typeof props.tooltipClass === 'function' ? props.tooltipClass({\n      dock: opts.dock\n    }) : props.tooltipClass,\n    content: typeof props.contentClass === 'function' ? props.contentClass({\n      dock: opts.dock\n    }) : props.contentClass,\n    arrow: typeof props.arrowClass === 'function' ? props.arrowClass({\n      dock: opts.dock\n    }) : props.arrowClass\n  };\n}\n\nfunction resolveContent(h, data, style, props) {\n  return props.content({\n    h: h,\n    style: style,\n    data: data\n  });\n}\n\nfunction render$3(data, placement, _ref) {\n  var renderer = _ref.renderer,\n      style = _ref.style,\n      props = _ref.props,\n      h = _ref.h;\n  var classes = resolveClasses(props, placement);\n  var content = resolveContent(h, data, style, props);\n  var tooltipDefaultStyle = {\n    position: 'relative',\n    display: 'inline-block'\n  };\n  var tooltipNode = h(\"div\", {\n    dir: props.direction,\n    class: classString(extend({\n      'pic-tooltip': true\n    }, classes.tooltip)),\n    style: extend(tooltipDefaultStyle, placement.computedTooltipStyle)\n  }, h(\"div\", {\n    style: style.content,\n    class: classString(extend({\n      'pic-tooltip-content': true\n    }, classes.content))\n  }, content), h(\"div\", {\n    class: classString(extend({\n      'pic-tooltip-arrow': true\n    }, classes.arrow)),\n    style: extend({}, style.arrow, style[\"arrow-\".concat(placement.dock)], placement.computedArrowStyle)\n  }));\n  renderer.render(tooltipNode);\n  return renderer.element().children[0];\n}\n\n// Successfull flow: pending -> active -> fulfilled (only with duration)\n// Cancelled flow: pending -> active -> cancelled\n// Rejected flow: pending -> rejected\n// Debounced flow: pending -> debounced -> pending -> [rejected|fulfilled]\nfunction dispatcherState() {\n  var fn = function fn() {};\n\n  var on = {\n    pending: [],\n    debounced: [],\n    active: [],\n    cancelled: [],\n    rejected: [],\n    fulfilled: []\n  };\n  var state;\n\n  fn.set = function (s) {\n    state = s;\n    on[state].forEach(function (event) {\n      return event(s);\n    });\n  };\n\n  fn.on = function (key, event) {\n    if (Array.isArray(key)) {\n      key.forEach(function (k) {\n        return on[k].push(event);\n      });\n    } else {\n      on[key].push(event);\n    }\n  };\n\n  fn.destroy = function () {\n    Object.keys(on).forEach(function (key) {\n      on[key].length = 0;\n    });\n  }; // fn.on(['pending', 'debounced', 'active', 'cancelled', 'rejected', 'fulfilled'], (e) => {\n  //   console.log(e);\n  // });\n\n\n  return fn;\n}\n\nfunction timeSpanDispatcher(_ref) {\n  var defaultDuration = _ref.defaultDuration,\n      defaultDelay = _ref.defaultDelay;\n  var actionId = null;\n  var fulfilledId = null;\n  var isActive = false;\n  var state = dispatcherState();\n\n  var fn = function fn() {};\n\n  var fulfilled = function fulfilled() {\n    actionId = null;\n    fulfilledId = null;\n    isActive = false;\n    state.set('fulfilled');\n  };\n\n  fn.invoke = function (action) {\n    var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultDuration;\n    var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultDelay;\n\n    if (actionId) {\n      clearTimeout(actionId);\n      state.set('debounced');\n    }\n\n    state.set('pending');\n    actionId = setTimeout(function () {\n      action();\n      isActive = true;\n      actionId = null;\n      state.set('active');\n    }, delay);\n\n    if (duration > 0) {\n      if (fulfilledId) {\n        clearTimeout(fulfilledId);\n      }\n\n      fulfilledId = setTimeout(fulfilled, duration + Math.max(delay, 0));\n    }\n  };\n\n  fn.clear = function () {\n    if (isActive) {\n      state.set('cancelled');\n    } else if (actionId) {\n      clearTimeout(actionId);\n      state.set('rejected');\n    }\n\n    if (fulfilledId) {\n      clearTimeout(fulfilledId);\n    }\n\n    actionId = null;\n    fulfilledId = null;\n    isActive = false;\n  };\n\n  fn.on = function (key, event) {\n    state.on(key, event);\n  };\n\n  fn.destroy = function () {\n    fn.clear();\n    state.destroy();\n  };\n\n  return fn;\n}\n\nfunction getDockTransform() {\n  var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  return {\n    left: \"translate(-100%,-50%) translateX(\".concat(-offset, \"px)\"),\n    right: \"translate(\".concat(offset, \"px, -50%)\"),\n    top: \"translate(-50%, -100%) translateY(\".concat(-offset, \"px)\"),\n    bottom: \"translate(-50%, \".concat(offset, \"px)\")\n  };\n}\n\nfunction getDockOffset(width, height) {\n  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  return {\n    left: {\n      x: -width - offset,\n      y: -height / 2\n    },\n    right: {\n      x: offset,\n      y: -height / 2\n    },\n    top: {\n      x: -width / 2,\n      y: -height - offset\n    },\n    bottom: {\n      x: -width / 2,\n      y: offset\n    }\n  };\n}\n\nfunction getComputedArrowStyle(offset) {\n  return {\n    left: {\n      left: '100%',\n      top: \"calc(50% - \".concat(offset, \"px)\"),\n      borderWidth: \"\".concat(offset, \"px\")\n    },\n    right: {\n      left: \"\".concat(-offset * 2, \"px\"),\n      top: \"calc(50% - \".concat(offset, \"px)\"),\n      borderWidth: \"\".concat(offset, \"px\")\n    },\n    top: {\n      left: \"calc(50% - \".concat(offset, \"px)\"),\n      top: '100%',\n      borderWidth: \"\".concat(offset, \"px\")\n    },\n    bottom: {\n      left: \"calc(50% - \".concat(offset, \"px)\"),\n      top: \"\".concat(-offset * 2, \"px\"),\n      borderWidth: \"\".concat(offset, \"px\")\n    }\n  };\n}\n\nfunction isInsideArea(area, vx, vy, width, height, offset) {\n  var rect = {\n    x: vx + offset.x,\n    y: vy + offset.y,\n    width: width,\n    height: height\n  };\n\n  if (rect.x < 0 || rect.y < 0) {\n    return false;\n  }\n\n  if (rect.x + rect.width > area.width || rect.y + rect.height > area.height) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * @param {vx} vx X-coordinate realative to the area\n * @param {vy} vy Y-coordinate realative to the area\n */\n\n\nfunction calcOffset(_ref) {\n  var area = _ref.area,\n      vx = _ref.vx,\n      vy = _ref.vy,\n      width = _ref.width,\n      height = _ref.height,\n      offset = _ref.offset;\n  var rect = {\n    x: vx + offset.x,\n    y: vy + offset.y,\n    width: width,\n    height: height\n  };\n  var offsetX = rect.x < 0 ? -rect.x : 0;\n  var offsetY = rect.y < 0 ? -rect.y : 0;\n  offsetX += rect.x + rect.width > area.width ? -(rect.x + rect.width - area.width) : 0;\n  offsetY += rect.y + rect.height > area.height ? -(rect.y + rect.height - area.height) : 0;\n  return {\n    x: offsetX,\n    y: offsetY\n  };\n}\n\nfunction alignToBounds(_ref2) {\n  var resources = _ref2.resources,\n      nodes = _ref2.nodes,\n      pointer = _ref2.pointer,\n      elmWidth = _ref2.width,\n      elmHeight = _ref2.height,\n      options = _ref2.options;\n  var targetBounds = pointer.targetBounds;\n\n  var _resources$getNodeBou = resources.getNodeBoundsRelativeToTarget(nodes[0]),\n      x = _resources$getNodeBou.x,\n      y = _resources$getNodeBou.y,\n      width = _resources$getNodeBou.width,\n      height = _resources$getNodeBou.height;\n\n  var docks = {\n    left: {\n      x: x,\n      y: y + height / 2\n    },\n    right: {\n      x: x + width,\n      y: y + height / 2\n    },\n    top: {\n      x: x + width / 2,\n      y: y\n    },\n    bottom: {\n      x: x + width / 2,\n      y: y + height\n    }\n  }; // Check if explicit dock\n\n  var dockTransforms = getDockTransform(options.offset);\n  var transform = dockTransforms[options.dock];\n\n  if (transform) {\n    return {\n      computedTooltipStyle: {\n        left: \"\".concat(docks[options.dock].x, \"px\"),\n        top: \"\".concat(docks[options.dock].y, \"px\"),\n        transform: transform\n      },\n      computedArrowStyle: getComputedArrowStyle(options.offset)[options.dock],\n      dock: options.dock\n    };\n  }\n\n  var area = {\n    width: options.area === 'target' ? targetBounds.width : window.innerWidth,\n    height: options.area === 'target' ? targetBounds.height : window.innerHeight\n  };\n  var dockOffsets = getDockOffset(elmWidth, elmHeight, options.offset);\n  var dockOrder = ['top', 'left', 'right', 'bottom'];\n\n  for (var i = 0; i < dockOrder.length; i += 1) {\n    var dock = dockOrder[i];\n    var vx = options.area === 'target' ? docks[dock].x : targetBounds.left + docks[dock].x;\n    var vy = options.area === 'target' ? docks[dock].y : targetBounds.top + docks[dock].y;\n\n    if (isInsideArea(area, vx, vy, elmWidth, elmHeight, dockOffsets[dock])) {\n      return {\n        computedTooltipStyle: {\n          left: \"\".concat(docks[dock].x, \"px\"),\n          top: \"\".concat(docks[dock].y, \"px\"),\n          transform: dockTransforms[dock]\n        },\n        computedArrowStyle: getComputedArrowStyle(options.offset)[dock],\n        dock: dock\n      };\n    }\n  }\n\n  return {\n    computedTooltipStyle: {\n      left: \"\".concat(docks.top.x, \"px\"),\n      top: \"\".concat(docks.top.y, \"px\"),\n      transform: dockTransforms.top\n    },\n    computedArrowStyle: getComputedArrowStyle(options.offset).top,\n    dock: 'top'\n  };\n}\n\nfunction alignToPoint(_ref3) {\n  var options = _ref3.options,\n      pointer = _ref3.pointer,\n      width = _ref3.width,\n      height = _ref3.height,\n      dockOrder = _ref3.dockOrder,\n      x = _ref3.x,\n      y = _ref3.y;\n  var targetBounds = pointer.targetBounds; // Check if explicit dock\n\n  var dockTransforms = getDockTransform(options.offset);\n  var transform = dockTransforms[options.dock];\n\n  if (transform) {\n    return {\n      computedTooltipStyle: {\n        left: \"\".concat(x, \"px\"),\n        top: \"\".concat(y, \"px\"),\n        transform: transform\n      },\n      computedArrowStyle: getComputedArrowStyle(options.offset)[options.dock],\n      dock: options.dock\n    };\n  }\n\n  var area = {\n    width: options.area === 'target' ? targetBounds.width : window.innerWidth,\n    height: options.area === 'target' ? targetBounds.height : window.innerHeight\n  };\n  var dockOffsets = getDockOffset(width, height, options.offset);\n  var results = [];\n  var edgeMargin = 20;\n  var vx = options.area === 'target' ? x : targetBounds.left + x;\n  var vy = options.area === 'target' ? y : targetBounds.top + y;\n\n  for (var i = 0; i < dockOrder.length; i += 1) {\n    var dock = dockOrder[i];\n    var offset = calcOffset({\n      area: area,\n      vx: vx,\n      vy: vy,\n      width: width,\n      height: height,\n      offset: dockOffsets[dock]\n    });\n    var computedTooltipStyle = {\n      left: \"\".concat(x, \"px\"),\n      top: \"\".concat(y, \"px\"),\n      transform: dockTransforms[dock]\n    };\n    var computedArrowStyle = getComputedArrowStyle(options.offset)[dock];\n\n    if (offset.x !== 0) {\n      computedTooltipStyle.width = \"\".concat(width - edgeMargin - Math.abs(offset.x), \"px\");\n\n      if (dock === 'top' || dock === 'bottom') {\n        computedTooltipStyle.left = \"\".concat(x + offset.x, \"px\");\n        computedArrowStyle.left = \"calc(50% \".concat(offset.x > 0 ? '-' : '+', \" \").concat(Math.abs(offset.x), \"px)\");\n      }\n    }\n\n    var result = {\n      computedTooltipStyle: computedTooltipStyle,\n      computedArrowStyle: computedArrowStyle,\n      dock: dock,\n      rect: {\n        width: width,\n        height: height\n      }\n    };\n\n    if (offset.x === 0 && offset.y === 0) {\n      return result;\n    }\n\n    result.offset = offset;\n    results.push(result);\n  }\n\n  results.sort(function (a, b) {\n    return Math.abs(a.offset.x) - Math.abs(b.offset.x);\n  });\n  return results[0];\n}\n\nfunction alignToPointer(_ref4) {\n  var options = _ref4.options,\n      pointer = _ref4.pointer,\n      width = _ref4.width,\n      height = _ref4.height;\n  var x = pointer.x,\n      y = pointer.y;\n  return alignToPoint({\n    x: x,\n    y: y,\n    pointer: pointer,\n    width: width,\n    height: height,\n    options: options,\n    dockOrder: ['top', 'left', 'right', 'bottom']\n  });\n}\n\nfunction alignToSlice(_ref5) {\n  var options = _ref5.options,\n      pointer = _ref5.pointer,\n      width = _ref5.width,\n      height = _ref5.height,\n      nodes = _ref5.nodes,\n      resources = _ref5.resources;\n  var node = nodes[0];\n  var dx = pointer.dx,\n      dy = pointer.dy;\n  var componentBounds = resources.getComponentBoundsFromNode(node); // cx and cy relative to targetBounds\n\n  var center = {\n    x: dx + componentBounds.x + componentBounds.width / 2,\n    y: dy + componentBounds.y + componentBounds.height / 2\n  };\n  var _node$desc$slice = node.desc.slice,\n      start = _node$desc$slice.start,\n      end = _node$desc$slice.end,\n      outerRadius = _node$desc$slice.outerRadius; // Node origin is at 12 o clock, clockwise, but Math uses 3 a clock, so it's transformed to origin at 3 a clock\n\n  var middle = (start + end) / 2 - Math.PI / 2;\n  var PI2 = Math.PI * 2;\n  var radians = (middle % PI2 + PI2) % PI2;\n  var dockOrder = ['top', 'left', 'right', 'bottom'];\n\n  if (options.dock === 'auto') {\n    if (radians <= Math.PI / 4 || radians >= Math.PI * 7 / 4) {\n      dockOrder = ['right', 'top', 'bottom', 'left'];\n    } else if (radians <= Math.PI * 3 / 4) {\n      dockOrder = ['bottom', 'left', 'right', 'top'];\n    } else if (radians <= Math.PI * 5 / 4) {\n      dockOrder = ['left', 'top', 'bottom', 'right'];\n    } else {\n      dockOrder = ['top', 'left', 'right', 'bottom'];\n    }\n  }\n\n  return alignToPoint({\n    x: center.x + outerRadius * componentBounds.scaleRatio.x * Math.cos(radians),\n    y: center.y + outerRadius * componentBounds.scaleRatio.y * Math.sin(radians),\n    pointer: pointer,\n    width: width,\n    height: height,\n    options: options,\n    dockOrder: dockOrder\n  });\n}\n\nfunction _getComponentBoundsFromNode(node, pointer, chart) {\n  var comp = node.key ? chart.component(node.key) : chart.componentsFromPoint({\n    x: pointer.clientX,\n    y: pointer.clientY\n  })[0];\n\n  if (!comp) {\n    return {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0,\n      scaleRatio: {\n        x: 1,\n        y: 1\n      }\n    };\n  }\n\n  var componentSize = comp.rect;\n  return extend({\n    scaleRatio: componentSize.scaleRatio\n  }, componentSize.computedInner);\n}\n\nfunction _getNodeBoundsRelativeToTarget(node, pointer, chart) {\n  var componentBounds = _getComponentBoundsFromNode(node, pointer, chart);\n\n  var bounds = node.bounds;\n  return {\n    x: componentBounds.x + pointer.dx + bounds.x,\n    y: componentBounds.y + pointer.dy + bounds.y,\n    width: bounds.width,\n    height: bounds.height\n  };\n}\n\nvar STRATEGIES = {\n  bounds: alignToBounds,\n  pointer: alignToPointer,\n  slice: alignToSlice\n};\nfunction placement(_ref6, _ref7) {\n  var width = _ref6.width,\n      height = _ref6.height;\n  var chart = _ref7.chart,\n      state = _ref7.state,\n      props = _ref7.props;\n  var propCtx = {\n    resources: {\n      formatter: chart.formatter,\n      scale: chart.scale,\n      component: chart.component,\n      getComponentBoundsFromNode: function getComponentBoundsFromNode(node) {\n        return _getComponentBoundsFromNode(node, state.pointer, chart);\n      },\n      getNodeBoundsRelativeToTarget: function getNodeBoundsRelativeToTarget(node) {\n        return _getNodeBoundsRelativeToTarget(node, state.pointer, chart);\n      }\n    },\n    nodes: state.activeNodes,\n    pointer: state.pointer,\n    width: width,\n    height: height\n  };\n\n  var type = _typeof(props.placement);\n\n  if (type === 'object' && typeof props.placement.fn === 'function') {\n    // Custom placement strategy function\n    return props.placement.fn(propCtx);\n  }\n\n  var opts = {\n    type: 'pointer',\n    offset: 8,\n    dock: 'auto',\n    area: 'viewport'\n  };\n\n  if (type === 'function') {\n    // Custom placement function\n    opts = extend(opts, props.placement(propCtx));\n  }\n\n  if (type === 'object' && STRATEGIES[props.placement.type]) {\n    // Predefined placement function with options\n    opts = extend(opts, props.placement);\n  } else if (type === 'string' && STRATEGIES[props.placement]) {\n    // Predefined placement function without options\n    opts = extend(opts, {\n      type: props.placement\n    });\n  }\n\n  propCtx.options = opts;\n  var plcm = STRATEGIES[opts.type](propCtx);\n\n  var _propCtx$resources$ge = propCtx.resources.getComponentBoundsFromNode(propCtx.nodes[0]),\n      minX = _propCtx$resources$ge.x,\n      minY = _propCtx$resources$ge.y,\n      maxX = _propCtx$resources$ge.width,\n      maxY = _propCtx$resources$ge.height;\n\n  minX += propCtx.pointer.dx;\n  maxX += minX;\n  minY += propCtx.pointer.dy;\n  maxY += minY; // Clamp tooltip position\n\n  plcm.computedTooltipStyle.left = \"\".concat(Math.min(Math.max(0, minX, parseFloat(plcm.computedTooltipStyle.left)), maxX), \"px\");\n  plcm.computedTooltipStyle.top = \"\".concat(Math.min(Math.max(0, minY, parseFloat(plcm.computedTooltipStyle.top)), maxY), \"px\");\n  return plcm;\n}\n\nvar instance;\nfunction setActive(action) {\n  instance = action;\n}\nfunction removeActive(action) {\n  if (instance === action) {\n    instance = null;\n    return true;\n  }\n\n  return false;\n}\nfunction cancelActive(a) {\n  if (instance && instance !== a) {\n    instance();\n  }\n}\nfunction remove$1() {\n  instance = null;\n}\n\n/**\n * @typedef {object}\n * @alias component--tooltip.settings\n */\n\nvar DEFAULT_SETTINGS$8 = {\n  /**\n   * How long the tooltip is visible, in milliseconds\n   * @type {number=}\n   */\n  duration: 8000,\n\n  /**\n   * Delay before the tooltip is rendered, in milliseconds\n   * @type {number=}\n   */\n  delay: 500,\n\n  /**\n   * Reduce incoming nodes to only a set of applicable nodes. Is called as a part of the `show` event.\n   * @type {function=}\n   * @returns {array} An array of nodes\n   */\n  filter: function filter(nodes) {\n    return nodes.filter(function (node) {\n      return node.data && typeof node.data.value !== 'undefined';\n    });\n  },\n\n  /**\n   * Extract data from a node.\n   * @type {function=}\n   * @returns {object} An array of data\n   */\n  extract: function extract(ctx) {\n    return ctx.node.data.value;\n  },\n\n  /**\n   * Content generator. Extracted data is available in the `data` property, where each value in the area is the extracted datum from a node.\n   * @type {function=}\n   * @returns {object[]} Array of h objects\n   */\n  content: function content(_ref) {\n    var h = _ref.h,\n        data = _ref.data;\n    return data.map(function (datum) {\n      return h('div', {}, datum);\n    });\n  },\n\n  /**\n   * Comparison function. If evaluted to true, the incoming nodes in the `show` event are ignored. If evaluated to false, any active tooltip is cleared and a new tooltip is queued.\n   *\n   * The function gets two parameters, the first is the currently active set of nodes, if any, and the second is the incoming set of nodes. By default the two set of nodes are considered equal if their data attributes are the same.\n   * @type {function=}\n   * @returns {boolean}\n   */\n  isEqual: function isEqual(prev, curr) {\n    return prev.length && prev.length === curr.length && prev.every(function (p, i) {\n      return curr[i] && JSON.stringify(p.data) === JSON.stringify(curr[i].data);\n    });\n  },\n\n  /**\n   * @typedef {object=}\n   */\n  placement: {\n    /**\n     * Available types: [pointer | bounds | slice]\n     * @type {string=}\n     */\n    type: 'pointer',\n\n    /**\n     * Docking position of the tooltip. Available positions: [left | right | top | bottom | auto]\n     * @type {string=}\n     */\n    dock: 'auto',\n\n    /**\n     * Distance from the content area to the tooltip position, in px.\n     * @type {number=}\n     */\n    offset: 8,\n\n    /**\n     * Specify the limiting area, where target is the component area unless the appendTo property is set, in which case it referes to the appendTo element. Viewport is the browser viewport.\n     *\n     * Available options are: [viewport | target]\n     * @type {number=}\n     */\n    area: 'viewport'\n  },\n\n  /**\n   * Set tooltip class.\n  * @type {object<string, boolean>=}\n  */\n  tooltipClass: {},\n\n  /**\n   * Set content class.\n  * @type {object<string, boolean>=}\n  */\n  contentClass: {},\n\n  /**\n   * Set arrow class.\n  * @type {object<string, boolean>=}\n  */\n  arrowClass: {},\n\n  /**\n   * Content direction [ltr | rtl]\n   * @type {string=}\n   */\n  direction: 'ltr',\n\n  /**\n   * Explicitly set a target element. This allows the tooltip to attach itself outside the picasso container.\n   * @type {HTMLElement=}\n   */\n  appendTo: undefined,\n\n  /**\n   * Component lifecycle hook. Called before the tooltip is displayed.\n   * @type {function=}\n   */\n  beforeShow: undefined,\n\n  /**\n   * Component lifecycle hook. Called after the tooltip have been displayed.\n   * @type {function=}\n   */\n  afterShow: undefined,\n\n  /**\n   * Component lifecycle hook. Called before the tooltip is hidden.\n   * @type {function=}\n   */\n  beforeHide: undefined,\n\n  /**\n   * Component lifecycle hook. Called when the toolip is hidden. By default this deletes the tooltip element.\n   * @type {function=}\n   */\n  onHide: undefined,\n\n  /**\n   * Component lifecycle hook. Called after the tooltip is hidden.\n   * @type {function=}\n   */\n  afterHide: undefined\n};\nvar DEFAULT_STYLE = {\n  tooltip: {},\n  content: {\n    backgroundColor: '$gray-25',\n    color: '$font-color--inverted',\n    fontFamily: '$font-family',\n    fontSize: '$font-size',\n    lineHeight: '$line-height',\n    borderRadius: '4px',\n    padding: '8px',\n    opacity: 0.9\n  },\n  arrow: {\n    position: 'absolute',\n    width: '0px',\n    height: '0px',\n    borderStyle: 'solid',\n    color: '$gray-25',\n    opacity: 0.9\n  },\n  'arrow-bottom': {\n    borderTopColor: 'transparent',\n    borderLeftColor: 'transparent',\n    borderRightColor: 'transparent'\n  },\n  'arrow-top': {\n    borderBottomColor: 'transparent',\n    borderLeftColor: 'transparent',\n    borderRightColor: 'transparent'\n  },\n  'arrow-right': {\n    borderTopColor: 'transparent',\n    borderLeftColor: 'transparent',\n    borderBottomColor: 'transparent'\n  },\n  'arrow-left': {\n    borderTopColor: 'transparent',\n    borderBottomColor: 'transparent',\n    borderRightColor: 'transparent'\n  }\n};\n\nfunction toPoint(event, _ref2) {\n  var chart = _ref2.chart,\n      state = _ref2.state;\n  var x = 0;\n  var y = 0;\n\n  if (event.center) {\n    x += event.center.x;\n    y += event.center.y;\n  } else {\n    x += event.clientX;\n    y += event.clientY;\n  } // TODO Don't do getBoundingClientRect lookup here. It's performance heavy.\n\n\n  var chartBounds = chart.element.getBoundingClientRect();\n  var targetBounds = state.targetElement.getBoundingClientRect();\n  var clientX = x;\n  var clientY = y;\n  var dx = chartBounds.left - targetBounds.left;\n  var dy = chartBounds.top - targetBounds.top;\n  var cx = x - chartBounds.left;\n  var cy = y - chartBounds.top;\n  x -= targetBounds.left;\n  y -= targetBounds.top;\n  return {\n    x: x,\n    // Target point relative to the target bounds\n    y: y,\n    dx: dx,\n    // Delta from target bounds to the chart bounds\n    dy: dy,\n    cx: cx,\n    // Target point relative to the chart bounds\n    cy: cy,\n    clientX: clientX,\n    clientY: clientY,\n    targetBounds: targetBounds,\n    // Target bounding rect\n    chartBounds: chartBounds // Chart bounding rect\n\n  };\n}\n\nvar component$3 = {\n  require: ['chart', 'renderer'],\n  defaultSettings: {\n    settings: DEFAULT_SETTINGS$8,\n    style: DEFAULT_STYLE\n  },\n  renderer: 'dom',\n  on: {\n    hide: function hide() {\n      this.hide();\n    },\n    show: function show(event) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.show(event, opts);\n    },\n    prevent: function prevent(p) {\n      this.prevent(p);\n    }\n  },\n  hide: function hide() {\n    this.dispatcher.clear();\n    this.state.activeNodes = [];\n    this.state.pointer = {};\n  },\n  show: function show(event) {\n    var _this = this;\n\n    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        nodes = _ref3.nodes,\n        duration = _ref3.duration,\n        delay = _ref3.delay;\n\n    if (this.state.prevent) {\n      return;\n    } // Set pointer here to always expose latest pointer to invokeRenderer\n\n\n    this.state.pointer = toPoint(event, this);\n    var fNodes;\n\n    if (Array.isArray(nodes)) {\n      fNodes = this.props.filter(nodes);\n    } else {\n      fNodes = this.props.filter(this.chart.shapesAt({\n        x: this.state.pointer.cx,\n        y: this.state.pointer.cy\n      }));\n    }\n\n    if (this.props.isEqual(this.state.activeNodes, fNodes)) {\n      return;\n    }\n\n    this.dispatcher.clear();\n    this.state.activeNodes = fNodes;\n\n    if (this.state.activeNodes.length) {\n      this.dispatcher.invoke(function () {\n        return _this.invokeRenderer(_this.state.activeNodes);\n      }, duration, delay);\n    }\n  },\n  prevent: function prevent(p) {\n    this.state.prevent = !!p;\n  },\n  init: function init(settings) {\n    var _this2 = this;\n\n    this.state = {\n      activeNodes: [],\n      pointer: {},\n      targetElement: null,\n      prevent: false\n    };\n    this.props = settings.settings;\n    this.dispatcher = timeSpanDispatcher({\n      defaultDuration: this.props.duration,\n      defaultDelay: this.props.delay\n    });\n    var instanceId = this.dispatcher.clear;\n    this.dispatcher.on('pending', function () {\n      // Cancel only if the active is another instance\n      cancelActive(instanceId);\n      setActive(instanceId);\n\n      if (typeof _this2.props.beforeShow === 'function') {\n        _this2.props.beforeShow.call(undefined, {\n          resources: {\n            formatter: _this2.chart.formatter,\n            scale: _this2.chart.scale\n          }\n        });\n      }\n    });\n    this.dispatcher.on(['cancelled', 'fulfilled'], function () {\n      var listenerCtx = {\n        resources: {\n          formatter: _this2.chart.formatter,\n          scale: _this2.chart.scale\n        }\n      };\n\n      if (typeof _this2.props.beforeHide === 'function') {\n        _this2.props.beforeHide.call(undefined, extend({\n          element: _this2.state.tooltipElm\n        }, listenerCtx));\n      }\n\n      if (typeof _this2.props.onHide === 'function') {\n        _this2.props.onHide.call(undefined, extend({\n          element: _this2.state.tooltipElm\n        }, listenerCtx));\n      } else {\n        _this2.renderer.clear([]); // Hide tooltip\n\n      }\n\n      if (typeof _this2.props.afterHide === 'function') {\n        _this2.props.afterHide.call(undefined, listenerCtx);\n      }\n\n      removeActive(instanceId);\n      _this2.state.tooltipElm = undefined;\n    });\n    this.dispatcher.on('active', function () {\n      if (typeof _this2.props.afterShow === 'function') {\n        _this2.props.afterShow.call(undefined, {\n          element: _this2.state.tooltipElm,\n          resources: {\n            formatter: _this2.chart.formatter,\n            scale: _this2.chart.scale\n          }\n        });\n      }\n    });\n  },\n  created: function created() {\n    this.init(this.settings);\n  },\n  beforeUpdate: function beforeUpdate(_ref4) {\n    var settings = _ref4.settings;\n\n    if (this.dispatcher) {\n      this.dispatcher.destroy();\n      remove$1();\n    }\n\n    this.init(settings);\n  },\n  render: function render(h) {\n    this.h = h;\n    return []; // Nothing to render initially.\n  },\n  beforeDestroy: function beforeDestroy() {\n    this.dispatcher.destroy();\n    remove$1();\n  },\n  appendTo: function appendTo() {\n    if (this.props.appendTo) {\n      this.state.targetElement = typeof this.props.appendTo === 'function' ? this.props.appendTo({\n        resources: {\n          formatter: this.chart.formatter,\n          scale: this.chart.scale\n        }\n      }) : this.props.appendTo;\n\n      var _this$state$targetEle = this.state.targetElement.getBoundingClientRect(),\n          width = _this$state$targetEle.width,\n          height = _this$state$targetEle.height;\n\n      this.renderer.destroy();\n      this.renderer.size({\n        width: width,\n        height: height\n      });\n      this.renderer.appendTo(this.state.targetElement);\n    } else {\n      this.state.targetElement = this.renderer.element();\n    }\n  },\n  mounted: function mounted() {\n    this.appendTo();\n  },\n  updated: function updated() {\n    // Append here to, otherwise the picasso displayOrder logic screw things up\n    this.appendTo();\n  },\n  invokeRenderer: function invokeRenderer(nodes) {\n    var items = extractor(nodes, this);\n    var pseudoElement = render$3(items, {\n      style: {\n        left: '0px',\n        top: '0px',\n        visibility: 'hidden'\n      }\n    }, this);\n    var pos = placement(pseudoElement.getBoundingClientRect(), this);\n    this.state.tooltipElm = render$3(items, pos, this);\n  }\n};\n\n/**\n * @typedef {object} component--tooltip\n */\n\n/**\n * @type {string}\n * @memberof component--tooltip\n */\n\nvar type$4 = 'tooltip';\nfunction addTooltip(picasso) {\n  picasso.component(type$4, component$3);\n}\n\nvar debugColliderDef = {\n  require: ['renderer', 'chart'],\n  defaultSettings: {\n    settings: {\n      target: '',\n      selector: '*',\n      fill: 'rgba(0, 255, 0, 0.1)',\n      stroke: 'lime',\n      opacity: 1,\n      useOuterRect: false\n    }\n  },\n  on: {\n    update: function update() {\n      this.draw();\n    }\n  },\n  draw: function draw() {\n    var _this = this;\n\n    var shapes = this.chart.findShapes(this.props.selector).filter(function (s) {\n      return s.key === _this.props.target;\n    }); // Find all shapes\n\n    var colliders = shapes.filter(function (s) {\n      return s.collider;\n    }).map(function (s) {\n      return s.collider;\n    });\n    colliders.forEach(function (c) {\n      c.fill = _this.props.fill;\n      c.stroke = _this.props.stroke;\n      c.opacity = _this.props.opacity;\n      c.collider = {\n        type: null\n      };\n    });\n    this.renderer.render(colliders);\n  },\n  created: function created() {\n    this.props = this.settings.settings;\n  },\n  resize: function resize(_ref) {\n    var outer = _ref.outer,\n        inner = _ref.inner;\n\n    if (this.props.useOuterRect) {\n      return outer;\n    }\n\n    return inner;\n  },\n  render: function render() {},\n  mounted: function mounted() {\n    this.draw();\n  },\n  updated: function updated() {\n    this.props = this.settings.settings;\n    this.draw();\n  }\n};\n\nvar PI_X2 = Math.PI * 2;\n/**\n * Implementation of F.6.5 https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n * @ignore\n * @param {number} rx - Arc x-radius\n * @param {number} ry - Arc y-radius\n * @param {number} rotation - Arc rotation in degrees (0-360)\n * @param {boolean} largeArcFlag\n * @param {boolean} sweepFlag\n * @param {number} endX - X-coordinate for end of arc\n * @param {number} endY - Y-coordinate for end of arc\n * @param {number} startX - X-coordinate for start of arc\n * @param {number} startY - Y-coordinate for start of arc\n * @returns {object}\n */\n\nfunction arcToCenter(rx, ry, rotation, largeArcFlag, sweepFlag, endX, endY, startX, startY) {\n  var startAngle;\n  var endAngle;\n  var sweepAngle;\n  var cx;\n  var cy;\n  var radiusRatio;\n  var rad = toRadians(rotation % 360); // F.6.5.1\n\n  var cos = Math.cos(rad);\n  var sin = Math.sin(rad);\n  var hdx = (startX - endX) / 2;\n  var hdy = (startY - endY) / 2;\n  var x1d = cos * hdx + sin * hdy;\n  var y1d = cos * hdy - sin * hdx; // F.6.6\n\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  radiusRatio = Math.pow(x1d, 2) / Math.pow(rx, 2) + Math.pow(y1d, 2) / Math.pow(ry, 2);\n\n  if (radiusRatio > 1) {\n    radiusRatio = Math.sqrt(radiusRatio);\n    rx *= radiusRatio;\n    ry *= radiusRatio;\n  } // F.6.5.2\n\n\n  var rxry = rx * ry;\n  var rxy1d = rx * y1d;\n  var ryx1d = ry * x1d;\n  var den = Math.pow(rxy1d, 2) + Math.pow(ryx1d, 2);\n  var num = Math.pow(rxry, 2) - den;\n  var frac = Math.sqrt(Math.max(num / den, 0));\n\n  if (largeArcFlag === sweepFlag) {\n    frac = -frac;\n  }\n\n  var cxd = frac * (rxy1d / ry);\n  var cyd = frac * -(ryx1d / rx); // F.6.5.3\n\n  var mx = (startX + endX) / 2;\n  var my = (startY + endY) / 2;\n  cx = cos * cxd - sin * cyd + mx;\n  cy = sin * cxd + cos * cyd + my; // F.6.5.6 clockwise angle\n\n  var ux = (x1d - cxd) / rx;\n  var uy = (y1d - cyd) / ry;\n  var vx = (-x1d - cxd) / rx;\n  var vy = (-y1d - cyd) / ry;\n  startAngle = Math.atan2(uy, ux);\n  startAngle += startAngle < 0 ? PI_X2 : 0;\n  endAngle = Math.atan2(vy, vx);\n  endAngle += endAngle < 0 ? PI_X2 : 0;\n  sweepAngle = endAngle - startAngle;\n\n  if (!sweepFlag && startAngle < endAngle) {\n    sweepAngle -= PI_X2;\n  } else if (sweepFlag && endAngle < startAngle) {\n    sweepAngle += PI_X2;\n  }\n\n  sweepAngle %= PI_X2;\n  return {\n    startAngle: startAngle,\n    sweepAngle: sweepAngle,\n    cx: cx,\n    cy: cy,\n    rx: rx,\n    ry: ry\n  };\n}\n\n/**\n * Measure the flatnass of a cubic bezier curve\n * @ignore\n * @param {point} s - Start point\n * @param {point} cp1 - First control point\n * @param {point} cp2 - Second control point\n * @param {point} e - End point\n */\nfunction flatness(s, cp1, cp2, e) {\n  var ux = Math.abs(s.x + cp2.x - (cp1.x + cp1.x));\n  var uy = Math.abs(s.y + cp2.y - (cp1.y + cp1.y));\n  var vx = Math.abs(cp1.x + e.x - (cp2.x + cp2.x));\n  var vy = Math.abs(cp1.y + e.y - (cp2.y + cp2.y));\n  return ux + uy + vx + vy;\n}\n\nfunction mid(p0, p1) {\n  return {\n    x: (p0.x + p1.x) / 2,\n    y: (p0.y + p1.y) / 2\n  };\n}\n\nfunction interpolate(t, s, cp1, cp2, e) {\n  var td = 1 - t;\n  var t0 = Math.pow(td, 3) * s;\n  var t1 = 3 * Math.pow(td, 2) * t * cp1;\n  var t2 = 3 * td * Math.pow(t, 2) * cp2;\n  var t3 = Math.pow(t, 3) * e;\n  return t0 + t1 + t2 + t3;\n}\n/**\n * Recursive subdivision of a curve using de Casteljau algorithm.\n * Splits the curve into multiple line segments where each segments is choosen based on a level of flatness.\n * @ignore\n * @param {point} s - Start point\n * @param {point} cp1 - First control point\n * @param {point} cp2 - Second control point\n * @param {point} e - End point\n * @param {array} points - Initial set of points\n * @returns {point[]} Array of points\n */\n\n\nfunction toPoints(s, cp1, cp2, e) {\n  var points = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n\n  if (flatness(s, cp1, cp2, e) <= 10) {\n    // Poor man's Set\n    if (points.indexOf(s) === -1) {\n      points.push(s);\n    }\n\n    if (points.indexOf(e) === -1) {\n      points.push(e);\n    }\n\n    return points;\n  }\n\n  var t = 0.5;\n  var m0 = mid(s, cp1);\n  var m1 = mid(cp1, cp2);\n  var m2 = mid(cp2, e);\n  var b = {\n    // Split curve at point\n    x: interpolate(t, s.x, cp1.x, cp2.x, e.x),\n    y: interpolate(t, s.y, cp1.y, cp2.y, e.y)\n  };\n  var q0 = mid(m0, m1); // New cp2 for left curve\n\n  var q1 = mid(m1, m2); // New cp1 for right curve\n\n  toPoints(s, m0, q0, b, points); // left curve\n\n  toPoints(b, q1, m2, e, points); // Right curve\n\n  return points;\n}\n\nfunction toCubic(s, cp, e) {\n  var cp1x = s.x + 2 / 3 * (cp.x - s.x);\n  var cp1y = s.y + 2 / 3 * (cp.y - s.y);\n  var cp2x = e.x + 2 / 3 * (cp.x - e.x);\n  var cp2y = e.y + 2 / 3 * (cp.y - e.y);\n  var cp1 = {\n    x: cp1x,\n    y: cp1y\n  };\n  var cp2 = {\n    x: cp2x,\n    y: cp2y\n  };\n  return {\n    cp1: cp1,\n    cp2: cp2\n  };\n}\n/**\n * Recursive subdivision of a curve using de Casteljau algorithm.\n * Splits the curve into multiple line segments where each segments is choosen based on a level of flatness.\n * @ignore\n * @param {point} s - Start point\n * @param {point} cp - Control point\n * @param {point} e - End point\n * @returns {point[]} Array of points\n */\n\n\nfunction toPoints$1(s, cp, e) {\n  var _toCubic = toCubic(s, cp, e),\n      cp1 = _toCubic.cp1,\n      cp2 = _toCubic.cp2;\n\n  return toPoints(s, cp1, cp2, e);\n}\n\nvar EPSILON$1 = 1e-12;\n\nfunction removeDuplicates(points) {\n  for (var i = 0; i < points.length - 1; i++) {\n    var p0 = points[i];\n    var p1 = points[i + 1];\n\n    if (Math.abs(p0.x - p1.x) < EPSILON$1 && Math.abs(p0.y - p1.y) < EPSILON$1) {\n      points.splice(i, 1);\n      i--;\n    }\n  }\n}\n/**\n * Transform an arc to a set of points a long the arc.\n * Specifiction F.6 (https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes)\n * @ignore\n * @param {array} s - Segments\n * @param {number} startX - X-coordinate for start of arc\n * @param {number} startY - Y-coordinate for start of arc\n */\n\n\nfunction arcToPoints(s, startX, startY) {\n  var points = [];\n  var largeArcFlag = !!s[4]; // F.6.3\n\n  var sweepFlag = !!s[5]; // F.6.3\n\n  var rotation = s[3];\n  var endX = s[6];\n  var endY = s[7];\n  var rx = s[1];\n  var ry = s[2];\n  var cx;\n  var cy;\n  var sweepAngle;\n  var startAngle;\n\n  if (s[0] === 'a') {\n    endX += startX;\n    endY += startY;\n  } // F.6.2\n\n\n  if (startX === endY && startY === endY) {\n    return points;\n  } // Given no radius, threat as lineTo command\n\n\n  if (!rx || !ry) {\n    points.push({\n      x: endX,\n      y: endY\n    });\n    return points;\n  }\n\n  var _arcToCenter = arcToCenter(rx, ry, rotation, largeArcFlag, sweepFlag, endX, endY, startX, startY);\n\n  cx = _arcToCenter.cx;\n  cy = _arcToCenter.cy;\n  rx = _arcToCenter.rx;\n  ry = _arcToCenter.ry;\n  sweepAngle = _arcToCenter.sweepAngle;\n  startAngle = _arcToCenter.startAngle;\n  // Approximation of perimeter\n  var p = Math.abs(sweepAngle * Math.sqrt((Math.pow(rx, 2) + Math.pow(ry, 2)) / 2)); // Generate a point every 10th pixel. Scaling of the node should probably be included in this calculation\n\n  var res = Math.ceil(p / 10);\n  var resAngle = sweepAngle / res;\n\n  for (var k = 1; k <= res; k++) {\n    var deltaAngle = resAngle * k;\n    var radians = (startAngle + deltaAngle) % PI_X2;\n    var cos = Math.cos(radians);\n    var sin = Math.sin(radians); // F.6.3 https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n\n    points.push({\n      x: cx + cos * rx + -sin * cos,\n      y: cy + sin * ry + cos * sin\n    });\n  } // points.push({ x: cx, y: cy });\n\n\n  return points;\n}\n/**\n * Converts a SVG path data string into a set of points.\n * @ignore\n * @param {string} path\n * @returns {Array<point[]>} Array of points\n */\n\n\nfunction pathToPoints(path) {\n  var commands = src_2(path);\n  var segments = [];\n  var points = [];\n  var x = 0; // Current point\n\n  var y = 0;\n  var cpx = null; // Last control point on a cubic curve\n\n  var cpy = null;\n  var qcpx = null; // Last control point on a quad curve\n\n  var qcpy = null;\n\n  for (var i = 0; i < commands.length; ++i) {\n    var cmd = commands[i];\n    var pathType = cmd[0]; // Reset control point if command is not cubic\n\n    if (pathType !== 'S' && pathType !== 's' && pathType !== 'C' && pathType !== 'c') {\n      cpx = null;\n      cpy = null;\n    }\n\n    if (pathType !== 'T' && pathType !== 't' && pathType !== 'Q' && pathType !== 'q') {\n      qcpx = null;\n      qcpy = null;\n    }\n\n    switch (pathType) {\n      case 'm':\n        if (points.length) {\n          segments.push(points.splice(0));\n        }\n\n      // Fall through\n\n      case 'l':\n        // eslint-disable-line no-fallthrough\n        x += cmd[1];\n        y += cmd[2];\n        points.push({\n          x: x,\n          y: y\n        });\n        break;\n\n      case 'M':\n        if (points.length) {\n          segments.push(points.splice(0));\n        }\n\n      // Fall through\n\n      case 'L':\n        // eslint-disable-line no-fallthrough\n        x = cmd[1];\n        y = cmd[2];\n        points.push({\n          x: x,\n          y: y\n        });\n        break;\n\n      case 'H':\n        x = cmd[1];\n        points.push({\n          x: x,\n          y: y\n        });\n        break;\n\n      case 'h':\n        x += cmd[1];\n        points.push({\n          x: x,\n          y: y\n        });\n        break;\n\n      case 'V':\n        y = cmd[1];\n        points.push({\n          x: x,\n          y: y\n        });\n        break;\n\n      case 'v':\n        y += cmd[1];\n        points.push({\n          x: x,\n          y: y\n        });\n        break;\n\n      case 'a':\n        points.push.apply(points, _toConsumableArray$1(arcToPoints(cmd, x, y)));\n        x += cmd[6];\n        y += cmd[7];\n        break;\n\n      case 'A':\n        points.push.apply(points, _toConsumableArray$1(arcToPoints(cmd, x, y)));\n        x = cmd[6];\n        y = cmd[7];\n        break;\n\n      case 'c':\n        points.push.apply(points, _toConsumableArray$1(toPoints({\n          x: x,\n          y: y\n        }, {\n          x: cmd[1] + x,\n          y: cmd[2] + y\n        }, {\n          x: cmd[3] + x,\n          y: cmd[4] + y\n        }, {\n          x: cmd[5] + x,\n          y: cmd[6] + y\n        })));\n        cpx = cmd[3] + x; // Last control point\n\n        cpy = cmd[4] + y;\n        x += cmd[5];\n        y += cmd[6];\n        break;\n\n      case 'C':\n        points.push.apply(points, _toConsumableArray$1(toPoints({\n          x: x,\n          y: y\n        }, {\n          x: cmd[1],\n          y: cmd[2]\n        }, {\n          x: cmd[3],\n          y: cmd[4]\n        }, {\n          x: cmd[5],\n          y: cmd[6]\n        })));\n        cpx = cmd[3]; // Last control point\n\n        cpy = cmd[4];\n        x = cmd[5];\n        y = cmd[6];\n        break;\n\n      case 's':\n        if (cpx === null || cpx === null) {\n          cpx = x;\n          cpy = y;\n        }\n\n        points.push.apply(points, _toConsumableArray$1(toPoints({\n          x: x,\n          y: y\n        }, {\n          x: 2 * x - cpx,\n          y: 2 * y - cpy\n        }, {\n          x: cmd[1] + x,\n          y: cmd[2] + y\n        }, {\n          x: cmd[3] + x,\n          y: cmd[4] + y\n        })));\n        cpx = cmd[1] + x; // last control point\n\n        cpy = cmd[2] + y;\n        x += cmd[3];\n        y += cmd[4];\n        break;\n\n      case 'S':\n        if (cpx === null || cpx === null) {\n          cpx = x;\n          cpy = y;\n        }\n\n        points.push.apply(points, _toConsumableArray$1(toPoints({\n          x: x,\n          y: y\n        }, {\n          x: 2 * x - cpx,\n          y: 2 * y - cpy\n        }, {\n          x: cmd[1],\n          y: cmd[2]\n        }, {\n          x: cmd[3],\n          y: cmd[4]\n        })));\n        cpx = cmd[1]; // last control point\n\n        cpy = cmd[2];\n        x = cmd[3];\n        y = cmd[4];\n        break;\n\n      case 'Q':\n        points.push.apply(points, _toConsumableArray$1(toPoints$1({\n          x: x,\n          y: y\n        }, {\n          x: cmd[1],\n          y: cmd[2]\n        }, {\n          x: cmd[3],\n          y: cmd[4]\n        })));\n        qcpx = cmd[1]; // last control point\n\n        qcpy = cmd[2];\n        x = cmd[3];\n        y = cmd[4];\n        break;\n\n      case 'q':\n        points.push.apply(points, _toConsumableArray$1(toPoints$1({\n          x: x,\n          y: y\n        }, {\n          x: cmd[1] + x,\n          y: cmd[2] + y\n        }, {\n          x: cmd[3] + x,\n          y: cmd[4] + y\n        })));\n        qcpx = cmd[1] + x; // last control point\n\n        qcpy = cmd[2] + y;\n        x += cmd[3];\n        y += cmd[4];\n        break;\n\n      case 'T':\n        if (qcpx === null || qcpx === null) {\n          qcpx = x;\n          qcpy = y;\n        }\n\n        qcpx = 2 * x - qcpx; // last control point\n\n        qcpy = 2 * y - qcpy;\n        points.push.apply(points, _toConsumableArray$1(toPoints$1({\n          x: x,\n          y: y\n        }, {\n          x: qcpx,\n          y: qcpy\n        }, {\n          x: cmd[1],\n          y: cmd[2]\n        })));\n        x = cmd[1];\n        y = cmd[2];\n        break;\n\n      case 't':\n        if (qcpx === null || qcpx === null) {\n          qcpx = x;\n          qcpy = y;\n        }\n\n        qcpx = 2 * x - qcpx; // last control point\n\n        qcpy = 2 * y - qcpy;\n        points.push.apply(points, _toConsumableArray$1(toPoints$1({\n          x: x,\n          y: y\n        }, {\n          x: qcpx,\n          y: qcpy\n        }, {\n          x: cmd[1] + x,\n          y: cmd[2] + y\n        })));\n        x += cmd[1];\n        y += cmd[2];\n        break;\n\n      case 'z':\n      case 'Z':\n        if (points.length) {\n          points.push({\n            x: points[0].x,\n            y: points[0].y\n          });\n        }\n\n        break;\n\n      default: // Do nothing\n\n    }\n  }\n\n  removeDuplicates(points);\n  segments.push(points.splice(0));\n  return segments;\n}\n\nvar debugPathToPointsDef = {\n  require: ['renderer', 'chart'],\n  defaultSettings: {\n    settings: {\n      target: '',\n      fill: 'transparent',\n      stroke: 'lime',\n      opacity: 1,\n      radius: 2,\n      useOuterRect: false\n    }\n  },\n  on: {\n    update: function update() {\n      this.draw();\n    }\n  },\n  draw: function draw() {\n    var _this = this;\n\n    var shapes = this.chart.findShapes('path').filter(function (s) {\n      return s.key === _this.props.target;\n    }); // Find all shapes\n\n    var circles = [];\n    shapes.forEach(function (s) {\n      pathToPoints(s.attrs.d).forEach(function (segment) {\n        segment.forEach(function (p) {\n          circles.push({\n            type: 'circle',\n            cx: p.x,\n            cy: p.y,\n            r: _this.props.radius,\n            fill: _this.props.fill,\n            stroke: _this.props.stroke,\n            opacity: _this.props.opacity,\n            collider: {\n              type: null\n            }\n          });\n        });\n      });\n    });\n    this.renderer.render(circles);\n  },\n  created: function created() {\n    this.props = this.settings.settings;\n  },\n  resize: function resize(_ref) {\n    var outer = _ref.outer,\n        inner = _ref.inner;\n\n    if (this.props.useOuterRect) {\n      return outer;\n    }\n\n    return inner;\n  },\n  render: function render() {},\n  mounted: function mounted() {\n    this.draw();\n  },\n  updated: function updated() {\n    this.props = this.settings.settings;\n    this.draw();\n  }\n};\n\nfunction debugCollider(picasso) {\n  picasso.component('debug-collider', debugColliderDef);\n}\nfunction debugPathToPoints(picasso) {\n  picasso.component('debug-path-to-points', debugPathToPointsDef);\n}\n\nvar components = [box$1, pointMarker, pie$1, gridLine, refLine, axis, text, scrollbar, rangeBrush, rangeBrush$1, lassoBrush, labels, categoricalLegend, sequentialLegend, line$2, areaBrush, addTooltip, debugCollider, debugPathToPoints];\n\nvar Node =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @private\n   */\n  function Node(type) {\n    _classCallCheck$1(this, Node);\n\n    this._parent = null;\n    this._children = [];\n    this._ancestors = null;\n    this.type = type;\n    this.data = null;\n  }\n  /**\n   * Detaches this node from its parent, if such exists.\n   * @returns {Node}\n   */\n\n\n  _createClass$1(Node, [{\n    key: \"detach\",\n    value: function detach() {\n      if (this._parent) {\n        this._parent.removeChild(this);\n      }\n\n      return this;\n    }\n    /**\n     * Parent of this node.\n     * @readonly\n     * @type {Node}\n     */\n\n  }, {\n    key: \"equals\",\n\n    /**\n     *\n     * @returns {Boolean}\n     */\n    value: function equals(n) {\n      var children = this.children;\n      var nChildren = n.children;\n\n      if (children.length !== nChildren.length) {\n        return false;\n      } // Requires deterministic child order\n\n\n      for (var i = 0; i < children.length; i++) {\n        if (!children[i].equals(nChildren[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        type: this.type,\n        children: this.children.map(function (ch) {\n          return ch.toJSON();\n        })\n      };\n    }\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return this._parent;\n    }\n    /**\n     * Checks whether this node is a branch.\n     *\n     * True if this node has children, false otherwise.\n     * @readonly\n     * @type {Boolean}\n     */\n\n  }, {\n    key: \"isBranch\",\n    get: function get() {\n      return this._children && this._children.length;\n    }\n    /**\n     * Children of this node.\n     * @readonly\n     * @type {Node[]}\n     */\n\n  }, {\n    key: \"children\",\n    get: function get() {\n      return this._children;\n    }\n    /**\n     * Ancestors of this node, including parent.\n     * @readonly\n     * @type {Node[]}\n     */\n\n  }, {\n    key: \"ancestors\",\n    get: function get() {\n      if (!this._ancestors) {\n        this._ancestors = [];\n\n        if (this.parent) {\n          var _this$_ancestors;\n\n          (_this$_ancestors = this._ancestors).push.apply(_this$_ancestors, [this.parent].concat(_toConsumableArray$1(this.parent.ancestors)));\n        }\n      }\n\n      return this._ancestors;\n    }\n    /**\n     * Descendants of this node.\n     * @readonly\n     * @type {Node[]}\n     */\n\n  }, {\n    key: \"descendants\",\n    get: function get() {\n      var r = [];\n      var len = this.children.length;\n      var i;\n      var c;\n\n      for (i = 0, len; i < len; i++) {\n        c = this.children[i];\n        r.push(c);\n\n        if (c.children.length) {\n          r.push.apply(r, _toConsumableArray$1(c.descendants));\n        }\n      }\n\n      return r;\n    }\n  }]);\n\n  return Node;\n}();\n\n/**\n * Construct a new GeoRect instance\n * @private\n */\n\nvar GeoRect =\n/*#__PURE__*/\nfunction () {\n  function GeoRect() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$x = _ref.x,\n        x = _ref$x === void 0 ? 0 : _ref$x,\n        _ref$y = _ref.y,\n        y = _ref$y === void 0 ? 0 : _ref$y,\n        _ref$width = _ref.width,\n        width = _ref$width === void 0 ? 0 : _ref$width,\n        _ref$height = _ref.height,\n        height = _ref$height === void 0 ? 0 : _ref$height,\n        _ref$minWidth = _ref.minWidth,\n        minWidth = _ref$minWidth === void 0 ? 0 : _ref$minWidth,\n        _ref$minHeight = _ref.minHeight,\n        minHeight = _ref$minHeight === void 0 ? 0 : _ref$minHeight;\n\n    _classCallCheck$1(this, GeoRect);\n\n    this.set({\n      x: x,\n      y: y,\n      width: width,\n      height: height,\n      minWidth: minWidth,\n      minHeight: minHeight\n    });\n  }\n\n  _createClass$1(GeoRect, [{\n    key: \"set\",\n    value: function set() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref2$x = _ref2.x,\n          x = _ref2$x === void 0 ? 0 : _ref2$x,\n          _ref2$y = _ref2.y,\n          y = _ref2$y === void 0 ? 0 : _ref2$y,\n          _ref2$width = _ref2.width,\n          width = _ref2$width === void 0 ? 0 : _ref2$width,\n          _ref2$height = _ref2.height,\n          height = _ref2$height === void 0 ? 0 : _ref2$height,\n          _ref2$minWidth = _ref2.minWidth,\n          minWidth = _ref2$minWidth === void 0 ? 0 : _ref2$minWidth,\n          _ref2$minHeight = _ref2.minHeight,\n          minHeight = _ref2$minHeight === void 0 ? 0 : _ref2$minHeight;\n\n      this.type = 'rect';\n\n      if (width >= 0) {\n        this.x = x;\n        this.width = Math.max(width, minWidth);\n      } else {\n        this.x = x + Math.min(width, -minWidth);\n        this.width = -Math.min(width, -minWidth);\n      }\n\n      if (height >= 0) {\n        this.y = y;\n        this.height = Math.max(height, minHeight);\n      } else {\n        this.y = y + Math.min(height, -minHeight);\n        this.height = -Math.min(height, -minHeight);\n      }\n    }\n    /**\n     * @param {point} p\n     * @returns {boolean} True if there is an intersection, false otherwise\n     */\n\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(p) {\n      return testRectPoint(this, p);\n    }\n    /**\n     * @param {point[]} points - Line start and end point as an array of points\n     * @returns {boolean} True if there is an intersection, false otherwise\n     */\n\n  }, {\n    key: \"intersectsLine\",\n    value: function intersectsLine(points) {\n      var line = pointsToLine(points);\n      return testRectLine(this, line);\n    }\n    /**\n     * @param {point[]} points - Rect vertices as an array of points\n     * @returns {boolean} True if there is an intersection, false otherwise\n     */\n\n  }, {\n    key: \"intersectsRect\",\n    value: function intersectsRect(points) {\n      var rect = pointsToRect(points);\n      return testRectRect(this, rect);\n    }\n    /**\n     * @param {circle} c\n     * @returns {boolean} True if there is an intersection, false otherwise\n     */\n\n  }, {\n    key: \"intersectsCircle\",\n    value: function intersectsCircle(c) {\n      return testCircleRect(c, this);\n    }\n    /**\n     * @param {GeoPolygon} polygon\n     * @returns {boolean} True if there is an intersection, false otherwise\n     */\n\n  }, {\n    key: \"intersectsPolygon\",\n    value: function intersectsPolygon(polygon) {\n      return testPolygonRect(polygon, this);\n    }\n    /**\n     * Get the points\n     * @returns {point[]}\n     */\n\n  }, {\n    key: \"points\",\n    value: function points() {\n      return [{\n        x: this.x,\n        y: this.y\n      }, {\n        x: this.x + this.width,\n        y: this.y\n      }, {\n        x: this.x + this.width,\n        y: this.y + this.height\n      }, {\n        x: this.x,\n        y: this.y + this.height\n      }];\n    }\n  }]);\n\n  return GeoRect;\n}();\n\nfunction create$4() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return _construct(GeoRect, args);\n}\n\n/**\n * Construct a new GeoCircle instance\n * @private\n */\n\nvar GeoCircle =\n/*#__PURE__*/\nfunction () {\n  function GeoCircle() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$cx = _ref.cx,\n        cx = _ref$cx === void 0 ? 0 : _ref$cx,\n        _ref$cy = _ref.cy,\n        cy = _ref$cy === void 0 ? 0 : _ref$cy,\n        _ref$r = _ref.r,\n        r = _ref$r === void 0 ? 0 : _ref$r,\n        _ref$minRadius = _ref.minRadius,\n        minRadius = _ref$minRadius === void 0 ? 0 : _ref$minRadius;\n\n    _classCallCheck$1(this, GeoCircle);\n\n    this.set({\n      cx: cx,\n      cy: cy,\n      r: r,\n      minRadius: minRadius\n    });\n  }\n\n  _createClass$1(GeoCircle, [{\n    key: \"set\",\n    value: function set() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref2$cx = _ref2.cx,\n          cx = _ref2$cx === void 0 ? 0 : _ref2$cx,\n          _ref2$cy = _ref2.cy,\n          cy = _ref2$cy === void 0 ? 0 : _ref2$cy,\n          _ref2$r = _ref2.r,\n          r = _ref2$r === void 0 ? 0 : _ref2$r,\n          _ref2$minRadius = _ref2.minRadius,\n          minRadius = _ref2$minRadius === void 0 ? 0 : _ref2$minRadius;\n\n      this.type = 'circle';\n      this.cx = cx;\n      this.cy = cy;\n      this.r = Math.max(r, minRadius);\n      this.vector = {\n        x: this.cx,\n        y: this.cy\n      };\n    }\n    /**\n     * @param {point} p\n     * @returns {boolean} True if there is an intersection, false otherwise\n     */\n\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(p) {\n      return testCirclePoint(this, p);\n    }\n    /**\n     * @param {point[]} points - Line start and end point as an array of points\n     * @returns {boolean} True if there is an intersection, false otherwise\n     */\n\n  }, {\n    key: \"intersectsLine\",\n    value: function intersectsLine(points) {\n      var line = pointsToLine(points);\n      return testCircleLine(this, line);\n    }\n    /**\n     * @param {point[]} points - Rect vertices as an array of points\n     * @returns {boolean} True if there is an intersection, false otherwise\n     */\n\n  }, {\n    key: \"intersectsRect\",\n    value: function intersectsRect(points) {\n      var rect = pointsToRect(points);\n      return testCircleRect(this, rect);\n    }\n    /**\n     * @param {circle} c\n     * @returns {boolean} True if there is an intersection, false otherwise\n     */\n\n  }, {\n    key: \"intersectsCircle\",\n    value: function intersectsCircle(c) {\n      return testCircleCircle(this, c);\n    }\n    /**\n     * @param {GeoPolygon} polygon\n     * @returns {boolean} True if there is an intersection, false otherwise\n     */\n\n  }, {\n    key: \"intersectsPolygon\",\n    value: function intersectsPolygon(polygon) {\n      return testCirclePolygon(this, polygon);\n    }\n    /**\n     * Get the points\n     * @returns {point[]}\n     */\n\n  }, {\n    key: \"points\",\n    value: function points() {\n      return [{\n        x: this.cx,\n        y: this.cy\n      }];\n    }\n  }]);\n\n  return GeoCircle;\n}();\n\nfunction create$5() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return _construct(GeoCircle, args);\n}\n\n/**\n * Construct a new GeoLine instance\n * @private\n */\n\nvar GeoLine =\n/*#__PURE__*/\nfunction () {\n  function GeoLine() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$x = _ref.x1,\n        x1 = _ref$x === void 0 ? 0 : _ref$x,\n        _ref$y = _ref.y1,\n        y1 = _ref$y === void 0 ? 0 : _ref$y,\n        _ref$x2 = _ref.x2,\n        x2 = _ref$x2 === void 0 ? 0 : _ref$x2,\n        _ref$y2 = _ref.y2,\n        y2 = _ref$y2 === void 0 ? 0 : _ref$y2,\n        _ref$tolerance = _ref.tolerance,\n        tolerance = _ref$tolerance === void 0 ? 0 : _ref$tolerance;\n\n    _classCallCheck$1(this, GeoLine);\n\n    this.set({\n      x1: x1,\n      y1: y1,\n      x2: x2,\n      y2: y2,\n      tolerance: tolerance\n    });\n  }\n\n  _createClass$1(GeoLine, [{\n    key: \"set\",\n    value: function set() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref2$x = _ref2.x1,\n          x1 = _ref2$x === void 0 ? 0 : _ref2$x,\n          _ref2$y = _ref2.y1,\n          y1 = _ref2$y === void 0 ? 0 : _ref2$y,\n          _ref2$x2 = _ref2.x2,\n          x2 = _ref2$x2 === void 0 ? 0 : _ref2$x2,\n          _ref2$y2 = _ref2.y2,\n          y2 = _ref2$y2 === void 0 ? 0 : _ref2$y2,\n          _ref2$tolerance = _ref2.tolerance,\n          tolerance = _ref2$tolerance === void 0 ? 0 : _ref2$tolerance;\n\n      this.type = 'line';\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n      this.tolerance = Math.max(0, Math.round(tolerance));\n      this.vectors = this.points();\n      this.zeroSize = x1 === x2 && y1 === y2;\n    }\n    /**\n     * @param {point} p\n     * @returns {boolean} True if there is an intersection, false otherwise\n     */\n\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(p) {\n      if (this.tolerance > 0) {\n        var c = {\n          cx: p.x,\n          cy: p.y,\n          r: this.tolerance\n        };\n        return testCircleLine(c, this);\n      }\n\n      return testLinePoint(this, p);\n    }\n    /**\n     * @param {point[]} points - Line start and end point as an array of points\n     * @returns {boolean} True if there is an intersection, false otherwise\n     */\n\n  }, {\n    key: \"intersectsLine\",\n    value: function intersectsLine(points) {\n      var line = pointsToLine(points);\n      return testLineLine(this, line);\n    }\n    /**\n     * @param {point[]} points - Rect vertices as an array of points\n     * @returns {boolean} True if there is an intersection, false otherwise\n     */\n\n  }, {\n    key: \"intersectsRect\",\n    value: function intersectsRect(points) {\n      var rect = pointsToRect(points);\n      return testRectLine(rect, this);\n    }\n    /**\n     * @param {circle} c\n     * @returns {boolean} True if there is an intersection, false otherwise\n     */\n\n  }, {\n    key: \"intersectsCircle\",\n    value: function intersectsCircle(c) {\n      return testCircleLine(c, this);\n    }\n    /**\n     * @param {GeoPolygon} polygon\n     * @returns {boolean} True if there is an intersection, false otherwise\n     */\n\n  }, {\n    key: \"intersectsPolygon\",\n    value: function intersectsPolygon(polygon) {\n      return testPolygonLine(polygon, this);\n    }\n    /**\n     * Get the points\n     * @returns {point[]}\n     */\n\n  }, {\n    key: \"points\",\n    value: function points() {\n      return [{\n        x: this.x1,\n        y: this.y1\n      }, {\n        x: this.x2,\n        y: this.y2\n      }];\n    }\n  }]);\n\n  return GeoLine;\n}();\n\nfunction create$6() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return _construct(GeoLine, args);\n}\n\nfunction close(vertices) {\n  var first = vertices[0];\n  var last = vertices[vertices.length - 1];\n\n  if (first.x !== last.x || first.y !== last.y) {\n    vertices.push(first);\n  }\n}\n\nfunction removeDuplicates$1(vertices) {\n  for (var i = 0; i < vertices.length - 1; i++) {\n    var v0 = vertices[i];\n    var v1 = vertices[i + 1];\n\n    if (v0.x === v1.x && v0.y === v1.y) {\n      vertices.splice(i, 1);\n      i--;\n    }\n  }\n}\n/**\n * Construct a new GeoPolygon instance\n * @private\n */\n\n\nvar GeoPolygon =\n/*#__PURE__*/\nfunction () {\n  function GeoPolygon() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$vertices = _ref.vertices,\n        vertices = _ref$vertices === void 0 ? [] : _ref$vertices;\n\n    _classCallCheck$1(this, GeoPolygon);\n\n    this.set({\n      vertices: vertices\n    });\n  }\n  /**\n   * Set the vertices.\n   * If vertices doesn't close the polygon, a closing vertice is appended.\n   * @param {object} input An object with a vertices property\n   * @param {point[]} [input.vertices=[]] Vertices are represented as an array of points.\n   */\n\n\n  _createClass$1(GeoPolygon, [{\n    key: \"set\",\n    value: function set() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref2$vertices = _ref2.vertices,\n          vertices = _ref2$vertices === void 0 ? [] : _ref2$vertices;\n\n      this.type = 'polygon';\n      this.vertices = vertices.slice();\n      this.edges = [];\n      removeDuplicates$1(this.vertices);\n\n      if (this.vertices.length <= 2) {\n        return;\n      }\n\n      close(this.vertices);\n      this.xMin = NaN;\n      this.yMin = NaN;\n      this.xMax = NaN;\n      this.yMax = NaN;\n\n      for (var i = 0; i < this.vertices.length; i++) {\n        if (i < this.vertices.length - 1) {\n          this.edges.push([this.vertices[i], this.vertices[i + 1]]);\n        }\n\n        this.xMin = isNaN(this.xMin) ? this.vertices[i].x : Math.min(this.xMin, this.vertices[i].x);\n        this.xMax = isNaN(this.xMax) ? this.vertices[i].x : Math.max(this.xMax, this.vertices[i].x);\n        this.yMin = isNaN(this.yMin) ? this.vertices[i].y : Math.min(this.yMin, this.vertices[i].y);\n        this.yMax = isNaN(this.yMax) ? this.vertices[i].y : Math.max(this.yMax, this.vertices[i].y);\n      }\n\n      this._bounds = null;\n      this._boundingRect = null;\n    }\n    /**\n     * Check if a point is inside the area of the polygon.\n     * Supports convex, concave and self-intersecting polygons (filled area).\n     * @param {point} point\n     * @returns {boolean} True if there is an intersection, false otherwise\n     */\n\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(point) {\n      return testPolygonPoint(this, point);\n    }\n    /**\n     * Check if circle is inside the area of the polygon.\n     * Supports convex, concave and self-intersecting polygons (filled area).\n     * @param {circle} circle\n     * @returns {boolean} True if there is an intersection, false otherwise\n     */\n\n  }, {\n    key: \"intersectsCircle\",\n    value: function intersectsCircle(circle) {\n      return testCirclePolygon(circle, this);\n    }\n    /**\n     * @param {point[]} points - Line start and end point as an array of points\n     * @returns {boolean} True if there is an intersection, false otherwise\n     */\n\n  }, {\n    key: \"intersectsLine\",\n    value: function intersectsLine(points) {\n      return testPolygonLine(this, pointsToLine(points));\n    }\n    /**\n     * @param {point[]} points - Rect vertices as an array of points\n     * @returns {boolean} True if there is an intersection, false otherwise\n     */\n\n  }, {\n    key: \"intersectsRect\",\n    value: function intersectsRect(points) {\n      return testPolygonRect(this, pointsToRect(points));\n    }\n    /**\n     * Check if polygon intersects another polygon.\n     * Supports convex, concave and self-intersecting polygons (filled area).\n     * @param {GeoPolygon} polygon\n     * @returns {boolean} True if there is an intersection, false otherwise\n     */\n\n  }, {\n    key: \"intersectsPolygon\",\n    value: function intersectsPolygon(polygon) {\n      // This is a unoptimized solution and should be replaced by a more efficient algorithm.\n      if (!testRectRect(this.boundingRect(), polygon.boundingRect())) {\n        return false;\n      }\n\n      var intersects = false;\n\n      for (var i = 0, len = this.edges.length; i < len; i++) {\n        intersects = testPolygonLine(polygon, pointsToLine(this.edges[i]));\n\n        if (intersects === true) {\n          break;\n        }\n      }\n\n      return intersects;\n    }\n    /**\n     * Get the points\n     * @returns {point[]}\n     */\n\n  }, {\n    key: \"points\",\n    value: function points() {\n      return this.vertices;\n    }\n    /**\n     * Get the bounds of the polygon, as an array of points\n     * @returns {point[]}\n     */\n\n  }, {\n    key: \"bounds\",\n    value: function bounds() {\n      if (!this._bounds) {\n        this._bounds = [{\n          x: this.xMin,\n          y: this.yMin\n        }, {\n          x: this.xMax,\n          y: this.yMin\n        }, {\n          x: this.xMax,\n          y: this.yMax\n        }, {\n          x: this.xMin,\n          y: this.yMax\n        }];\n      }\n\n      return this._bounds;\n    }\n    /**\n     * Get the bounding rect of the polygon\n     * @returns {rect}\n     */\n\n  }, {\n    key: \"boundingRect\",\n    value: function boundingRect() {\n      if (!this._boundingRect) {\n        this._boundingRect = {\n          x: this.xMin,\n          y: this.yMin,\n          width: this.xMax - this.xMin,\n          height: this.yMax - this.yMin\n        };\n      }\n\n      return this._boundingRect;\n    }\n  }]);\n\n  return GeoPolygon;\n}();\n/**\n* Construct a new GeoPolygon instance\n* @param {object} input An object with a vertices property\n* @param {point[]} [input.vertices=[]] Vertices are represented as an array of points.\n* @returns {GeoPolygon} GeoPolygon instance\n* @private\n*/\n\n\nfunction create$7() {\n  for (var _len = arguments.length, a = new Array(_len), _key = 0; _key < _len; _key++) {\n    a[_key] = arguments[_key];\n  }\n\n  return _construct(GeoPolygon, a);\n}\n\nfunction pointsAreNotEqual(p0, p1) {\n  return p0.x !== p1.x || p0.y !== p1.y;\n}\n/**\n * Construct a new GeoPolyline instance\n * @private\n */\n\n\nvar GeoPolyline =\n/*#__PURE__*/\nfunction () {\n  function GeoPolyline() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$points = _ref.points,\n        points = _ref$points === void 0 ? [] : _ref$points;\n\n    _classCallCheck$1(this, GeoPolyline);\n\n    this.set({\n      points: points\n    });\n  }\n\n  _createClass$1(GeoPolyline, [{\n    key: \"set\",\n    value: function set() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref2$points = _ref2.points,\n          points = _ref2$points === void 0 ? [] : _ref2$points;\n\n      this.type = 'polyline';\n      this.segments = [];\n      this._points = points.slice();\n\n      if (this._points.length > 1) {\n        for (var i = 0, len = this._points.length - 1; i < len; i++) {\n          if (pointsAreNotEqual(this._points[i], this._points[i + 1])) {\n            this.segments.push({\n              x1: this._points[i].x,\n              y1: this._points[i].y,\n              x2: this._points[i + 1].x,\n              y2: this._points[i + 1].y\n            });\n          }\n        }\n      }\n    }\n    /**\n     * @param {point} point\n     * @returns {boolean} True if there is an intersection, false otherwise\n     */\n\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(point) {\n      return this.segments.some(function (line) {\n        return testLinePoint(line, point);\n      });\n    }\n    /**\n     * @param {circle} circle\n     * @returns {boolean} True if there is an intersection, false otherwise\n     */\n\n  }, {\n    key: \"intersectsCircle\",\n    value: function intersectsCircle(circle) {\n      return this.segments.some(function (line) {\n        return testCircleLine(circle, line);\n      });\n    }\n    /**\n     * @param {point[]} points - Line start and end point as an array of points\n     * @returns {boolean} True if there is an intersection, false otherwise\n     */\n\n  }, {\n    key: \"intersectsLine\",\n    value: function intersectsLine(points) {\n      var testLine = pointsToLine(points);\n      return this.segments.some(function (line) {\n        return testLineLine(line, testLine);\n      });\n    }\n    /**\n     * @param {point[]} points - Rect vertices as an array of points\n     * @returns {boolean} True if there is an intersection, false otherwise\n     */\n\n  }, {\n    key: \"intersectsRect\",\n    value: function intersectsRect(points) {\n      var rect = pointsToRect(points);\n      return this.segments.some(function (line) {\n        return testRectLine(rect, line);\n      });\n    }\n    /**\n     * @param {GeoPolygon} polygon\n     * @returns {boolean} True if there is an intersection, false otherwise\n     */\n\n  }, {\n    key: \"intersectsPolygon\",\n    value: function intersectsPolygon(polygon) {\n      // This is a unoptimized solution and should be replaced by a more efficient algorithm.\n      return this.segments.some(function (line) {\n        return testPolygonLine(polygon, line);\n      });\n    }\n    /**\n     * Get the points\n     * @returns {point[]}\n     */\n\n  }, {\n    key: \"points\",\n    value: function points() {\n      return this._points;\n    }\n  }]);\n\n  return GeoPolyline;\n}();\n\nfunction create$8() {\n  for (var _len = arguments.length, a = new Array(_len), _key = 0; _key < _len; _key++) {\n    a[_key] = arguments[_key];\n  }\n\n  return _construct(GeoPolyline, a);\n}\n\nvar reg$3 = registryFactory();\nreg$3.add('rect', create$4);\nreg$3.add('circle', create$5);\nreg$3.add('line', create$6);\nreg$3.add('polygon', create$7);\nreg$3.add('polyline', create$8);\nfunction create$9(type, input) {\n  // eslint-disable-line import/prefer-default-export\n  return reg$3.get(type)(input);\n}\n/**\n * @typedef {object} rect\n * @property {number} x - X-coordinate\n * @property {number} y - Y-coordinate\n * @property {number} width - Width\n * @property {number} height - Height\n */\n\n/**\n * @typedef {object} line\n * @property {number} x1 - Start x-coordinate\n * @property {number} y1 - Start y-coordinate\n * @property {number} x2 - End x-coordinate\n * @property {number} y2 - End y-coordinate\n */\n\n/**\n * @typedef {object} point\n * @property {number} x - X-coordinate\n * @property {number} y - Y-coordinate\n */\n\n/**\n * @typedef {object} circle\n * @property {number} cx - Center x-coordinate\n * @property {number} cy - Center y-coordinate\n * @property {number} r - Circle radius\n */\n\n/**\n * @typedef {object} polygon\n * @property {Array<point>} points - Array of connected points\n */\n\n/**\n * @typedef {object} polyline\n * @property {Array<point>} points - Array of connected points\n */\n\n/**\n * @typedef {object} path\n * @property {string} d - Path definition\n */\n\n/**\n * Construct a new GeometryCollection instance\n * @private\n  */\n\nvar GeometryCollection =\n/*#__PURE__*/\nfunction () {\n  function GeometryCollection() {\n    var collection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    _classCallCheck$1(this, GeometryCollection);\n\n    this.set(collection);\n  }\n\n  _createClass$1(GeometryCollection, [{\n    key: \"set\",\n    value: function set() {\n      var _this = this;\n\n      var collection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      this.geometries = [];\n      collection.forEach(function (geo) {\n        var geoInstance = create$9(geo.type, geo);\n\n        if (geoInstance) {\n          _this.geometries.push(geoInstance);\n        }\n      });\n    }\n    /**\n     * @param {point} p\n     * @returns {boolean} True if there is an intersection, false otherwise\n     */\n\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(p) {\n      return this.geometries.some(function (geo) {\n        return geo.containsPoint(p);\n      });\n    }\n    /**\n     * @param {point[]} points - Line start and end point as an array of points\n     * @returns {boolean} True if there is an intersection, false otherwise\n     */\n\n  }, {\n    key: \"intersectsLine\",\n    value: function intersectsLine(points) {\n      return this.geometries.some(function (geo) {\n        return geo.intersectsLine(points);\n      });\n    }\n    /**\n     * @param {point[]} points - Rect vertices as an array of points\n     * @returns {boolean} True if there is an intersection, false otherwise\n     */\n\n  }, {\n    key: \"intersectsRect\",\n    value: function intersectsRect(points) {\n      return this.geometries.some(function (geo) {\n        return geo.intersectsRect(points);\n      });\n    }\n    /**\n     * @param {circle} c\n     * @returns {boolean} True if there is an intersection, false otherwise\n     */\n\n  }, {\n    key: \"intersectsCircle\",\n    value: function intersectsCircle(c) {\n      return this.geometries.some(function (geo) {\n        return geo.intersectsCircle(c);\n      });\n    }\n    /**\n     * @param {GeoPolygon} polygon\n     * @returns {boolean} True if there is an intersection, false otherwise\n     */\n\n  }, {\n    key: \"intersectsPolygon\",\n    value: function intersectsPolygon(polygon) {\n      return this.geometries.some(function (geo) {\n        return geo.intersectsPolygon(polygon);\n      });\n    }\n  }]);\n\n  return GeometryCollection;\n}();\n\nfunction create$a() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return _construct(GeometryCollection, args);\n}\n\nvar Matrix =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates a matrix with identity values.\n   * @private\n   */\n  function Matrix() {\n    _classCallCheck$1(this, Matrix);\n\n    this._elements = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];\n    this._stack = [];\n  }\n  /**\n   * Creates a new matrix with a copy of the current values.\n   */\n\n\n  _createClass$1(Matrix, [{\n    key: \"clone\",\n    value: function clone() {\n      var mt = new Matrix();\n      return mt.multiply(this);\n    }\n    /**\n    * Sets the matrix values\n    * @param {Number[][]} arr A 3x3 array.\n    */\n\n  }, {\n    key: \"set\",\n    value: function set(arr) {\n      this._elements = arr;\n      return this;\n    }\n    /**\n    * Saves the current matrix values to a stack.\n    */\n\n  }, {\n    key: \"save\",\n    value: function save() {\n      this._stack.push(this.elements);\n\n      return this;\n    }\n    /**\n    * Sets the current matrix values to the last ones saved on to the stack.\n    */\n\n  }, {\n    key: \"restore\",\n    value: function restore() {\n      if (this._stack.length) {\n        this._elements = this._stack.pop(); // TODO - use a copy instead\n      }\n\n      return this;\n    }\n    /**\n    * Adds a scalar value to each element in the matrix.\n    * @param {Number} value\n    */\n\n  }, {\n    key: \"add\",\n    value: function add(value) {\n      // assume scalar\n      var i, j;\n\n      for (i = 0; i < this._elements.length; i++) {\n        for (j = 0; j < this._elements[i].length; j++) {\n          this._elements[i][j] += value;\n        }\n      }\n\n      return this;\n    }\n    /**\n    * Translates the current matrix along the x and y axis.\n    * @param {Number} x\n    * @param {Number} y\n    */\n\n  }, {\n    key: \"translate\",\n    value: function translate(x, y) {\n      this.multiply([[1, 0, x], [0, 1, y], [0, 0, 1]]);\n      return this;\n    }\n    /**\n    * Rotates the current matrix.\n    * @param {Number} radianAngle Angle in radians.\n    */\n\n  }, {\n    key: \"rotate\",\n    value: function rotate(radianAngle) {\n      var cos = Math.cos(-radianAngle),\n          sin = Math.sin(-radianAngle);\n      this.multiply([[cos, sin, 0], [-sin, cos, 0], [0, 0, 1]]);\n      return this;\n    }\n    /**\n    *\n    * If value is a number; multiplies each element in the matrix by the given value.\n    * If value is a matrix; multiplies the two matrices.\n    * @param {Number|Array|Matrix} value\n    */\n\n  }, {\n    key: \"multiply\",\n    value: function multiply(value) {\n      var i, j, m, k;\n\n      if (value instanceof Matrix) {\n        value = value._elements;\n      }\n\n      if (Array.isArray(value)) {\n        // matrix multiplication\n        m = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];\n\n        for (i = 0; i < this._elements.length; i++) {\n          // row\n          for (j = 0; j < this._elements[i].length; j++) {\n            // column\n            for (k = 0; k < 3; k++) {\n              // row\n              m[i][j] += this._elements[i][k] * value[k][j];\n            }\n          }\n        }\n\n        this._elements = m;\n      } else {\n        // scalar multiplication\n        for (i = 0; i < this._elements.length; i++) {\n          for (j = 0; j < this._elements[i].length; j++) {\n            this._elements[i][j] *= value;\n          }\n        }\n      }\n\n      return this;\n    }\n    /**\n    * Scales the matrix along x and y axis.\n    * @param {Number} x The value to scale the matrix with along the x direction\n    * @param {Number} [y=x] The value to scale the matrix with along the y direction.\n    */\n\n  }, {\n    key: \"scale\",\n    value: function scale(x) {\n      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;\n      // if ( arguments.length < 2 || typeof y === \"undefined\" ) {\n      //  y = x;\n      // }\n      this.multiply([[x, 0, 0], [0, y, 0], [0, 0, 1]]);\n      return this;\n    }\n    /**\n     * Multiples the matrix with the supplied transformation values\n     * @param {Number} a Horizontal scaling\n     * @param {Number} b Horizontal skewing\n     * @param {Number} c Vertical skewing\n     * @param {Number} d Vertical scaling\n     * @param {Number} e Horizontal moving\n     * @param {Number} f Vertical scaling\n     */\n\n  }, {\n    key: \"transform\",\n    value: function transform(a, b, c, d, e, f) {\n      this.multiply([[a, c, e], [b, d, f], [0, 0, 1]]);\n      return this;\n    }\n    /**\n    * Gets the value of the determinant.\n    * @return {Number}\n    */\n\n  }, {\n    key: \"determinant\",\n    value: function determinant() {\n      var a = this._elements[0][0],\n          b = this._elements[0][1],\n          c = this._elements[0][2],\n          d = this._elements[1][0],\n          e = this._elements[1][1],\n          f = this._elements[1][2],\n          g = this._elements[2][0],\n          h = this._elements[2][1],\n          i = this._elements[2][2],\n          p = 0;\n      p = a * e * i + b * f * g + c * d * h - c * e * g - b * d * i - a * f * h;\n      return p;\n    }\n    /**\n    * Inverts the matrix.\n    */\n\n  }, {\n    key: \"invert\",\n    value: function invert() {\n      var dt = this.determinant(),\n          a = this._elements[0][0],\n          b = this._elements[0][1],\n          c = this._elements[0][2],\n          d = this._elements[1][0],\n          e = this._elements[1][1],\n          f = this._elements[1][2],\n          g = this._elements[2][0],\n          h = this._elements[2][1],\n          k = this._elements[2][2];\n      this._elements = [[e * k - f * h, c * h - b * k, b * f - c * e], [f * g - d * k, a * k - c * g, c * d - a * f], [d * h - e * g, g * b - a * h, a * e - b * d]];\n      this.multiply(1 / dt); // TODO - handle when dt === 0 ?\n\n      return this;\n    }\n    /**\n    * Transposes the elements of the matrix.\n    */\n\n  }, {\n    key: \"transpose\",\n    value: function transpose() {\n      var m = Object.create(this._elements); // ?\n\n      this._elements = [[m[0][0], m[1][0], m[2][0]], [m[0][1], m[1][1], m[2][1]], [m[0][2], m[1][2], m[2][2]]];\n      return this;\n    }\n    /**\n    * Resets the inner elements of the matrix to identity values.\n    */\n\n  }, {\n    key: \"identity\",\n    value: function identity() {\n      this._elements = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];\n      return this;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this._elements.map(function (r) {\n        return r.join('\\t');\n      }).join('\\n'));\n    }\n  }, {\n    key: \"isIdentity\",\n    value: function isIdentity() {\n      var m = this._elements;\n      return m[0][0] === 1 && m[0][1] === 0 && m[0][2] === 0 && m[1][0] === 0 && m[1][1] === 1 && m[1][2] === 0 && m[2][0] === 0 && m[2][1] === 0 && m[2][2] === 1;\n    }\n    /**\n     * Transforms the given point by this matrix and returns a new point\n     */\n\n  }, {\n    key: \"transformPoint\",\n    value: function transformPoint(p) {\n      var vec = [p.x, p.y, 1],\n          i,\n          j,\n          e = this._elements,\n          m = [0, 0, 0];\n\n      for (i = 0; i < this._elements.length; i++) {\n        // row\n        for (j = 0; j < this._elements[i].length; j++) {\n          // column\n          m[i] += vec[j] * e[i][j];\n        }\n      }\n\n      return {\n        x: m[0],\n        y: m[1]\n      };\n    }\n    /**\n     * Transforms the given points by this matrix and returns the new points\n     */\n\n  }, {\n    key: \"transformPoints\",\n    value: function transformPoints(array) {\n      var vec,\n          i,\n          j,\n          k,\n          m,\n          e = this._elements,\n          ret = [];\n\n      for (k = 0; k < array.length; k++) {\n        vec = [array[k].x, array[k].y, 1];\n        m = [0, 0, 0];\n\n        for (i = 0; i < this._elements.length; i++) {\n          // row\n          for (j = 0; j < this._elements[i].length; j++) {\n            // column\n            m[i] += vec[j] * e[i][j];\n          }\n        }\n\n        ret.push({\n          x: m[0],\n          y: m[1]\n        });\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"elements\",\n    get: function get() {\n      var m = this._elements;\n      return [[m[0][0], m[0][1], m[0][2]], [m[1][0], m[1][1], m[1][2]], [m[2][0], m[2][1], m[2][2]]];\n    }\n  }]);\n\n  return Matrix;\n}();\n\nvar transformRegEx = /(translate|scale|rotate|matrix)\\(([0-9,.eE+-\\s]+)(?:,|\\s?)+\\)/g;\n\nfunction parseTransform(transform) {\n  var m,\n      commands = [];\n\n  while ((m = transformRegEx.exec(transform)) !== null) {\n    // eslint-disable-line no-cond-assign\n    var argsStr = m[2].trim();\n    var args = argsStr.indexOf(',') === -1 ? argsStr.split(' ') : argsStr.split(',');\n    commands.push({\n      cmd: m[1],\n      args: args.filter(function (a) {\n        return a.trim().length > 0;\n      }).map(function (a) {\n        return Number(a);\n      })\n    });\n  }\n\n  return commands;\n}\n\nfunction resolveRotateCmd(matrix, transform) {\n  var radians = transform.args[0] * (Math.PI / 180);\n\n  if (transform.args.length > 2) {\n    var x = transform.args[1];\n    var y = transform.args[2];\n    matrix.translate(x, y);\n    matrix.rotate(radians);\n    matrix.translate(-x, -y);\n  } else if (transform.args.length === 1) {\n    matrix.rotate(radians);\n  }\n}\n\nfunction resolveScaleCmd(matrix, transform) {\n  var x = transform.args[0];\n  var y = isNaN(transform.args[1]) ? transform.args[0] : transform.args[1];\n  matrix.scale(x, y);\n}\n\nfunction resolveTranslateCmd(matrix, transform) {\n  var x = transform.args[0];\n  var y = isNaN(transform.args[1]) ? 0 : transform.args[1];\n  matrix.translate(x, y);\n}\n\nfunction resolveMatrixCmd(matrix, transform) {\n  if (transform.args.length >= 6) {\n    matrix.transform.apply(matrix, _toConsumableArray$1(transform.args));\n  }\n}\n\nfunction resolveTransform(t, matrix) {\n  var transforms = parseTransform(t);\n  var transform;\n\n  for (var i = 0, len = transforms.length; i < len; i++) {\n    transform = transforms[i];\n\n    if (transform.cmd === 'rotate') {\n      resolveRotateCmd(matrix, transform);\n    } else if (transform.cmd === 'scale') {\n      resolveScaleCmd(matrix, transform);\n    } else if (transform.cmd === 'matrix') {\n      resolveMatrixCmd(matrix, transform);\n    } else if (transform.cmd === 'translate') {\n      resolveTranslateCmd(matrix, transform);\n    }\n  }\n}\n\n/* eslint-disable no-useless-escape */\nvar SELECTOR_MAPS = {\n  type: /^\\w[\\w-]+/,\n  attr: /^\\[\\w(?:[\\w\\._-]+)?(?:[!]?=['\\\"][\\w\\s*#_-]*['\\\"])?\\]/,\n  universal: /^(\\*)/,\n  tag: /^\\.(\\w+)/\n};\nvar FILTERS = {\n  type: function type(c, objects) {\n    // eslint-disable-line arrow-body-style\n    return objects.filter(function (o) {\n      var type = o.type;\n\n      if (type) {\n        return type.toLowerCase() === c.toLowerCase();\n      }\n\n      return false;\n    });\n  },\n  attr: function attr(_attr, operator, value, objects) {\n    // eslint-disable-line arrow-body-style\n    return objects.filter(function (o) {\n      var v = o.attrs[_attr];\n\n      if (!operator) {\n        // TODO handle undefined differently for != operator? As display object may very well have a default rendering color\n        return typeof v !== 'undefined';\n      }\n\n      if (typeof v === 'undefined') {\n        return false;\n      }\n\n      switch (operator) {\n        case '=':\n          return value === String(v);\n\n        case '!=':\n          return value !== String(v);\n\n        default:\n          return false;\n      }\n    });\n  },\n  universal: function universal(objects) {\n    return objects;\n  },\n  tag: function tag(selector, objects) {\n    // eslint-disable-line arrow-body-style\n    return objects.filter(function (o) {\n      var tag = o.tag;\n\n      if (tag) {\n        return tag.trim().split(/\\s+/).indexOf(selector.replace('.', '')) !== -1;\n      }\n\n      return false;\n    });\n  }\n};\n/**\n* Filters out objects of given type and value\n* @ignore\n* @example\n* filter(\n*   {type:'type', value:'Circle'},\n*   [new Circle(), new Rectangle()]\n* )\n* // [Circle]\n* @param {Object} token\n* @param {Array} objects\n* @returns {Object[]} Objects that fulfill the type and value\n*/\n\nfunction filter(token, objects) {\n  if (!objects || !objects.length || !token || typeof FILTERS[token.type] !== 'function') {\n    return [];\n  }\n\n  switch (token.type) {\n    case 'type':\n      return FILTERS[token.type](token.value, objects);\n\n    case 'attr':\n      return FILTERS[token.type](token.attribute, token.operator, token.attributeValue, objects);\n\n    case 'universal':\n      return FILTERS[token.type](objects);\n\n    case 'tag':\n      return FILTERS[token.type](token.value, objects);\n\n    default:\n      return [];\n  }\n}\n/**\n* Tokenizes a string into supported selectors\n* @ignore\n*\n* @example\n* tokenize(\"Circle[color='red']\")\n*\n* @param {String} s\n*/\n\nfunction tokenize(s) {\n  var groups = [];\n  var sub;\n  var info;\n  var match;\n  var validSelector;\n  s.split(/\\s*,\\s*/).forEach(function (group) {\n    group = group.trim();\n    sub = [];\n\n    var selectorMapsIterator = function selectorMapsIterator(key) {\n      match = group.match(SELECTOR_MAPS[key]);\n\n      if (match) {\n        validSelector = true;\n        group = group.slice(match[0].length);\n        info = {\n          type: key,\n          value: match[0]\n        };\n\n        if (key === 'attr') {\n          // extract parts of attribute from e.g. [color='red'] => (color, =, red)\n          match = match[0].match(/\\[(\\w[\\w\\._-]+)?(?:([!]?=)['\\\"]([\\w\\s#_-]*)['\\\"])?\\]/);\n          info.attribute = match[1];\n          info.operator = match[2];\n          info.attributeValue = match[3];\n        }\n\n        sub.push(info);\n      }\n    };\n\n    while (group) {\n      validSelector = false;\n      match = group.match(/^\\s*([>+~]|\\s)\\s*/);\n\n      if (match) {\n        validSelector = true;\n        sub.push({\n          type: ' ',\n          value: match[0]\n        });\n        group = group.slice(match[0].length);\n      }\n\n      Object.keys(SELECTOR_MAPS).forEach(selectorMapsIterator);\n\n      if (sub && sub.length && groups.indexOf(sub) < 0) {\n        groups.push(sub);\n      }\n\n      if (!validSelector) {\n        break;\n      }\n    }\n  });\n  return groups;\n}\n\nfunction find(s, object) {\n  var result = [];\n  var groupResults = [];\n  var groups;\n  var descendants;\n\n  if (object.isBranch) {\n    groups = tokenize(s);\n    descendants = object.descendants;\n    var tokens;\n\n    var _loop = function _loop(gi, glen) {\n      tokens = groups[gi];\n      var levels = [];\n      var filtered = descendants.slice();\n      var hasRemainder = false;\n      tokens.reverse().forEach(function (token) {\n        if (token.type === ' ') {\n          levels.push(filtered);\n          filtered = descendants.slice();\n          hasRemainder = false;\n          return;\n        }\n\n        filtered = filter(token, filtered);\n        hasRemainder = true;\n      });\n\n      if (hasRemainder) {\n        levels.push(filtered);\n      }\n\n      var selected = levels[0].filter(function (node) {\n        var ancestor = node.parent;\n        var idx;\n\n        for (var _i = 1; _i < levels.length; _i++) {\n          idx = levels[_i].indexOf(ancestor);\n\n          while (ancestor && idx < 0) {\n            ancestor = ancestor.parent;\n            idx = levels[_i].indexOf(ancestor);\n          }\n\n          if (idx < 0) {\n            return false;\n          }\n        }\n\n        return true;\n      });\n      groupResults.push(selected);\n    };\n\n    for (var gi = 0, glen = groups.length; gi < glen; gi++) {\n      _loop(gi, glen);\n    }\n\n    for (var i = 0, len = groupResults.length; i < len; i++) {\n      for (var ni = 0, nlen = groupResults[i].length; ni < nlen; ni++) {\n        if (result.indexOf(groupResults[i][ni]) < 0) {\n          result.push(groupResults[i][ni]);\n        }\n      }\n    }\n  }\n\n  return result || [];\n}\n\nvar nodeSelector = {\n  find: find\n};\n\nfunction appendDpi(points, dpi) {\n  for (var i = 0, len = points.length; i < len; i++) {\n    points[i].x /= dpi;\n    points[i].y /= dpi;\n  }\n}\n\nfunction geometryToDef(geometry, dpi, mvm) {\n  var type = geometry.type;\n  var points = mvm ? mvm.transformPoints(geometry.points()) : geometry.points();\n  appendDpi(points, dpi);\n  var def = null;\n\n  if (type === 'rect' || type === 'bounds') {\n    def = pointsToRect(points);\n    def.type = type;\n  } else if (type === 'circle') {\n    def = pointsToCircle(points, geometry.r);\n    def.type = type;\n  } else if (type === 'line') {\n    def = pointsToLine(points);\n    def.type = type;\n  } else if (type === 'polygon' || type === 'polyline') {\n    var path = pointsToPath(points, type === 'polygon');\n    def = {\n      type: 'path',\n      d: path\n    };\n  }\n\n  return def;\n}\n/**\n * @ignore\n * @returns {object} Returns a node definition of the collider\n */\n\n\nfunction colliderToShape(node, dpi) {\n  if (node.collider) {\n    var mvm = node.modelViewMatrix;\n    var isCollection = node.colliderType === 'collection';\n\n    if (isCollection) {\n      var children = node.collider.geometries.map(function (geometry) {\n        return geometryToDef(geometry, dpi, mvm);\n      });\n      return {\n        type: 'container',\n        children: children\n      };\n    }\n\n    return geometryToDef(node.collider, dpi, mvm);\n  }\n\n  return null;\n}\n/**\n * Read-only object representing a node on the scene.\n */\n\n\nvar SceneNode =\n/*#__PURE__*/\nfunction () {\n  function SceneNode(node) {\n    var _this = this;\n\n    _classCallCheck$1(this, SceneNode);\n\n    this._bounds = function () {\n      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      var _ref = node.boundingRect ? node.boundingRect(includeTransform) : {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      },\n          x = _ref.x,\n          y = _ref.y,\n          width = _ref.width,\n          height = _ref.height;\n\n      return {\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      };\n    };\n\n    this._attrs = node.attrs;\n    this._type = node.type;\n    this._data = node.data;\n    this._dpi = node.stage ? node.stage.dpi : 1;\n\n    this._collider = function () {\n      return colliderToShape(node, _this._dpi);\n    };\n\n    this._desc = node.desc;\n    this._tag = node.tag;\n\n    this._children = function () {\n      return node.children.map(function (n) {\n        return new SceneNode(n);\n      });\n    };\n\n    this._parent = function () {\n      return node.parent ? new SceneNode(node.parent) : null;\n    };\n\n    this._cache = {\n      elementBoundingRect: null\n    };\n\n    this._getElementBoundingRect = function () {\n      if (!_this._cache.elementBoundingRect && _this.element) {\n        _this._cache.elementBoundingRect = _this.element.getBoundingClientRect();\n      }\n\n      return _this._cache.elementBoundingRect || {\n        left: 0,\n        top: 0\n      };\n    };\n  }\n  /**\n   * Get child nodes\n   * @type {SceneNode[]}\n   */\n\n\n  _createClass$1(SceneNode, [{\n    key: \"boundsRelativeTo\",\n\n    /**\n     * Bounding rectangle of the node, relative a target.\n     *\n     * If target is an HTMLElement, the bounds are relative to the HTMLElement.\n     * Any other target type will return the bounds relative to the viewport of the browser.\n     *\n     * @param {HTMLElement|any} target\n     * @param {boolean} includeTransform - Whether to include any applied transforms on the node\n     * @returns {rect}\n     * @example\n     *\n     * node.boundsRelativeTo($('div'));\n     * node.boundsRelativeTo('viewport');\n     */\n    value: function boundsRelativeTo(target) {\n      var includeTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      var type = _typeof(target);\n\n      var bounds = includeTransform ? this.bounds : this.localBounds;\n\n      var selfRect = this._getElementBoundingRect();\n\n      var dx = selfRect.left;\n      var dy = selfRect.top;\n\n      if (type === 'object' && target !== null && typeof target.getBoundingClientRect === 'function') {\n        var _target$getBoundingCl = target.getBoundingClientRect(),\n            _target$getBoundingCl2 = _target$getBoundingCl.left,\n            left = _target$getBoundingCl2 === void 0 ? 0 : _target$getBoundingCl2,\n            _target$getBoundingCl3 = _target$getBoundingCl.top,\n            top = _target$getBoundingCl3 === void 0 ? 0 : _target$getBoundingCl3;\n\n        dx -= left;\n        dy -= top;\n      }\n\n      bounds.x += dx;\n      bounds.y += dy;\n      return bounds;\n    }\n    /**\n     * Collider of the node. Transform on the node has been applied to the collider shape, if any, but excluding scaling transform related to devicePixelRatio.\n     * Origin is in the top-left corner of the scene element.\n     *\n     * If node has no collider, null is returned.\n     * @type {line|rect|circle|path}\n     */\n\n  }, {\n    key: \"children\",\n    get: function get() {\n      return this._children();\n    }\n    /**\n     * Get parent node\n     * @type {SceneNode}\n     */\n\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return this._parent();\n    }\n    /**\n     * Node type\n     * @type {string}\n     */\n\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this._type;\n    }\n    /**\n     * Get the associated data\n     * @type {any}\n     */\n\n  }, {\n    key: \"data\",\n    get: function get() {\n      return this._data;\n    }\n    /**\n     * Node attributes\n     * @type {object}\n     */\n\n  }, {\n    key: \"attrs\",\n    get: function get() {\n      return this._attrs;\n    }\n    /**\n     * Element the scene is attached to\n     * @type {HTMLElement}\n     * @private\n     */\n\n  }, {\n    key: \"element\",\n    set: function set(e) {\n      this._cache.elementBoundingRect = null;\n      this._element = e;\n    }\n    /**\n     * Element the scene is attached to\n     * @type {HTMLElement}\n     */\n    ,\n    get: function get() {\n      return this._element;\n    }\n    /**\n    * Key of the component this shape belongs to\n    * @type {string}\n    * @private\n    */\n\n  }, {\n    key: \"key\",\n    set: function set(k) {\n      this._key = k;\n    }\n    /**\n    * Key of the component this shape belongs to\n    * @type {string}\n    */\n    ,\n    get: function get() {\n      return this._key;\n    }\n    /**\n     * Bounding rectangle of the node. After any transform has been applied, if any, but excluding scaling transform related to devicePixelRatio.\n     * Origin is in the top-left corner of the scene element.\n     * @type {rect}\n     */\n\n  }, {\n    key: \"bounds\",\n    get: function get() {\n      var bounds = this._bounds();\n\n      bounds.x /= this._dpi;\n      bounds.y /= this._dpi;\n      bounds.width /= this._dpi;\n      bounds.height /= this._dpi;\n      return bounds;\n    }\n    /**\n     * Bounding rectangle of the node withing it's local coordinate system.\n     * Origin is in the top-left corner of the scene element.\n     * @type {rect}\n     */\n\n  }, {\n    key: \"localBounds\",\n    get: function get() {\n      var bounds = this._bounds(false);\n\n      return bounds;\n    }\n  }, {\n    key: \"collider\",\n    get: function get() {\n      return this._collider();\n    }\n    /**\n     * Node description\n     * @type {object}\n     */\n\n  }, {\n    key: \"desc\",\n    get: function get() {\n      return this._desc;\n    }\n    /**\n     * Node tag\n     * @type {string}\n     */\n\n  }, {\n    key: \"tag\",\n    get: function get() {\n      return this._tag;\n    }\n  }]);\n\n  return SceneNode;\n}();\n\nfunction create$b() {\n  for (var _len = arguments.length, a = new Array(_len), _key = 0; _key < _len; _key++) {\n    a[_key] = arguments[_key];\n  }\n\n  return _construct(SceneNode, a);\n}\n\nvar Collision =\n/*#__PURE__*/\nfunction () {\n  function Collision(node) {\n    _classCallCheck$1(this, Collision);\n\n    this._node = create$b(node);\n    this._parent = null;\n    this._input = null;\n  }\n\n  _createClass$1(Collision, [{\n    key: \"node\",\n    get: function get() {\n      return this._node;\n    }\n  }, {\n    key: \"parent\",\n    set: function set(p) {\n      this._parent = p;\n    },\n    get: function get() {\n      return this._parent;\n    }\n  }, {\n    key: \"input\",\n    set: function set(i) {\n      this._input = i;\n    },\n    get: function get() {\n      return this._input;\n    }\n  }]);\n\n  return Collision;\n}();\nfunction create$c() {\n  for (var _len = arguments.length, a = new Array(_len), _key = 0; _key < _len; _key++) {\n    a[_key] = arguments[_key];\n  }\n\n  return _construct(Collision, a);\n}\n\nfunction appendParentNode(node, collision) {\n  var p = node.parent;\n\n  if (p && p.type !== 'stage') {\n    collision.parent = create$c(p);\n    var pp = p.parent;\n\n    if (pp && pp.type !== 'stage') {\n      appendParentNode(pp, collision.parent);\n    }\n  }\n}\n\nfunction appendInputShape(shape, collisions) {\n  for (var i = 0, len = collisions.length; i < len; i++) {\n    collisions[i].input = shape;\n  }\n}\n\nfunction resolveFrontChildCollision(node, type, input) {\n  var num = node.descendants.length;\n\n  for (var i = num - 1; i >= 0; i--) {\n    var desc = node.descendants[i];\n\n    if (desc.collider === null) {\n      continue;\n    }\n\n    if (desc.collider[type](input)) {\n      var collision = create$c(desc);\n      appendParentNode(desc, collision);\n      return collision;\n    }\n  }\n\n  return null;\n}\n\nfunction resolveGeometryCollision(node, type, input) {\n  if (node.collider[type](input)) {\n    var c = create$c(node);\n    appendParentNode(node, c);\n    return c;\n  }\n\n  return null;\n}\n\nfunction inverseTransform(node, input) {\n  var transformedInput = {};\n\n  if (node.modelViewMatrix) {\n    if (Array.isArray(input)) {\n      // Rect or Line\n      transformedInput = node.inverseModelViewMatrix.transformPoints(input);\n    } else if (!isNaN(input.r)) {\n      // Circle\n      var p = {\n        x: input.cx,\n        y: input.cy\n      };\n\n      var _node$inverseModelVie = node.inverseModelViewMatrix.transformPoint(p);\n\n      transformedInput.cx = _node$inverseModelVie.x;\n      transformedInput.cy = _node$inverseModelVie.y;\n      transformedInput.r = input.r;\n    } else if (Array.isArray(input.vertices)) {\n      // Polygon\n      transformedInput.vertices = node.inverseModelViewMatrix.transformPoints(input.vertices);\n    } else {\n      // Point\n      transformedInput = node.inverseModelViewMatrix.transformPoint(input);\n    }\n  } else {\n    transformedInput = input;\n  }\n\n  if (Array.isArray(transformedInput.vertices)) {\n    transformedInput = create$7(transformedInput); // TODO Shouldn't have to do this here, currently its beacause a collision algorithm optimization, i.e. caching of polygon bounds\n  }\n\n  return transformedInput;\n}\n\nfunction resolveCollision(node, intersectionType, input) {\n  if (node.colliderType === null) {\n    return null;\n  }\n\n  var transformedInput = inverseTransform(node, input);\n\n  if (node.colliderType === 'frontChild') {\n    return resolveFrontChildCollision(node, intersectionType, transformedInput);\n  }\n\n  return resolveGeometryCollision(node, intersectionType, transformedInput);\n}\n\nfunction findAllCollisions(nodes, intersectionType, ary, input) {\n  var num = nodes.length;\n\n  for (var i = 0; i < num; i++) {\n    var node = nodes[i];\n    var collision = resolveCollision(node, intersectionType, input);\n\n    if (collision) {\n      ary.push(collision);\n    } // Only traverse children if no match is found on parent and it doesnt have any custom collider\n\n\n    if (node.children && !collision && !node.collider) {\n      findAllCollisions(node.children, intersectionType, ary, input);\n    }\n  }\n}\n\nfunction hasCollision(nodes, intersectionType, input) {\n  var num = nodes.length;\n\n  for (var i = 0; i < num; i++) {\n    var node = nodes[i];\n    var collision = resolveCollision(node, intersectionType, input);\n\n    if (collision !== null) {\n      return true;\n    }\n\n    if (node.children && !node.collider) {\n      return hasCollision(node.children, intersectionType, input);\n    }\n  }\n\n  return false;\n}\n\nfunction resolveShape(shape) {\n  var ratio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var type = getShapeType(shape);\n  var _shape = {};\n\n  switch (type) {\n    case 'circle':\n      _shape.cx = shape.cx * ratio;\n      _shape.cy = shape.cy * ratio;\n      _shape.r = shape.r;\n      return ['intersectsCircle', _shape];\n\n    case 'rect':\n      _shape = rectToPoints(shape).map(function (p) {\n        return scalarMultiply(p, ratio);\n      });\n      return ['intersectsRect', _shape];\n\n    case 'line':\n      _shape = lineToPoints(shape).map(function (p) {\n        return scalarMultiply(p, ratio);\n      });\n      return ['intersectsLine', _shape];\n\n    case 'point':\n      _shape = scalarMultiply(shape, ratio);\n      return ['containsPoint', _shape];\n\n    case 'polygon':\n      _shape.vertices = shape.vertices.map(function (vertex) {\n        return scalarMultiply(vertex, ratio);\n      });\n      return ['intersectsPolygon', _shape];\n\n    default:\n      return [];\n  }\n}\n\nfunction resolveCollionsOnNode(node, shape) {\n  var _resolveShape = resolveShape(shape, node.dpi),\n      _resolveShape2 = _slicedToArray(_resolveShape, 2),\n      intersectionType = _resolveShape2[0],\n      _shape = _resolveShape2[1];\n\n  var collisions = [];\n\n  if (intersectionType) {\n    findAllCollisions([node], intersectionType, collisions, _shape);\n    appendInputShape(shape, collisions);\n  }\n\n  return collisions;\n}\nfunction hasCollisionOnNode(node, shape) {\n  var _resolveShape3 = resolveShape(shape, node.dpi),\n      _resolveShape4 = _slicedToArray(_resolveShape3, 2),\n      intersectionType = _resolveShape4[0],\n      _shape = _resolveShape4[1];\n\n  return hasCollision([node], intersectionType, _shape);\n}\n\n/**\n * @typedef {object} node-def\n * @property {string} type\n * @property {string|gradient-def|pattern-def} [fill] - {@link https://www.w3.org/TR/fill-stroke-3/#fill-shorthand}\n * @property {string|gradient-def|pattern-def} [stroke] - {@link https://www.w3.org/TR/fill-stroke-3/#propdef-stroke}\n * @property {number} [strokeWidth] - {@link https://www.w3.org/TR/fill-stroke-3/#propdef-stroke-width}\n * @property {string|number[]} [strokeDasharray] - {@link https://www.w3.org/TR/fill-stroke-3/#propdef-stroke-dasharray}\n * @property {number} [opacity] - {@link https://www.w3.org/TR/css-color-4/#propdef-opacity}\n * @property {string} [transform] - {@link https://www.w3.org/TR/SVG/coords.html#TransformAttribute}\n * @property {object} [data] - Data object, may contain any properties\n * @property {object} [desc] - Meta-data object, may contain any properties\n * @property {string} [tag] - White-space seperated list of tags\n * @property {string} [id] - Unique identifier of the node\n * @property {object} [collider]\n */\n\nvar DisplayObject =\n/*#__PURE__*/\nfunction (_Node) {\n  _inherits(DisplayObject, _Node);\n\n  function DisplayObject(type) {\n    var _this;\n\n    _classCallCheck$1(this, DisplayObject);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DisplayObject).call(this, type));\n    _this._stage = null;\n    _this._collider = {\n      type: null,\n      definition: null,\n      fn: null\n    };\n    _this._attrs = {};\n    _this._node = null;\n    return _this;\n  }\n\n  _createClass$1(DisplayObject, [{\n    key: \"set\",\n    value: function set() {\n      var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.node = v;\n      var data = v.data,\n          desc = v.desc,\n          tag = v.tag,\n          strokeReference = v.strokeReference,\n          fillReference = v.fillReference;\n      assignMappedAttribute(this.attrs, v);\n\n      if (typeof data !== 'undefined') {\n        this.data = data;\n      }\n\n      if (_typeof(desc) === 'object') {\n        this.desc = extend(true, {}, desc);\n      }\n\n      if (typeof tag === 'string') {\n        this.tag = tag;\n      }\n\n      if (typeof strokeReference === 'string') {\n        this.strokeReference = strokeReference;\n      }\n\n      if (typeof fillReference === 'string') {\n        this.fillReference = fillReference;\n      }\n    }\n  }, {\n    key: \"findShapes\",\n    value: function findShapes(selector) {\n      return nodeSelector.find(selector, this).map(function (node) {\n        return create$b(node);\n      });\n    }\n  }, {\n    key: \"getItemsFrom\",\n    value: function getItemsFrom(shape) {\n      return resolveCollionsOnNode(this, shape);\n    }\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(p) {\n      return hasCollisionOnNode(this, p);\n    }\n  }, {\n    key: \"intersectsLine\",\n    value: function intersectsLine(line) {\n      return hasCollisionOnNode(this, line);\n    }\n  }, {\n    key: \"intersectsRect\",\n    value: function intersectsRect(rect) {\n      return hasCollisionOnNode(this, rect);\n    }\n  }, {\n    key: \"intersectsCircle\",\n    value: function intersectsCircle(circle) {\n      return hasCollisionOnNode(this, circle);\n    }\n  }, {\n    key: \"intersectsPolygon\",\n    value: function intersectsPolygon(polygon) {\n      return hasCollisionOnNode(this, polygon);\n    }\n  }, {\n    key: \"resolveLocalTransform\",\n    value: function resolveLocalTransform() {\n      var m = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Matrix();\n\n      if (typeof this.attrs.transform !== 'undefined') {\n        resolveTransform(this.attrs.transform, m);\n      }\n\n      this.modelViewMatrix = m.clone();\n    }\n  }, {\n    key: \"resolveGlobalTransform\",\n    value: function resolveGlobalTransform() {\n      var m = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Matrix();\n      var a = this.ancestors;\n\n      if (a.length > 0) {\n        for (var i = a.length - 1; i >= 0; i--) {\n          a[i].resolveLocalTransform(m);\n          m = a[i].modelViewMatrix;\n        }\n      }\n\n      this.resolveLocalTransform(m);\n    }\n    /**\n     * Returns the value of attribute a.\n     * @private\n     * @param a\n     * @returns {*} The value of attribute a.\n     */\n\n  }, {\n    key: \"attr\",\n    value: function attr(a) {\n      return this.attrs[a];\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(d) {\n      var attrs = this.attrs;\n      var attrKeys = Object.keys(attrs);\n      var dAttrs = d.attrs;\n      var dAttrKeys = Object.keys(dAttrs);\n\n      if (attrKeys.length !== dAttrKeys.length) {\n        return false;\n      }\n\n      for (var i = 0; i < attrKeys.length; i++) {\n        var key = attrKeys[i];\n\n        if (!Object.hasOwnProperty.call(dAttrs, key)) {\n          return false;\n        }\n\n        if (attrs[key] !== dAttrs[key]) {\n          return false;\n        }\n      }\n\n      return _get(_getPrototypeOf(DisplayObject.prototype), \"equals\", this).call(this, d);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = _get(_getPrototypeOf(DisplayObject.prototype), \"toJSON\", this).call(this);\n\n      json.attrs = this.attrs;\n      return json;\n    }\n  }, {\n    key: \"attrs\",\n    get: function get() {\n      return this._attrs;\n    }\n  }, {\n    key: \"stage\",\n    get: function get() {\n      if (this._parent && !this._stage) {\n        // lazy evaluation\n        this._stage = this._parent.stage;\n      } else if (!this._parent && this._stage !== this) {\n        this._stage = null;\n      }\n\n      return this._stage;\n    }\n  }, {\n    key: \"modelViewMatrix\",\n    set: function set(m) {\n      this._mvm = m;\n      this._imvm = null;\n    },\n    get: function get() {\n      return this._mvm;\n    }\n  }, {\n    key: \"inverseModelViewMatrix\",\n    get: function get() {\n      this._imvm = this._imvm ? this._imvm : this._mvm.clone().invert();\n      return this._imvm;\n    }\n  }, {\n    key: \"node\",\n    set: function set(n) {\n      this._node = n;\n    },\n    get: function get() {\n      return this._node;\n    }\n  }, {\n    key: \"collider\",\n    set: function set(definition) {\n      var type = Array.isArray(definition) ? 'collection' : definition && definition.type;\n\n      if (typeof type !== 'string') {\n        // Non string type definition resets the collider\n        this._collider.type = null;\n        this._collider.definition = null;\n        this._collider.fn = null;\n        return;\n      } // Check if a collider of the same type is already defined, if so, do an update\n\n\n      if (this._collider !== null && this._collider.type === type && this._collider.fn !== null) {\n        this._collider.fn.set(definition);\n\n        this._collider.definition = definition;\n        return;\n      } // Store the definition so that it can be lazy evaluated\n\n\n      this._collider.type = type;\n      this._collider.definition = definition;\n    },\n    get: function get() {\n      // Resolve geometry function from cache\n      if (this._collider.fn !== null) {\n        return this._collider.fn;\n      } // Resolve geometry function and store it in cache\n\n\n      switch (this._collider.type) {\n        case 'collection':\n          this._collider.fn = create$a(this._collider.definition);\n          break;\n\n        case 'frontChild':\n          // TODO Deprecate\n          // Front child is not resolved by a function on this node, but instead on one of its child nodes\n          return true;\n\n        case 'bounds':\n          this._collider.fn = create$9('rect', this.boundingRect());\n          break;\n\n        case 'line':\n        case 'rect':\n        case 'circle':\n        case 'polygon':\n        case 'polyline':\n          this._collider.fn = create$9(this._collider.type, this._collider.definition);\n          break;\n\n        default:\n          return null;\n      }\n\n      return this._collider.fn;\n    }\n  }, {\n    key: \"colliderType\",\n    get: function get() {\n      return this._collider.type;\n    }\n  }]);\n\n  return DisplayObject;\n}(Node);\n\nvar NodeContainer =\n/*#__PURE__*/\nfunction (_Node) {\n  _inherits(NodeContainer, _Node);\n\n  function NodeContainer() {\n    _classCallCheck$1(this, NodeContainer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(NodeContainer).apply(this, arguments));\n  }\n\n  _createClass$1(NodeContainer, [{\n    key: \"addChild\",\n    value: function addChild(c) {\n      if (!c || !(c instanceof Node)) {\n        throw new TypeError(\"Expecting a Node as argument, but got \".concat(c));\n      }\n\n      if (c === this) {\n        throw new Error('Can not add itself as child!');\n      }\n\n      if (c._children && c._children.length && this.ancestors.indexOf(c) >= 0) {\n        throw new Error('Can not add an ancestor as child!');\n      }\n\n      if (c._parent && c._parent !== this) {\n        c._parent.removeChild(c);\n      }\n\n      this._children.push(c);\n\n      c._parent = this;\n      c._ancestors = null;\n      return this;\n    }\n  }, {\n    key: \"addChildren\",\n    value: function addChildren(children) {\n      var i,\n          num = children ? children.length : 0;\n\n      for (i = 0; i < num; i++) {\n        this.addChild(children[i]);\n      }\n\n      return this;\n    }\n    /**\n     * Removes given child node from this node.\n     * @private\n     * @param {Node} c\n     * @returns {Node} This object, for chaining purposes.\n     */\n\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(c) {\n      var indx = this._children.indexOf(c);\n\n      if (indx >= 0) {\n        this._children.splice(indx, 1);\n\n        c._parent = null;\n        c._ancestors = null;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"removeChildren\",\n    value: function removeChildren(children) {\n      var i, num;\n\n      if (!this._children) {\n        return this;\n      }\n\n      if (children) {\n        num = children.length;\n\n        for (i = 0; i < num; i++) {\n          this.removeChild(children[i]);\n        }\n      } else {\n        while (this._children.length) {\n          this.removeChild(this._children[0]);\n        }\n      }\n\n      return this;\n    }\n  }]);\n\n  return NodeContainer;\n}(Node);\n\n/**\n * @extends node-def\n * @typedef {object} node--container-def\n * @property {node-def[]} children - Array of child nodes\n */\n\nvar NC = NodeContainer.prototype;\n\nvar Container =\n/*#__PURE__*/\nfunction (_DisplayObject) {\n  _inherits(Container, _DisplayObject);\n\n  function Container() {\n    var _this;\n\n    var s = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck$1(this, Container);\n\n    var _s$type = s.type,\n        type = _s$type === void 0 ? 'container' : _s$type;\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Container).call(this, type));\n\n    _this.set(s);\n\n    return _this;\n  }\n\n  _createClass$1(Container, [{\n    key: \"set\",\n    value: function set() {\n      var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      _get(_getPrototypeOf(Container.prototype), \"set\", this).call(this, v);\n\n      var collider = v.collider;\n      var opts = extend({\n        type: null\n      }, collider);\n      this.collider = opts;\n      this.__boundingRect = {\n        true: null,\n        false: null\n      };\n      this.__bounds = {\n        true: null,\n        false: null\n      };\n    }\n  }, {\n    key: \"appendChildRect\",\n    value: function appendChildRect(child, includeTransform) {\n      if (typeof child.bounds !== 'undefined') {\n        var rect = this.__boundingRect[includeTransform] || {};\n\n        var _child$bounds = child.bounds(includeTransform),\n            _child$bounds2 = _slicedToArray(_child$bounds, 3),\n            p0 = _child$bounds2[0],\n            p2 = _child$bounds2[2];\n\n        var xMin = p0.x,\n            yMin = p0.y;\n        var xMax = p2.x,\n            yMax = p2.y;\n\n        var _xMax = isNaN(rect.width) ? xMax : Math.max(xMax, rect.width + rect.x);\n\n        var _yMax = isNaN(rect.height) ? yMax : Math.max(yMax, rect.height + rect.y);\n\n        rect.x = isNaN(rect.x) ? xMin : Math.min(xMin, rect.x);\n        rect.y = isNaN(rect.y) ? yMin : Math.min(yMin, rect.y);\n        rect.width = _xMax - rect.x;\n        rect.height = _yMax - rect.y;\n        this.__boundingRect[includeTransform] = rect;\n      }\n    }\n  }, {\n    key: \"boundingRect\",\n    value: function boundingRect() {\n      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (this.__boundingRect[includeTransform] !== null) {\n        return this.__boundingRect[includeTransform];\n      }\n\n      var num = this.children.length;\n\n      for (var i = 0; i < num; i++) {\n        this.appendChildRect(this.children[i], includeTransform);\n      }\n\n      this.__boundingRect[includeTransform] = extend({\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      }, this.__boundingRect[includeTransform]);\n      return this.__boundingRect[includeTransform];\n    }\n  }, {\n    key: \"bounds\",\n    value: function bounds() {\n      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (this.__bounds[includeTransform] !== null) {\n        return this.__bounds[includeTransform];\n      }\n\n      var rect = this.boundingRect(includeTransform);\n      this.__bounds[includeTransform] = [{\n        x: rect.x,\n        y: rect.y\n      }, {\n        x: rect.x + rect.width,\n        y: rect.y\n      }, {\n        x: rect.x + rect.width,\n        y: rect.y + rect.height\n      }, {\n        x: rect.x,\n        y: rect.y + rect.height\n      }];\n      return this.__bounds[includeTransform];\n    }\n  }, {\n    key: \"addChild\",\n    value: function addChild(c) {\n      var r = NC.addChild.call(this, c);\n\n      if (this._collider && this._collider.type === 'bounds') {\n        this.appendChildRect(c, true);\n        var opts = extend({\n          type: 'bounds',\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        }, this.__boundingRect.true);\n        this.collider = opts;\n      }\n\n      return r;\n    }\n  }, {\n    key: \"addChildren\",\n    value: function addChildren(children) {\n      var r = NC.addChildren.call(this, children);\n      var num = children.length;\n\n      if (this._collider && this._collider.type === 'bounds' && num > 0) {\n        for (var i = 0; i < num; i++) {\n          this.appendChildRect(children[i], true);\n        }\n\n        var opts = extend({\n          type: 'bounds',\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        }, this.__boundingRect.true);\n        this.collider = opts;\n      }\n\n      return r;\n    }\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(c) {\n      c._stage = null;\n      var desc = c.descendants,\n          num = desc ? desc.length : 0,\n          i; // remove reference to stage from all descendants\n\n      for (i = 0; i < num; i++) {\n        desc[i]._stage = null;\n      }\n\n      NC.removeChild.call(this, c);\n\n      if (this._collider && this._collider.type === 'bounds') {\n        this.__boundingRect = {\n          true: null,\n          false: null\n        };\n        this.__bounds = {\n          true: null,\n          false: null\n        };\n        var opts = extend(this.boundingRect(true), {\n          type: 'bounds'\n        });\n        this.collider = opts;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"removeChildren\",\n    value: function removeChildren(children) {\n      NC.removeChildren.call(this, children);\n\n      if (this._collider && this._collider.type === 'bounds') {\n        this.__boundingRect = {\n          true: null,\n          false: null\n        };\n        this.__bounds = {\n          true: null,\n          false: null\n        };\n        var opts = extend(this.boundingRect(true), {\n          type: 'bounds'\n        });\n        this.collider = opts;\n      }\n\n      return this;\n    }\n  }]);\n\n  return Container;\n}(DisplayObject);\nfunction create$d() {\n  for (var _len = arguments.length, s = new Array(_len), _key = 0; _key < _len; _key++) {\n    s[_key] = arguments[_key];\n  }\n\n  return _construct(Container, s);\n}\n\nvar Stage =\n/*#__PURE__*/\nfunction (_Container) {\n  _inherits(Stage, _Container);\n\n  function Stage(dpi) {\n    var _this;\n\n    _classCallCheck$1(this, Stage);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Stage).call(this, 'stage'));\n    _this._stage = _assertThisInitialized(_this);\n    _this._dpiRatio = dpi || 1;\n    return _this;\n  }\n\n  _createClass$1(Stage, [{\n    key: \"dpi\",\n    get: function get() {\n      return this._dpiRatio;\n    }\n  }]);\n\n  return Stage;\n}(Container);\nfunction create$e() {\n  for (var _len = arguments.length, a = new Array(_len), _key = 0; _key < _len; _key++) {\n    a[_key] = arguments[_key];\n  }\n\n  return _construct(Stage, a);\n}\n\n/**\n * @typedef {object} gradient-def\n * @property {string} type\n * @property {object[]} stops\n * @property {string} [stops[].type=linearGradient] - radialGradient|linearGradient\n * @property {string} stops[].color - {@link https://www.w3.org/TR/SVG/types.html#DataTypeColor}\n * @property {string} [stops[].opacity=1] - {@link https://www.w3.org/TR/css-color-4/#propdef-opacity}\n * @property {number} stops[].offset - {@link https://www.w3.org/TR/SVG/pservers.html#StopElementOffsetAttribute}\n * @property {number} [degree] - Gradient rotation angle\n */\n\n/**\n * @typedef {object} node--gradient-item-def\n * @property {string} id - Gradient identifier\n * @property {number} x1 - {@link https://www.w3.org/TR/SVG/pservers.html#LinearGradientElementX1Attribute}\n * @property {number} y1 - {@link https://www.w3.org/TR/SVG/pservers.html#LinearGradientElementY1Attribute}\n * @property {number} x2 - {@link https://www.w3.org/TR/SVG/pservers.html#LinearGradientElementX2Attribute}\n * @property {number} y2 - {@link https://www.w3.org/TR/SVG/pservers.html#LinearGradientElementY2Attribute}\n * @property {number} offset - {@link https://www.w3.org/TR/SVG/pservers.html#StopElementOffsetAttribute}\n * @property {object} style - {@link https://www.w3.org/TR/SVG/styling.html#StyleAttribute}\n */\n\nvar NC$1 = NodeContainer.prototype;\nvar allowedAttrs = ['x1', 'x2', 'y1', 'y2', 'id', 'offset', 'style'];\n\nvar GradientItem =\n/*#__PURE__*/\nfunction (_DisplayObject) {\n  _inherits(GradientItem, _DisplayObject);\n\n  function GradientItem() {\n    var _this;\n\n    var s = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck$1(this, GradientItem);\n\n    var _s$type = s.type,\n        type = _s$type === void 0 ? 'container' : _s$type;\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(GradientItem).call(this, type));\n\n    _this.set(s);\n\n    _this._boundingRect = {};\n    return _this;\n  }\n\n  _createClass$1(GradientItem, [{\n    key: \"set\",\n    value: function set() {\n      var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      _get(_getPrototypeOf(GradientItem.prototype), \"set\", this).call(this, v);\n\n      var attrs = this.attrs;\n      var attrKey = '';\n\n      for (var i = 0, len = allowedAttrs.length; i !== len; i++) {\n        attrKey = allowedAttrs[i];\n\n        if (typeof v[attrKey] !== 'undefined') {\n          attrs[attrKey] = v[attrKey];\n        }\n      }\n    }\n  }, {\n    key: \"addChild\",\n    value: function addChild(c) {\n      var r = NC$1.addChild.call(this, c);\n      return r;\n    }\n  }, {\n    key: \"addChildren\",\n    value: function addChildren(children) {\n      var r = NC$1.addChildren.call(this, children);\n      return r;\n    }\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(c) {\n      c._stage = null;\n      var desc = c.descendants,\n          num = desc ? desc.length : 0,\n          i; // remove reference to stage from all descendants\n\n      for (i = 0; i < num; i++) {\n        desc[i]._stage = null;\n      }\n\n      NC$1.removeChild.call(this, c);\n      return this;\n    }\n  }, {\n    key: \"removeChildren\",\n    value: function removeChildren(children) {\n      NC$1.removeChildren.call(this, children);\n      return this;\n    }\n  }]);\n\n  return GradientItem;\n}(DisplayObject);\nfunction create$f() {\n  for (var _len = arguments.length, s = new Array(_len), _key = 0; _key < _len; _key++) {\n    s[_key] = arguments[_key];\n  }\n\n  return _construct(GradientItem, s);\n}\n\n/**\n * @experimental\n * @typedef {object} pattern-def\n * @property {'pattern'} type\n * @property {string} fill\n * @property {number} width\n * @property {number} height\n * @property {object[]} shapes\n * @example\n * Stripe pattern\n * ```js\n * {\n *   type: 'pattern',\n *   fill: 'red',\n *   width: 4,\n *   height: 4,\n *   shapes: [\n *     { type: 'rect', x: 3, y: 0, width: 1, height: 1 },\n *     { type: 'rect', x: 2, y: 1, width: 1, height: 1 },\n *     { type: 'rect', x: 1, y: 2, width: 1, height: 1 },\n *     { type: 'rect', x: 0, y: 3, width: 1, height: 1 },\n *   ]\n * }\n * ```\n */\n\nvar NC$2 = NodeContainer.prototype;\nvar allowedAttrs$1 = ['patternUnits', 'x', 'y', 'width', 'height', 'id'];\n\nvar PatternItem =\n/*#__PURE__*/\nfunction (_DisplayObject) {\n  _inherits(PatternItem, _DisplayObject);\n\n  function PatternItem() {\n    var _this;\n\n    var s = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck$1(this, PatternItem);\n\n    var _s$type = s.type,\n        type = _s$type === void 0 ? 'container' : _s$type;\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(PatternItem).call(this, type));\n\n    _this.set(s);\n\n    _this._boundingRect = {};\n    return _this;\n  }\n\n  _createClass$1(PatternItem, [{\n    key: \"set\",\n    value: function set() {\n      var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      _get(_getPrototypeOf(PatternItem.prototype), \"set\", this).call(this, v);\n\n      var attrs = this.attrs;\n      var attrKey = '';\n\n      for (var i = 0, len = allowedAttrs$1.length; i !== len; i++) {\n        attrKey = allowedAttrs$1[i];\n\n        if (typeof v[attrKey] !== 'undefined') {\n          attrs[attrKey] = v[attrKey];\n        }\n      }\n    }\n  }, {\n    key: \"addChild\",\n    value: function addChild(c) {\n      var r = NC$2.addChild.call(this, c);\n      return r;\n    }\n  }, {\n    key: \"addChildren\",\n    value: function addChildren(children) {\n      var r = NC$2.addChildren.call(this, children);\n      return r;\n    }\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(c) {\n      c._stage = null;\n      var desc = c.descendants,\n          num = desc ? desc.length : 0,\n          i; // remove reference to stage from all descendants\n\n      for (i = 0; i < num; i++) {\n        desc[i]._stage = null;\n      }\n\n      NC$2.removeChild.call(this, c);\n      return this;\n    }\n  }, {\n    key: \"removeChildren\",\n    value: function removeChildren(children) {\n      NC$2.removeChildren.call(this, children);\n      return this;\n    }\n  }]);\n\n  return PatternItem;\n}(DisplayObject);\nfunction create$g() {\n  for (var _len = arguments.length, s = new Array(_len), _key = 0; _key < _len; _key++) {\n    s[_key] = arguments[_key];\n  }\n\n  return _construct(PatternItem, s);\n}\n\n/**\n * @extends node-def\n * @typedef {object} node--rect-def\n * @property {number} x - {@link https://www.w3.org/TR/SVG/shapes.html#RectElementXAttribute}\n * @property {number} y - {@link https://www.w3.org/TR/SVG/shapes.html#RectElementYAttribute}\n * @property {number} width - {@link https://www.w3.org/TR/SVG/shapes.html#RectElementWidthAttribute}\n * @property {number} height- {@link https://www.w3.org/TR/SVG/shapes.html#RectElementHeightAttribute}\n */\n\nvar Rect =\n/*#__PURE__*/\nfunction (_DisplayObject) {\n  _inherits(Rect, _DisplayObject);\n\n  function Rect() {\n    var _this2;\n\n    var _this;\n\n    _classCallCheck$1(this, Rect);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Rect).call(this, 'rect'));\n\n    (_this2 = _this).set.apply(_this2, arguments);\n\n    return _this;\n  }\n\n  _createClass$1(Rect, [{\n    key: \"set\",\n    value: function set() {\n      var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _v$x = v.x,\n          x = _v$x === void 0 ? 0 : _v$x,\n          _v$y = v.y,\n          y = _v$y === void 0 ? 0 : _v$y,\n          _v$width = v.width,\n          width = _v$width === void 0 ? 0 : _v$width,\n          _v$height = v.height,\n          height = _v$height === void 0 ? 0 : _v$height,\n          _v$rx = v.rx,\n          rx = _v$rx === void 0 ? 0 : _v$rx,\n          _v$ry = v.ry,\n          ry = _v$ry === void 0 ? 0 : _v$ry,\n          collider = v.collider;\n      var opts = extend({\n        type: 'rect',\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      }, collider);\n\n      _get(_getPrototypeOf(Rect.prototype), \"set\", this).call(this, v);\n\n      if (width >= 0) {\n        this.attrs.x = x;\n        this.attrs.width = width;\n      } else {\n        this.attrs.x = x + width;\n        this.attrs.width = -width;\n      }\n\n      if (height >= 0) {\n        this.attrs.y = y;\n        this.attrs.height = height;\n      } else {\n        this.attrs.y = y + height;\n        this.attrs.height = -height;\n      }\n\n      if (rx > 0) {\n        this.attrs.rx = rx;\n      }\n\n      if (ry > 0) {\n        this.attrs.ry = ry;\n      }\n\n      this.collider = opts;\n      this.__boundingRect = {\n        true: null,\n        false: null\n      };\n      this.__bounds = {\n        true: null,\n        false: null\n      };\n    }\n  }, {\n    key: \"boundingRect\",\n    value: function boundingRect() {\n      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (this.__boundingRect[includeTransform] !== null) {\n        return this.__boundingRect[includeTransform];\n      }\n\n      var p = rectToPoints(this.attrs);\n      var pt = includeTransform && this.modelViewMatrix ? this.modelViewMatrix.transformPoints(p) : p;\n\n      var _getMinMax = getMinMax(pt),\n          _getMinMax2 = _slicedToArray(_getMinMax, 4),\n          xMin = _getMinMax2[0],\n          yMin = _getMinMax2[1],\n          xMax = _getMinMax2[2],\n          yMax = _getMinMax2[3];\n\n      this.__boundingRect[includeTransform] = {\n        x: xMin,\n        y: yMin,\n        width: xMax - xMin,\n        height: yMax - yMin\n      };\n      return this.__boundingRect[includeTransform];\n    }\n  }, {\n    key: \"bounds\",\n    value: function bounds() {\n      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (this.__bounds[includeTransform] !== null) {\n        return this.__bounds[includeTransform];\n      }\n\n      var rect = this.boundingRect(includeTransform);\n      this.__bounds[includeTransform] = [{\n        x: rect.x,\n        y: rect.y\n      }, {\n        x: rect.x + rect.width,\n        y: rect.y\n      }, {\n        x: rect.x + rect.width,\n        y: rect.y + rect.height\n      }, {\n        x: rect.x,\n        y: rect.y + rect.height\n      }];\n      return this.__bounds[includeTransform];\n    }\n  }]);\n\n  return Rect;\n}(DisplayObject);\nfunction create$h() {\n  for (var _len = arguments.length, s = new Array(_len), _key = 0; _key < _len; _key++) {\n    s[_key] = arguments[_key];\n  }\n\n  return _construct(Rect, s);\n}\n\n/**\n * @extends node-def\n * @typedef {object} node--circle-def\n * @property {number} cx - {@link https://www.w3.org/TR/SVG/shapes.html#CircleElementCXAttribute}\n * @property {number} cy - {@link https://www.w3.org/TR/SVG/shapes.html#CircleElementCYAttribute}\n * @property {number} r - {@link https://www.w3.org/TR/SVG/shapes.html#CircleElementRAttribute}\n */\n\nvar Circle =\n/*#__PURE__*/\nfunction (_DisplayObject) {\n  _inherits(Circle, _DisplayObject);\n\n  function Circle() {\n    var _this2;\n\n    var _this;\n\n    _classCallCheck$1(this, Circle);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Circle).call(this, 'circle'));\n\n    (_this2 = _this).set.apply(_this2, arguments);\n\n    return _this;\n  }\n\n  _createClass$1(Circle, [{\n    key: \"set\",\n    value: function set() {\n      var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _v$cx = v.cx,\n          cx = _v$cx === void 0 ? 0 : _v$cx,\n          _v$cy = v.cy,\n          cy = _v$cy === void 0 ? 0 : _v$cy,\n          _v$r = v.r,\n          r = _v$r === void 0 ? 0 : _v$r,\n          collider = v.collider;\n      var opts = extend({\n        type: 'circle',\n        cx: cx,\n        cy: cy,\n        r: r\n      }, collider);\n\n      _get(_getPrototypeOf(Circle.prototype), \"set\", this).call(this, v);\n\n      this.attrs.cx = cx;\n      this.attrs.cy = cy;\n      this.attrs.r = r;\n      this.collider = opts;\n      this.__boundingRect = {\n        true: null,\n        false: null\n      };\n      this.__bounds = {\n        true: null,\n        false: null\n      };\n    }\n  }, {\n    key: \"boundingRect\",\n    value: function boundingRect() {\n      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (this.__boundingRect[includeTransform] !== null) {\n        return this.__boundingRect[includeTransform];\n      } // TODO Handle Circle bounds correctly for a circle transformed to an non axis aligned ellipse/circle\n      // Current solution only rotate the bounds, giving a larger boundingRect if rotated\n\n\n      var p = this.bounds(includeTransform);\n      this.__boundingRect[includeTransform] = {\n        x: p[0].x,\n        y: p[0].y,\n        width: p[2].x - p[0].x,\n        height: p[2].y - p[0].y\n      };\n      return this.__boundingRect[includeTransform];\n    }\n  }, {\n    key: \"bounds\",\n    value: function bounds() {\n      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (this.__bounds[includeTransform] !== null) {\n        return this.__bounds[includeTransform];\n      } // TODO Handle Circle bounds correctly for a circle transformed to an non axis aligned ellipse/circle\n\n\n      var _this$attrs = this.attrs,\n          cx = _this$attrs.cx,\n          cy = _this$attrs.cy,\n          rX = _this$attrs.r,\n          rY = _this$attrs.r;\n      var x = cx - rX;\n      var y = cy - rY;\n      var w = rX * 2;\n      var h = rY * 2;\n      var p = [{\n        x: x,\n        y: y\n      }, {\n        x: x + w,\n        y: y\n      }, {\n        x: x + w,\n        y: y + h\n      }, {\n        x: x,\n        y: y + h\n      }];\n\n      if (includeTransform && this.modelViewMatrix) {\n        p = this.modelViewMatrix.transformPoints(p);\n\n        var _getMinMax = getMinMax(p),\n            _getMinMax2 = _slicedToArray(_getMinMax, 4),\n            xMin = _getMinMax2[0],\n            yMin = _getMinMax2[1],\n            xMax = _getMinMax2[2],\n            yMax = _getMinMax2[3];\n\n        w = xMax - xMin;\n        h = yMax - yMin;\n        this.__bounds[includeTransform] = [{\n          x: xMin,\n          y: yMin\n        }, {\n          x: xMin + w,\n          y: yMin\n        }, {\n          x: xMin + w,\n          y: yMin + h\n        }, {\n          x: xMin,\n          y: yMin + h\n        }];\n      } else {\n        this.__bounds[includeTransform] = p;\n      }\n\n      return this.__bounds[includeTransform];\n    }\n  }]);\n\n  return Circle;\n}(DisplayObject);\nfunction create$i() {\n  for (var _len = arguments.length, s = new Array(_len), _key = 0; _key < _len; _key++) {\n    s[_key] = arguments[_key];\n  }\n\n  return _construct(Circle, s);\n}\n\n/**\n * @extends node-def\n * @typedef {object} node--line-def\n * @property {number} x1 - {@link https://www.w3.org/TR/SVG/shapes.html#LineElementX1Attribute}\n * @property {number} y1 - {@link https://www.w3.org/TR/SVG/shapes.html#LineElementY1Attribute}\n * @property {number} x2 - {@link https://www.w3.org/TR/SVG/shapes.html#LineElementX2Attribute}\n * @property {number} y2 - {@link https://www.w3.org/TR/SVG/shapes.html#LineElementY2Attribute}\n */\n\nvar Line =\n/*#__PURE__*/\nfunction (_DisplayObject) {\n  _inherits(Line, _DisplayObject);\n\n  function Line() {\n    var _this2;\n\n    var _this;\n\n    _classCallCheck$1(this, Line);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Line).call(this, 'line'));\n\n    (_this2 = _this).set.apply(_this2, arguments);\n\n    return _this;\n  }\n\n  _createClass$1(Line, [{\n    key: \"set\",\n    value: function set() {\n      var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _v$x = v.x1,\n          x1 = _v$x === void 0 ? 0 : _v$x,\n          _v$y = v.y1,\n          y1 = _v$y === void 0 ? 0 : _v$y,\n          _v$x2 = v.x2,\n          x2 = _v$x2 === void 0 ? 0 : _v$x2,\n          _v$y2 = v.y2,\n          y2 = _v$y2 === void 0 ? 0 : _v$y2,\n          collider = v.collider;\n\n      _get(_getPrototypeOf(Line.prototype), \"set\", this).call(this, v);\n\n      this.attrs.x1 = x1;\n      this.attrs.y1 = y1;\n      this.attrs.x2 = x2;\n      this.attrs.y2 = y2;\n      var defaultCollider = {\n        type: 'line',\n        x1: x1,\n        y1: y1,\n        x2: x2,\n        y2: y2\n      };\n      this.collider = extend(defaultCollider, collider);\n      this.__boundingRect = {\n        true: null,\n        false: null\n      };\n      this.__bounds = {\n        true: null,\n        false: null\n      };\n    }\n  }, {\n    key: \"boundingRect\",\n    value: function boundingRect() {\n      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (this.__boundingRect[includeTransform] !== null) {\n        return this.__boundingRect[includeTransform];\n      }\n\n      var p = lineToPoints(this.attrs);\n\n      if (includeTransform && this.modelViewMatrix) {\n        p = this.modelViewMatrix.transformPoints(p);\n      }\n\n      var _getMinMax = getMinMax(p),\n          _getMinMax2 = _slicedToArray(_getMinMax, 4),\n          xMin = _getMinMax2[0],\n          yMin = _getMinMax2[1],\n          xMax = _getMinMax2[2],\n          yMax = _getMinMax2[3];\n\n      var hasSize = xMin !== xMax || yMin !== yMax;\n      this.__boundingRect[includeTransform] = {\n        x: xMin,\n        y: yMin,\n        width: hasSize ? Math.max(1, xMax - xMin) : 0,\n        height: hasSize ? Math.max(1, yMax - yMin) : 0\n      };\n      return this.__boundingRect[includeTransform];\n    }\n  }, {\n    key: \"bounds\",\n    value: function bounds() {\n      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (this.__bounds[includeTransform] !== null) {\n        return this.__bounds[includeTransform];\n      }\n\n      var rect = this.boundingRect(includeTransform);\n      this.__bounds[includeTransform] = [{\n        x: rect.x,\n        y: rect.y\n      }, {\n        x: rect.x + rect.width,\n        y: rect.y\n      }, {\n        x: rect.x + rect.width,\n        y: rect.y + rect.height\n      }, {\n        x: rect.x,\n        y: rect.y + rect.height\n      }];\n      return this.__bounds[includeTransform];\n    }\n  }]);\n\n  return Line;\n}(DisplayObject);\nfunction create$j() {\n  for (var _len = arguments.length, s = new Array(_len), _key = 0; _key < _len; _key++) {\n    s[_key] = arguments[_key];\n  }\n\n  return _construct(Line, s);\n}\n\nvar PI_2 = Math.PI / 2;\n\nfunction lineAngle(p0, p1) {\n  var t = Math.atan2(p1.y - p0.y, p1.x - p0.x);\n  return t < 0 ? t + Math.PI * 2 : t;\n} // TODO Find a more accurate method to find the open and closed points\n\n\nfunction rotatePoint$1(p, angle, radius) {\n  return {\n    x: p.x + Math.cos(angle) * radius,\n    y: p.y + Math.sin(angle) * radius\n  };\n}\n\nfunction polylineToPolygonCollider(points, radius) {\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var open = [];\n  var close = []; // TODO handle case if points.length === 2\n\n  if (opts.forceOrientation === 'h') {\n    var start = points[0].x < points[1].x ? -1 : 1;\n    var end = points[points.length - 1].x > points[points.length - 2].x ? 1 : -1;\n    points.unshift({\n      x: points[0].x + start,\n      y: points[0].y\n    });\n    points.push({\n      x: points[points.length - 1].x + end,\n      y: points[points.length - 1].y\n    });\n  } else if (opts.forceOrientation === 'v') {\n    var _start = points[0].y < points[1].y ? -1 : 1;\n\n    var _end = points[points.length - 1].y > points[points.length - 2].y ? 1 : -1;\n\n    points.unshift({\n      x: points[0].x,\n      y: points[0].y + _start\n    });\n    points.push({\n      x: points[points.length - 1].x,\n      y: points[points.length - 1].y + _end\n    });\n  }\n\n  var len = points.length - 1;\n\n  for (var i = 1; i < len; i++) {\n    var prev = points[i - 1];\n    var curr = points[i];\n    var next = points[i + 1];\n    var currToPrev = lineAngle(curr, prev);\n    var currToNext = lineAngle(curr, next);\n    var openAngle = (currToPrev + currToNext) / 2;\n    var closeAngle = openAngle + Math.PI;\n    var maxAngle = Math.max(openAngle, closeAngle);\n    var minAngle = Math.min(openAngle, closeAngle);\n    var openClose = currToPrev > currToNext;\n\n    if (i === 1) {\n      var prevToCurr = lineAngle(prev, curr);\n      open.push(rotatePoint$1(prev, prevToCurr - PI_2, radius));\n      close.unshift(rotatePoint$1(prev, prevToCurr + PI_2, radius));\n    }\n\n    var opened = openClose ? maxAngle : minAngle;\n    var closed = openClose ? minAngle : maxAngle;\n    open.push(rotatePoint$1(curr, opened, radius));\n    close.unshift(rotatePoint$1(curr, closed, radius));\n\n    if (i === len - 1) {\n      var nextToCurr = lineAngle(next, curr);\n      open.push(rotatePoint$1(next, nextToCurr + PI_2, radius));\n      close.unshift(rotatePoint$1(next, nextToCurr - PI_2, radius));\n    }\n  }\n\n  return {\n    type: 'polygon',\n    vertices: [].concat(open, close)\n  };\n}\n\nfunction flatten2d(ary) {\n  var newAry = [];\n  var a;\n  var len = ary.length;\n\n  for (var i = 0; i < len; i++) {\n    a = ary[i];\n\n    for (var k = 0; k < a.length; k++) {\n      newAry.push(a[k]);\n    }\n  }\n\n  return newAry;\n}\n\nvar EPSILON$2 = 1e-12;\n/**\n * @extends node-def\n * @typedef {object} node--path-def\n * @property {string} d - {@link https://www.w3.org/TR/SVG/paths.html#DAttribute}\n */\n\nfunction isClosed(points) {\n  if (points.length < 2) {\n    return false;\n  }\n\n  var p0 = points[0];\n  var p1 = points[points.length - 1];\n  return Math.abs(p0.x - p1.x) < EPSILON$2 && Math.abs(p0.y - p1.y) < EPSILON$2;\n}\n\nvar Path$1 =\n/*#__PURE__*/\nfunction (_DisplayObject) {\n  _inherits(Path, _DisplayObject);\n\n  function Path() {\n    var _this2;\n\n    var _this;\n\n    _classCallCheck$1(this, Path);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Path).call(this, 'path'));\n\n    (_this2 = _this).set.apply(_this2, arguments);\n\n    return _this;\n  }\n\n  _createClass$1(Path, [{\n    key: \"set\",\n    value: function set() {\n      var _this3 = this;\n\n      var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      _get(_getPrototypeOf(Path.prototype), \"set\", this).call(this, v);\n\n      this.segments = [];\n      this.points = [];\n      this.attrs.d = v.d;\n\n      if (Array.isArray(v.collider) || _typeof(v.collider) === 'object' && typeof v.collider.type !== 'undefined') {\n        this.collider = v.collider;\n      } else if (v.d) {\n        this.segments = pathToPoints(v.d);\n        this.segments.forEach(function (segment) {\n          if (segment.length <= 1) ; else if (isClosed(segment)) {\n            _this3.collider = extend({\n              type: 'polygon',\n              vertices: segment\n            }, v.collider);\n          } else if (_typeof(v.collider) === 'object' && v.collider.visual) {\n            var size = _this3.attrs['stroke-width'] / 2;\n            _this3.collider = polylineToPolygonCollider(segment, size, v.collider);\n          } else {\n            _this3.collider = extend({\n              type: 'polyline',\n              points: segment\n            }, v.collider);\n          }\n        });\n      }\n\n      this.__boundingRect = {\n        true: null,\n        false: null\n      };\n      this.__bounds = {\n        true: null,\n        false: null\n      };\n    }\n  }, {\n    key: \"boundingRect\",\n    value: function boundingRect() {\n      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (this.__boundingRect[includeTransform] !== null) {\n        return this.__boundingRect[includeTransform];\n      }\n\n      if (!this.points.length) {\n        this.segments = this.segments.length ? this.segments : pathToPoints(this.attrs.d);\n        this.points = flatten2d(this.segments);\n      }\n\n      var pt = includeTransform && this.modelViewMatrix ? this.modelViewMatrix.transformPoints(this.points) : this.points;\n\n      var _getMinMax = getMinMax(pt),\n          _getMinMax2 = _slicedToArray(_getMinMax, 4),\n          xMin = _getMinMax2[0],\n          yMin = _getMinMax2[1],\n          xMax = _getMinMax2[2],\n          yMax = _getMinMax2[3];\n\n      this.__boundingRect[includeTransform] = {\n        x: xMin || 0,\n        y: yMin || 0,\n        width: xMax - xMin || 0,\n        height: yMax - yMin || 0\n      };\n      return this.__boundingRect[includeTransform];\n    }\n  }, {\n    key: \"bounds\",\n    value: function bounds() {\n      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (this.__bounds[includeTransform] !== null) {\n        return this.__bounds[includeTransform];\n      }\n\n      var rect = this.boundingRect(includeTransform);\n      this.__bounds[includeTransform] = [{\n        x: rect.x,\n        y: rect.y\n      }, {\n        x: rect.x + rect.width,\n        y: rect.y\n      }, {\n        x: rect.x + rect.width,\n        y: rect.y + rect.height\n      }, {\n        x: rect.x,\n        y: rect.y + rect.height\n      }];\n      return this.__bounds[includeTransform];\n    }\n  }]);\n\n  return Path;\n}(DisplayObject);\nfunction create$k() {\n  for (var _len = arguments.length, s = new Array(_len), _key = 0; _key < _len; _key++) {\n    s[_key] = arguments[_key];\n  }\n\n  return _construct(Path$1, s);\n}\n\nfunction hasData(_ref) {\n  var data = _ref.data,\n      _boundingRect = _ref._boundingRect,\n      _textBoundsFn = _ref._textBoundsFn;\n  return typeof data !== 'undefined' && data !== null && (_boundingRect || _textBoundsFn);\n}\n/**\n * @extends node-def\n * @typedef {object} node--text-def\n * @property {string} text\n * @property {number} x - {@link https://www.w3.org/TR/SVG/text.html#TextElementXAttribute}\n * @property {number} y - {@link https://www.w3.org/TR/SVG/text.html#TextElementYAttribute}\n * @property {number} [dx] - {@link https://www.w3.org/TR/SVG/text.html#TextElementDXAttribute}\n * @property {number} [dy] - {@link https://www.w3.org/TR/SVG/text.html#TextElementDYAttribute}\n * @property {string} [fontSize] - {@link https://www.w3.org/TR/SVG/text.html#FontPropertiesUsedBySVG}\n * @property {string} [fontFamily] - {@link https://www.w3.org/TR/SVG/text.html#FontPropertiesUsedBySVG}\n * @property {rect} [boundingRect] - Explicitly set the bounding rectangle of the node. Has predence over textBoundsFn\n * @property {function} [textBoundsFn] - Implicitly set the bounding rectangle of the node, the function must return an object with x, y, width and height attributes\n * @property {string} [baseline] - Alias for dominantBaseline\n * @property {string} [dominantBaseline] - {@link https://www.w3.org/TR/SVG/text.html#BaselineAlignmentProperties}\n * @property {string} [anchor] - Alias for textAnchor\n * @property {string} [textAnchor] - {@link https://www.w3.org/TR/SVG/text.html#TextAnchorProperty}\n * @property {string} [wordBreak] - Word-break option\n * @property {number} [maxWidth] - Maximum allowed text width\n * @property {number} [maxHeight] - Maximum allowed text height. If both maxLines and maxHeight are set, the property that results in the fewest number of lines is used\n * @property {number} [maxLines] - Maximum number of lines allowed\n * @property {number} [lineHeight=1.2] - Line height\n */\n\n\nvar Text =\n/*#__PURE__*/\nfunction (_DisplayObject) {\n  _inherits(Text, _DisplayObject);\n\n  function Text() {\n    var _this2;\n\n    var _this;\n\n    _classCallCheck$1(this, Text);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Text).call(this, 'text'));\n\n    (_this2 = _this).set.apply(_this2, arguments);\n\n    return _this;\n  }\n\n  _createClass$1(Text, [{\n    key: \"set\",\n    value: function set() {\n      var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _v$x = v.x,\n          x = _v$x === void 0 ? 0 : _v$x,\n          _v$y = v.y,\n          y = _v$y === void 0 ? 0 : _v$y,\n          _v$dx = v.dx,\n          dx = _v$dx === void 0 ? 0 : _v$dx,\n          _v$dy = v.dy,\n          dy = _v$dy === void 0 ? 0 : _v$dy,\n          textBoundsFn = v.textBoundsFn,\n          text = v.text,\n          title = v.title,\n          collider = v.collider,\n          boundingRect = v.boundingRect,\n          ellipsed = v.ellipsed;\n\n      _get(_getPrototypeOf(Text.prototype), \"set\", this).call(this, v);\n\n      this.attrs.x = x;\n      this.attrs.y = y;\n      this.attrs.dx = dx;\n      this.attrs.dy = dy;\n      this.attrs.text = text;\n\n      if (typeof title !== 'undefined') {\n        this.attrs.title = String(title);\n      }\n\n      if (_typeof(boundingRect) === 'object') {\n        this._textBoundsFn = function () {\n          return boundingRect;\n        };\n      } else if (typeof textBoundsFn === 'function') {\n        this._textBoundsFn = textBoundsFn;\n      }\n\n      if (typeof ellipsed === 'string') {\n        this.ellipsed = ellipsed;\n      }\n\n      this.collider = extend({\n        type: hasData(this) ? 'bounds' : null\n      }, collider);\n      this.__boundingRect = {\n        true: null,\n        false: null\n      };\n      this.__bounds = {\n        true: null,\n        false: null\n      };\n    }\n  }, {\n    key: \"boundingRect\",\n    value: function boundingRect() {\n      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (this.__boundingRect[includeTransform] !== null) {\n        return this.__boundingRect[includeTransform];\n      }\n\n      var rect;\n\n      if (typeof this._textBoundsFn === 'function') {\n        rect = this._textBoundsFn(this.attrs);\n      } else {\n        return {\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        };\n      }\n\n      var p = rectToPoints(rect);\n      var pt = includeTransform && this.modelViewMatrix ? this.modelViewMatrix.transformPoints(p) : p;\n\n      var _getMinMax = getMinMax(pt),\n          _getMinMax2 = _slicedToArray(_getMinMax, 4),\n          xMin = _getMinMax2[0],\n          yMin = _getMinMax2[1],\n          xMax = _getMinMax2[2],\n          yMax = _getMinMax2[3];\n\n      this.__boundingRect[includeTransform] = {\n        x: xMin,\n        y: yMin,\n        width: xMax - xMin,\n        height: yMax - yMin\n      };\n      return this.__boundingRect[includeTransform];\n    }\n  }, {\n    key: \"bounds\",\n    value: function bounds() {\n      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (this.__bounds[includeTransform] !== null) {\n        return this.__bounds[includeTransform];\n      }\n\n      var rect = this.boundingRect(includeTransform);\n      this.__bounds[includeTransform] = [{\n        x: rect.x,\n        y: rect.y\n      }, {\n        x: rect.x + rect.width,\n        y: rect.y\n      }, {\n        x: rect.x + rect.width,\n        y: rect.y + rect.height\n      }, {\n        x: rect.x,\n        y: rect.y + rect.height\n      }];\n      return this.__bounds[includeTransform];\n    }\n  }]);\n\n  return Text;\n}(DisplayObject);\nfunction create$l() {\n  for (var _len = arguments.length, s = new Array(_len), _key = 0; _key < _len; _key++) {\n    s[_key] = arguments[_key];\n  }\n\n  return _construct(Text, s);\n}\n\nvar reg$4 = registryFactory();\nreg$4.add('rect', create$h);\nreg$4.add('circle', create$i);\nreg$4.add('text', create$l);\nreg$4.add('line', create$j);\nreg$4.add('path', create$k);\nreg$4.add('stage', create$e);\nreg$4.add('container', create$d);\nreg$4.add('defs', create$d);\nreg$4.add('linearGradient', create$f);\nreg$4.add('radialGradient', create$f);\nreg$4.add('stop', create$f);\nreg$4.add('pattern', create$g);\nfunction create$m(type, input) {\n  // eslint-disable-line import/prefer-default-export\n  return reg$4.get(type)(input);\n}\n\n/**\n * Creates a context. Input an array of strings that should be inherited by the context.\n * @private\n *\n * @param  {Array}  [whitelist=[]]  An array of whitelisted string keys to inherit\n * @return {Function}               A context function\n */\n\nfunction contextFactory() {\n  var whitelist = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var states = [{}];\n  /**\n   * Returns the current context as an object. The object is mutable.\n   * @private\n   *\n   * @return {Object}   Current context\n   */\n\n  function context() {\n    // Returns the current context, the last in the stack.\n    var item = states[states.length - 1];\n    return item;\n  }\n  /**\n   * Call context.save() to save the current context and move down the stack.\n   *\n   * @param  {Object} [item={}]   Optional item to save.\n   * @return {Object}             The current context, just as context()\n   */\n\n\n  context.save = function save() {\n    var item = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var current = context();\n    var obj = {};\n    var key = ''; // Only inherit whitelisted properties\n\n    for (var i = 0; i < whitelist.length; i++) {\n      key = whitelist[i];\n\n      if (typeof current[key] !== 'undefined') {\n        obj[key] = current[key];\n      }\n    } // Extend the new object with the saved item\n\n\n    extend(obj, item); // Push it to the stack\n\n    states.push(obj); // Return the new current context\n\n    return context();\n  };\n  /**\n   * Restore the previous context. Returns the context.\n   *\n   * @return {Undefined}   Returns nothing\n   */\n\n\n  context.restore = function restore() {\n    // Remove the last element from the stack\n    states.splice(states.length - 1, 1);\n  };\n\n  return context;\n}\n\nvar styleContext = contextFactory(['stroke', 'fill', 'strokeWidth', 'opacity', 'fontFamily', 'fontSize', 'baseline']);\n\nfunction doEvent(state, listeners) {\n  if (!Array.isArray(listeners)) {\n    return;\n  }\n\n  for (var i = 0, len = listeners.length; i < len; i++) {\n    listeners[i](state);\n  }\n}\n\nfunction updateState(state, index, nodes) {\n  state.node = nodes[index];\n  state.index = index;\n}\n\nfunction traverse(items, parent, matrix, on) {\n  var disabled = false;\n  var state = {\n    siblings: items,\n    node: null,\n    index: 0\n  };\n\n  for (var i = 0, len = items.length; i < len; i++) {\n    updateState(state, i, items);\n    doEvent(state, on.create);\n    disabled = typeof state.node.disabled === 'function' ? state.node.disabled() : state.node.disabled;\n\n    if (disabled) {\n      continue;\n    } // Save the current style context to be able to inherit styles\n\n\n    state.node = styleContext.save(state.node);\n    var displayNode = create$m(state.node.type, state.node);\n\n    if (displayNode) {\n      if (state.node.transform) {\n        matrix.save();\n        resolveTransform(state.node.transform, matrix);\n      }\n\n      if (!matrix.isIdentity()) {\n        displayNode.modelViewMatrix = matrix.clone();\n      }\n\n      parent.addChild(displayNode);\n\n      if (state.node.children) {\n        traverse(state.node.children, displayNode, matrix, on);\n      }\n\n      if (state.node.transform) {\n        matrix.restore();\n      }\n    } // Revert to previous style context\n\n\n    styleContext.restore();\n  }\n}\n\nfunction scene(_ref) {\n  var items = _ref.items,\n      stage = _ref.stage,\n      dpi = _ref.dpi,\n      _ref$on = _ref.on,\n      on = _ref$on === void 0 ? {} : _ref$on;\n\n  if (!stage) {\n    stage = create$m('stage', dpi);\n  }\n\n  traverse(items, stage, new Matrix(), on);\n  return stage;\n}\n\n/**\n * Get or create a gradient\n * @ignore\n * @param  {Object} g        Canvas 2d context\n * @param  {Object} node    Current node (for width/height properties)\n * @param  {Object} gradient The gradient properties\n * @return {Object}          A canvas compatible radial or linear gradient object\n */\n\nfunction createCanvasGradient(g, node, gradient) {\n  var orientation = gradient.orientation,\n      degree = gradient.degree,\n      _gradient$stops = gradient.stops,\n      stops = _gradient$stops === void 0 ? [] : _gradient$stops;\n  var newGradient = null;\n\n  if (orientation === 'radial') {\n    var bounds = node.boundingRect();\n    newGradient = g.createRadialGradient(bounds.x + bounds.width / 2, bounds.y + bounds.height / 2, 1e-5, bounds.x + bounds.width / 2, bounds.y + bounds.height / 2, Math.max(bounds.width, bounds.height) / 2);\n  } else {\n    var points = degreesToPoints(degree);\n    ['x1', 'x2', 'y1', 'y2'].forEach(function (c) {\n      if (c in gradient) {\n        points[c] = gradient[c];\n      }\n    });\n\n    var _bounds = node.boundingRect();\n\n    newGradient = g.createLinearGradient(_bounds.x + points.x1 * _bounds.width, _bounds.y + points.y1 * _bounds.height, _bounds.x + points.x2 * _bounds.width, _bounds.y + points.y2 * _bounds.height);\n  }\n\n  for (var i = 0, len = stops.length; i < len; i++) {\n    var stop = stops[i];\n    newGradient.addColorStop(stop.offset, stop.color);\n  }\n\n  return newGradient;\n}\n\nfunction getPattern(pattern, dummyCanvas, ctx) {\n  dummyCanvas.width = pattern.width;\n  dummyCanvas.height = pattern.height;\n  ctx.save();\n  ctx.fillStyle = pattern.fill;\n  pattern.shapes.forEach(function (s) {\n    switch (s.type) {\n      case 'rect':\n        ctx.rect(s.x, s.y, s.width, s.height);\n        break;\n\n      default:\n        break;\n    }\n  });\n  ctx.fill();\n  ctx.restore();\n  return ctx.createPattern(dummyCanvas, 'repeat');\n}\n\nfunction patternizer(document) {\n  var dummyCanvas = document.createElement('canvas');\n  var ctx = dummyCanvas.getContext('2d');\n  var cache = {};\n  return {\n    create: function create(pattern) {\n      var key = pattern.key;\n\n      if (key) {\n        cache[key] = cache[key] || getPattern(pattern, dummyCanvas, ctx);\n        return cache[key];\n      }\n\n      return getPattern(pattern, dummyCanvas, ctx);\n    },\n    clear: function clear() {\n      cache = {};\n    }\n  };\n}\n\n/**\n * @typedef {object} renderer-container-def\n * @property {number} [x] - x-coordinate\n * @property {number} [y] - y-coordinate\n * @property {number} [width] - Width\n * @property {number} [height] - Height\n * @property {object} [scaleRatio]\n * @property {number} [scaleRatio.x] - Scale ratio on x-axis\n * @property {number} [scaleRatio.y] - Scale ratio on y-axis\n * @property {object} [margin]\n * @property {number} [margin.left] - Left margin\n * @property {number} [margin.top] - Top margin\n */\n\n/**\n * Create the renderer box\n * @private\n * @param {renderer-container-def} [opts]\n * @returns {renderer-container-def} A svg renderer instance\n */\nfunction createRendererBox() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      x = _ref.x,\n      y = _ref.y,\n      width = _ref.width,\n      height = _ref.height,\n      scaleRatio = _ref.scaleRatio,\n      margin = _ref.margin,\n      edgeBleed = _ref.edgeBleed;\n\n  var box = {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0,\n    scaleRatio: {\n      x: 1,\n      y: 1\n    },\n    margin: {\n      left: 0,\n      top: 0\n    },\n    edgeBleed: {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0,\n      bool: false\n    }\n  };\n  box.x = isNaN(x) ? box.x : x;\n  box.y = isNaN(y) ? box.y : y;\n  box.width = isNaN(width) ? box.width : width;\n  box.height = isNaN(height) ? box.height : height;\n\n  if (typeof scaleRatio !== 'undefined') {\n    box.scaleRatio.x = isNaN(scaleRatio.x) ? box.scaleRatio.x : scaleRatio.x;\n    box.scaleRatio.y = isNaN(scaleRatio.y) ? box.scaleRatio.y : scaleRatio.y;\n  }\n\n  if (typeof margin !== 'undefined') {\n    box.margin.left = isNaN(margin.left) ? 0 : margin.left;\n    box.margin.top = isNaN(margin.top) ? 0 : margin.top;\n  }\n\n  if (_typeof(edgeBleed) === 'object') {\n    ['left', 'right', 'top', 'bottom'].forEach(function (prop) {\n      if (!isNaN(edgeBleed[prop]) && edgeBleed[prop] > 0) {\n        box.edgeBleed[prop] = edgeBleed[prop];\n        box.edgeBleed.bool = true;\n      }\n    });\n  }\n\n  box.computedPhysical = {\n    x: Math.round(box.margin.left + (box.x - box.edgeBleed.left) * box.scaleRatio.x),\n    y: Math.round(box.margin.top + (box.y - box.edgeBleed.top) * box.scaleRatio.y),\n    width: Math.round((box.width + box.edgeBleed.left + box.edgeBleed.right) * box.scaleRatio.x),\n    height: Math.round((box.height + box.edgeBleed.top + box.edgeBleed.bottom) * box.scaleRatio.y)\n  };\n  return box;\n}\n\n/**\n * Base renderer factory\n * @private\n */\n\nfunction create$n() {\n  /**\n  * @interface\n  * @alias renderer\n  */\n  var renderer = {\n    /**\n    * Get the element this renderer is attached to\n    * @returns {HTMLElement}\n    */\n    element: function element() {},\n\n    /**\n     * Get the root element of the renderer\n     * @returns {HTMLElement}\n     */\n    root: function root() {},\n\n    /**\n    * @param {HTMLElement} element - Element to attach renderer to\n    * @returns {HTMLElement} Root element of the renderer\n    */\n    appendTo: function appendTo() {},\n\n    /**\n     * @param {node-def[]} nodes - Nodes to render\n     * @returns {boolean} True if the nodes where rendered, otherwise false\n     */\n    render: function render() {\n      return false;\n    },\n\n    /**\n     * Get nodes renderer at area\n     * @param {point|circle|rect|line|polygon} geometry - Get nodes that intersects with geometry\n     * @returns {SceneNode[]}\n     */\n    itemsAt: function itemsAt() {\n      return [];\n    },\n\n    /**\n     * Get all nodes matching the provided selector\n     * @param {string} selector CSS selector [type, attribute, universal, class]\n     * @returns {SceneNode[]} Array of objects containing matching nodes\n     */\n    findShapes: function findShapes() {\n      return [];\n    },\n\n    /**\n     * Clear all child elements from the renderer root element\n     * @returns {renderer} The renderer instance\n     */\n    clear: function clear() {},\n\n    /**\n     * Remove the renderer root element from its parent element\n     */\n    destory: function destory() {},\n\n    /**\n     * Set or Get the size definition of the renderer container.\n     * @param {renderer-container-def} [opts] - Size definition\n     * @returns {renderer-container-def} The current size definition\n     */\n    size: function size() {},\n\n    /**\n     * @function\n     * @param {object} opts\n     * @param {string} opts.text - Text to measure\n     * @param {string} opts.fontSize - {@link https://www.w3.org/TR/SVG/text.html#FontPropertiesUsedBySVG}\n     * @param {string} opts.fontFamily - {@link https://www.w3.org/TR/SVG/text.html#FontPropertiesUsedBySVG}\n     * @returns {object} Width and height of text\n     * @example\n     * measureText({\n     *  text: 'my text',\n     *  fontSize: '12px',\n     *  fontFamily: 'Arial'\n     * }); // returns { width: 20, height: 12 }\n     */\n    measureText: measureText$1,\n\n    /**\n     * Calculates the bounding rectangle of a text node. Including any potential line breaks.\n     * @function\n     * @param {node--text-def} node\n     * @return {rect} The bounding rectangle\n     */\n    textBounds: textBounds,\n    setKey: function setKey(key) {\n      renderer.element().setAttribute('data-key', key);\n    }\n  };\n  return renderer;\n}\n\nfunction hasData$1(data) {\n  return typeof data !== 'undefined' && data !== null;\n}\n\nfunction injectTextBoundsFn(renderer) {\n  return function (_ref) {\n    var node = _ref.node;\n\n    if (node.type === 'text' && hasData$1(node.data) && !node.textBoundsFn) {\n      node.textBoundsFn = renderer.textBounds;\n    }\n  };\n}\n\nvar reg$5 = registryFactory();\n\nfunction toLineDash(p) {\n  if (Array.isArray(p)) {\n    return p;\n  }\n\n  if (typeof p === 'string') {\n    if (p.indexOf(',') !== -1) {\n      return p.split(',');\n    }\n\n    return p.split(' ');\n  }\n\n  return [];\n}\n\nfunction dpiScale(g) {\n  var dpr = typeof window === 'undefined' ? 1 : window.devicePixelRatio || 1;\n  var backingStorePixelRatio = g.webkitBackingStorePixelRatio || g.mozBackingStorePixelRatio || g.msBackingStorePixelRatio || g.oBackingStorePixelRatio || g.backingStorePixelRatio || 1;\n  return dpr / backingStorePixelRatio;\n}\n\nfunction resolveMatrix(p, g) {\n  g.setTransform(p[0][0], p[1][0], p[0][1], p[1][1], p[0][2], p[1][2]);\n}\n\nfunction applyContext(g, s, shapeToCanvasMap) {\n  var computed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var computedKeys = Object.keys(computed);\n\n  for (var i = 0, len = shapeToCanvasMap.length; i < len; i++) {\n    var cmd = shapeToCanvasMap[i];\n    var shapeCmd = cmd[0];\n    var canvasCmd = cmd[1];\n    var convertCmd = cmd[2];\n\n    if (shapeCmd in s.attrs && !(canvasCmd in computed) && g[canvasCmd] !== s.attrs[shapeCmd]) {\n      var val = convertCmd ? convertCmd(s.attrs[shapeCmd]) : s.attrs[shapeCmd];\n\n      if (typeof g[canvasCmd] === 'function') {\n        g[canvasCmd](val);\n      } else {\n        g[canvasCmd] = val;\n      }\n    }\n  }\n\n  for (var _i = 0, _len = computedKeys.length; _i < _len; _i++) {\n    var key = computedKeys[_i];\n    g[key] = computed[key];\n  }\n}\n\nfunction renderShapes(shapes, g, shapeToCanvasMap, deps) {\n  for (var i = 0, len = shapes.length; i < len; i++) {\n    var shape = shapes[i];\n    var computed = {};\n    g.save();\n\n    if (shape.attrs && (shape.attrs.fill || shape.attrs.stroke)) {\n      if (shape.attrs.fill && _typeof(shape.attrs.fill) === 'object' && shape.attrs.fill.type === 'gradient') {\n        computed.fillStyle = createCanvasGradient(g, shape, shape.attrs.fill);\n      } else if (shape.attrs.fill && _typeof(shape.attrs.fill) === 'object' && shape.attrs.fill.type === 'pattern') {\n        computed.fillStyle = deps.patterns.create(shape.attrs.fill);\n      }\n\n      if (shape.attrs.stroke && _typeof(shape.attrs.stroke) === 'object' && shape.attrs.stroke.type === 'gradient') {\n        computed.strokeStyle = createCanvasGradient(g, shape, shape.attrs.stroke);\n      } else if (shape.attrs.stroke && _typeof(shape.attrs.stroke) === 'object' && shape.attrs.stroke.type === 'pattern') {\n        computed.strokeStyle = deps.patterns.create(shape.attrs.stroke);\n      }\n    }\n\n    applyContext(g, shape, shapeToCanvasMap, computed);\n\n    if (shape.modelViewMatrix) {\n      resolveMatrix(shape.modelViewMatrix.elements, g);\n    }\n\n    if (reg$5.has(shape.type)) {\n      reg$5.get(shape.type)(shape.attrs, {\n        g: g,\n        doFill: 'fill' in shape.attrs && shape.attrs.fill !== 'none',\n        doStroke: 'stroke' in shape.attrs && shape.attrs['stroke-width'] !== 0,\n        ellipsed: shape.ellipsed\n      });\n    }\n\n    if (shape.children) {\n      renderShapes(shape.children, g, shapeToCanvasMap, deps);\n    }\n\n    g.restore();\n  }\n}\n/**\n * Create a new canvas renderer\n * @typedef {function} canvasRendererFactory\n * @param {function} sceneFn - Scene factory\n * @returns {renderer} A canvas renderer instance\n */\n\n\nfunction renderer() {\n  var sceneFn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : scene;\n  var el;\n  var scene$1;\n  var hasChangedRect = false;\n  var rect = createRendererBox();\n  var shapeToCanvasMap = [['fill', 'fillStyle'], ['stroke', 'strokeStyle'], ['opacity', 'globalAlpha'], ['globalAlpha', 'globalAlpha'], ['stroke-width', 'lineWidth'], ['stroke-linejoin', 'lineJoin'], ['stroke-dasharray', 'setLineDash', toLineDash]];\n  var patterns;\n  var canvasRenderer = create$n();\n\n  canvasRenderer.element = function () {\n    return el;\n  };\n\n  canvasRenderer.root = function () {\n    return el;\n  };\n\n  canvasRenderer.appendTo = function (element) {\n    if (!el) {\n      el = element.ownerDocument.createElement('canvas');\n      el.style.position = 'absolute';\n      el.style['-webkit-font-smoothing'] = 'antialiased';\n      el.style['-moz-osx-font-smoothing'] = 'antialiased';\n      el.style.pointerEvents = 'none';\n    }\n\n    element.appendChild(el);\n    return el;\n  };\n\n  canvasRenderer.render = function (shapes) {\n    if (!el) {\n      return false;\n    }\n\n    if (!patterns) {\n      patterns = patternizer(el.ownerDocument);\n    }\n\n    var g = el.getContext('2d');\n    var dpiRatio = dpiScale(g);\n    var scaleX = rect.scaleRatio.x;\n    var scaleY = rect.scaleRatio.y;\n\n    if (hasChangedRect) {\n      el.style.left = \"\".concat(rect.computedPhysical.x, \"px\");\n      el.style.top = \"\".concat(rect.computedPhysical.y, \"px\");\n      el.style.width = \"\".concat(rect.computedPhysical.width, \"px\");\n      el.style.height = \"\".concat(rect.computedPhysical.height, \"px\");\n      el.width = Math.round(rect.computedPhysical.width * dpiRatio);\n      el.height = Math.round(rect.computedPhysical.height * dpiRatio);\n    }\n\n    var sceneContainer = {\n      type: 'container',\n      children: shapes,\n      transform: rect.edgeBleed.bool ? \"translate(\".concat(rect.edgeBleed.left * dpiRatio * scaleX, \", \").concat(rect.edgeBleed.top * dpiRatio * scaleY, \")\") : ''\n    };\n\n    if (dpiRatio !== 1 || scaleX !== 1 || scaleY !== 1) {\n      sceneContainer.transform += \"scale(\".concat(dpiRatio * scaleX, \", \").concat(dpiRatio * scaleY, \")\");\n    }\n\n    var newScene = sceneFn({\n      items: [sceneContainer],\n      dpi: dpiRatio,\n      on: {\n        create: [onLineBreak(canvasRenderer.measureText), injectTextBoundsFn(canvasRenderer)]\n      }\n    });\n    var hasChangedScene = scene$1 ? !newScene.equals(scene$1) : true;\n    patterns.clear();\n    var doRender = hasChangedRect || hasChangedScene;\n\n    if (doRender) {\n      canvasRenderer.clear();\n      renderShapes(newScene.children, g, shapeToCanvasMap, {\n        patterns: patterns\n      });\n    }\n\n    hasChangedRect = false;\n    scene$1 = newScene;\n    return doRender;\n  };\n\n  canvasRenderer.itemsAt = function (input) {\n    return scene$1 ? scene$1.getItemsFrom(input) : [];\n  };\n\n  canvasRenderer.findShapes = function (selector) {\n    return scene$1 ? scene$1.findShapes(selector) : [];\n  };\n\n  canvasRenderer.clear = function () {\n    if (el) {\n      el.width = el.width; // eslint-disable-line\n    }\n\n    scene$1 = null;\n    return canvasRenderer;\n  };\n\n  canvasRenderer.size = function (opts) {\n    if (opts) {\n      var newRect = createRendererBox(opts);\n\n      if (JSON.stringify(rect) !== JSON.stringify(newRect)) {\n        hasChangedRect = true;\n        rect = newRect;\n      }\n    }\n\n    return rect;\n  };\n\n  canvasRenderer.destroy = function () {\n    if (el) {\n      if (el.parentElement) {\n        el.parentElement.removeChild(el);\n      }\n\n      el = null;\n    }\n\n    scene$1 = null;\n  };\n\n  return canvasRenderer;\n}\nfunction register(type, renderFn) {\n  reg$5.add(type, renderFn);\n}\n\nfunction clampRadius(max, value) {\n  return Math.max(0, Math.min(max, value));\n}\n/**\n * Implementation details follow rx/ry restrictions from https://svgwg.org/svg2-draft/geometry.html#RX\n *\n * Using Quadratic Bézier curve it's not possible accurately represent a circle or ellipse but should for the case of a rounded rectangle be sufficent.\n * @private\n */\n\n\nfunction quadraticRoundedRect(g, x, y, width, height, rx, ry) {\n  rx = clampRadius(width / 2, rx > 0 ? rx : ry);\n  ry = clampRadius(height / 2, ry > 0 ? ry : rx);\n  g.moveTo(x, y + ry);\n  g.lineTo(x, y + height - ry);\n  g.quadraticCurveTo(x, y + height, x + rx, y + height);\n  g.lineTo(x + width - rx, y + height);\n  g.quadraticCurveTo(x + width, y + height, x + width, y + height - ry);\n  g.lineTo(x + width, y + ry);\n  g.quadraticCurveTo(x + width, y, x + width - rx, y);\n  g.lineTo(x + rx, y);\n  g.quadraticCurveTo(x, y, x, y + ry);\n}\n\nfunction render$4(rect, _ref) {\n  var g = _ref.g,\n      doFill = _ref.doFill,\n      doStroke = _ref.doStroke;\n  g.beginPath();\n\n  if (rect.rx > 0 || rect.ry > 0) {\n    quadraticRoundedRect(g, rect.x, rect.y, rect.width, rect.height, rect.rx, rect.ry);\n  } else {\n    g.rect(rect.x, rect.y, rect.width, rect.height);\n  }\n\n  if (doFill) {\n    g.fill();\n  }\n\n  if (doStroke) {\n    g.stroke();\n  }\n}\n\nfunction render$5(circle, _ref) {\n  var g = _ref.g,\n      doFill = _ref.doFill,\n      doStroke = _ref.doStroke;\n  g.beginPath();\n  g.moveTo(circle.cx + circle.r, circle.cy);\n  g.arc(circle.cx, circle.cy, circle.r, 0, Math.PI * 2, false);\n\n  if (doFill) {\n    g.fill();\n  }\n\n  if (doStroke) {\n    g.stroke();\n  }\n}\n\nfunction render$6(line, _ref) {\n  var g = _ref.g,\n      doStroke = _ref.doStroke;\n  g.beginPath();\n  g.moveTo(line.x1, line.y1);\n  g.lineTo(line.x2, line.y2);\n\n  if (doStroke) {\n    g.stroke();\n  }\n}\n\n/* eslint no-misleading-character-class: 0 */\n// Source: https://en.wikipedia.org/wiki/Bi-directional_text and http://www.unicode.org/Public/6.0.0/ucd/UnicodeData.txt\n// 3 types of strong direction characters: L (strong left-to-right), R(strong right-to-left, Hebrew) and AL(strong right-to-left, Arabic language)\nvar rangesOfLChars = \"[A-Za-z\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02B8\\u02BB-\\u02C1\\u02D0-\\u02D1\\u02E0-\\u02E4\\u02EE\\u0370-\\u0373\\u0376-\\u037D\\u0386\\u0388-\\u03F5\\u03F7-\\u0482\\u048A-\\u0589\\u0903-\\u0939\\u093B\\u093D-\\u0940\\u0949-\\u094C\\u094E-\\u0950\\u0958-\\u0961\\u0964-\\u097F\\u0982-\\u09B9\\u09BD-\\u09C0\\u09C7-\\u09CC\\u09CE-\\u09E1\\u09E6-\\u09F1\\u09F4-\\u09FA\\u0A03-\\u0A39\\u0A3E-\\u0A40\\u0A59-\\u0A6F\\u0A72-\\u0A74\\u0A83-\\u0AB9\\u0ABD-\\u0AC0\\u0AC9-\\u0ACC\\u0AD0-\\u0AE1\\u0AE6-\\u0AEF\\u0B02-\\u0B39\\u0B3D-\\u0B3E\\u0B40\\u0B47-\\u0B4C\\u0B57-\\u0B61\\u0B66-\\u0B77\\u0B83-\\u0BBF\\u0BC1-\\u0BCC\\u0BD0-\\u0BF2\\u0C01-\\u0C3D\\u0C41-\\u0C44\\u0C58-\\u0C61\\u0C66-\\u0C6F\\u0C7F-\\u0CB9\\u0CBD-\\u0CCB\\u0CD5-\\u0CE1\\u0CE6-\\u0D40\\u0D46-\\u0D4C\\u0D4E-\\u0D61\\u0D66-\\u0DC6\\u0DCF-\\u0DD1\\u0DD8-\\u0E30\\u0E32-\\u0E33\\u0E40-\\u0E46\\u0E4F-\\u0EB0\\u0EB2-\\u0EB3\\u0EBD-\\u0EC6\\u0ED0-\\u0F17\\u0F1A-\\u0F34\\u0F36\\u0F38\\u0F3E-\\u0F6C\\u0F7F\\u0F85\\u0F88-\\u0F8C\\u0FBE-\\u0FC5\\u0FC7-\\u102C\\u1031\\u1038\\u103B-\\u103C\\u103F-\\u1057\\u105A-\\u105D\\u1061-\\u1070\\u1075-\\u1081\\u1083-\\u1084\\u1087-\\u108C\\u108E-\\u109C\\u109E-\\u135A\\u1360-\\u138F\\u13A0-\\u13F4\\u1401-\\u167F\\u1681-\\u169A\\u16A0-\\u1711\\u1720-\\u1731\\u1735-\\u1751\\u1760-\\u1770\\u1780-\\u17B6\\u17BE-\\u17C5\\u17C7-\\u17C8\\u17D4-\\u17DA\\u17DC\\u17E0-\\u17E9\\u1810-\\u18A8\\u18AA-\\u191C\\u1923-\\u1926\\u1929-\\u1931\\u1933-\\u1938\\u1946-\\u19DA\\u1A00-\\u1A16\\u1A19-\\u1A55\\u1A57\\u1A61\\u1A63-\\u1A64\\u1A6D-\\u1A72\\u1A80-\\u1AAD\\u1B04-\\u1B33\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43-\\u1B6A\\u1B74-\\u1B7C\\u1B82-\\u1BA1\\u1BA6-\\u1BA7\\u1BAA-\\u1BE5\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1BF2-\\u1C2B\\u1C34-\\u1C35\\u1C3B-\\u1C7F\\u1CD3\\u1CE1\\u1CE9-\\u1CEC\\u1CEE-\\u1DBF\\u1E00-\\u1FBC\\u1FBE\\u1FC2-\\u1FCC\\u1FD0-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FFC\\u200E\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E-\\u214F\\u2160-\\u2188\\u2336-\\u237A\\u2395\\u249C-\\u24E9\\u26AC\\u2800-\\u28FF\\u2C00-\\u2CE4\\u2CEB-\\u2CEE\\u2D00-\\u2D70\\u2D80-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u31BA\\u31F0-\\u321C\\u3220-\\u324F\\u3260-\\u327B\\u327F-\\u32B0\\u32C0-\\u32CB\\u32D0-\\u3376\\u337B-\\u33DD\\u33E0-\\u33FE\\u3400-\\u4DB5\\u4E00-\\uA48C\\uA4D0-\\uA60C\\uA610-\\uA66E\\uA680-\\uA6EF\\uA6F2-\\uA6F7\\uA722-\\uA787\\uA789-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA824\\uA827\\uA830-\\uA837\\uA840-\\uA873\\uA880-\\uA8C3\\uA8CE-\\uA8D9\\uA8F2-\\uA925\\uA92E-\\uA946\\uA952-\\uA97C\\uA983-\\uA9B2\\uA9B4-\\uA9B5\\uA9BA-\\uA9BB\\uA9BD-\\uAA28\\uAA2F-\\uAA30\\uAA33-\\uAA34\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA4D-\\uAAAF\\uAAB1\\uAAB5-\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2-\\uABE4\\uABE6-\\uABE7\\uABE9-\\uABEC\\uABF0-\\uFB17\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFDC]\";\nvar rangesOfRChars = \"[\\u05BE\\u05C0\\u05C3\\u05C6\\u05D0-\\u05F4\\u07C0-\\u07EA\\u07F4-\\u07F5\\u07FA-\\u0815\\u081A\\u0824\\u0828\\u0830-\\u0858\\u085E\\u200F\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB4F]\";\nvar rangesOfALChars = \"[\\u0608\\u060B\\u060D\\u061B-\\u064A\\u066D-\\u066F\\u0671-\\u06D5\\u06E5-\\u06E6\\u06EE-\\u06EF\\u06FA-\\u070D\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\uFB50-\\uFD3D\\uFD50-\\uFDFC\\uFE70-\\uFEFC]\"; // let rangesOfNChars = '[\\u0009-\\u000D\\u001C-\\u0022\\u0026-\\u002A\\u003B-\\u0040\\u005B-\\u0060\\u007B-\\u007E\\u0085\\u00A1\\u00A6-\\u00A9\\u00AB-\\u00AC\\u00AE-\\u00AF\\u00B4\\u00B6-\\u00B8\\u00BB-\\u00BF\\u00D7\\u00F7\\u02B9-\\u02BA\\u02C2-\\u02CF\\u02D2-\\u02DF\\u02E5-\\u02ED\\u02EF-\\u02FF\\u0374-\\u0375\\u037E-\\u0385\\u0387\\u03F6\\u058A\\u0606-\\u0607\\u060E-\\u060F\\u06DE\\u06E9\\u07F6-\\u07F9\\u0BF3-\\u0BF8\\u0BFA\\u0C78-\\u0C7E\\u0F3A-\\u0F3D\\u1390-\\u1399\\u1400\\u1680\\u169B-\\u169C\\u17F0-\\u180A\\u180E\\u1940-\\u1945\\u19DE-\\u19FF\\u1FBD\\u1FBF-\\u1FC1\\u1FCD-\\u1FCF\\u1FDD-\\u1FDF\\u1FED-\\u1FEF\\u1FFD-\\u200A\\u2010-\\u2029\\u2035-\\u2043\\u2045-\\u205F\\u207C-\\u207E\\u208C-\\u208E\\u2100-\\u2101\\u2103-\\u2106\\u2108-\\u2109\\u2114\\u2116-\\u2118\\u211E-\\u2123\\u2125\\u2127\\u2129\\u213A-\\u213B\\u2140-\\u2144\\u214A-\\u214D\\u2150-\\u215F\\u2189-\\u2211\\u2214-\\u2335\\u237B-\\u2394\\u2396-\\u2487\\u24EA-\\u26AB\\u26AD-\\u27FF\\u2900-\\u2B59\\u2CE5-\\u2CEA\\u2CF9-\\u2CFF\\u2E00-\\u3004\\u3008-\\u3020\\u3030\\u3036-\\u3037\\u303D-\\u303F\\u309B-\\u309C\\u30A0\\u30FB\\u31C0-\\u31E3\\u321D-\\u321E\\u3250-\\u325F\\u327C-\\u327E\\u32B1-\\u32BF\\u32CC-\\u32CF\\u3377-\\u337A\\u33DE-\\u33DF\\u33FF\\u4DC0-\\u4DFF\\uA490-\\uA4C6\\uA60D-\\uA60F\\uA673\\uA67E-\\uA67F\\uA700-\\uA721\\uA788\\uA828-\\uA82B\\uA874-\\uA877\\uFD3E-\\uFD3F\\uFDFD\\uFE10-\\uFE19\\uFE30-\\uFE4F\\uFE51\\uFE54\\uFE56-\\uFE5E\\uFE60-\\uFE61\\uFE64-\\uFE68\\uFE6B\\uFF01-\\uFF02\\uFF06-\\uFF0A\\uFF1B-\\uFF20\\uFF3B-\\uFF40\\uFF5B-\\uFF65\\uFFE2-\\uFFE4\\uFFE8-\\uFFFD]';\n\nvar rangesOfLRgExp = new RegExp(rangesOfLChars);\nvar rangesOfRRgExp = new RegExp(rangesOfRChars);\nvar rangesOfALRgExp = new RegExp(rangesOfALChars); // let rangesOfNRgExp = new RegExp(rangesOfNChars);\n// let lrm = String.fromCharCode(8206); // left-to-right marker\n// let rlm = String.fromCharCode(8207); // right-to-left marker\n\nfunction isLtrChar(c) {\n  return rangesOfLRgExp.test(c);\n}\n\nfunction isRtlChar(c) {\n  return rangesOfRRgExp.test(c) || rangesOfALRgExp.test(c);\n}\n\nfunction detectTextDirection(s) {\n  var n = s ? s.length : 0,\n      i,\n      c;\n\n  for (i = 0; i < n; i++) {\n    c = s[i];\n\n    if (isLtrChar(c)) {\n      return 'ltr';\n    }\n\n    if (isRtlChar(c)) {\n      return 'rtl';\n    }\n  }\n\n  return 'ltr';\n}\nvar textAnchorRTLMap = {\n  start: 'end',\n  end: 'start',\n  center: 'center',\n  middle: 'middle'\n};\n/* let flippedTextAnchor = true;\nlet detected = false;\nexport function detectRtlSvgSupport(ns, ownerDoc) {\n  if (!detected) {\n    const body = ownerDoc.body;\n    if (body) {\n      const rtlTestSVG = ownerDoc.createElementNS(ns, 'svg');\n      const textNode = ownerDoc.createElementNS(ns, 'text');\n      const group = ownerDoc.createElementNS(ns, 'g');\n\n      rtlTestSVG.setAttribute('xmlns', ns);\n      rtlTestSVG.setAttribute('style', 'position: absolute; width: 100px; height: 100px; top: -100px; left: 0px');\n\n      textNode.setAttribute('text-anchor', 'start');\n      textNode.setAttribute('direction', 'rtl');\n      textNode.setAttribute('font-size', '14px');\n      textNode.setAttribute('x', 50);\n      textNode.setAttribute('y', 50);\n      textNode.textContent = 'ثعبان';\n\n      group.appendChild(textNode);\n      rtlTestSVG.appendChild(group);\n      body.appendChild(rtlTestSVG);\n\n      flippedTextAnchor = textNode.getBoundingClientRect().left < 50;\n      body.removeChild(rtlTestSVG);\n    }\n  }\n  detected = true;\n} */\n\nfunction flipTextAnchor(value, dir) {\n  if (dir === 'rtl') {\n    return textAnchorRTLMap[value];\n  }\n\n  return value;\n}\n\nfunction render$7(t, _ref) {\n  var g = _ref.g,\n      ellipsed = _ref.ellipsed;\n  var text = ellipsed || ellipsText(t, measureText$1);\n  g.font = \"\".concat(t['font-size'], \" \").concat(t['font-family']);\n  var dir = detectTextDirection(t.text);\n\n  if (g.canvas.dir !== dir) {\n    g.canvas.dir = dir;\n  }\n\n  var textAnchor = t['text-anchor'] === 'middle' ? 'center' : t['text-anchor'];\n  var textAlign = flipTextAnchor(textAnchor, g.canvas.dir);\n\n  if (textAlign && g.textAlign !== textAlign) {\n    g.textAlign = textAlign;\n  }\n\n  var bdy = baselineHeuristic(t);\n  g.fillText(text, t.x + t.dx, t.y + t.dy + bdy);\n}\n\nfunction render$8(path, _ref) {\n  var g = _ref.g,\n      doStroke = _ref.doStroke,\n      doFill = _ref.doFill;\n  var p = new Path2D(path.d);\n\n  if (doFill) {\n    g.fill(p);\n  }\n\n  if (doStroke) {\n    g.stroke(p);\n  }\n}\n\nregister('rect', render$4);\nregister('circle', render$5);\nregister('line', render$6);\nregister('path', render$8);\nregister('text', render$7);\nfunction rendererComponent(picasso) {\n  picasso.renderer('canvas', renderer);\n}\n\nfunction diff$1(from, to) {\n  var added = [];\n  var items;\n  var removed = [];\n  var updatedNew = [];\n  var updatedOld = [];\n  var fromIds;\n  var toIds;\n\n  var idMapper = function idMapper(a) {\n    return a.id;\n  };\n\n  var nodeMapper = function nodeMapper(node, i) {\n    var id;\n\n    if (_typeof(node) === 'object') {\n      if ('id' in node) {\n        id = node.id;\n      } else {\n        id = i;\n      }\n    } else {\n      id = node;\n    }\n\n    return {\n      content: node,\n      id: \"\".concat(id, \"__\").concat(node.type || '')\n    };\n  };\n\n  if (!from.isTree) {\n    from = from.map(nodeMapper);\n  }\n\n  to = to.map(nodeMapper);\n  fromIds = from.map(idMapper);\n  toIds = to.map(idMapper); // TODO - handle duplicate values\n  // added = to.filter( v => fromIds.indexOf( v.id ) < 0 );\n  // updatedNew = to.filter( v => fromIds.indexOf( v.id ) >= 0 );\n  // removed = from.filter( v => toIds.indexOf( v.id ) < 0 );\n  // updatedOld = from.filter( v => toIds.indexOf( v.id ) >= 0 );\n\n  for (var i = 0, len = to.length; i < len; i++) {\n    var idx = fromIds.indexOf(to[i].id);\n\n    if (idx === -1) {\n      added.push(to[i]);\n    } else {\n      updatedNew.push(to[i]);\n    }\n  }\n\n  for (var _i = 0, _len = from.length; _i < _len; _i++) {\n    var _idx = toIds.indexOf(from[_i].id);\n\n    if (_idx === -1) {\n      removed.push(from[_i]);\n    } else {\n      updatedOld.push(from[_i]);\n    }\n  }\n\n  for (var _i2 = 0, _len2 = added.length; _i2 < _len2; _i2++) {\n    if (added[_i2].content.children) {\n      added[_i2].diff = diff$1([], added[_i2].content.children);\n      added[_i2].children = added[_i2].diff.updatedNew.concat(added[_i2].diff.added);\n      added[_i2].children.isTree = true;\n    }\n  }\n\n  for (var _i3 = 0, _len3 = updatedNew.length; _i3 < _len3; _i3++) {\n    updatedNew[_i3].diff = diff$1(updatedOld[_i3].children || [], updatedNew[_i3].content.children || []);\n    updatedNew[_i3].object = updatedOld[_i3].object;\n    updatedNew[_i3].children = updatedNew[_i3].diff.items;\n  }\n\n  items = updatedNew.concat(added);\n  added.isTree = true;\n  removed.isTree = true;\n  updatedNew.isTree = true;\n  updatedOld.isTree = true;\n  items.isTree = true;\n  return {\n    added: added,\n    updatedNew: updatedNew,\n    updatedOld: updatedOld,\n    removed: removed,\n    items: items\n  };\n}\n\nfunction createNodes(nodes, parent, create) {\n  for (var i = 0, len = nodes.length; i < len; i++) {\n    nodes[i].object = create(nodes[i].content.type, parent);\n  }\n}\n\nfunction destroyNodes(nodes, destroy) {\n  for (var i = 0, len = nodes.length; i < len; i++) {\n    if (nodes[i].object !== null && typeof nodes[i].object !== 'undefined') {\n      destroy(nodes[i].object);\n      nodes[i].object = null;\n    }\n  }\n}\n\nfunction updateNodes(nodes, creator, maintainer, destroyer) {\n  var item;\n\n  for (var i = 0, len = nodes.length; i < len; i++) {\n    item = nodes[i];\n\n    if (item.object !== null && typeof item.object !== 'undefined') {\n      maintainer(item.object, item.content);\n\n      if (item.diff) {\n        createNodes(item.diff.added, item.object, creator);\n        destroyNodes(item.diff.removed, destroyer);\n        updateNodes(item.diff.items, creator, maintainer, destroyer);\n      }\n    }\n  }\n}\n\nfunction createTree(oldItems, newItems, root, creator, maintainer, destroyer) {\n  var d = diff$1(oldItems, newItems);\n  createNodes(d.added, root, creator);\n  destroyNodes(d.removed, destroyer);\n  updateNodes(d.items, creator, maintainer, destroyer);\n  return d.items;\n}\n\nvar svgNs = 'http://www.w3.org/2000/svg';\n\nvar creator = function creator(type, parent) {\n  if (!type || typeof type !== 'string') {\n    throw new Error(\"Invalid type: \".concat(type));\n  }\n\n  var el = parent.ownerDocument.createElementNS(svgNs, type === 'container' ? 'g' : type);\n  parent.appendChild(el);\n  return el;\n};\n\nvar destroyer = function destroyer(el) {\n  if (el.parentNode) {\n    el.parentNode.removeChild(el);\n  }\n};\n\nvar maintainer = function maintainer(element, item) {\n  for (var attr in item.attrs) {\n    if (attr === 'stroke' && item.strokeReference) {\n      element.setAttribute('stroke', item.strokeReference);\n    } else if (attr === 'fill' && item.fillReference) {\n      element.setAttribute('fill', item.fillReference);\n    } else if (attr === 'text') {\n      element.setAttribute('style', 'white-space: pre');\n      element.textContent = item.ellipsed || ellipsText(item.attrs, measureText$1);\n      var dir = detectTextDirection(item.attrs.text);\n\n      if (dir === 'rtl') {\n        element.setAttribute('direction', 'rtl');\n        element.setAttribute('dir', 'rtl');\n        element.setAttribute('text-anchor', flipTextAnchor(element.getAttribute('text-anchor'), dir));\n      }\n    } else if (item.type === 'text' && (attr === 'dy' || attr === 'dominant-baseline')) {\n      var dy = +element.getAttribute(attr) || 0;\n      var val = 0;\n\n      if (attr === 'dominant-baseline') {\n        val = baselineHeuristic(item.attrs);\n      } else {\n        val = item.attrs[attr];\n      }\n\n      element.setAttribute('dy', val + dy);\n    } else if (item.type === 'text' && attr === 'title' && item.attrs.title) {\n      var t = element.ownerDocument.createElementNS(svgNs, 'title');\n      t.textContent = item.attrs.title;\n      element.appendChild(t);\n    } else {\n      element.setAttribute(attr, item.attrs[attr]);\n    }\n  }\n\n  if (typeof item.data === 'string' || typeof item.data === 'number' || typeof item.data === 'boolean') {\n    element.setAttribute('data', item.data);\n  } else if (_typeof(item.data) === 'object' && item.data !== null) {\n    for (var d in item.data) {\n      if (typeof item.data[d] === 'string' || typeof item.data[d] === 'number' || typeof item.data[d] === 'boolean') {\n        element.setAttribute(\"data-\".concat(d), item.data[d]);\n      }\n    }\n  }\n};\n\nvar TreeItemRenderer =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Constructor\n   * @private\n   * @param  {TreeCreator} treeCreator - Function used to create the DOM tree..\n   * @param  {SVGCreator} nodeCreator - Function used to create nodes.\n   * @param  {SVGMaintainer} nodeMaintainer - Function used to update nodes.\n   * @param  {SVGDestroyer} nodeDestroyer - Function used to destroy nodes.\n   */\n  function TreeItemRenderer(treeCreator, nodeCreator, nodeMaintainer, nodeDestroyer) {\n    _classCallCheck$1(this, TreeItemRenderer);\n\n    this.create = treeCreator;\n    this.nodeCreator = nodeCreator;\n    this.nodeMaintainer = nodeMaintainer;\n    this.nodeDestroyer = nodeDestroyer;\n  }\n\n  _createClass$1(TreeItemRenderer, [{\n    key: \"render\",\n    value: function render(newItems, root) {\n      return this.create([], newItems, root, this.nodeCreator, this.nodeMaintainer, this.nodeDestroyer);\n    }\n  }]);\n\n  return TreeItemRenderer;\n}();\n\nfunction tree() {\n  return new TreeItemRenderer(createTree, creator, maintainer, destroyer);\n}\n/**\n * Create an SVGElement and attach to parent.\n * @private\n * @callback SVGCreator\n * @param {String} type - The type of element to create.\n * @param {SVGElement} parent - The parent element to append the new element to.\n * @return {SVGElement} The created element\n */\n\n/**\n * Update the element with content from item.\n * @private\n * @callback SVGMaintainer\n * @param {SVGElement} el - The element to update\n * @param {Object} item - The object to use as input for the update\n */\n\n/**\n * Detach element from its parent.\n * @private\n * @callback SVGDestroyer\n * @param {SVGElement} el - Element to destroy.\n */\n\n/**\n * Create, update and destroy nodes.\n * @private\n * @callback TreeCreator\n * @param {Object[]} existing - The existing items in the tree.\n * @param {Object[]} active - The new items to create the tree from.\n * @param {SVGCreator} creator - Function used to create nodes.\n * @param {SVGMaintainer} maintainer - Function used to update nodes.\n * @param {SVGDestroyer} destroyer - Function used to destroy nodes.\n */\n\n/* eslint import/prefer-default-export: 0 */\n\n/**\n * Hash an object\n * Modified version of Java's HashCode function\n * Source: {@link http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/}\n * @ignore\n *\n * @param  {Object} item Item to hash\n * @return {String}      Unique hash id\n */\nfunction hashObject(item) {\n  var hash = 0;\n  var i;\n  var chr;\n  var len;\n  item = JSON.stringify(item);\n\n  if (item.length === 0) {\n    return hash;\n  }\n\n  for (i = 0, len = item.length; i < len; i++) {\n    chr = item.charCodeAt(i);\n    hash = (hash << 5) - hash + chr;\n    hash &= hash; // Convert to 32bit integer\n  }\n\n  return hash;\n}\n\nfunction gradienter(bucket) {\n  var hasher = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : hashObject;\n  var cache = {};\n  var uid = Date.now();\n  var p = {\n    getOrCreateGradient: function getOrCreateGradient() {\n      var item = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var attr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'fill';\n      var url = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      var gradientHash = hasher(item[attr]);\n      var gradientId = \"picasso-gradient-\".concat(uid, \"-\").concat(gradientHash);\n\n      if (!cache[gradientHash]) {\n        var _item$attr = item[attr],\n            orientation = _item$attr.orientation,\n            degree = _item$attr.degree,\n            _item$attr$stops = _item$attr.stops,\n            stops = _item$attr$stops === void 0 ? [] : _item$attr$stops;\n        var gradient = {};\n\n        if (degree === undefined) {\n          degree = 90;\n        } // Default to linear\n\n\n        if (orientation === 'radial') {\n          gradient.type = 'radialGradient';\n        } else {\n          gradient = degreesToPoints(degree);\n          ['x1', 'x2', 'y1', 'y2'].forEach(function (c) {\n            if (c in item[attr]) {\n              gradient[c] = item[attr][c];\n            }\n          });\n          gradient.type = 'linearGradient';\n        }\n\n        gradient.id = gradientId;\n        gradient.children = stops.map(function (_ref) {\n          var offset = _ref.offset,\n              color = _ref.color,\n              opacity = _ref.opacity;\n          return {\n            type: 'stop',\n            offset: \"\".concat(offset * 100, \"%\"),\n            style: \"stop-color:\".concat(color, \";stop-opacity:\").concat(typeof opacity !== 'undefined' ? opacity : 1)\n          };\n        });\n        bucket.push(gradient);\n        cache[gradientHash] = gradientId;\n      }\n\n      return \"url('\".concat(url, \"#\").concat(gradientId, \"')\");\n    },\n    onCreate: function onCreate(state) {\n      var url = '';\n\n      if (typeof window !== 'undefined') {\n        url = window.location.href.split('#')[0];\n      }\n\n      var item = state.node;\n\n      if (item.fill && _typeof(item.fill) === 'object' && item.fill.type === 'gradient') {\n        item.fillReference = p.getOrCreateGradient(item, 'fill', url);\n      }\n\n      if (item.stroke && _typeof(item.stroke) === 'object' && item.stroke.type === 'gradient') {\n        item.strokeReference = p.getOrCreateGradient(item, 'stroke', url);\n      }\n    },\n    clear: function clear() {\n      cache = {};\n    }\n  };\n  return p;\n}\n\nfunction patternizer$1(bucket) {\n  var hasher = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : hashObject;\n  var cache = {};\n  var uid = Date.now();\n  var p = {\n    onCreate: function onCreate(state) {\n      var inputs = {};\n\n      if (state.node && _typeof(state.node.fill) === 'object' && state.node.fill.type === 'pattern' && state.node.fill.shapes) {\n        inputs.fill = state.node.fill;\n      }\n\n      if (state.node && _typeof(state.node.stroke) === 'object' && state.node.stroke.type === 'pattern' && state.node.stroke.shapes) {\n        inputs.stroke = state.node.stroke;\n      }\n\n      Object.keys(inputs).forEach(function (key) {\n        var url = '';\n        var input = inputs[key];\n        var patternHash = hasher(input);\n        var pnid = \"picasso-pattern-\".concat(uid, \"-\").concat(patternHash);\n\n        if (typeof window !== 'undefined') {\n          url = window.location.href.split('#')[0];\n        }\n\n        if (!cache[patternHash]) {\n          var pn = {\n            patternUnits: 'userSpaceOnUse',\n            x: 0,\n            y: 0,\n            width: input.width,\n            height: input.height,\n            type: 'pattern',\n            id: pnid,\n            children: [],\n            fill: input.fill\n          };\n          input.shapes.forEach(function (s) {\n            pn.children.push(s);\n          });\n          bucket.push(pn);\n          cache[patternHash] = true;\n        }\n\n        state.node[\"\".concat(key, \"Reference\")] = \"url('\".concat(url, \"#\").concat(pnid, \"')\");\n      });\n    },\n    clear: function clear() {\n      cache = {};\n    }\n  };\n  return p;\n}\n\n/**\n * Create a new svg renderer\n * @typedef {function} svgRendererFactory\n * @param {function} treeFactory - Node tree factory\n * @param {string} ns - Namespace definition\n * @param {function} sceneFn - Scene factory\n * @returns {renderer} A svg renderer instance\n */\n\nfunction renderer$1() {\n  var treeFn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : tree;\n  var ns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : svgNs;\n  var sceneFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : scene;\n  var tree$1 = treeFn();\n  var el;\n  var group;\n  var hasChangedRect = false;\n  var rect = createRendererBox();\n  var scene$1;\n  var svg = create$n();\n  var defs = {\n    type: 'defs',\n    children: []\n  };\n  var patterns = patternizer$1(defs.children);\n  var gradients = gradienter(defs.children);\n\n  svg.element = function () {\n    return el;\n  };\n\n  svg.root = function () {\n    return group;\n  };\n\n  svg.appendTo = function (element) {\n    if (!el) {\n      el = element.ownerDocument.createElementNS(ns, 'svg');\n      el.style.position = 'absolute';\n      el.style['-webkit-font-smoothing'] = 'antialiased';\n      el.style['-moz-osx-font-smoothing'] = 'antialiased';\n      el.style.pointerEvents = 'none';\n      el.setAttribute('xmlns', ns);\n      group = element.ownerDocument.createElementNS(ns, 'g');\n      group.style.pointerEvents = 'auto';\n      el.appendChild(group);\n    }\n\n    element.appendChild(el);\n    return el;\n  };\n\n  svg.render = function (nodes) {\n    if (!el) {\n      return false;\n    }\n\n    var scaleX = rect.scaleRatio.x;\n    var scaleY = rect.scaleRatio.y;\n\n    if (hasChangedRect) {\n      el.style.left = \"\".concat(rect.computedPhysical.x, \"px\");\n      el.style.top = \"\".concat(rect.computedPhysical.y, \"px\");\n      el.setAttribute('width', rect.computedPhysical.width);\n      el.setAttribute('height', rect.computedPhysical.height);\n    }\n\n    gradients.clear();\n    patterns.clear();\n    defs.children.length = 0;\n    var sceneContainer = {\n      type: 'container',\n      children: Array.isArray(nodes) ? [].concat(_toConsumableArray$1(nodes), [defs]) : nodes,\n      transform: rect.edgeBleed.bool ? \"translate(\".concat(rect.edgeBleed.left * scaleX, \", \").concat(rect.edgeBleed.top * scaleY, \")\") : ''\n    };\n\n    if (scaleX !== 1 || scaleY !== 1) {\n      sceneContainer.transform += \"scale(\".concat(scaleX, \", \").concat(scaleY, \")\");\n    }\n\n    var newScene = sceneFn({\n      items: [sceneContainer],\n      on: {\n        create: [function (state) {\n          state.node.fillReference = undefined;\n          state.node.strokeReference = undefined;\n        }, gradients.onCreate, patterns.onCreate, onLineBreak(svg.measureText), injectTextBoundsFn(svg)]\n      }\n    });\n    var hasChangedScene = scene$1 ? !newScene.equals(scene$1) : true;\n    var doRender = hasChangedRect || hasChangedScene;\n\n    if (doRender) {\n      svg.clear();\n      tree$1.render(newScene.children, group);\n    }\n\n    hasChangedRect = false;\n    scene$1 = newScene;\n    return doRender;\n  };\n\n  svg.itemsAt = function (input) {\n    return scene$1 ? scene$1.getItemsFrom(input) : [];\n  };\n\n  svg.findShapes = function (selector) {\n    return scene$1 ? scene$1.findShapes(selector) : [];\n  };\n\n  svg.clear = function () {\n    if (!group) {\n      return svg;\n    }\n\n    scene$1 = null;\n    var g = group.cloneNode(false);\n    el.replaceChild(g, group);\n    group = g;\n    return svg;\n  };\n\n  svg.destroy = function () {\n    // parentElement is not supported in IE11 for SVGElement.\n    if (el && el.parentNode) {\n      el.parentNode.removeChild(el);\n    }\n\n    el = null;\n    group = null;\n  };\n\n  svg.size = function (opts) {\n    if (opts) {\n      var newRect = createRendererBox(opts);\n\n      if (JSON.stringify(rect) !== JSON.stringify(newRect)) {\n        hasChangedRect = true;\n        rect = newRect;\n      }\n    }\n\n    return rect;\n  };\n\n  return svg;\n}\nfunction rendererComponent$1(picasso) {\n  picasso.renderer('svg', renderer$1);\n}\n\nvar VNode = function VNode() {};\n\nvar options = {};\n\nvar stack$1 = [];\n\nvar EMPTY_CHILDREN = [];\n\nfunction h(nodeName, attributes) {\n\tvar children = EMPTY_CHILDREN,\n\t    lastSimple,\n\t    child,\n\t    simple,\n\t    i;\n\tfor (i = arguments.length; i-- > 2;) {\n\t\tstack$1.push(arguments[i]);\n\t}\n\tif (attributes && attributes.children != null) {\n\t\tif (!stack$1.length) stack$1.push(attributes.children);\n\t\tdelete attributes.children;\n\t}\n\twhile (stack$1.length) {\n\t\tif ((child = stack$1.pop()) && child.pop !== undefined) {\n\t\t\tfor (i = child.length; i--;) {\n\t\t\t\tstack$1.push(child[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (typeof child === 'boolean') child = null;\n\n\t\t\tif (simple = typeof nodeName !== 'function') {\n\t\t\t\tif (child == null) child = '';else if (typeof child === 'number') child = String(child);else if (typeof child !== 'string') simple = false;\n\t\t\t}\n\n\t\t\tif (simple && lastSimple) {\n\t\t\t\tchildren[children.length - 1] += child;\n\t\t\t} else if (children === EMPTY_CHILDREN) {\n\t\t\t\tchildren = [child];\n\t\t\t} else {\n\t\t\t\tchildren.push(child);\n\t\t\t}\n\n\t\t\tlastSimple = simple;\n\t\t}\n\t}\n\n\tvar p = new VNode();\n\tp.nodeName = nodeName;\n\tp.children = children;\n\tp.attributes = attributes == null ? undefined : attributes;\n\tp.key = attributes == null ? undefined : attributes.key;\n\n\treturn p;\n}\n\nfunction extend$2(obj, props) {\n  for (var i in props) {\n    obj[i] = props[i];\n  }return obj;\n}\n\nfunction applyRef(ref, value) {\n  if (ref) {\n    if (typeof ref == 'function') ref(value);else ref.current = value;\n  }\n}\n\nvar defer = typeof Promise == 'function' ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout;\n\nvar IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;\n\nvar items = [];\n\nfunction enqueueRender(component) {\n\tif (!component._dirty && (component._dirty = true) && items.push(component) == 1) {\n\t\t( defer)(rerender);\n\t}\n}\n\nfunction rerender() {\n\tvar p;\n\twhile (p = items.pop()) {\n\t\tif (p._dirty) renderComponent(p);\n\t}\n}\n\nfunction isSameNodeType(node, vnode, hydrating) {\n\tif (typeof vnode === 'string' || typeof vnode === 'number') {\n\t\treturn node.splitText !== undefined;\n\t}\n\tif (typeof vnode.nodeName === 'string') {\n\t\treturn !node._componentConstructor && isNamedNode(node, vnode.nodeName);\n\t}\n\treturn hydrating || node._componentConstructor === vnode.nodeName;\n}\n\nfunction isNamedNode(node, nodeName) {\n\treturn node.normalizedNodeName === nodeName || node.nodeName.toLowerCase() === nodeName.toLowerCase();\n}\n\nfunction getNodeProps(vnode) {\n\tvar props = extend$2({}, vnode.attributes);\n\tprops.children = vnode.children;\n\n\tvar defaultProps = vnode.nodeName.defaultProps;\n\tif (defaultProps !== undefined) {\n\t\tfor (var i in defaultProps) {\n\t\t\tif (props[i] === undefined) {\n\t\t\t\tprops[i] = defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn props;\n}\n\nfunction createNode(nodeName, isSvg) {\n\tvar node = isSvg ? document.createElementNS('http://www.w3.org/2000/svg', nodeName) : document.createElement(nodeName);\n\tnode.normalizedNodeName = nodeName;\n\treturn node;\n}\n\nfunction removeNode(node) {\n\tvar parentNode = node.parentNode;\n\tif (parentNode) parentNode.removeChild(node);\n}\n\nfunction setAccessor(node, name, old, value, isSvg) {\n\tif (name === 'className') name = 'class';\n\n\tif (name === 'key') ; else if (name === 'ref') {\n\t\tapplyRef(old, null);\n\t\tapplyRef(value, node);\n\t} else if (name === 'class' && !isSvg) {\n\t\tnode.className = value || '';\n\t} else if (name === 'style') {\n\t\tif (!value || typeof value === 'string' || typeof old === 'string') {\n\t\t\tnode.style.cssText = value || '';\n\t\t}\n\t\tif (value && typeof value === 'object') {\n\t\t\tif (typeof old !== 'string') {\n\t\t\t\tfor (var i in old) {\n\t\t\t\t\tif (!(i in value)) node.style[i] = '';\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (var i in value) {\n\t\t\t\tnode.style[i] = typeof value[i] === 'number' && IS_NON_DIMENSIONAL.test(i) === false ? value[i] + 'px' : value[i];\n\t\t\t}\n\t\t}\n\t} else if (name === 'dangerouslySetInnerHTML') {\n\t\tif (value) node.innerHTML = value.__html || '';\n\t} else if (name[0] == 'o' && name[1] == 'n') {\n\t\tvar useCapture = name !== (name = name.replace(/Capture$/, ''));\n\t\tname = name.toLowerCase().substring(2);\n\t\tif (value) {\n\t\t\tif (!old) node.addEventListener(name, eventProxy, useCapture);\n\t\t} else {\n\t\t\tnode.removeEventListener(name, eventProxy, useCapture);\n\t\t}\n\t\t(node._listeners || (node._listeners = {}))[name] = value;\n\t} else if (name !== 'list' && name !== 'type' && !isSvg && name in node) {\n\t\ttry {\n\t\t\tnode[name] = value == null ? '' : value;\n\t\t} catch (e) {}\n\t\tif ((value == null || value === false) && name != 'spellcheck') node.removeAttribute(name);\n\t} else {\n\t\tvar ns = isSvg && name !== (name = name.replace(/^xlink:?/, ''));\n\n\t\tif (value == null || value === false) {\n\t\t\tif (ns) node.removeAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase());else node.removeAttribute(name);\n\t\t} else if (typeof value !== 'function') {\n\t\t\tif (ns) node.setAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase(), value);else node.setAttribute(name, value);\n\t\t}\n\t}\n}\n\nfunction eventProxy(e) {\n\treturn this._listeners[e.type]( e);\n}\n\nvar mounts = [];\n\nvar diffLevel = 0;\n\nvar isSvgMode = false;\n\nvar hydrating = false;\n\nfunction flushMounts() {\n\tvar c;\n\twhile (c = mounts.shift()) {\n\t\tif (c.componentDidMount) c.componentDidMount();\n\t}\n}\n\nfunction diff$2(dom, vnode, context, mountAll, parent, componentRoot) {\n\tif (!diffLevel++) {\n\t\tisSvgMode = parent != null && parent.ownerSVGElement !== undefined;\n\n\t\thydrating = dom != null && !('__preactattr_' in dom);\n\t}\n\n\tvar ret = idiff(dom, vnode, context, mountAll, componentRoot);\n\n\tif (parent && ret.parentNode !== parent) parent.appendChild(ret);\n\n\tif (! --diffLevel) {\n\t\thydrating = false;\n\n\t\tif (!componentRoot) flushMounts();\n\t}\n\n\treturn ret;\n}\n\nfunction idiff(dom, vnode, context, mountAll, componentRoot) {\n\tvar out = dom,\n\t    prevSvgMode = isSvgMode;\n\n\tif (vnode == null || typeof vnode === 'boolean') vnode = '';\n\n\tif (typeof vnode === 'string' || typeof vnode === 'number') {\n\t\tif (dom && dom.splitText !== undefined && dom.parentNode && (!dom._component || componentRoot)) {\n\t\t\tif (dom.nodeValue != vnode) {\n\t\t\t\tdom.nodeValue = vnode;\n\t\t\t}\n\t\t} else {\n\t\t\tout = document.createTextNode(vnode);\n\t\t\tif (dom) {\n\t\t\t\tif (dom.parentNode) dom.parentNode.replaceChild(out, dom);\n\t\t\t\trecollectNodeTree(dom, true);\n\t\t\t}\n\t\t}\n\n\t\tout['__preactattr_'] = true;\n\n\t\treturn out;\n\t}\n\n\tvar vnodeName = vnode.nodeName;\n\tif (typeof vnodeName === 'function') {\n\t\treturn buildComponentFromVNode(dom, vnode, context, mountAll);\n\t}\n\n\tisSvgMode = vnodeName === 'svg' ? true : vnodeName === 'foreignObject' ? false : isSvgMode;\n\n\tvnodeName = String(vnodeName);\n\tif (!dom || !isNamedNode(dom, vnodeName)) {\n\t\tout = createNode(vnodeName, isSvgMode);\n\n\t\tif (dom) {\n\t\t\twhile (dom.firstChild) {\n\t\t\t\tout.appendChild(dom.firstChild);\n\t\t\t}\n\t\t\tif (dom.parentNode) dom.parentNode.replaceChild(out, dom);\n\n\t\t\trecollectNodeTree(dom, true);\n\t\t}\n\t}\n\n\tvar fc = out.firstChild,\n\t    props = out['__preactattr_'],\n\t    vchildren = vnode.children;\n\n\tif (props == null) {\n\t\tprops = out['__preactattr_'] = {};\n\t\tfor (var a = out.attributes, i = a.length; i--;) {\n\t\t\tprops[a[i].name] = a[i].value;\n\t\t}\n\t}\n\n\tif (!hydrating && vchildren && vchildren.length === 1 && typeof vchildren[0] === 'string' && fc != null && fc.splitText !== undefined && fc.nextSibling == null) {\n\t\tif (fc.nodeValue != vchildren[0]) {\n\t\t\tfc.nodeValue = vchildren[0];\n\t\t}\n\t} else if (vchildren && vchildren.length || fc != null) {\n\t\t\tinnerDiffNode(out, vchildren, context, mountAll, hydrating || props.dangerouslySetInnerHTML != null);\n\t\t}\n\n\tdiffAttributes(out, vnode.attributes, props);\n\n\tisSvgMode = prevSvgMode;\n\n\treturn out;\n}\n\nfunction innerDiffNode(dom, vchildren, context, mountAll, isHydrating) {\n\tvar originalChildren = dom.childNodes,\n\t    children = [],\n\t    keyed = {},\n\t    keyedLen = 0,\n\t    min = 0,\n\t    len = originalChildren.length,\n\t    childrenLen = 0,\n\t    vlen = vchildren ? vchildren.length : 0,\n\t    j,\n\t    c,\n\t    f,\n\t    vchild,\n\t    child;\n\n\tif (len !== 0) {\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tvar _child = originalChildren[i],\n\t\t\t    props = _child['__preactattr_'],\n\t\t\t    key = vlen && props ? _child._component ? _child._component.__key : props.key : null;\n\t\t\tif (key != null) {\n\t\t\t\tkeyedLen++;\n\t\t\t\tkeyed[key] = _child;\n\t\t\t} else if (props || (_child.splitText !== undefined ? isHydrating ? _child.nodeValue.trim() : true : isHydrating)) {\n\t\t\t\tchildren[childrenLen++] = _child;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (vlen !== 0) {\n\t\tfor (var i = 0; i < vlen; i++) {\n\t\t\tvchild = vchildren[i];\n\t\t\tchild = null;\n\n\t\t\tvar key = vchild.key;\n\t\t\tif (key != null) {\n\t\t\t\tif (keyedLen && keyed[key] !== undefined) {\n\t\t\t\t\tchild = keyed[key];\n\t\t\t\t\tkeyed[key] = undefined;\n\t\t\t\t\tkeyedLen--;\n\t\t\t\t}\n\t\t\t} else if (min < childrenLen) {\n\t\t\t\t\tfor (j = min; j < childrenLen; j++) {\n\t\t\t\t\t\tif (children[j] !== undefined && isSameNodeType(c = children[j], vchild, isHydrating)) {\n\t\t\t\t\t\t\tchild = c;\n\t\t\t\t\t\t\tchildren[j] = undefined;\n\t\t\t\t\t\t\tif (j === childrenLen - 1) childrenLen--;\n\t\t\t\t\t\t\tif (j === min) min++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tchild = idiff(child, vchild, context, mountAll);\n\n\t\t\tf = originalChildren[i];\n\t\t\tif (child && child !== dom && child !== f) {\n\t\t\t\tif (f == null) {\n\t\t\t\t\tdom.appendChild(child);\n\t\t\t\t} else if (child === f.nextSibling) {\n\t\t\t\t\tremoveNode(f);\n\t\t\t\t} else {\n\t\t\t\t\tdom.insertBefore(child, f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (keyedLen) {\n\t\tfor (var i in keyed) {\n\t\t\tif (keyed[i] !== undefined) recollectNodeTree(keyed[i], false);\n\t\t}\n\t}\n\n\twhile (min <= childrenLen) {\n\t\tif ((child = children[childrenLen--]) !== undefined) recollectNodeTree(child, false);\n\t}\n}\n\nfunction recollectNodeTree(node, unmountOnly) {\n\tvar component = node._component;\n\tif (component) {\n\t\tunmountComponent(component);\n\t} else {\n\t\tif (node['__preactattr_'] != null) applyRef(node['__preactattr_'].ref, null);\n\n\t\tif (unmountOnly === false || node['__preactattr_'] == null) {\n\t\t\tremoveNode(node);\n\t\t}\n\n\t\tremoveChildren(node);\n\t}\n}\n\nfunction removeChildren(node) {\n\tnode = node.lastChild;\n\twhile (node) {\n\t\tvar next = node.previousSibling;\n\t\trecollectNodeTree(node, true);\n\t\tnode = next;\n\t}\n}\n\nfunction diffAttributes(dom, attrs, old) {\n\tvar name;\n\n\tfor (name in old) {\n\t\tif (!(attrs && attrs[name] != null) && old[name] != null) {\n\t\t\tsetAccessor(dom, name, old[name], old[name] = undefined, isSvgMode);\n\t\t}\n\t}\n\n\tfor (name in attrs) {\n\t\tif (name !== 'children' && name !== 'innerHTML' && (!(name in old) || attrs[name] !== (name === 'value' || name === 'checked' ? dom[name] : old[name]))) {\n\t\t\tsetAccessor(dom, name, old[name], old[name] = attrs[name], isSvgMode);\n\t\t}\n\t}\n}\n\nvar recyclerComponents = [];\n\nfunction createComponent(Ctor, props, context) {\n\tvar inst,\n\t    i = recyclerComponents.length;\n\n\tif (Ctor.prototype && Ctor.prototype.render) {\n\t\tinst = new Ctor(props, context);\n\t\tComponent.call(inst, props, context);\n\t} else {\n\t\tinst = new Component(props, context);\n\t\tinst.constructor = Ctor;\n\t\tinst.render = doRender;\n\t}\n\n\twhile (i--) {\n\t\tif (recyclerComponents[i].constructor === Ctor) {\n\t\t\tinst.nextBase = recyclerComponents[i].nextBase;\n\t\t\trecyclerComponents.splice(i, 1);\n\t\t\treturn inst;\n\t\t}\n\t}\n\n\treturn inst;\n}\n\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n\nfunction setComponentProps(component, props, renderMode, context, mountAll) {\n\tif (component._disable) return;\n\tcomponent._disable = true;\n\n\tcomponent.__ref = props.ref;\n\tcomponent.__key = props.key;\n\tdelete props.ref;\n\tdelete props.key;\n\n\tif (typeof component.constructor.getDerivedStateFromProps === 'undefined') {\n\t\tif (!component.base || mountAll) {\n\t\t\tif (component.componentWillMount) component.componentWillMount();\n\t\t} else if (component.componentWillReceiveProps) {\n\t\t\tcomponent.componentWillReceiveProps(props, context);\n\t\t}\n\t}\n\n\tif (context && context !== component.context) {\n\t\tif (!component.prevContext) component.prevContext = component.context;\n\t\tcomponent.context = context;\n\t}\n\n\tif (!component.prevProps) component.prevProps = component.props;\n\tcomponent.props = props;\n\n\tcomponent._disable = false;\n\n\tif (renderMode !== 0) {\n\t\tif (renderMode === 1 || options.syncComponentUpdates !== false || !component.base) {\n\t\t\trenderComponent(component, 1, mountAll);\n\t\t} else {\n\t\t\tenqueueRender(component);\n\t\t}\n\t}\n\n\tapplyRef(component.__ref, component);\n}\n\nfunction renderComponent(component, renderMode, mountAll, isChild) {\n\tif (component._disable) return;\n\n\tvar props = component.props,\n\t    state = component.state,\n\t    context = component.context,\n\t    previousProps = component.prevProps || props,\n\t    previousState = component.prevState || state,\n\t    previousContext = component.prevContext || context,\n\t    isUpdate = component.base,\n\t    nextBase = component.nextBase,\n\t    initialBase = isUpdate || nextBase,\n\t    initialChildComponent = component._component,\n\t    skip = false,\n\t    snapshot = previousContext,\n\t    rendered,\n\t    inst,\n\t    cbase;\n\n\tif (component.constructor.getDerivedStateFromProps) {\n\t\tstate = extend$2(extend$2({}, state), component.constructor.getDerivedStateFromProps(props, state));\n\t\tcomponent.state = state;\n\t}\n\n\tif (isUpdate) {\n\t\tcomponent.props = previousProps;\n\t\tcomponent.state = previousState;\n\t\tcomponent.context = previousContext;\n\t\tif (renderMode !== 2 && component.shouldComponentUpdate && component.shouldComponentUpdate(props, state, context) === false) {\n\t\t\tskip = true;\n\t\t} else if (component.componentWillUpdate) {\n\t\t\tcomponent.componentWillUpdate(props, state, context);\n\t\t}\n\t\tcomponent.props = props;\n\t\tcomponent.state = state;\n\t\tcomponent.context = context;\n\t}\n\n\tcomponent.prevProps = component.prevState = component.prevContext = component.nextBase = null;\n\tcomponent._dirty = false;\n\n\tif (!skip) {\n\t\trendered = component.render(props, state, context);\n\n\t\tif (component.getChildContext) {\n\t\t\tcontext = extend$2(extend$2({}, context), component.getChildContext());\n\t\t}\n\n\t\tif (isUpdate && component.getSnapshotBeforeUpdate) {\n\t\t\tsnapshot = component.getSnapshotBeforeUpdate(previousProps, previousState);\n\t\t}\n\n\t\tvar childComponent = rendered && rendered.nodeName,\n\t\t    toUnmount,\n\t\t    base;\n\n\t\tif (typeof childComponent === 'function') {\n\n\t\t\tvar childProps = getNodeProps(rendered);\n\t\t\tinst = initialChildComponent;\n\n\t\t\tif (inst && inst.constructor === childComponent && childProps.key == inst.__key) {\n\t\t\t\tsetComponentProps(inst, childProps, 1, context, false);\n\t\t\t} else {\n\t\t\t\ttoUnmount = inst;\n\n\t\t\t\tcomponent._component = inst = createComponent(childComponent, childProps, context);\n\t\t\t\tinst.nextBase = inst.nextBase || nextBase;\n\t\t\t\tinst._parentComponent = component;\n\t\t\t\tsetComponentProps(inst, childProps, 0, context, false);\n\t\t\t\trenderComponent(inst, 1, mountAll, true);\n\t\t\t}\n\n\t\t\tbase = inst.base;\n\t\t} else {\n\t\t\tcbase = initialBase;\n\n\t\t\ttoUnmount = initialChildComponent;\n\t\t\tif (toUnmount) {\n\t\t\t\tcbase = component._component = null;\n\t\t\t}\n\n\t\t\tif (initialBase || renderMode === 1) {\n\t\t\t\tif (cbase) cbase._component = null;\n\t\t\t\tbase = diff$2(cbase, rendered, context, mountAll || !isUpdate, initialBase && initialBase.parentNode, true);\n\t\t\t}\n\t\t}\n\n\t\tif (initialBase && base !== initialBase && inst !== initialChildComponent) {\n\t\t\tvar baseParent = initialBase.parentNode;\n\t\t\tif (baseParent && base !== baseParent) {\n\t\t\t\tbaseParent.replaceChild(base, initialBase);\n\n\t\t\t\tif (!toUnmount) {\n\t\t\t\t\tinitialBase._component = null;\n\t\t\t\t\trecollectNodeTree(initialBase, false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (toUnmount) {\n\t\t\tunmountComponent(toUnmount);\n\t\t}\n\n\t\tcomponent.base = base;\n\t\tif (base && !isChild) {\n\t\t\tvar componentRef = component,\n\t\t\t    t = component;\n\t\t\twhile (t = t._parentComponent) {\n\t\t\t\t(componentRef = t).base = base;\n\t\t\t}\n\t\t\tbase._component = componentRef;\n\t\t\tbase._componentConstructor = componentRef.constructor;\n\t\t}\n\t}\n\n\tif (!isUpdate || mountAll) {\n\t\tmounts.push(component);\n\t} else if (!skip) {\n\n\t\tif (component.componentDidUpdate) {\n\t\t\tcomponent.componentDidUpdate(previousProps, previousState, snapshot);\n\t\t}\n\t}\n\n\twhile (component._renderCallbacks.length) {\n\t\tcomponent._renderCallbacks.pop().call(component);\n\t}if (!diffLevel && !isChild) flushMounts();\n}\n\nfunction buildComponentFromVNode(dom, vnode, context, mountAll) {\n\tvar c = dom && dom._component,\n\t    originalComponent = c,\n\t    oldDom = dom,\n\t    isDirectOwner = c && dom._componentConstructor === vnode.nodeName,\n\t    isOwner = isDirectOwner,\n\t    props = getNodeProps(vnode);\n\twhile (c && !isOwner && (c = c._parentComponent)) {\n\t\tisOwner = c.constructor === vnode.nodeName;\n\t}\n\n\tif (c && isOwner && (!mountAll || c._component)) {\n\t\tsetComponentProps(c, props, 3, context, mountAll);\n\t\tdom = c.base;\n\t} else {\n\t\tif (originalComponent && !isDirectOwner) {\n\t\t\tunmountComponent(originalComponent);\n\t\t\tdom = oldDom = null;\n\t\t}\n\n\t\tc = createComponent(vnode.nodeName, props, context);\n\t\tif (dom && !c.nextBase) {\n\t\t\tc.nextBase = dom;\n\n\t\t\toldDom = null;\n\t\t}\n\t\tsetComponentProps(c, props, 1, context, mountAll);\n\t\tdom = c.base;\n\n\t\tif (oldDom && dom !== oldDom) {\n\t\t\toldDom._component = null;\n\t\t\trecollectNodeTree(oldDom, false);\n\t\t}\n\t}\n\n\treturn dom;\n}\n\nfunction unmountComponent(component) {\n\n\tvar base = component.base;\n\n\tcomponent._disable = true;\n\n\tif (component.componentWillUnmount) component.componentWillUnmount();\n\n\tcomponent.base = null;\n\n\tvar inner = component._component;\n\tif (inner) {\n\t\tunmountComponent(inner);\n\t} else if (base) {\n\t\tif (base['__preactattr_'] != null) applyRef(base['__preactattr_'].ref, null);\n\n\t\tcomponent.nextBase = base;\n\n\t\tremoveNode(base);\n\t\trecyclerComponents.push(component);\n\n\t\tremoveChildren(base);\n\t}\n\n\tapplyRef(component.__ref, null);\n}\n\nfunction Component(props, context) {\n\tthis._dirty = true;\n\n\tthis.context = context;\n\n\tthis.props = props;\n\n\tthis.state = this.state || {};\n\n\tthis._renderCallbacks = [];\n}\n\nextend$2(Component.prototype, {\n\tsetState: function setState(state, callback) {\n\t\tif (!this.prevState) this.prevState = this.state;\n\t\tthis.state = extend$2(extend$2({}, this.state), typeof state === 'function' ? state(this.state, this.props) : state);\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t},\n\tforceUpdate: function forceUpdate(callback) {\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\trenderComponent(this, 2);\n\t},\n\trender: function render() {}\n});\n\nfunction render$9(vnode, parent, merge) {\n  return diff$2(merge, vnode, {}, false, parent, false);\n}\n\nfunction renderer$2() {\n  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _opts$createElement = opts.createElement,\n      createElement = _opts$createElement === void 0 ? document.createElement.bind(document) : _opts$createElement;\n  var el;\n  var rect = createRendererBox();\n  var dNode;\n  var dom = create$n();\n\n  dom.element = function () {\n    return el;\n  };\n\n  dom.root = function () {\n    return el;\n  };\n\n  dom.appendTo = function (element) {\n    if (!el) {\n      el = createElement('div');\n      el.style.position = 'absolute';\n      el.style['-webkit-font-smoothing'] = 'antialiased';\n      el.style['-moz-osx-font-smoothing'] = 'antialiased';\n      el.style.pointerEvents = 'none';\n    }\n\n    element.appendChild(el);\n    return el;\n  };\n\n  dom.render = function (nodes) {\n    if (!el) {\n      return false;\n    }\n\n    el.style.left = \"\".concat(rect.computedPhysical.x, \"px\");\n    el.style.top = \"\".concat(rect.computedPhysical.y, \"px\");\n    el.style.width = \"\".concat(rect.computedPhysical.width, \"px\");\n    el.style.height = \"\".concat(rect.computedPhysical.height, \"px\");\n    var vNode;\n\n    if (Array.isArray(nodes)) {\n      vNode = h(\"div\", null, nodes);\n    } else {\n      vNode = nodes;\n    }\n\n    dNode = render$9(vNode, el, dNode);\n    return true;\n  };\n\n  dom.renderArgs = [h]; // Arguments to render functions using the DOM renderer\n\n  dom.clear = function () {\n    if (el) {\n      var first = el.firstChild;\n\n      while (first) {\n        el.removeChild(first);\n        first = el.firstChild;\n      }\n\n      dNode = null;\n    }\n\n    return dom;\n  };\n\n  dom.destroy = function () {\n    if (el && el.parentElement) {\n      el.parentElement.removeChild(el);\n    }\n\n    el = null;\n    dNode = null;\n  };\n\n  dom.size = function (inner) {\n    if (inner) {\n      rect = createRendererBox(inner);\n    }\n\n    return rect;\n  };\n\n  return dom;\n}\n\nfunction rendererComponent$2(picasso) {\n  picasso.renderer('dom', renderer$2);\n}\n\nvar renderers = [rendererComponent$1, rendererComponent, rendererComponent$2];\n\nvar scales = [];\n\nvar LOG_LEVEL = {\n  OFF: 0,\n  ERROR: 1,\n  WARN: 2,\n  INFO: 3,\n  DEBUG: 4\n};\n\nvar loggerFn = function loggerFn() {\n  var _LOG_FN;\n\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$level = _ref.level,\n      level = _ref$level === void 0 ? LOG_LEVEL.OFF : _ref$level,\n      _ref$pipe = _ref.pipe,\n      pipe = _ref$pipe === void 0 ? console : _ref$pipe;\n\n  var currentlevel = level;\n  var LOG_FN = (_LOG_FN = {}, _defineProperty(_LOG_FN, LOG_LEVEL.OFF, function () {}), _defineProperty(_LOG_FN, LOG_LEVEL.ERROR, function () {\n    return pipe.error.apply(pipe, arguments);\n  }), _defineProperty(_LOG_FN, LOG_LEVEL.WARN, function () {\n    return pipe.warn.apply(pipe, arguments);\n  }), _defineProperty(_LOG_FN, LOG_LEVEL.INFO, function () {\n    return pipe.info.apply(pipe, arguments);\n  }), _defineProperty(_LOG_FN, LOG_LEVEL.DEBUG, function () {\n    return pipe.log.apply(pipe, arguments);\n  }), _LOG_FN);\n\n  var log = function log(lev) {\n    if (!lev || currentlevel < lev) {\n      return;\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    (LOG_FN[lev] || LOG_FN[LOG_LEVEL.DEBUG]).apply(void 0, args);\n  };\n  /**\n   * @typedef {object} logger\n   * @private\n   */\n\n\n  return (\n    /** @lends logger */\n    {\n      /**\n       * Log a message\n       * @param {number} lev - The log level\n       * @param {...any} args\n       * @kind function\n       */\n      log: log,\n\n      /**\n       * Log an error message\n       * @param {...any} args\n       */\n      error: function error() {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        return log.apply(void 0, [LOG_LEVEL.ERROR].concat(args));\n      },\n\n      /**\n       * Log a warning message\n       * @param {...any} args\n       */\n      warn: function warn() {\n        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          args[_key3] = arguments[_key3];\n        }\n\n        return log.apply(void 0, [LOG_LEVEL.WARN].concat(args));\n      },\n\n      /**\n       * Log an info message\n       * @param {...any} args\n       */\n      info: function info() {\n        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n          args[_key4] = arguments[_key4];\n        }\n\n        return log.apply(void 0, [LOG_LEVEL.INFO].concat(args));\n      },\n\n      /**\n       * Log a debug message\n       * @param {...any} args\n       */\n      debug: function debug() {\n        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n          args[_key5] = arguments[_key5];\n        }\n\n        return log.apply(void 0, [LOG_LEVEL.DEBUG].concat(args));\n      },\n\n      /**\n       * Set the current log level\n       * @param {number} lev - The log level\n       */\n      level: function level(lev) {\n        if (typeof lev === 'number') {\n          currentlevel = lev;\n        }\n\n        return currentlevel;\n      },\n      LOG_LEVEL: LOG_LEVEL\n    }\n  );\n};\n\nvar palettes = [{\n  key: 'categorical',\n  colors: [['#a54343', '#d76c6c', '#ec983d', '#ecc43d', '#f9ec86', '#cbe989', '#70ba6e', '#578b60', '#79d69f', '#26a0a7', '#138185', '#65d3da'] // breeze colors\n  ]\n}, {\n  key: 'diverging',\n  colors: [['#3d52a1', '#3a89c9', '#77b7e5', '#b4ddf7', '#e6f5fe', '#ffe3aa', '#f9bd7e', '#ed875e', '#d24d3e', '#ae1c3e']]\n}, {\n  key: 'sequential',\n  colors: [['rgb(180,221,212)', 'rgb(34, 83, 90)']]\n}];\n/* eslint quote-props: 0 */\n\nvar style = {\n  // -- FOUNDATION --\n  // fonts\n  '$font-family': \"'Source Sans Pro', Arial, sans-serif\",\n  '$font-size': '12px',\n  '$line-height': '16px',\n  '$font-size--l': '16px',\n  // base grays\n  '$gray-100': '#ffffff',\n  '$gray-98': '#f9f9f9',\n  '$gray-95': '#f2f2f2',\n  '$gray-90': '#e6e6e6',\n  '$gray-35': '#595959',\n  '$gray-30': '#4d4d4d',\n  '$gray-25': '#404040',\n  '$gray-20': '#333333',\n  // borders\n  '$border-95': 'rgba(255, 255, 255, 0.05)',\n  '$border-90': 'rgba(255, 255, 255, 0.1)',\n  '$border-80': 'rgba(255, 255, 255, 0.2)',\n  '$border-20': 'rgba(0, 0, 0, 0.2)',\n  '$border-10': 'rgba(0, 0, 0, 0.1)',\n  '$border-5': 'rgba(0, 0, 0, 0.05)',\n  // primary colors\n  '$primary-blue': '#3F8AB3',\n  '$primary-green': '#6CB33F',\n  '$primary-red': '#DC423F',\n  '$primary-orange': '#EF960F',\n  // spacing\n  '$spacing--s': 4,\n  '$spacing': 8,\n  '$spacing--l': 12,\n  // -------------------------\n  // -- ALIASES --\n  '$font-color': '$gray-35',\n  '$font-color--inverted': '$gray-90',\n  '$guide-color': '$gray-90',\n  '$guide-color--inverted': '$gray-35',\n  '$border': '$border-80',\n  '$border--inverted': '$border-10',\n  // -------------------------\n  // -- MIXINS --\n  // data points\n  '$shape': {\n    // data shape\n    fill: '$primary-blue',\n    strokeWidth: 1,\n    stroke: '$border'\n  },\n  '$shape-outline': {\n    // data shape which usually does not have a fill, e.g. the line in a linechart\n    stroke: '$primary-blue',\n    strokeWidth: 2\n  },\n  '$shape-guide': {\n    // lines that somehow belongs to a data shape, e.g. whiskers in a boxplot\n    stroke: '$guide-color',\n    strokeWidth: 1\n  },\n  '$shape-guide--inverted': {\n    '@extend': '$shape-guide',\n    stroke: '$guide-color--inverted'\n  },\n  '$label': {\n    fontSize: '$font-size',\n    fontFamily: '$font-family',\n    fill: '$font-color'\n  },\n  '$label--inverted': {\n    '$extend': '$label',\n    fill: '$font-color--inverted'\n  },\n  // user interface\n  '$label-overlay': {\n    // e.g. selection range bubble\n    fontSize: '$font-size--l',\n    fontFamily: '$font-family',\n    fill: '$gray-100',\n    // background fill\n    color: '$font-color',\n    stroke: '$guide-color--inverted',\n    strokeWidth: 1,\n    borderRadius: 4\n  },\n  '$title': {\n    '@extend': '$label',\n    fontSize: '$font-size--l'\n  },\n  '$guide-line': {\n    strokeWidth: 1,\n    stroke: '$guide-color'\n  },\n  '$guide-line--minor': {\n    strokeWidth: 1,\n    stroke: '$gray-95' // needs alias\n\n  },\n  '$padding--s': {\n    left: '$spacing--s',\n    right: '$spacing--s',\n    top: '$spacing--s',\n    bottom: '$spacing--s'\n  },\n  '$padding': {\n    left: '$spacing',\n    right: '$spacing',\n    top: '$spacing',\n    bottom: '$spacing'\n  },\n  '$selection-area-target': {\n    fill: '$primary-green',\n    strokeWidth: 0,\n    opacity: 0.2\n  }\n};\n\nfunction usePlugin(plugin) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var api = arguments.length > 2 ? arguments[2] : undefined;\n  plugin(api, options);\n}\n\nfunction pic() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var registries = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var logger = loggerFn(config.logger);\n  /**\n   * @lends picassojs\n   */\n\n  var regis = {\n    // -- registries --\n\n    /**\n     * Component registry\n     * @type {registry}\n     */\n    component: registryFactory(registries.component, 'component', logger),\n\n    /**\n     * Data registry\n     * @type {registry}\n     */\n    data: registryFactory(registries.data, 'data', logger),\n\n    /**\n     * Formatter registry\n     * @type {registry}\n     */\n    formatter: registryFactory(registries.formatter, 'formatter', logger),\n\n    /**\n     * Interaction registry\n     * @type {registry}\n     */\n    interaction: registryFactory(registries.interaction, 'interaction', logger),\n\n    /**\n     * Renderer registry\n     * @type {registry}\n     */\n    renderer: rendererRegistry(registries.renderer),\n\n    /**\n     * Scale registry\n     * @type {registry}\n     */\n    scale: registryFactory(registries.scale, 'scale', logger),\n\n    /**\n     * Symbol registry\n     * @type {registry}\n     * @private\n     */\n    symbol: registryFactory(registries.symbol, 'symbol', logger),\n    // -- misc --\n\n    /**\n     * log some some stuff\n     * @type {logger}\n     * @private\n     */\n    logger: logger\n  };\n\n  if (config.renderer && config.renderer.prio) {\n    regis.renderer.default(config.renderer.prio[0]);\n  }\n  /**\n   * picasso.js entry point\n   * @experimental\n   * @entry\n   * @alias picassojs\n   * @param {object} cfg\n   * @param {object} cfg.renderer\n   * @param {Array<string>} cfg.renderer.prio\n   * @param {object} cfg.logger\n   * @param {number} cfg.logger.level\n   * @param {object} cfg.style\n   * @param {Array<object>} cfg.palettes\n   * @returns {picassojs}\n   */\n\n\n  function picassojs() {\n    var cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var cc = {\n      palettes: config.palettes.concat(cfg.palettes || []),\n      style: extend({}, config.style, cfg.style),\n      logger: cfg.logger || config.logger,\n      renderer: cfg.renderer || config.renderer\n    };\n    return pic(cc, regis);\n  }\n  /**\n   * @callback picassojs~plugin\n   * @param {picassojs~registries} registries\n   * @param {object} options\n   */\n\n  /**\n   * @param {picassojs~plugin} plugin\n   * @param {object} [options]\n   */\n\n\n  picassojs.use = function (plugin) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return usePlugin(plugin, options, regis);\n  };\n  /**\n   * @param {chart-definition} definition\n   * @returns {chart}\n   */\n\n\n  picassojs.chart = function (definition) {\n    return chartFn(definition, {\n      registries: regis,\n      logger: logger,\n      style: config.style,\n      palettes: config.palettes\n    });\n  };\n\n  picassojs.config = function () {\n    return config;\n  };\n\n  Object.keys(regis).forEach(function (key) {\n    picassojs[key] = regis[key];\n  });\n  /**\n   * picasso.js version\n   * @type {string}\n   */\n\n  picassojs.version = about.version;\n  return picassojs;\n}\n\nvar p = pic({\n  renderer: {\n    prio: ['svg', 'canvas']\n  },\n  logger: {\n    level: 0\n  },\n  style: style,\n  palettes: palettes\n}, {\n  component: componentRegistry,\n  data: dataRegistry,\n  formatter: formatterRegistry,\n  interaction: reg$2,\n  renderer: rendererRegistry(),\n  scale: scaleRegistry,\n  symbol: reg$1\n});\ncomponents.forEach(p.use);\nrenderers.forEach(p.use);\nscales.forEach(p.use);\n\nexport default p;\n//# sourceMappingURL=picasso.esm.js.map\n",
        "/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = require(\"./urls\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (typeof __webpack_nonce__ === 'undefined') {\n\t\treturn null;\n\t}\n\n\treturn __webpack_nonce__;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === 'function'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n",
        "\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n",
        "var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n",
        "/* eslint-disable semi */\r\n/* eslint-disable max-len */\r\nfunction bar1mes(prop) {\r\n  return {\r\n    scales: {\r\n      y: {\r\n        data: { field: 'qMeasureInfo/0' },\r\n        invert: true,\r\n        include: [0]\r\n      },\r\n      t: { data: { extract: { field: 'qDimensionInfo/0' } }, padding: prop.minichart.barpadding },\r\n    },\r\n    components: [{\r\n      type: 'grid-line',\r\n      y: prop.minichart.gridlinehor,\r\n      x: prop.minichart.gridlinever\r\n    }, {\r\n      key: 'exp1',\r\n      type: 'box',\r\n      data: {\r\n        extract: {\r\n          field: 'qDimensionInfo/0',\r\n          props: {\r\n            start: 0,\r\n            end: { field: 'qMeasureInfo/0' }\r\n          }\r\n        }\r\n      },\r\n      settings: {\r\n        major: { scale: 't' },\r\n        minor: { scale: 'y' },\r\n        box: {\r\n          fill: prop.minichart.colorone.color\r\n        }\r\n      }\r\n    },\r\n    {\r\n      show: prop.minichart.ref.show,\r\n      type: 'ref-line',\r\n      lines: {\r\n        y: [{\r\n          scale: 'y',\r\n          value: prop.minichart.ref.value,\r\n          line: {\r\n            strokeWidth: prop.minichart.ref.strokewidth,\r\n            stroke: prop.minichart.ref.color.color,\r\n          },\r\n          label: {\r\n            background: {\r\n              fill: 'white',\r\n              opacity: 0\r\n            },\r\n            opacity: 0\r\n          }\r\n        }]\r\n      }\r\n    }]\r\n  };\r\n}\r\n\r\nfunction bar2mes(prop) {\r\n  return {\r\n    scales: {\r\n      y: {\r\n        data: { fields: ['qMeasureInfo/0', 'qMeasureInfo/1'] },\r\n        invert: true,\r\n        include: [0]\r\n      },\r\n      t: { data: { extract: { field: 'qDimensionInfo/0' } }, padding: prop.minichart.barpadding, align: prop.minichart.baraligncompare1 },\r\n      v: { data: { extract: { field: 'qDimensionInfo/0' } }, padding: prop.minichart.barpadding, align: prop.minichart.baraligncompare2 }\r\n    },\r\n    components: [{\r\n      type: 'grid-line',\r\n      y: prop.minichart.gridlinehor,\r\n      x: prop.minichart.gridlinever\r\n    }, {\r\n      key: 'exp2',\r\n      type: 'box',\r\n      data: {\r\n        extract: {\r\n          field: 'qDimensionInfo/0',\r\n          props: {\r\n            start: 0,\r\n            end: { field: 'qMeasureInfo/1' },\r\n          }\r\n        }\r\n      },\r\n      settings: {\r\n        major: { scale: 't' },\r\n        minor: { scale: 'y' },\r\n        box: {\r\n          fill: prop.minichart.colortwo.color\r\n        }\r\n      }\r\n    },\r\n    {\r\n      key: 'exp1',\r\n      type: 'box',\r\n      data: {\r\n        extract: {\r\n          field: 'qDimensionInfo/0',\r\n          props: {\r\n            start: 0,\r\n            end: { field: 'qMeasureInfo/0' }\r\n          }\r\n        }\r\n      },\r\n      settings: {\r\n        major: { scale: 'v' },\r\n        minor: { scale: 'y' },\r\n        box: {\r\n          fill: prop.minichart.colorone.color\r\n        }\r\n      }\r\n    },\r\n    {\r\n      show: prop.minichart.ref.show,\r\n      type: 'ref-line',\r\n      lines: {\r\n        y: [{\r\n          scale: 'y',\r\n          value: prop.minichart.ref.value,\r\n          line: {\r\n            strokeWidth: prop.minichart.ref.strokewidth,\r\n            stroke: prop.minichart.ref.color.color,\r\n          },\r\n          label: {\r\n            background: {\r\n              fill: 'white',\r\n              opacity: 0\r\n            },\r\n            opacity: 0\r\n          }\r\n        }]\r\n      }\r\n    }]\r\n  };\r\n}\r\n\r\nfunction line1mes(prop) {\r\n  return {\r\n    scales: {\r\n      y: {\r\n        data: { field: 'qMeasureInfo/0' },\r\n        invert: true,\r\n        expand: prop.minichart.linescaleexpand\r\n      },\r\n      t: { data: { extract: { field: 'qDimensionInfo/0' } } }\r\n    },\r\n    components: [{\r\n      type: 'grid-line',\r\n      y: prop.minichart.gridlinehor,\r\n      x: prop.minichart.gridlinever\r\n    }, {\r\n      key: 'line1',\r\n      type: 'line',\r\n      data: {\r\n        extract: {\r\n          field: 'qDimensionInfo/0',\r\n          props: {\r\n            v: { field: 'qMeasureInfo/0' }\r\n          }\r\n        }\r\n      },\r\n      settings: {\r\n        coordinates: {\r\n          major: { scale: 't' },\r\n          minor: { scale: 'y', ref: 'v' }\r\n        },\r\n        layers: {\r\n          line: {\r\n            stroke: prop.minichart.colorone.color\r\n          }\r\n        }\r\n      }\r\n    },\r\n    {\r\n      key: 'dot1',\r\n      type: 'point',\r\n      data: {\r\n        extract: {\r\n          field: 'qDimensionInfo/0',\r\n          props: {\r\n            v: { field: 'qMeasureInfo/0' }\r\n          }\r\n        }\r\n      },\r\n      settings: {\r\n        x: { scale: 't' },\r\n        y: { scale: 'y', ref: 'v' },\r\n        fill: prop.minichart.colorone.color,\r\n        size: prop.minichart.dotsize\r\n      }\r\n    },\r\n    {\r\n      show: prop.minichart.ref.show,\r\n      type: 'ref-line',\r\n      lines: {\r\n        y: [{\r\n          scale: 'y',\r\n          value: prop.minichart.ref.value,\r\n          line: {\r\n            strokeWidth: prop.minichart.ref.strokewidth,\r\n            stroke: prop.minichart.ref.color.color,\r\n          },\r\n          label: {\r\n            background: {\r\n              fill: 'white',\r\n              opacity: 0\r\n            },\r\n            opacity: 0\r\n          }\r\n        }]\r\n      }\r\n    }]\r\n  };\r\n}\r\n\r\nfunction line2mes(prop) {\r\n  return {\r\n    scales: {\r\n      y: {\r\n        data: { fields: ['qMeasureInfo/0', 'qMeasureInfo/1'] },\r\n        invert: true,\r\n        include: [0],\r\n        expand: prop.minichart.linescaleexpand\r\n      },\r\n      t: { data: { extract: { field: 'qDimensionInfo/0' } } }\r\n    },\r\n    components: [{\r\n      type: 'grid-line',\r\n      y: prop.minichart.gridlinehor,\r\n      x: prop.minichart.gridlinever\r\n    }, {\r\n      key: 'line1',\r\n      type: 'line',\r\n      data: {\r\n        extract: {\r\n          field: 'qDimensionInfo/0',\r\n          props: {\r\n            v: { field: 'qMeasureInfo/0' }\r\n          }\r\n        }\r\n      },\r\n      settings: {\r\n        coordinates: {\r\n          major: { scale: 't' },\r\n          minor: { scale: 'y', ref: 'v' }\r\n        },\r\n        layers: {\r\n          line: {\r\n            stroke: prop.minichart.colorone.color\r\n          }\r\n        }\r\n      }\r\n    },\r\n    {\r\n      key: 'dot1',\r\n      type: 'point',\r\n      data: {\r\n        extract: {\r\n          field: 'qDimensionInfo/0',\r\n          props: {\r\n            v: { field: 'qMeasureInfo/0' }\r\n          }\r\n        }\r\n      },\r\n      settings: {\r\n        x: { scale: 't' },\r\n        y: { scale: 'y', ref: 'v' },\r\n        fill: prop.minichart.colorone.color,\r\n        size: prop.minichart.dotsize\r\n      }\r\n    },\r\n    {\r\n      key: 'line2',\r\n      type: 'line',\r\n      data: {\r\n        extract: {\r\n          field: 'qDimensionInfo/0',\r\n          props: {\r\n            v: { field: 'qMeasureInfo/1' }\r\n          }\r\n        }\r\n      },\r\n      settings: {\r\n        coordinates: {\r\n          major: { scale: 't' },\r\n          minor: { scale: 'y', ref: 'v' }\r\n        },\r\n        layers: {\r\n          line: {\r\n            stroke: prop.minichart.colortwo.color\r\n          }\r\n        }\r\n      }\r\n    },\r\n    {\r\n      key: 'dot2',\r\n      type: 'point',\r\n      data: {\r\n        extract: {\r\n          field: 'qDimensionInfo/0',\r\n          props: {\r\n            v: { field: 'qMeasureInfo/1' }\r\n          }\r\n        }\r\n      },\r\n      settings: {\r\n        x: { scale: 't' },\r\n        y: { scale: 'y', ref: 'v' },\r\n        fill: prop.minichart.colortwo.color,\r\n        size: prop.minichart.dotsize\r\n      }\r\n    },\r\n    {\r\n      show: prop.minichart.ref.show,\r\n      type: 'ref-line',\r\n      lines: {\r\n        y: [{\r\n          scale: 'y',\r\n          value: prop.minichart.ref.value,\r\n          line: {\r\n            strokeWidth: prop.minichart.ref.strokewidth,\r\n            stroke: prop.minichart.ref.color.color,\r\n          },\r\n          label: {\r\n            background: {\r\n              fill: 'white',\r\n              opacity: 0\r\n            },\r\n            opacity: 0\r\n          }\r\n        }]\r\n      }\r\n    }]\r\n  };\r\n}\r\n\r\nfunction gauge1mes(prop) {\r\n}\r\n\r\nexport default {\r\n  bar1mes,\r\n  bar2mes,\r\n  line1mes,\r\n  line2mes,\r\n  gauge1mes\r\n};\r\n\r\n\r\n\r\n",
        "/* eslint-disable max-len */\nvar qlik = window.require('qlik');\nimport $ from 'jquery';\nimport picasso from 'picasso.js';\nimport picassoQ from 'picasso-plugin-q';\nimport chartdef from './chartdef';\n\n// eslint-disable-next-line padded-blocks\nexport default ['$scope', '$element', function ($scope, $element) {\n\n  // Check if app id matches the current app id for In App Pictures\n  let app = qlik.currApp($scope);\n  let id = app.id;\n  let pictureUrl = $scope.layout.prop.background.picture;\n  if (!pictureUrl.includes(id) && !pictureUrl.includes('/content/')) {\n    let split = pictureUrl.split('/');\n    split[2] = id;\n    split = split.join('/');\n    $scope.layout.prop.background.picture = split;\n  }\n\n  picasso.use(picassoQ);\n\n  const ds = [{\n    type: 'q',\n    key: 'qHyperCube',\n    data: $scope.layout.qHyperCube\n  }];\n\n  var picassoSettings;\n\n  //picks settings JSON for picasso --> picassoSettings\n  function getSettings() {\n    var chartType = $scope.layout.prop.minichart.type;\n    var amountMes = $scope.layout.qHyperCube.qMeasureInfo.length;\n\n    switch (chartType) {\n      case 'bar':\n        switch (amountMes) {\n          case 1:\n            picassoSettings = chartdef.bar1mes($scope.layout.prop);\n            break;\n          case 2:\n            picassoSettings = chartdef.bar2mes($scope.layout.prop);\n            break;\n        }\n        break;\n      case 'line':\n        switch (amountMes) {\n          case 1:\n            picassoSettings = chartdef.line1mes($scope.layout.prop);\n            break;\n          case 2:\n            picassoSettings = chartdef.line2mes($scope.layout.prop);\n            break;\n        }\n        break;\n      case 'gauge':\n        picassoSettings = chartdef.gauge1mes($scope.layout.prop);\n        break;\n    }\n  }\n\n  //function to create picasso chart\n  function createChart() {\n    getSettings();\n    $scope.chart = picasso.chart({\n      element: $element.find('.adv-kpi-chart')[0],\n      data: ds,\n      settings: picassoSettings,\n      beforeRender() { qlik.resize(); }\n    });\n  }\n\n  //Scope for changes within hypercube measures\n  $scope.$watch(\"layout.qHyperCube.qMeasureInfo\", function () {\n    if ($scope.layout.qHyperCube.qMeasureInfo[0] && $scope.layout.qHyperCube.qDimensionInfo[0]) {\n      if ($scope.chart) {\n        getSettings();\n        $scope.chart.settings = picassoSettings;\n        $scope.chart.update($scope.chart);\n      } else {\n        createChart();\n      }\n    } else {\n      if ($scope.chart) {\n        $scope.chart.destroy();\n        $scope.chart = false;\n      }\n    }\n  }, true);\n\n  //Scope for changes within hypercube dimension\n  $scope.$watch(\"layout.qHyperCube.qDimensionInfo\", function () {\n    if ($scope.layout.qHyperCube.qMeasureInfo[0] && $scope.layout.qHyperCube.qDimensionInfo[0]) {\n      if ($scope.chart) {\n        getSettings();\n        $scope.chart.settings = picassoSettings;\n        $scope.chart.update($scope.chart);\n      } else {\n        createChart();\n      }\n    } else {\n      if ($scope.chart) {\n        $scope.chart.destroy();\n        $scope.chart = false;\n      }\n    }\n  }, true);\n\n  //Scope  for changes within minichart settings\n  $scope.$watch(\"layout.prop\", function () {\n    if ($scope.chart) {\n      getSettings();\n      $scope.chart.settings = picassoSettings;\n      //console.log(picassoSettings);\n      $scope.chart.update($scope.chart);\n      qlik.resize();\n    }\n  }, true);\n\n  //Get initial Settings\n  getSettings();\n\n  //Scope CSS definition for background\n  $scope.$watch('[layout.prop.background]', function () {\n    try {\n      if ($scope.layout.prop.background.cssswitch) {\n        if ($scope.layout.prop.background.css != '') {\n          $scope.backgroundcss = JSON.parse($scope.layout.prop.background.css);\n        }\n        if ($scope.layout.prop.background.pictureswitch) {\n          $scope.backgroundcss[\"background-image\"] = 'url(' + $scope.layout.prop.background.picture + ')';\n        }\n      } else {\n        if($scope.layout.prop.background.switchfxpick){\n          $scope.backgroundcss = { \"background-color\": $scope.layout.prop.background.colorfx };\n        }\n        if($scope.layout.prop.background.switchfxpick == false){\n          $scope.backgroundcss = { \"background-color\": $scope.layout.prop.background.color.color };\n        }\n      }\n    } catch (err) {\n      console.log(err);\n    }\n  }, true);\n\n  //Scope CSS definition customCSS\n  $scope.$watch('[layout.prop.customcss]', function () {\n    try {\n      if ($scope.layout.prop.customcss.switch) {\n        if ($scope.layout.prop.customcss.css != '') {\n          $scope.customcss = $scope.layout.prop.customcss.css.replace(/&/g, \"div[tid='\" + $scope.layout.qInfo.qId + \"']\");\n        }\n      }\n    } catch (err) {\n      console.log(err);\n    }\n  }, true);  \n}];",
        "/* eslint-disable max-len */\n\ndefine(['qlik'], function (qlik, utils) {\n  var data = {\n    uses: 'data',\n    translation: \"Mini-Chart - Data\",\n    type: \"items\",\n    items: {\n      dimensions: {\n        uses: \"dimensions\",\n        description: (a, b) => {\n          return \"Minichart dimension\";\n        },\n        disabledRef: '',\n        min: 0,\n        max: 1\n      },\n      measures: {\n        uses: \"measures\",\n        description: (a, b) => {\n          return [\"Minichart first measure\", \"Minichart second measure\"][b];\n        },\n        min: 0,\n        max: 2\n      }\n    }\n  };\n\n  /* Measure 1 Settings */\n\n  var measure1Fx = {\n    ref: \"prop.measure1.fx\",\n    label: \"Measure\",\n    type: \"string\",\n    expression: \"always\"\n  };\n\n  var measure1Name = {\n    ref: \"prop.measure1.name\",\n    label: \"Measure Title\",\n    type: \"string\",\n    expression: \"optional\"\n  };\n\n  var measure1Align = {\n    ref: \"prop.measure1.align\",\n    label: \"Text align\",\n    type: \"string\",\n    component: \"dropdown\",\n    options: [{\n      value: \"left\",\n      label: \"left\"\n    }, {\n      value: \"center\",\n      label: \"center\"\n    }, {\n      value: \"right\",\n      label: \"right\"\n    }],\n    defaultValue: \"center\"\n  };\n\n  var measure1KpiStyleSize = {\n    label: \"Font Size\",\n    ref: \"prop.measure1.kpi.size\",\n    type: \"string\",\n    expression: \"optional\",\n    defaultValue: \"1.8rem\"\n  };\n\n  var measure1KpiFont = {\n    label: \"Font\",\n    ref: \"prop.measure1.kpi.font\",\n    type: \"string\",\n    expression: \"optional\",\n    defaultValue: \"QlikView Sans,sans-serif\"\n  };\n\n  var measure1KpiStyleBold = {\n    label: \"bold\",\n    ref: \"prop.measure1.kpi.bold\",\n    type: \"string\",\n    component: \"switch\",\n    options: [{\n      value: \"400\",\n      label: \"Off\"\n    }, {\n      value: \"700\",\n      label: \"On\"\n    }],\n    defaultValue: \"400\"\n  };\n\n  var measure1KpiStyleItalic = {\n    label: \"italic\",\n    ref: \"prop.measure1.kpi.italic\",\n    type: \"string\",\n    component: \"switch\",\n    options: [{\n      value: \"normal\",\n      label: \"Off\"\n    }, {\n      value: \"italic\",\n      label: \"On\"\n    }],\n    defaultValue: \"normal\"\n  };\n\n  var measure1KpiStyleUnderline = {\n    label: \"underline\",\n    ref: \"prop.measure1.kpi.underline\",\n    type: \"string\",\n    component: \"switch\",\n    options: [{\n      value: \"none\",\n      label: \"Off\"\n    }, {\n      value: \"underline\",\n      label: \"On\"\n    }],\n    defaultValue: \"normal\"\n  };\n\n  var measure1KpiStyleColor = {\n    label: \"Color\",\n    ref: \"prop.measure1.kpi.color.color\",\n    type: \"string\",\n    expression: \"optional\",\n    defaultValue: \"#595959\"\n  };\n\n  var measure1TitleStyleSize = {\n    label: \"Font Size\",\n    ref: \"prop.measure1.title.size\",\n    type: \"string\",\n    expression: \"optional\",\n    defaultValue: \"1.5rem\"\n  };\n\n  var measure1TitleFont = {\n    label: \"Font\",\n    ref: \"prop.measure1.title.font\",\n    type: \"string\",\n    expression: \"optional\",\n    defaultValue: \"QlikView Sans,sans-serif\"\n  };\n\n  var measure1TitleStyleBold = {\n    label: \"bold\",\n    ref: \"prop.measure1.title.bold\",\n    type: \"string\",\n    component: \"switch\",\n    options: [{\n      value: \"400\",\n      label: \"Off\"\n    }, {\n      value: \"700\",\n      label: \"On\"\n    }],\n    defaultValue: \"400\"\n  };\n\n  var measure1TitleStyleItalic = {\n    label: \"italic\",\n    ref: \"prop.measure1.title.italic\",\n    type: \"string\",\n    component: \"switch\",\n    options: [{\n      value: \"normal\",\n      label: \"Off\"\n    }, {\n      value: \"italic\",\n      label: \"On\"\n    }],\n    defaultValue: \"normal\"\n  };\n\n  var measure1TitleStyleUnderline = {\n    label: \"underline\",\n    ref: \"prop.measure1.title.underline\",\n    type: \"string\",\n    component: \"switch\",\n    options: [{\n      value: \"none\",\n      label: \"Off\"\n    }, {\n      value: \"underline\",\n      label: \"On\"\n    }],\n    defaultValue: \"normal\"\n  };\n\n  var measure1TitleStyleColor = {\n    ref: \"prop.measure1.title.color\",\n    label: \"Color\",\n    component: \"color-picker\",\n    type: \"object\",\n    defaultValue: \"#595959\"\n  };\n\n  var measure1TrendSwitch = {\n    ref: \"prop.measure1.trend.switch\",\n    label: \"Show Trend\",\n    type: \"boolean\",\n    component: \"switch\",\n    options: [{\n      value: false,\n      label: \"Off\"\n    }, {\n      value: true,\n      label: \"On\"\n    }],\n    defaultValue: false\n  };\n\n  var measure1TrendSide = {\n    ref: \"prop.measure1.trend.side\",\n    label: \"Trend Side\",\n    component: \"dropdown\",\n    type: \"string\",\n    options: [{\n      value: \"left\",\n      label: \"left\"\n    }, {\n      value: \"right\",\n      label: \"right\"\n    }],\n    defaultValue: \"right\",\n    show: function (data) {\n      if (data.prop.measure1.trend.switch) { return true; }\n    }\n  };\n\n  var measure1TrendIcon = {\n    type: \"string\",\n    ref: \"prop.measure1.trend.icon\",\n    label: \"Icon\",\n    expression: \"optional\",\n    defaultValue: \"triangle-top\",\n    show: function (data) {\n      if (data.prop.measure1.trend.switch) { return true; }\n    }\n  };\n\n  var measure1TrendIconColor = {\n    ref: \"prop.measure1.trend.color\",\n    label: \"Color\",\n    expression: \"optional\",\n    type: \"string\",\n    defaultValue: \"#595959\",\n    show: function (data) {\n      if (data.prop.measure1.trend.switch) { return true; }\n    }\n  };\n\n  var measure1TrendFontSize = {\n    ref: \"prop.measure1.trend.size\",\n    label: \"Icon Size\",\n    expression: \"optional\",\n    type: \"string\",\n    defaultValue: \"0.9rem\",\n    show: function (data) {\n      if (data.prop.measure1.trend.switch) { return true; }\n    }\n  };\n\n  /* Measure 2 Settings */\n\n  var measure2Fx = {\n    ref: \"prop.measure2.fx\",\n    label: \"Measure\",\n    type: \"string\",\n    expression: \"always\"\n  };\n\n  var measure2Name = {\n    ref: \"prop.measure2.name\",\n    label: \"Measure Title\",\n    type: \"string\",\n    expression: \"optional\"\n  };\n\n  var measure2Align = {\n    ref: \"prop.measure2.align\",\n    label: \"Text align\",\n    type: \"string\",\n    component: \"dropdown\",\n    options: [{\n      value: \"left\",\n      label: \"left\"\n    }, {\n      value: \"center\",\n      label: \"center\"\n    }, {\n      value: \"right\",\n      label: \"right\"\n    }],\n    defaultValue: \"center\"\n  };\n\n  var measure2KpiStyleSize = {\n    label: \"Font Size\",\n    ref: \"prop.measure2.kpi.size\",\n    type: \"string\",\n    expression: \"optional\",\n    defaultValue: \"0.8rem\"\n  };\n\n  var measure2KpiFont = {\n    label: \"Font\",\n    ref: \"prop.measure2.kpi.font\",\n    type: \"string\",\n    expression: \"optional\",\n    defaultValue: \"QlikView Sans,sans-serif\"\n  };\n\n  var measure2KpiStyleBold = {\n    label: \"bold\",\n    ref: \"prop.measure2.kpi.bold\",\n    type: \"string\",\n    component: \"switch\",\n    options: [{\n      value: \"400\",\n      label: \"Off\"\n    }, {\n      value: \"700\",\n      label: \"On\"\n    }],\n    defaultValue: \"400\"\n  };\n\n  var measure2KpiStyleItalic = {\n    label: \"italic\",\n    ref: \"prop.measure2.kpi.italic\",\n    type: \"string\",\n    component: \"switch\",\n    options: [{\n      value: \"normal\",\n      label: \"Off\"\n    }, {\n      value: \"italic\",\n      label: \"On\"\n    }],\n    defaultValue: \"normal\"\n  };\n\n  var measure2KpiStyleUnderline = {\n    label: \"underline\",\n    ref: \"prop.measure2.kpi.underline\",\n    type: \"string\",\n    component: \"switch\",\n    options: [{\n      value: \"none\",\n      label: \"Off\"\n    }, {\n      value: \"underline\",\n      label: \"On\"\n    }],\n    defaultValue: \"normal\"\n  };\n\n  var measure2KpiStyleColor = {\n    label: \"Color\",\n    ref: \"prop.measure2.kpi.color.color\",\n    type: \"string\",\n    expression: \"optional\",\n    defaultValue: \"#595959\"\n  };\n\n  var measure2TitleStyleSize = {\n    label: \"Font Size\",\n    ref: \"prop.measure2.title.size\",\n    type: \"string\",\n    expression: \"optional\",\n    defaultValue: \"0.8rem\"\n  };\n\n  var measure2TitleFont = {\n    label: \"Font\",\n    ref: \"prop.measure2.title.font\",\n    type: \"string\",\n    expression: \"optional\",\n    defaultValue: \"QlikView Sans,sans-serif\"\n  };\n\n  var measure2TitleStyleBold = {\n    label: \"bold\",\n    ref: \"prop.measure2.title.bold\",\n    type: \"string\",\n    component: \"switch\",\n    options: [{\n      value: \"400\",\n      label: \"Off\"\n    }, {\n      value: \"700\",\n      label: \"On\"\n    }],\n    defaultValue: \"400\"\n  };\n\n  var measure2TitleStyleItalic = {\n    label: \"italic\",\n    ref: \"prop.measure2.title.italic\",\n    type: \"string\",\n    component: \"switch\",\n    options: [{\n      value: \"normal\",\n      label: \"Off\"\n    }, {\n      value: \"italic\",\n      label: \"On\"\n    }],\n    defaultValue: \"normal\"\n  };\n\n  var measure2TitleStyleUnderline = {\n    label: \"underline\",\n    ref: \"prop.measure2.title.underline\",\n    type: \"string\",\n    component: \"switch\",\n    options: [{\n      value: \"none\",\n      label: \"Off\"\n    }, {\n      value: \"underline\",\n      label: \"On\"\n    }],\n    defaultValue: \"normal\"\n  };\n\n  var measure2TitleStyleColor = {\n    ref: \"prop.measure2.title.color\",\n    label: \"Color\",\n    component: \"color-picker\",\n    type: \"object\",\n    defaultValue: \"#595959\"\n  };\n\n  var measure2TrendSwitch = {\n    ref: \"prop.measure2.trend.switch\",\n    label: \"Show Trend\",\n    type: \"boolean\",\n    component: \"switch\",\n    options: [{\n      value: false,\n      label: \"Off\"\n    }, {\n      value: true,\n      label: \"On\"\n    }],\n    defaultValue: false\n  };\n\n  var measure2TrendIcon = {\n    type: \"string\",\n    ref: \"prop.measure2.trend.icon\",\n    label: \"Icon\",\n    expression: \"optional\",\n    defaultValue: \"triangle-top\",\n    show: function (data) {\n      if (data.prop.measure2.trend.switch) { return true; }\n    }\n  };\n\n  var measure2TrendIconColor = {\n    ref: \"prop.measure2.trend.color\",\n    label: \"Color\",\n    expression: \"optional\",\n    type: \"string\",\n    defaultValue: \"#595959\",\n    show: function (data) {\n      if (data.prop.measure2.trend.switch) { return true; }\n    }\n  };\n\n  var measure2TrendFontSize = {\n    ref: \"prop.measure2.trend.size\",\n    label: \"Icon Size\",\n    expression: \"optional\",\n    type: \"string\",\n    defaultValue: \"0.9rem\",\n    show: function (data) {\n      if (data.prop.measure2.trend.switch) { return true; }\n    }\n  };\n\n  /* Measure 3 Settings */\n\n  var measure3Fx = {\n    ref: \"prop.measure3.fx\",\n    label: \"Measure\",\n    type: \"string\",\n    expression: \"always\"\n  };\n\n  var measure3Name = {\n    ref: \"prop.measure3.name\",\n    label: \"Measure Title\",\n    type: \"string\",\n    expression: \"optional\"\n  };\n\n  var measure3Align = {\n    ref: \"prop.measure3.align\",\n    label: \"Text align\",\n    type: \"string\",\n    component: \"dropdown\",\n    options: [{\n      value: \"left\",\n      label: \"left\"\n    }, {\n      value: \"center\",\n      label: \"center\"\n    }, {\n      value: \"right\",\n      label: \"right\"\n    }],\n    defaultValue: \"center\"\n  };\n\n  var measure3KpiStyleSize = {\n    label: \"Font Size\",\n    ref: \"prop.measure3.kpi.size\",\n    type: \"string\",\n    expression: \"optional\",\n    defaultValue: \"0.8rem\"\n  };\n\n  var measure3KpiFont = {\n    label: \"Font\",\n    ref: \"prop.measure3.kpi.font\",\n    type: \"string\",\n    expression: \"optional\",\n    defaultValue: \"QlikView Sans,sans-serif\"\n  };\n\n  var measure3KpiStyleBold = {\n    label: \"bold\",\n    ref: \"prop.measure3.kpi.bold\",\n    type: \"string\",\n    component: \"switch\",\n    options: [{\n      value: \"400\",\n      label: \"Off\"\n    }, {\n      value: \"700\",\n      label: \"On\"\n    }],\n    defaultValue: \"400\"\n  };\n\n  var measure3KpiStyleItalic = {\n    label: \"italic\",\n    ref: \"prop.measure3.kpi.italic\",\n    type: \"string\",\n    component: \"switch\",\n    options: [{\n      value: \"normal\",\n      label: \"Off\"\n    }, {\n      value: \"italic\",\n      label: \"On\"\n    }],\n    defaultValue: \"normal\"\n  };\n\n  var measure3KpiStyleUnderline = {\n    label: \"underline\",\n    ref: \"prop.measure3.kpi.underline\",\n    type: \"string\",\n    component: \"switch\",\n    options: [{\n      value: \"none\",\n      label: \"Off\"\n    }, {\n      value: \"underline\",\n      label: \"On\"\n    }],\n    defaultValue: \"normal\"\n  };\n\n  var measure3KpiStyleColor = {\n    label: \"Color\",\n    ref: \"prop.measure3.kpi.color.color\",\n    type: \"string\",\n    expression: \"optional\",\n    defaultValue: \"#595959\"\n  };\n\n  var measure3TitleStyleSize = {\n    label: \"Font Size\",\n    ref: \"prop.measure3.title.size\",\n    type: \"string\",\n    expression: \"optional\",\n    defaultValue: \"0.8rem\"\n  };\n\n  var measure3TitleFont = {\n    label: \"Font\",\n    ref: \"prop.measure3.title.font\",\n    type: \"string\",\n    expression: \"optional\",\n    defaultValue: \"QlikView Sans,sans-serif\"\n  };\n\n  var measure3TitleStyleBold = {\n    label: \"bold\",\n    ref: \"prop.measure3.title.bold\",\n    type: \"string\",\n    component: \"switch\",\n    options: [{\n      value: \"400\",\n      label: \"Off\"\n    }, {\n      value: \"700\",\n      label: \"On\"\n    }],\n    defaultValue: \"400\"\n  };\n\n  var measure3TitleStyleItalic = {\n    label: \"italic\",\n    ref: \"prop.measure3.title.italic\",\n    type: \"string\",\n    component: \"switch\",\n    options: [{\n      value: \"normal\",\n      label: \"Off\"\n    }, {\n      value: \"italic\",\n      label: \"On\"\n    }],\n    defaultValue: \"normal\"\n  };\n\n  var measure3TitleStyleUnderline = {\n    label: \"underline\",\n    ref: \"prop.measure3.title.underline\",\n    type: \"string\",\n    component: \"switch\",\n    options: [{\n      value: \"none\",\n      label: \"Off\"\n    }, {\n      value: \"underline\",\n      label: \"On\"\n    }],\n    defaultValue: \"normal\"\n  };\n\n  var measure3TitleStyleColor = {\n    ref: \"prop.measure3.title.color\",\n    label: \"Color\",\n    component: \"color-picker\",\n    type: \"object\",\n    defaultValue: \"#595959\"\n  };\n\n  var measure3TrendSwitch = {\n    ref: \"prop.measure3.trend.switch\",\n    label: \"Show Trend\",\n    type: \"boolean\",\n    component: \"switch\",\n    options: [{\n      value: false,\n      label: \"Off\"\n    }, {\n      value: true,\n      label: \"On\"\n    }],\n    defaultValue: false\n  };\n\n  var measure3TrendIcon = {\n    type: \"string\",\n    ref: \"prop.measure3.trend.icon\",\n    label: \"Icon\",\n    expression: \"optional\",\n    defaultValue: \"triangle-top\",\n    show: function (data) {\n      if (data.prop.measure3.trend.switch) { return true; }\n    }\n  };\n\n  var measure3TrendIconColor = {\n    ref: \"prop.measure3.trend.color\",\n    label: \"Color\",\n    expression: \"optional\",\n    type: \"string\",\n    defaultValue: \"#595959\",\n    show: function (data) {\n      if (data.prop.measure3.trend.switch) { return true; }\n    }\n  };\n\n  var measure3TrendFontSize = {\n    ref: \"prop.measure3.trend.size\",\n    label: \"Icon Size\",\n    expression: \"optional\",\n    type: \"string\",\n    defaultValue: \"0.9rem\",\n    show: function (data) {\n      if (data.prop.measure3.trend.switch) { return true; }\n    }\n  };\n\n  /* Measure 4 Settings */\n\n  var measure4Fx = {\n    ref: \"prop.measure4.fx\",\n    label: \"Measure\",\n    type: \"string\",\n    expression: \"always\"\n  };\n\n  var measure4Name = {\n    ref: \"prop.measure4.name\",\n    label: \"Measure Title\",\n    type: \"string\",\n    expression: \"optional\"\n  };\n\n  var measure4Align = {\n    ref: \"prop.measure4.align\",\n    label: \"Text align\",\n    type: \"string\",\n    component: \"dropdown\",\n    options: [{\n      value: \"left\",\n      label: \"left\"\n    }, {\n      value: \"center\",\n      label: \"center\"\n    }, {\n      value: \"right\",\n      label: \"right\"\n    }],\n    defaultValue: \"center\"\n  };\n\n  var measure4KpiStyleSize = {\n    label: \"Font Size\",\n    ref: \"prop.measure4.kpi.size\",\n    type: \"string\",\n    expression: \"optional\",\n    defaultValue: \"0.8rem\"\n  };\n\n  var measure4KpiFont = {\n    label: \"Font\",\n    ref: \"prop.measure4.kpi.font\",\n    type: \"string\",\n    expression: \"optional\",\n    defaultValue: \"QlikView Sans,sans-serif\"\n  };\n\n  var measure4KpiStyleBold = {\n    label: \"bold\",\n    ref: \"prop.measure4.kpi.bold\",\n    type: \"string\",\n    component: \"switch\",\n    options: [{\n      value: \"400\",\n      label: \"Off\"\n    }, {\n      value: \"700\",\n      label: \"On\"\n    }],\n    defaultValue: \"400\"\n  };\n\n  var measure4KpiStyleItalic = {\n    label: \"italic\",\n    ref: \"prop.measure4.kpi.italic\",\n    type: \"string\",\n    component: \"switch\",\n    options: [{\n      value: \"normal\",\n      label: \"Off\"\n    }, {\n      value: \"italic\",\n      label: \"On\"\n    }],\n    defaultValue: \"normal\"\n  };\n\n  var measure4KpiStyleUnderline = {\n    label: \"underline\",\n    ref: \"prop.measure4.kpi.underline\",\n    type: \"string\",\n    component: \"switch\",\n    options: [{\n      value: \"none\",\n      label: \"Off\"\n    }, {\n      value: \"underline\",\n      label: \"On\"\n    }],\n    defaultValue: \"normal\"\n  };\n\n  var measure4KpiStyleColor = {\n    label: \"Color\",\n    ref: \"prop.measure4.kpi.color.color\",\n    type: \"string\",\n    expression: \"optional\",\n    defaultValue: \"#595959\"\n  };\n\n  var measure4TitleStyleSize = {\n    label: \"Font Size\",\n    ref: \"prop.measure4.title.size\",\n    type: \"string\",\n    expression: \"optional\",\n    defaultValue: \"0.8rem\"\n  };\n\n  var measure4TitleFont = {\n    label: \"Font\",\n    ref: \"prop.measure4.title.font\",\n    type: \"string\",\n    expression: \"optional\",\n    defaultValue: \"QlikView Sans,sans-serif\"\n  };\n\n  var measure4TitleStyleBold = {\n    label: \"bold\",\n    ref: \"prop.measure4.title.bold\",\n    type: \"string\",\n    component: \"switch\",\n    options: [{\n      value: \"400\",\n      label: \"Off\"\n    }, {\n      value: \"700\",\n      label: \"On\"\n    }],\n    defaultValue: \"400\"\n  };\n\n  var measure4TitleStyleItalic = {\n    label: \"italic\",\n    ref: \"prop.measure4.title.italic\",\n    type: \"string\",\n    component: \"switch\",\n    options: [{\n      value: \"normal\",\n      label: \"Off\"\n    }, {\n      value: \"italic\",\n      label: \"On\"\n    }],\n    defaultValue: \"normal\"\n  };\n\n  var measure4TitleStyleUnderline = {\n    label: \"underline\",\n    ref: \"prop.measure4.title.underline\",\n    type: \"string\",\n    component: \"switch\",\n    options: [{\n      value: \"none\",\n      label: \"Off\"\n    }, {\n      value: \"underline\",\n      label: \"On\"\n    }],\n    defaultValue: \"normal\"\n  };\n\n  var measure4TitleStyleColor = {\n    ref: \"prop.measure4.title.color\",\n    label: \"Color\",\n    component: \"color-picker\",\n    type: \"object\",\n    defaultValue: \"#595959\"\n  };\n\n  var measure4TrendSwitch = {\n    ref: \"prop.measure4.trend.switch\",\n    label: \"Show Trend\",\n    type: \"boolean\",\n    component: \"switch\",\n    options: [{\n      value: false,\n      label: \"Off\"\n    }, {\n      value: true,\n      label: \"On\"\n    }],\n    defaultValue: false\n  };\n\n  var measure4TrendIcon = {\n    type: \"string\",\n    ref: \"prop.measure4.trend.icon\",\n    label: \"Icon\",\n    expression: \"optional\",\n    defaultValue: \"triangle-top\",\n    show: function (data) {\n      if (data.prop.measure4.trend.switch) { return true; }\n    }\n  };\n\n  var measure4TrendIconColor = {\n    ref: \"prop.measure4.trend.color\",\n    label: \"Color\",\n    expression: \"optional\",\n    type: \"string\",\n    defaultValue: \"#595959\",\n    show: function (data) {\n      if (data.prop.measure4.trend.switch) { return true; }\n    }\n  };\n\n  var measure4TrendFontSize = {\n    ref: \"prop.measure4.trend.size\",\n    label: \"Icon Size\",\n    expression: \"optional\",\n    type: \"string\",\n    defaultValue: \"0.9rem\",\n    show: function (data) {\n      if (data.prop.measure4.trend.switch) { return true; }\n    }\n  };\n\n  /* Minichart Settings */\n\n  var minichartType = {\n    ref: \"prop.minichart.type\",\n    label: \"Chart-Type\",\n    component: \"dropdown\",\n    type: \"string\",\n    options: [{\n      value: \"line\",\n      label: \"Linechart\"\n    }, {\n      value: \"bar\",\n      label: \"Barchart\"\n    }],\n    defaultValue: \"bar\"\n  };\n\n  var minichartGridhor = {\n    ref: \"prop.minichart.gridlinehor\",\n    label: \"Chart-Grid-Line horizontal\",\n    component: \"dropdown\",\n    type: \"string\",\n    options: [{\n      value: false,\n      label: \"Off\"\n    }, {\n      value: 't',\n      label: \"Narrow\"\n    }, {\n      value: 'y',\n      label: \"Medium\"\n    }, {\n      value: 'w',\n      label: \"Wide\"\n    }],\n    defaultValue: false\n  };\n\n  var minichartGridver = {\n    ref: \"prop.minichart.gridlinever\",\n    label: \"Chart-Grid-Line vertical\",\n    component: \"dropdown\",\n    type: \"string\",\n    options: [{\n      value: false,\n      label: \"Off\"\n    }, {\n      value: 't',\n      label: \"Narrow\"\n    }, {\n      value: 'y',\n      label: \"Medium\"\n    }, {\n      value: 'w',\n      label: \"Wide\"\n    }],\n    defaultValue: false\n  };\n\n  var minichartColor1 = {\n    ref: \"prop.minichart.colorone\",\n    label: \"Measure-Color 1\",\n    component: \"color-picker\",\n    type: \"object\",\n    defaultValue: \"#989A97\"\n  };\n\n  var minichartColor2 = {\n    ref: \"prop.minichart.colortwo\",\n    label: \"Measure-Color 2\",\n    component: \"color-picker\",\n    type: \"object\",\n    defaultValue: \"#007ACC\",\n    show: function (data) {\n      if (data.qHyperCubeDef.qMeasures.length > 1) { return true; }\n    }\n  };\n\n  var minichartDotSize = {\n    ref: \"prop.minichart.dotsize\",\n    type: \"number\",\n    component: \"slider\",\n    label: \"Point size\",\n    min: 0,\n    max: 0.6,\n    step: 0.05,\n    defaultValue: 0.1,\n    show: function (data) {\n      if (data.prop.minichart.type == \"line\") { return true; }\n    }\n  };\n\n  var minichartLineScaleExpand = {\n    ref: \"prop.minichart.linescaleexpand\",\n    type: \"number\",\n    component: \"slider\",\n    label: \"Scale expand\",\n    min: 0,\n    max: 2,\n    step: 0.1,\n    defaultValue: 0.2,\n    show: function (data) {\n      if (data.prop.minichart.type == \"line\") { return true; }\n    }\n  };\n\n  var minichartBarPadding = {\n    ref: \"prop.minichart.barpadding\",\n    type: \"number\",\n    component: \"slider\",\n    label: \"Bar padding\",\n    min: 0,\n    max: 0.9,\n    step: 0.05,\n    defaultValue: 0,\n    show: function (data) {\n      if (data.prop.minichart.type == \"bar\") { return true; }\n    }\n  };\n\n  var minichartBarAlignCompare1 = {\n    ref: \"prop.minichart.baraligncompare1\",\n    type: \"number\",\n    component: \"slider\",\n    label: \"First bar alignment\",\n    min: 0,\n    max: 0.9,\n    step: 0.05,\n    defaultValue: 0.65,\n    show: function (data) {\n      if (data.prop.minichart.type == \"bar\" && data.qHyperCubeDef.qMeasures.length == 2) { return true; }\n    }\n  };\n\n  var minichartBarAlignCompare2 = {\n    ref: \"prop.minichart.baraligncompare2\",\n    type: \"number\",\n    component: \"slider\",\n    label: \"Second bar alignment\",\n    min: 0,\n    max: 0.9,\n    step: 0.05,\n    defaultValue: 0.35,\n    show: function (data) {\n      if (data.prop.minichart.type == \"bar\" && data.qHyperCubeDef.qMeasures.length == 2) { return true; }\n    }\n  };\n\n  var minichartOpacity = {\n    ref: \"prop.minichart.opacity\",\n    type: \"number\",\n    component: \"slider\",\n    label: \"Chart opacity\",\n    min: 0,\n    max: 1,\n    step: 0.1,\n    defaultValue: 1\n  };\n\n  var minichartRefShow = {\n    ref: \"prop.minichart.ref.show\",\n    type: \"boolean\",\n    component: \"switch\",\n    label: \"Show Reference-Line\",\n    options: [{\n      value: false,\n      label: \"Off\"\n    }, {\n      value: true,\n      label: \"On\"\n    }],\n    defaultValue: false\n  };\n\n  var minichartArea = {\n    ref: \"prop.minichart.area\",\n    type: \"number\",\n    component: \"slider\",\n    label: \"% Chart Area\",\n    min: 0,\n    max: 100,\n    step: 5,\n    defaultValue: 50\n  };\n\n  var minichartRefValue = {\n    ref: \"prop.minichart.ref.value\",\n    label: \"Value\",\n    type: \"number\",\n    expression: \"optional\",\n    show: function (data) {\n      if (data.prop.minichart.ref.show) { return true; }\n    }\n  };\n\n  var minichartRefStrokeWidth = {\n    ref: \"prop.minichart.ref.strokewidth\",\n    label: \"Line-Size\",\n    type: \"string\",\n    expression: \"optional\",\n    defaultValue: \"1px\",\n    show: function (data) {\n      if (data.prop.minichart.ref.show) { return true; }\n    }\n  };\n\n  var minichartRefColor = {\n    ref: \"prop.minichart.ref.color\",\n    label: \"Color\",\n    component: \"color-picker\",\n    type: \"object\",\n    defaultValue: {\n      color: \"#000000\",\n      index: \"-1\"\n    },\n    show: function (data) {\n      if (data.prop.minichart.ref.show) { return true; }\n    }\n  };\n\n  var minichartFullScreen = {\n    ref: \"prop.minichart.fullscreen\",\n    label: \"Chart Fullscreen Mode\",\n    component: \"switch\",\n    type: \"boolean\",\n    options: [{\n      value: false,\n      label: \"Off\"\n    }, {\n      value: true,\n      label: \"On\"\n    }],\n    defaultValue: false\n  };\n\n  /* else */\n\n  var horizontalrulerLineSwitch = {\n    ref: \"prop.line.switch\",\n    label: \"Show Line\",\n    component: \"switch\",\n    type: \"boolean\",\n    options: [{\n      value: false,\n      label: \"Off\"\n    }, {\n      value: true,\n      label: \"On\"\n    }],\n    defaultValue: false\n  };\n\n  var horizontalrulerLineType = {\n    ref: \"prop.line.type\",\n    label: \"Line Type\",\n    component: \"dropdown\",\n    type: \"string\",\n    options: [{\n      value: \"style-one\",\n      label: \"style-one\"\n    }, {\n      value: \"style-two\",\n      label: \"style-two\"\n    }, {\n      value: \"style-three\",\n      label: \"style-three\"\n    }, {\n      value: \"style-four\",\n      label: \"style-four\"\n    }, {\n      value: \"style-five\",\n      label: \"style-five\"\n    }, {\n      value: \"style-six\",\n      label: \"style-six\"\n    }],\n    defaultValue: \"style-one\"\n  };\n\n  var luiIconLink = {\n    label: \"LUI Icon list\",\n    component: \"link\",\n    url: \"https://qlik-oss.github.io/leonardo-ui/icons.html\"\n  };\n\n  var backgroundswitch = {\n    label: \"Switch Background\",\n    component: \"switch\",\n    ref: \"prop.background.switch\",\n    type: \"boolean\",\n    options: [{\n      value: true,\n      label: \"On\"\n    }, {\n      value: false,\n      label: \"Off\"\n    }],\n    defaultValue: false\n  };\n  \n  var backgroundswitchfxpick = {\n    label: \"Mode\",\n    component: \"switch\",\n    ref: \"prop.background.switchfxpick\",\n    type: \"boolean\",\n    options: [{\n      value: true,\n      label: \"Formula\"\n    }, {\n      value: false,\n      label: \"Color Picker\"\n    }],\n    defaultValue: false,\n    show: function (data) {\n      if (data.prop.background.switch && data.prop.background.cssswitch != true) { return true; }\n    }\n  };\n\n  var backgroundcolor = {\n    ref: \"prop.background.color\",\n    label: \"Color\",\n    component: \"color-picker\",\n    type: \"object\",\n    show: function (data) {\n      //if (data.prop.background.switch && data.prop.background.cssswitch != true) { return true; }\n      if (data.prop.background.switch && data.prop.background.cssswitch != true && data.prop.background.switchfxpick != true) { return true; }\n    }\n  };\n\n  var backgroundcolorfx = {\n    ref: \"prop.background.colorfx\",\n    label: \"Color\",\n    type: \"string\",\n    expression: \"optional\",\n    default: \"#ffffff\",\n    show: function (data) {\n      if (data.prop.background.switch && data.prop.background.cssswitch != true && data.prop.background.switchfxpick != false) { return true; }\n    }\n  };\n\n  var backgroundcssswitch = {\n    label: \"Switch to CSS\",\n    component: \"switch\",\n    ref: \"prop.background.cssswitch\",\n    type: \"boolean\",\n    options: [{\n      value: true,\n      label: \"On\"\n    }, {\n      value: false,\n      label: \"Off\"\n    }],\n    defaultValue: false,\n    show: function (data) {\n      if (data.prop.background.switch) { return true; }\n    }\n  };\n\n  var backgroundpictureswitch = {\n    label: \"Switch to picture\",\n    component: \"switch\",\n    ref: \"prop.background.pictureswitch\",\n    type: \"boolean\",\n    options: [{\n      value: true,\n      label: \"On\"\n    }, {\n      value: false,\n      label: \"Off\"\n    }],\n    defaultValue: false,\n    show: function (data) {\n      if (data.prop.background.cssswitch) { return true; }\n    }\n  };\n\n  var backgroundpicture = {\n    label: \"Picture\",\n    component: \"media\",\n    ref: \"prop.background.picture\",\n    type: \"string\",\n    layoutRef: \"prop.background.picture\",\n    defaultValue: \"false\",\n    show: function (data) {\n      if (data.prop.background.pictureswitch && data.prop.background.cssswitch) { return true; }\n    }\n  };\n\n  var paragraphbackground = {\n    label: `You can use a picture and the CSS definition to configure the style of the picture. (e.g. \"background-repeat\" : \"round\")`,\n    component: 'text',\n    show: function (data) {\n      if (data.prop.background.pictureswitch && data.prop.background.cssswitch) { return true; }\n    }\n  };\n\n  var backgroundcss = {\n    label: \"CSS Definition\",\n    ref: \"prop.background.css\",\n    type: \"string\",\n    expression: \"optional\",\n    defaultValue: \"\",\n    show: function (data) {\n      if (data.prop.background.cssswitch) { return true; }\n    }\n  };\n\n  var customcssswitch = {\n    label: \"Enable custom CSS\",\n    component: \"switch\",\n    ref: \"prop.customcss.switch\",\n    type: \"boolean\",\n    options: [{\n      value: true,\n      label: \"On\"\n    }, {\n      value: false,\n      label: \"Off\"\n    }],\n    defaultValue: false\n  };\n\n  var customcsscss = {\n    label: \"Custom CSS definition\",\n    component: \"textarea\",\n    ref: \"prop.customcss.css\",\n    type: \"string\",\n    expression: \"optional\",\n    defaultValue: \"\",\n    show: function (data) {\n      if (data.prop.customcss.switch) { return true; }\n    }\n  };\n\n  /* Actions */\n\n  var actionsJumpSwitch = {\n    label: \"Navigate to sheet\",\n    ref: \"prop.actions.jump.switch\",\n    type: \"string\",\n    component: \"switch\",\n    options: [{\n      value: false,\n      label: \"Off\"\n    }, {\n      value: true,\n      label: \"On\"\n    }],\n    defaultValue: false\n  };\n\n  var actionsJumpDropdown = {\n    label: \"Select a sheet\",\n    type: 'string',\n    ref: 'prop.actions.jump.sheet',\n    component: 'dropdown',\n    show: function (data) {\n      if (data.prop.actions.jump.switch) { return true; }\n    },\n    options: async (action, hyperCubeHandler) => {\n      const sheets = await hyperCubeHandler.app.getSheetList();\n      return sheets.map(sheet => ({\n        value: sheet.qInfo.qId,\n        label: sheet.qMeta.title,\n      }));\n    }\n  };\n\n  var actionsVariableSwitch = {\n    label: \"Set Variable\",\n    ref: \"prop.actions.variable.switch\",\n    type: \"string\",\n    component: \"switch\",\n    options: [{\n      value: false,\n      label: \"Off\"\n    }, {\n      value: true,\n      label: \"On\"\n    }],\n    defaultValue: false\n  };\n\n  var variableList, variableListPromise;\n\n  function getPromiseVariable() {\n    if (!variableListPromise) {\n      variableListPromise = qlik.currApp().createGenericObject({\n        qVariableListDef: {\n          qType: 'variable'\n        }\n      }).then(function (reply) {\n        variableList = reply.layout.qVariableList.qItems.map(function (item) {\n          return {\n            value: item.qName,\n            label: item.qName\n          };\n        });\n        return variableList;\n      });\n    }\n    return variableListPromise;\n  }\n\n  var actionsVariableDropdown = {\n    label: \"Select a Variable\",\n    type: 'string',\n    ref: 'prop.actions.variable.var',\n    component: 'dropdown',\n    show: function (data) {\n      if (data.prop.actions.variable.switch) { return true; }\n    },\n    options: function () {\n      if (variableList) {\n        return variableList;\n      }\n      return getPromiseVariable();\n    }\n  };\n\n  var actionsVariableSet = {\n    label: \"Value\",\n    ref: \"prop.actions.variable.set\",\n    type: \"string\",\n    expression: \"optional\",\n    defaultValue: \"\",\n    show: function (data) {\n      if (data.prop.actions.variable.switch) { return true; }\n    }\n  };\n\n  var actionsBookmarkSwitch = {\n    label: \"Apply Bookmark\",\n    ref: \"prop.actions.bookmark.switch\",\n    type: \"string\",\n    component: \"switch\",\n    options: [{\n      value: false,\n      label: \"Off\"\n    }, {\n      value: true,\n      label: \"On\"\n    }],\n    defaultValue: false\n  };\n\n  var bookmarkList, bookmarkListPromise;\n\n  function getPromiseBookmark() {\n    if (!bookmarkListPromise) {\n      bookmarkListPromise = qlik.currApp().createGenericObject({\n        qBookmarkListDef: {\n          qType: 'bookmark'\n        }\n      }).then(function (reply) {\n        bookmarkList = reply.layout.qBookmarkList.qItems.map(function (item) {\n          return {\n            value: item.qInfo.qId,\n            label: item.qMeta.title\n          };\n        });\n        return bookmarkList;\n      });\n    }\n    return bookmarkListPromise;\n  }\n\n  var actionsBookmarkDropdown = {\n    label: \"Select a Bookmark\",\n    type: 'string',\n    ref: 'prop.actions.bookmark.name',\n    component: 'dropdown',\n    show: function (data) {\n      if (data.prop.actions.bookmark.switch) { return true; }\n    },\n    options: function () {\n      if (bookmarkList) {\n        return bookmarkList;\n      }\n      return getPromiseBookmark();\n    }\n  };\n\n  var actionsOverlayHeadline = {\n    label: \"Overlay title\",\n    ref: \"prop.actions.headline\",\n    type: \"string\",\n    expression: \"optional\",\n    defaultValue: \"Headline text\",\n    show: function (data) {\n      if (data.prop.actions.variable.switch || data.prop.actions.jump.switch || data.prop.actions.bookmark.switch) { return true; }\n    }\n  };\n\n  var actionsOverlaySubline = {\n    label: \"Overlay description\",\n    ref: \"prop.actions.subline\",\n    type: \"string\",\n    expression: \"optional\",\n    defaultValue: \"Subline text\",\n    show: function (data) {\n      if (data.prop.actions.variable.switch || data.prop.actions.jump.switch || data.prop.actions.bookmark.switch) { return true; }\n    }\n  };\n\n  var sorting = {\n    uses: \"sorting\"\n  };\n\n  var addons = {\n    uses: \"addons\",\n    items: {\n      dataHandling: {\n        uses: \"dataHandling\"\n      }\n    }\n  };\n\n  var appearance = {\n    uses: \"settings\",\n    items: {\n      general: {\n        items: {\n          showTitles: {\n            defaultValue: false\n          },\n          details: {\n            show: false\n          },\n        }\n      },\n      horizontalruler: {\n        type: \"items\",\n        label: \"Horizontal-Line\",\n        items: {\n          horizontalrulerLineSwitch: horizontalrulerLineSwitch,\n          horizontalrulerLineType: horizontalrulerLineType\n        }\n      },\n      background: {\n        type: \"items\",\n        label: \"Background\",\n        items: {\n          backgroundswitch: backgroundswitch,\n          backgroundswitchfxpick: backgroundswitchfxpick,\n          backgroundcolor: backgroundcolor,\n          backgroundcolorfx: backgroundcolorfx,\n          backgroundcssswitch: backgroundcssswitch,\n          backgroundcss: backgroundcss,\n          backgroundpictureswitch: backgroundpictureswitch,\n          backgroundpicture: backgroundpicture,\n          paragraphbackground: paragraphbackground\n        }\n      },\n      customCSS: {\n        type: \"items\",\n        label: \"Custom object CSS\",\n        items: {\n          customcssswitch: customcssswitch,\n          customcsscss: customcsscss,\n          paragraph: {\n            label: 'You can write pure CSS code. Use \"&\" as selector to point to this particular object (div[tid=\"ID\"]).',\n            component: 'text'\n          },\n          paragraph1: {\n            label: 'Example: & .qv-inner-object {border: 2px solid green; border-radius: 20px;} ',\n            component: 'text'\n          }\n        }\n      }\n    }\n  };\n\n  var measures = {\n    type: \"items\",\n    label: \"Measures\",\n    component: \"expandable-items\",\n    items: {\n      measure_top: {\n        type: \"items\",\n        label: \"Top-Level\",\n        items: {\n          measure1Fx: measure1Fx,\n          measure1Name: measure1Name,\n          measure1Align: measure1Align,\n          measure1KPI: {\n            component: \"expandable-items\",\n            grouped: true,\n            items: {\n              headermeasure1Kpi: {\n                type: \"items\",\n                label: \"Measure Settings\",\n                items: {\n                  measure1KpiFont: measure1KpiFont,\n                  measure1KpiStyleSize: measure1KpiStyleSize,\n                  measure1KpiStyleBold: measure1KpiStyleBold,\n                  measure1KpiStyleItalic: measure1KpiStyleItalic,\n                  measure1KpiStyleColor: measure1KpiStyleColor,\n                  measure1KpiStyleUnderline: measure1KpiStyleUnderline\n                }\n              }\n            }\n          },\n          measure1Label: {\n            component: \"expandable-items\",\n            grouped: true,\n            items: {\n              headermeasure1Title: {\n                type: \"items\",\n                label: \"Title Settings\",\n                items: {\n                  measure1TitleFont: measure1TitleFont,\n                  measure1TitleStyleSize: measure1TitleStyleSize,\n                  measure1TitleStyleBold: measure1TitleStyleBold,\n                  measure1TitleStyleItalic: measure1TitleStyleItalic,\n                  measure1TitleStyleColor: measure1TitleStyleColor,\n                  measure1TitleStyleUnderline: measure1TitleStyleUnderline\n                }\n              }\n            }\n          },\n          measure1Trend: {\n            component: \"expandable-items\",\n            grouped: true,\n            items: {\n              headermeasure1Trend: {\n                type: \"items\",\n                label: \"Trend Settings\",\n                items: {\n                  measure1TrendSwitch: measure1TrendSwitch,\n                  measure1TrendIcon: measure1TrendIcon,\n                  luiIconLink: luiIconLink,\n                  measure1TrendIconColor: measure1TrendIconColor,\n                  measure1TrendSide: measure1TrendSide,\n                  measure1TrendFontSize: measure1TrendFontSize\n                }\n              }\n            }\n          }\n        }\n      },\n      measure_left: {\n        type: \"items\",\n        label: \"Left\",\n        items: {\n          measure2Fx: measure2Fx,\n          measure2Name: measure2Name,\n          measure2Align: measure2Align,\n          measure2KPI: {\n            component: \"expandable-items\",\n            grouped: true,\n            items: {\n              headermeasure2Kpi: {\n                type: \"items\",\n                label: \"Measure Settings\",\n                items: {\n                  measure2KpiFont: measure2KpiFont,\n                  measure2KpiStyleSize: measure2KpiStyleSize,\n                  measure2KpiStyleBold: measure2KpiStyleBold,\n                  measure2KpiStyleItalic: measure2KpiStyleItalic,\n                  measure2KpiStyleColor: measure2KpiStyleColor,\n                  measure2KpiStyleUnderline: measure2KpiStyleUnderline\n                }\n              }\n            }\n          },\n          measure2Label: {\n            component: \"expandable-items\",\n            grouped: true,\n            items: {\n              headermeasure2Title: {\n                type: \"items\",\n                label: \"Title Settings\",\n                items: {\n                  measure2TitleFont: measure2TitleFont,\n                  measure2TitleStyleSize: measure2TitleStyleSize,\n                  measure2TitleStyleBold: measure2TitleStyleBold,\n                  measure2TitleStyleItalic: measure2TitleStyleItalic,\n                  measure2TitleStyleColor: measure2TitleStyleColor,\n                  measure2TitleStyleUnderline: measure2TitleStyleUnderline\n                }\n              }\n            }\n          },\n          measure2Trend: {\n            component: \"expandable-items\",\n            grouped: true,\n            items: {\n              headermeasure2Trend: {\n                type: \"items\",\n                label: \"Trend Settings\",\n                items: {\n                  measure2TrendSwitch: measure2TrendSwitch,\n                  measure2TrendIcon: measure2TrendIcon,\n                  luiIconLink: luiIconLink,\n                  measure2TrendIconColor: measure2TrendIconColor,\n                  measure2TrendFontSize: measure2TrendFontSize\n                }\n              }\n            }\n          }\n        }\n      },\n      measure_center: {\n        type: \"items\",\n        label: \"Center\",\n        items: {\n          measure3Fx: measure3Fx,\n          measure3Name: measure3Name,\n          measure3Align: measure3Align,\n          measure3KPI: {\n            component: \"expandable-items\",\n            grouped: true,\n            items: {\n              headermeasure3Kpi: {\n                type: \"items\",\n                label: \"Measure Settings\",\n                items: {\n                  measure3KpiFont: measure3KpiFont,\n                  measure3KpiStyleSize: measure3KpiStyleSize,\n                  measure3KpiStyleBold: measure3KpiStyleBold,\n                  measure3KpiStyleItalic: measure3KpiStyleItalic,\n                  measure3KpiStyleColor: measure3KpiStyleColor,\n                  measure3KpiStyleUnderline: measure3KpiStyleUnderline\n                }\n              }\n            }\n          },\n          measure3Label: {\n            component: \"expandable-items\",\n            grouped: true,\n            items: {\n              headermeasure3Title: {\n                type: \"items\",\n                label: \"Title Settings\",\n                items: {\n                  measure3TitleFont: measure3TitleFont,\n                  measure3TitleStyleSize: measure3TitleStyleSize,\n                  measure3TitleStyleBold: measure3TitleStyleBold,\n                  measure3TitleStyleItalic: measure3TitleStyleItalic,\n                  measure3TitleStyleColor: measure3TitleStyleColor,\n                  measure3TitleStyleUnderline: measure3TitleStyleUnderline\n                }\n              }\n            }\n          },\n          measure3Trend: {\n            component: \"expandable-items\",\n            grouped: true,\n            items: {\n              headermeasure3Trend: {\n                type: \"items\",\n                label: \"Trend Settings\",\n                items: {\n                  measure3TrendSwitch: measure3TrendSwitch,\n                  measure3TrendIcon: measure3TrendIcon,\n                  luiIconLink: luiIconLink,\n                  measure3TrendIconColor: measure3TrendIconColor,\n                  measure3TrendFontSize: measure3TrendFontSize\n                }\n              }\n            }\n          }\n        }\n      },\n      measure_right: {\n        type: \"items\",\n        label: \"Right\",\n        items: {\n          measure4Fx: measure4Fx,\n          measure4Name: measure4Name,\n          measure4Align: measure4Align,\n          measure4KPI: {\n            component: \"expandable-items\",\n            grouped: true,\n            items: {\n              headermeasure4Kpi: {\n                type: \"items\",\n                label: \"Measure Settings\",\n                items: {\n                  measure4KpiFont: measure4KpiFont,\n                  measure4KpiStyleSize: measure4KpiStyleSize,\n                  measure4KpiStyleBold: measure4KpiStyleBold,\n                  measure4KpiStyleItalic: measure4KpiStyleItalic,\n                  measure4KpiStyleColor: measure4KpiStyleColor,\n                  measure4KpiStyleUnderline: measure4KpiStyleUnderline\n                }\n              }\n            }\n          },\n          measure4Label: {\n            component: \"expandable-items\",\n            grouped: true,\n            items: {\n              headermeasure4Title: {\n                type: \"items\",\n                label: \"Title Settings\",\n                items: {\n                  measure4TitleFont: measure4TitleFont,\n                  measure4TitleStyleSize: measure4TitleStyleSize,\n                  measure4TitleStyleBold: measure4TitleStyleBold,\n                  measure4TitleStyleItalic: measure4TitleStyleItalic,\n                  measure4TitleStyleColor: measure4TitleStyleColor,\n                  measure4TitleStyleUnderline: measure4TitleStyleUnderline\n                }\n              }\n            }\n          },\n          measure4Trend: {\n            component: \"expandable-items\",\n            grouped: true,\n            items: {\n              headermeasure4Trend: {\n                type: \"items\",\n                label: \"Trend Settings\",\n                items: {\n                  measure4TrendSwitch: measure4TrendSwitch,\n                  measure4TrendIcon: measure4TrendIcon,\n                  luiIconLink: luiIconLink,\n                  measure4TrendIconColor: measure4TrendIconColor,\n                  measure4TrendFontSize: measure4TrendFontSize\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  };\n\n  var actions = {\n    type: \"items\",\n    label: \"Actions\",\n    component: \"items\",\n    items: {\n      actionItems: {\n        component: \"expandable-items\",\n        grouped: true,\n        items: {\n          actionsJump: {\n            type: \"items\",\n            label: \"Sheet-navigation\",\n            items: {\n              actionsJumpSwitch: actionsJumpSwitch,\n              actionsJumpDropdown: actionsJumpDropdown,\n              paragraph: {\n                label: 'A click on the kpi navigates you to a defined sheet.',\n                component: 'text'\n              }\n            }\n          },\n          actionsVariable: {\n            type: \"items\",\n            label: \"Set Variable\",\n            items: {\n              actionsVariableSwitch: actionsVariableSwitch,\n              actionsVariableDropdown: actionsVariableDropdown,\n              actionsVariableSet: actionsVariableSet,\n              paragraph: {\n                label: 'A click on the kpi navigates sets a variable to a defined value',\n                component: 'text'\n              }\n            }\n          },\n          actionsBookmark: {\n            type: \"items\",\n            label: \"Apply Bookmark\",\n            items: {\n              actionsBookmarkSwitch: actionsBookmarkSwitch,\n              actionsBookmarkDropdown: actionsBookmarkDropdown,\n              paragraph: {\n                label: 'A click on the kpi applies the selected bookmark.',\n                component: 'text'\n              }\n            }\n          }\n        }\n      },\n      actionsOverlayHeadline: actionsOverlayHeadline,\n      actionsOverlaySubline: actionsOverlaySubline,\n      paragraph: {\n        label: 'If an action is set you can type in a head- and a subline to describe what is going to happen after clicking on the object.',\n        component: 'text',\n        show: function (data) {\n          if (data.prop.actions.variable.switch || data.prop.actions.jump.switch || data.prop.actions.bookmark.switch) { return true; }\n        }\n      }\n    }\n  };\n\n  var minichart = {\n    type: \"items\",\n    label: \"Mini-Chart - Config\",\n    component: \"items\",\n    items: {\n      minichartType: minichartType,\n      minichartArea: minichartArea,\n      minichartGridhor: minichartGridhor,\n      minichartGridver: minichartGridver,\n      minichartColor1: minichartColor1,\n      minichartColor2: minichartColor2,\n      minichartOpacity: minichartOpacity,\n      minichartDotSize: minichartDotSize,\n      minichartBarPadding: minichartBarPadding,\n      minichartBarAlignCompare1: minichartBarAlignCompare1,\n      minichartBarAlignCompare2: minichartBarAlignCompare2,\n      minichartLineScaleExpand: minichartLineScaleExpand,\n      minichartRefShow: minichartRefShow,\n      minichartRefValue: minichartRefValue,\n      minichartRefStrokeWidth: minichartRefStrokeWidth,\n      minichartRefColor: minichartRefColor,\n      minichartFullScreen: minichartFullScreen\n    }\n  };\n\n  var aboutDefinition = {\n    component: 'items',\n    label: 'About',\n    items: {\n      header: {\n        label: 'Advanced KPI',\n        style: 'header',\n        component: 'text'\n      },\n      paragraph1: {\n        label: `Advanced KPI is a visualization to give you more options to design your KPI Objects.`,\n        component: 'text'\n      },\n      paragraph2: {\n        label: 'Advanced KPI is based upon an extension created by Dennis Jaskowiak.',\n        component: 'text'\n      },\n      paragraph3: {\n        label: 'Version: 0.1.6',\n        component: 'text'\n      }\n    }\n  };\n\n  return {\n    type: \"items\",\n    component: \"accordion\",\n    items: {\n      measures: measures,\n      data: data,\n      minichart: minichart,\n      actions: actions,\n      appearance: appearance,\n      sorting: sorting,\n      addons: addons,\n      aboutDefinition: aboutDefinition\n    }\n  };\n});",
        "/* eslint-disable max-len */\nvar qlik = window.require('qlik');\nimport initialProperties from './initial-properties.js';\nimport template from './template.html';\nimport definition from './definition.js';\nimport controller from './controller.js';\n// eslint-disable-next-line no-unused-vars\nimport localCSS from './style.css';\n\nexport default {\n  initialProperties: initialProperties,\n  template: template,\n  definition: definition,\n  controller: controller,\n  support: {\n    snapshot: true,\n    export: true,\n    exportData: true,\n    viewData: function (data) {\n      if (data.qHyperCube.qMeasureInfo[0] && data.qHyperCube.qDimensionInfo[0]) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n  },\n  resize: function ($element, layout) {\n    this.paint($element, layout);\n    //removing zoom-layer for mobile view\n    $element.closest('.qv-gridcell').find('.transparent-overlay').remove();\n    return false;\n  },\n  paint: function ($element, layout) {\n    let app = qlik.currApp(this);\n    const scope = this.$scope;\n    this.$scope.isInEdit = this.options.interactionState == 2;\n\n    //console.log(layout);\n\n    //Display welcome message\n    scope.init = false;\n    if (layout.prop.measure1.fx != \"\" || layout.prop.measure2.fx != \"\" || layout.prop.measure3.fx != \"\" || layout.prop.measure4.fx != \"\") {\n      scope.init = false;\n    } else if (layout.prop.measure1.name != \"\" || layout.prop.measure2.name != \"\" || layout.prop.measure3.name != \"\" || layout.prop.measure4.name != \"\") {\n      scope.init = false;\n    } else if (layout.qHyperCube.qMeasureInfo[0] && layout.qHyperCube.qDimensionInfo[0]) {\n      scope.init = false;\n    } else if (layout.prop.background.switch || layout.prop.customcss.switch) {\n      scope.init = false;\n    } else {\n      scope.init = true;\n    }\n\n    // getting chart-offset\n    let ChartOffset = ((($element[0].clientHeight / 100) * scope.layout.prop.minichart.area) - $element[0].clientHeight) * -1;\n\n    if (scope.layout.qHyperCube.qDimensionInfo.length > 0 || scope.layout.qHyperCube.qMeasureInfo.length > 0) {\n      if (scope.layout.prop.minichart.fullscreen) {\n        scope.ChartOffset = { \"height\": ChartOffset + \"px)\", \"opacity\": scope.layout.prop.minichart.opacity };\n        scope.KPIPosition = { \"postion\": \"relative\", \"top\": \"0px\" };\n      } else {\n        scope.ChartOffset = { \"top\": `${ChartOffset + 10}` + \"px\", \"height\": \"calc(100% - \" + `${ChartOffset}` + \"px)\", \"opacity\": scope.layout.prop.minichart.opacity };\n        scope.KPIPosition = { \"postion\": \"relative\", \"top\": \"-\" + scope.layout.prop.minichart.area * 0.4 + \"%\" };\n      }\n    } else {\n      scope.KPIPosition = { \"postion\": \"relative\", \"top\": \"0px\" };\n    }\n\n    //refreshing chart\n    if (scope.chart) {\n      scope.chart.update();\n      qlik.Promise.resolve();\n    }\n\n    //Actions\n    try {\n      if (!this.$scope.isInEdit && (layout.prop.actions.jump.switch || layout.prop.actions.variable.switch || layout.prop.actions.bookmark.switch)) {\n        layout.prop.actions.hover = true;\n        //eventlistener for Actions\n        $element.find('.adv-kpi-overlay').on(\"click\", function () {\n          //apply sheet-navigation\n          if (layout.prop.actions.jump.switch) {\n            qlik.navigation.gotoSheet(layout.prop.actions.jump.sheet);\n          }\n          //set variable\n          if (layout.prop.actions.variable.switch) {\n            app.variable.setContent(layout.prop.actions.variable.var, layout.prop.actions.variable.set);\n          }\n          //apply bookmark\n          if (layout.prop.actions.bookmark.switch) {\n            app.bookmark.apply(layout.prop.actions.bookmark.name);\n          }\n        });\n      } else {\n        layout.prop.actions.hover = false;\n      }\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.log(err);\n    }\n  }\n};\n",
        "export default {\n  qHyperCubeDef: {\n    qDimensions: [],\n    qMeasures: [],\n    qInitialDataFetch: [{\n      qWidth: 3,\n      qHeight: 1000\n    }]\n  }\n};",
        "\nvar content = require(\"!!../node_modules/css-loader/dist/cjs.js!./style.css\");\n\nif(typeof content === 'string') content = [[module.id, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = require(\"!../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(module.hot) {\n\tmodule.hot.accept(\"!!../node_modules/css-loader/dist/cjs.js!./style.css\", function() {\n\t\tvar newContent = require(\"!!../node_modules/css-loader/dist/cjs.js!./style.css\");\n\n\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\n\t\tvar locals = (function(a, b) {\n\t\t\tvar key, idx = 0;\n\n\t\t\tfor(key in a) {\n\t\t\t\tif(!b || a[key] !== b[key]) return false;\n\t\t\t\tidx++;\n\t\t\t}\n\n\t\t\tfor(key in b) idx--;\n\n\t\t\treturn idx === 0;\n\t\t}(content.locals, newContent.locals));\n\n\t\tif(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');\n\n\t\tupdate(newContent);\n\t});\n\n\tmodule.hot.dispose(function() { update(); });\n}",
        "module.exports = \"<!-- adv-kpi-intro -->\\r\\n<div qv-requirements=\\\"\\\" ng-if=\\\"init\\\" class=\\\"requirements-wrapper\\\">\\r\\n    <div class=\\\"requirements\\\">\\r\\n        <h2 class=\\\"header\\\"><i class=\\\"object-icon  lui-icon  lui-icon--kpi\\\"></i></h2>\\r\\n        <div class=\\\"text\\\">Choose measures to display.</div>\\r\\n    </div>\\r\\n</div>\\r\\n<!-- adv-kpi-print-content -->\\r\\n<style ng-if=\\\"layout.prop.customcss.switch == true\\\" id=\\\"{{layout.qInfo.qId}}-css\\\">{{customcss}}</style>\\r\\n<div class=\\\"adv-kpi-overlay\\\" ng-show=\\\"layout.prop.actions.hover == true\\\">\\r\\n    <div class=\\\"adv-kpi-overlay-details adv-kpi-fadeIn-top\\\">\\r\\n        <h3>{{layout.prop.actions.headline}}</h3>\\r\\n        <p>{{layout.prop.actions.subline}}</p>\\r\\n      </div>\\r\\n</div>\\r\\n<div class=\\\"adv-kpi-background\\\" ng-if=\\\"layout.prop.background.switch == true\\\" ng-style=\\\"backgroundcss\\\"></div>\\r\\n<div class=\\\"adv-kpi-container\\\" ng-style=\\\"KPIPosition\\\">\\r\\n    <!-- KPI BOX 1 -->\\r\\n    <div class=\\\"row adv-kpi-1\\\">\\r\\n        <div class=\\\"col-xs-12\\\" ng-style=\\\"{'text-align' : layout.prop.measure1.align}\\\">\\r\\n            <div class=\\\"adv-kpi-name\\\"\\r\\n                ng-style=\\\"{'font-family' : layout.prop.measure1.title.font , 'font-size' : layout.prop.measure1.title.size , 'font-weight' : layout.prop.measure1.title.bold , 'font-style' : layout.prop.measure1.title.italic , 'text-decoration' : layout.prop.measure1.title.underline , 'color' : layout.prop.measure1.title.color.color}\\\">\\r\\n                {{layout.prop.measure1.name}}\\r\\n            </div>\\r\\n\\r\\n            <div class=\\\"adv-kpi-measure\\\"\\r\\n                ng-style=\\\"{'font-family' : layout.prop.measure1.kpi.font , 'font-size' : layout.prop.measure1.kpi.size , 'font-weight' : layout.prop.measure1.kpi.bold , 'font-style' : layout.prop.measure1.kpi.italic , 'text-decoration' : layout.prop.measure1.kpi.underline , 'color' : layout.prop.measure1.kpi.color.color}\\\">\\r\\n                <div class=\\\"adv-kpi-trend-a\\\" ng-class=\\\"[layout.prop.measure1.trend.icon]\\\"\\r\\n                    ng-if=\\\"layout.prop.measure1.trend.side == 'left' && layout.prop.measure1.trend.switch == true\\\">\\r\\n                    <span class=\\\"lui-icon lui-icon--{{layout.prop.measure1.trend.icon}}\\\"\\r\\n                        ng-style=\\\"{'color' : layout.prop.measure1.trend.color, 'font-size' : layout.prop.measure1.trend.size}\\\"\\r\\n                        aria-hidden=\\\"true\\\"></span>\\r\\n                </div>\\r\\n                {{layout.prop.measure1.fx}}\\r\\n                <div class=\\\"adv-kpi-trend-b\\\"\\r\\n                    ng-if=\\\"layout.prop.measure1.trend.side == 'right' && layout.prop.measure1.trend.switch == true\\\">\\r\\n                    <span class=\\\"lui-icon lui-icon--{{layout.prop.measure1.trend.icon}}\\\"\\r\\n                        ng-style=\\\"{'color' : layout.prop.measure1.trend.color, 'font-size' : layout.prop.measure1.trend.size}\\\"\\r\\n                        aria-hidden=\\\"true\\\"></span>\\r\\n                </div>\\r\\n            </div>\\r\\n        </div>\\r\\n    </div>\\r\\n\\r\\n    <hr class=\\\"{{layout.prop.line.type}}\\\" ng-if=\\\"layout.prop.line.switch == true\\\"\\r\\n        ng-style=\\\"{'color' : layout.prop.line.color.color}\\\">\\r\\n\\r\\n    <!-- KPI BOX Container -->\\r\\n    <div class=\\\"row adv-kpi-box\\\"\\r\\n        ng-if=\\\"layout.prop.measure2.fx !='' || layout.prop.measure3.fx !='' || layout.prop.measure4.fx !=''\\\">\\r\\n        <!-- KPI BOX 2 -->\\r\\n        <div class=\\\"col-xs-4\\\" ng-style=\\\"{'text-align' : layout.prop.measure2.align}\\\">\\r\\n            <div class=\\\"adv-kpi-measure\\\"\\r\\n                ng-style=\\\"{'font-family' : layout.prop.measure2.kpi.font , 'font-size' : layout.prop.measure2.kpi.size , 'font-weight' : layout.prop.measure2.kpi.bold , 'font-style' : layout.prop.measure2.kpi.italic , 'text-decoration' : layout.prop.measure2.kpi.underline , 'color' : layout.prop.measure2.kpi.color.color}\\\">\\r\\n                {{layout.prop.measure2.fx}}\\r\\n                <div class=\\\"adv-kpi-trend-b\\\"\\r\\n                    ng-if=\\\"layout.prop.measure2.trend.switch == true\\\">\\r\\n                    <span class=\\\"lui-icon lui-icon--{{layout.prop.measure2.trend.icon}}\\\"\\r\\n                        ng-style=\\\"{'color' : layout.prop.measure2.trend.color, 'font-size' : layout.prop.measure2.trend.size}\\\"\\r\\n                        aria-hidden=\\\"true\\\"></span>\\r\\n                </div>\\r\\n            </div>\\r\\n            <div class=\\\"adv-kpi-name\\\"\\r\\n                ng-style=\\\"{'font-family' : layout.prop.measure2.title.font , 'font-size' : layout.prop.measure2.title.size , 'font-weight' : layout.prop.measure2.title.bold , 'font-style' : layout.prop.measure2.title.italic , 'text-decoration' : layout.prop.measure2.title.underline , 'color' : layout.prop.measure2.title.color.color}\\\">\\r\\n                {{layout.prop.measure2.name}}\\r\\n            </div>\\r\\n        </div>\\r\\n\\r\\n        <!-- KPI BOX 3 -->\\r\\n        <div class=\\\"col-xs-4\\\" ng-style=\\\"{'text-align' : layout.prop.measure3.align}\\\">\\r\\n            <div class=\\\"adv-kpi-measure\\\"\\r\\n                ng-style=\\\"{'font-family' : layout.prop.measure3.kpi.font , 'font-size' : layout.prop.measure3.kpi.size , 'font-weight' : layout.prop.measure3.kpi.bold , 'font-style' : layout.prop.measure3.kpi.italic , 'text-decoration' : layout.prop.measure3.kpi.underline , 'color' : layout.prop.measure3.kpi.color.color}\\\">\\r\\n                {{layout.prop.measure3.fx}}\\r\\n                <div class=\\\"adv-kpi-trend-b\\\"\\r\\n                    ng-if=\\\"layout.prop.measure3.trend.switch == true\\\">\\r\\n                    <span class=\\\"lui-icon lui-icon--{{layout.prop.measure3.trend.icon}}\\\"\\r\\n                        ng-style=\\\"{'color' : layout.prop.measure3.trend.color, 'font-size' : layout.prop.measure3.trend.size}\\\"\\r\\n                        aria-hidden=\\\"true\\\"></span>\\r\\n                </div>\\r\\n            </div>\\r\\n            <div class=\\\"adv-kpi-name\\\"\\r\\n                ng-style=\\\"{'font-family' : layout.prop.measure3.title.font , 'font-size' : layout.prop.measure3.title.size , 'font-weight' : layout.prop.measure3.title.bold , 'font-style' : layout.prop.measure3.title.italic , 'text-decoration' : layout.prop.measure3.title.underline , 'color' : layout.prop.measure3.title.color.color}\\\">\\r\\n                {{layout.prop.measure3.name}}\\r\\n            </div>\\r\\n        </div>\\r\\n\\r\\n        <!-- KPI BOX 4 -->\\r\\n        <div class=\\\"col-xs-4\\\" ng-style=\\\"{'text-align' : layout.prop.measure4.align}\\\">\\r\\n            <div class=\\\"adv-kpi-measure\\\"\\r\\n                ng-style=\\\"{'font-family' : layout.prop.measure4.kpi.font , 'font-size' : layout.prop.measure4.kpi.size , 'font-weight' : layout.prop.measure4.kpi.bold , 'font-style' : layout.prop.measure4.kpi.italic , 'text-decoration' : layout.prop.measure4.kpi.underline , 'color' : layout.prop.measure4.kpi.color.color}\\\">\\r\\n                {{layout.prop.measure4.fx}}\\r\\n                <div class=\\\"adv-kpi-trend-b\\\"\\r\\n                    ng-if=\\\"layout.prop.measure4.trend.switch == true\\\">\\r\\n                    <span class=\\\"lui-icon lui-icon--{{layout.prop.measure4.trend.icon}}\\\"\\r\\n                        ng-style=\\\"{'color' : layout.prop.measure4.trend.color, 'font-size' : layout.prop.measure4.trend.size}\\\"\\r\\n                        aria-hidden=\\\"true\\\"></span>\\r\\n                </div>\\r\\n            </div>\\r\\n            <div class=\\\"adv-kpi-name\\\"\\r\\n                ng-style=\\\"{'font-family' : layout.prop.measure4.title.font , 'font-size' : layout.prop.measure4.title.size , 'font-weight' : layout.prop.measure4.title.bold , 'font-style' : layout.prop.measure4.title.italic , 'text-decoration' : layout.prop.measure4.title.underline , 'color' : layout.prop.measure4.title.color.color}\\\">\\r\\n                {{layout.prop.measure4.name}}\\r\\n            </div>\\r\\n        </div>\\r\\n\\r\\n    </div>\\r\\n</div>\\r\\n\\r\\n<div class=\\\"row adv-kpi-chart-box\\\">\\r\\n    <div class=\\\"col-xs-12\\\">\\r\\n        <div class=\\\"adv-kpi-chart\\\" ng-style=\\\"ChartOffset\\\"></div>\\r\\n    </div>\\r\\n</div>\";",
        "module.exports = __WEBPACK_EXTERNAL_MODULE_jquery__;",
        "module.exports = __WEBPACK_EXTERNAL_MODULE_qlik__;"
    ],
    "sourceRoot": ""
}